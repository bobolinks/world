var K1 = Object.defineProperty;
var Z1 = (c, e, t) => e in c ? K1(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var B = (c, e, t) => (Z1(c, typeof e != "symbol" ? e + "" : e, t), t);
import * as M from "three";
import { Object3D as En, Color as He, Vector2 as Nt, Vector3 as ge, Vector4 as pt, Matrix3 as bs, Matrix4 as je, EventDispatcher as vu, MathUtils as Yt, LinearSRGBColorSpace as Rn, SRGBColorSpace as vn, TangentSpaceNormalMap as Lf, ObjectSpaceNormalMap as Q1, StaticDrawUsage as ex, InterleavedBuffer as cm, InterleavedBufferAttribute as Vs, DynamicDrawUsage as xu, InstancedInterleavedBuffer as Ta, DepthTexture as lm, NearestFilter as js, LessCompare as tx, ShaderMaterial as ls, NoColorSpace as um, Material as Bn, WebGLCubeRenderTarget as nx, BoxGeometry as Xa, BackSide as bu, NoBlending as sx, Mesh as Qt, Scene as $a, LinearMipmapLinearFilter as yo, LinearFilter as uo, CubeCamera as rx, RenderTarget as ox, sRGBEncoding as ix, LinearEncoding as ax, Float16BufferAttribute as cx, REVISION as lx, NoToneMapping as Ff, LinearToneMapping as ux, ReinhardToneMapping as hx, CineonToneMapping as dx, ACESFilmicToneMapping as hm, FramebufferTexture as dm, UnsignedIntType as fx, DepthFormat as px, PointLight as Zo, DirectionalLight as pi, SpotLight as mi, AmbientLight as Nu, HemisphereLight as fm, Loader as vr, FileLoader as Js, LineBasicMaterial as wu, LineDashedMaterial as pm, MeshNormalMaterial as mx, MeshBasicMaterial as An, MeshLambertMaterial as mm, MeshPhongMaterial as fa, MeshStandardMaterial as Vn, MeshPhysicalMaterial as Cs, PointsMaterial as gm, SpriteMaterial as gx, MaterialLoader as gi, ObjectLoader as yx, BufferAttribute as no, BufferGeometry as Ss, Box3 as tr, InstancedBufferGeometry as ym, Float32BufferAttribute as yn, WireframeGeometry as vx, Sphere as yi, UniformsLib as so, ShaderLib as is, UniformsUtils as nr, Line3 as xx, CubicBezierCurve3 as bx, PerspectiveCamera as xr, OrthographicCamera as qa, CapsuleGeometry as vm, ConeGeometry as Nx, CylinderGeometry as wx, SphereGeometry as Ja, TorusGeometry as Tx, TorusKnotGeometry as Sx, ExtrudeGeometry as xm, PlaneGeometry as Tr, ShapePath as Tu, Shape as vo, Path as _x, MeshDepthMaterial as Mx, RGBADepthPacking as Ax, MeshDistanceMaterial as Cx, ShaderChunk as bm, DoubleSide as Su, InstancedBufferAttribute as Ex, FrontSide as Nm, Texture as Gn, AudioListener as Rx, PositionalAudio as Lx, AudioLoader as Fx, TrianglesDrawMode as Ox, TriangleFanDrawMode as zl, TriangleStripDrawMode as wm, LoaderUtils as ho, Quaternion as dr, InstancedMesh as Ix, TextureLoader as _u, ImageBitmapLoader as Px, RepeatWrapping as Ys, PropertyBinding as Qo, SkinnedMesh as Tm, LineSegments as Dx, Line as Sm, LineLoop as Ux, Points as _m, Group as ro, Skeleton as Mu, AnimationClip as Au, Bone as Bl, InterpolateLinear as Mm, ColorManagement as Of, NearestMipmapNearestFilter as Am, LinearMipmapNearestFilter as Cm, NearestMipmapLinearFilter as Em, ClampToEdgeWrapping as fo, MirroredRepeatWrapping as Rm, InterpolateDiscrete as zx, VectorKeyframeTrack as kl, NumberKeyframeTrack as Gl, QuaternionKeyframeTrack as Vl, Interpolant as Bx, Curve as kx, EquirectangularReflectionMapping as Lm, Uint16BufferAttribute as Gx, Euler as ws, AnimationMixer as Vx, LoopRepeat as jx, LoopOnce as Wx, Plane as jl, WebGLRenderTarget as Cu, HalfFloatType as Fm, PMREMGenerator as Hx, AdditiveBlending as Xx, Camera as $x, RGBAFormat as If, DataTexture as pa, FloatType as Pf, BufferGeometryLoader as qx, LoadingManager as Jx, ImageLoader as Df, Source as Gi, CubeTexture as Yx, Fog as Kx, FogExp2 as Zx, UVMapping as Qx, CubeReflectionMapping as eb, CubeRefractionMapping as tb, EquirectangularRefractionMapping as nb, CubeUVReflectionMapping as sb, PCFSoftShadowMap as rb } from "three";
const po = /* @__PURE__ */ new WeakMap(), Sa = /* @__PURE__ */ new Set(), ob = En.prototype.clone;
En.prototype.clone = function(c) {
  const e = ob.call(this, c);
  return po.set(this, e), e;
};
function ib() {
  for (const c of Sa)
    po.delete(c);
  Sa.clear();
}
function ab() {
  for (const c of Sa)
    po.delete(c);
  Sa.clear();
}
function cb(c, e, t) {
  ib();
  const r = c.clone(e);
  return c.traverse((n) => {
    if (!n.graph)
      return;
    const s = po.get(n);
    s && (s.graph = n.graph.clone(t || c, po));
  }), ab(), r;
}
const Wl = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, ut = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, lb = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
}, $r = ["fragment", "vertex"], Om = ["setup", "analyze", "generate"], Im = [...$r, "compute"], Ya = ["x", "y", "z", "w"];
function Ka(c) {
  let e = "{";
  c.isNode === !0 && (e += `uuid:"${c.uuid}"`);
  for (const { property: t, index: r, childNode: n } of ei(c)) {
    let s = Ka(n);
    s.includes(",") || (s = s.slice(s.indexOf('"'), s.indexOf("}"))), e += `,${t}${r !== void 0 ? "/" + r : ""}:${s}`;
  }
  return e += "}", e;
}
function* ei(c, e = !1) {
  for (const t in c) {
    if (t.startsWith("_") === !0)
      continue;
    const r = c[t];
    if (Array.isArray(r) === !0)
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
    else if (r && r.isNode === !0)
      yield { property: t, childNode: r };
    else if (typeof r == "object")
      for (const n in r) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
  }
}
function Ws(c) {
  if (c == null)
    return null;
  const e = typeof c;
  return c.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : c.isVector2 === !0 ? "vec2" : c.isVector3 === !0 ? "vec3" : c.isVector4 === !0 ? "vec4" : c.isMatrix3 === !0 ? "mat3" : c.isMatrix4 === !0 ? "mat4" : c.isColor === !0 ? "color" : c instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function Eu(c, ...e) {
  const t = c ? c.slice(-4) : void 0;
  return (t === "vec2" || t === "vec3" || t === "vec4") && e.length === 1 && (e = t === "vec2" ? [e[0], e[0]] : [e[0], e[0], e[0]]), c === "color" ? new He(...e) : t === "vec2" ? new Nt(...e) : t === "vec3" ? new ge(...e) : t === "vec4" ? new pt(...e) : t === "mat3" ? new bs(...e) : t === "mat4" ? new je(...e) : c === "bool" ? e[0] || !1 : c === "float" || c === "int" || c === "uint" ? e[0] || 0 : c === "string" ? e[0] || "" : c === "ArrayBuffer" ? Lu(e[0]) : null;
}
function Ru(c) {
  let e = "";
  const t = new Uint8Array(c);
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Lu(c) {
  return Uint8Array.from(atob(c), (e) => e.charCodeAt(0)).buffer;
}
const ub = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: Ru,
  base64ToArrayBuffer: Lu,
  getCacheKey: Ka,
  getNodeChildren: ei,
  getValueFromType: Eu,
  getValueType: Ws
}, Symbol.toStringTag, { value: "Module" })), Hl = /* @__PURE__ */ new Map();
let hb = 0, db = class extends vu {
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = ut.NONE, this.updateBeforeType = ut.NONE, this.uuid = Yt.generateUUID(), this.isNode = !0, Object.defineProperty(this, "id", { value: hb++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    const e = this;
    for (const { property: t, index: r, childNode: n } of ei(this))
      yield { childNode: n, replaceNode(s) {
        r === void 0 ? e[t] = s : e[t][r] = s;
      } };
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e, t = null) {
    e(this, t);
    for (const { childNode: r, replaceNode: n } of this.getChildren())
      r.traverse(e, n);
  }
  getCacheKey() {
    return Ka(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    for (const { childNode: r } of this.getChildren())
      t["_node" + r.id] = r;
    return null;
  }
  construct(e) {
    return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."), this.setup(e);
  }
  analyze(e) {
    const t = e.getDataFromNode(this);
    if (t.dependenciesCount = t.dependenciesCount === void 0 ? 1 : t.dependenciesCount + 1, t.dependenciesCount === 1) {
      const r = e.getNodeProperties(this);
      for (const n of Object.values(r))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    if (r && r.isNode === !0)
      return r.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const r = this.getShared(e);
    if (this !== r)
      return r.build(e, t);
    e.addNode(this), e.addChain(this);
    let n = null;
    const s = e.getBuildStage();
    if (s === "setup") {
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0 || e.context.tempRead === !1) {
        const i = e.stack.nodes.length;
        o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length !== i && (o.outputNode = e.stack);
        for (const a of Object.values(o))
          a && a.isNode === !0 && a.build(e);
      }
    } else if (s === "analyze")
      this.analyze(e);
    else if (s === "generate")
      if (this.generate.length === 1) {
        const i = this.getNodeType(e), a = e.getDataFromNode(this);
        n = a.snippet, n === void 0 && (n = this.generate(e) || "", a.snippet = n), n = e.format(n, i, t);
      } else
        n = this.generate(e, t) || "";
    return e.removeChain(this), n;
  }
  getSerializeChildren() {
    return ei(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(), r = {};
    for (const { property: n, index: s, childNode: o } of t)
      s !== void 0 ? (r[n] === void 0 && (r[n] = Number.isInteger(s) ? [] : {}), r[n][s] = o.toJSON(e.meta).uuid) : r[n] = o.toJSON(e.meta).uuid;
    Object.keys(r).length > 0 && (e.inputNodes = r);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const r in e.inputNodes)
        if (Array.isArray(e.inputNodes[r])) {
          const n = [];
          for (const s of e.inputNodes[r])
            n.push(t[s]);
          this[r] = n;
        } else if (typeof e.inputNodes[r] == "object") {
          const n = {};
          for (const s in e.inputNodes[r]) {
            const o = e.inputNodes[r][s];
            n[s] = t[o];
          }
          this[r] = n;
        } else {
          const n = e.inputNodes[r];
          this[r] = t[n];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: r } = this, n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let s = e.nodes[t];
    s === void 0 && (s = {
      uuid: t,
      type: r,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, n !== !0 && (e.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
    if (n) {
      const i = o(e.textures), a = o(e.images), l = o(e.nodes);
      i.length > 0 && (s.textures = i), a.length > 0 && (s.images = a), l.length > 0 && (s.nodes = l);
    }
    return s;
  }
};
const Oe = db;
function oe(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node class ${c} is not a class`);
  if (Hl.has(c))
    throw new Error(`Redefinition of node class ${c}`);
  Hl.set(c, e), e.type = c;
}
function Xl(c) {
  const e = Hl.get(c);
  if (e !== void 0)
    return new e();
}
class Pm extends Oe {
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Ws(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Ws(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = Ru(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? Eu(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Fu = Pm;
oe("InputNode", Pm);
class Dm extends Oe {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node.build(e), r = this.indexNode.build(e, "uint");
    return `${t}[ ${r} ]`;
  }
}
const Za = Dm;
oe("ArrayElementNode", Dm);
class Um extends Oe {
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let r = null;
    for (const n of this.convertTo.split("|"))
      (r === null || e.getTypeLength(t) === e.getTypeLength(n)) && (r = n);
    return r;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const r = this.node, n = this.getNodeType(e), s = r.build(e, n);
    return e.format(s, n, t);
  }
}
const Qa = Um;
oe("ConvertNode", Um);
class zm extends Oe {
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).dependenciesCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, t)), s = e.getDataFromNode(this);
      if (e.context.tempRead !== !1 && s.propertyName !== void 0)
        return e.format(s.propertyName, n, t);
      if (e.context.tempWrite !== !1 && n !== "void" && t !== "void" && this.hasDependencies(e)) {
        const o = super.build(e, n), i = e.getVarFromNode(this, n), a = e.getPropertyName(i);
        return e.addLineFlowCode(`${a} = ${o}`), s.snippet = o, s.propertyName = a, e.format(s.propertyName, n, t);
      }
    }
    return super.build(e, t);
  }
}
const _t = zm;
oe("TempNode", zm);
class Bm extends _t {
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, r) => t + e.getTypeLength(r.getNodeType(e)), 0));
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.nodes, s = [];
    for (const i of n) {
      const a = i.build(e);
      s.push(a);
    }
    const o = `${e.getType(r)}( ${s.join(", ")} )`;
    return e.format(o, r, t);
  }
}
const km = Bm;
oe("JoinNode", Bm);
const fb = Ya.join("");
class Gm extends Oe {
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(Ya.indexOf(t) + 1, e);
    return e;
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length);
  }
  generate(e, t) {
    const r = this.node, n = e.getTypeLength(r.getNodeType(e));
    let s = null;
    if (n > 1) {
      let o = null;
      this.getVectorLength() >= n && (o = e.getTypeFromLength(this.getVectorLength()));
      const a = r.build(e, o);
      this.components.length === n && this.components === fb.slice(0, this.components.length) ? s = e.format(a, o, t) : s = e.format(`${a}.${this.components}`, this.getNodeType(e), t);
    } else
      s = r.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
const _a = Gm;
oe("SplitNode", Gm);
class Vm extends _t {
  constructor(e, t, r) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = r;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: r, targetNode: n } = this, s = this.getNodeType(e), o = e.getTypeFromLength(r.length), i = n.build(e, o), a = t.build(e, s), l = e.getTypeLength(s), u = [];
    for (let h = 0; h < l; h++) {
      const d = Ya[h];
      d === r[0] ? (u.push(i), h += r.length - 1) : u.push(a + "." + d);
    }
    return `${e.getType(s)}( ${u.join(", ")} )`;
  }
}
const jm = Vm;
oe("SetNode", Vm);
class Wm extends Fu {
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.getConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const r = this.getNodeType(e);
    return e.format(this.generateConst(e), r, t);
  }
}
const Fn = Wm;
oe("ConstNode", Wm);
const qr = /* @__PURE__ */ new Map();
function V(c, e) {
  if (qr.has(c))
    throw new Error(`Redefinition of node element ${c}`);
  if (typeof e != "function")
    throw new Error(`Node element ${c} is not a function`);
  qr.set(c, e);
}
const Uf = (c) => c.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), Hm = {
  setup(c, e) {
    const t = e.shift();
    return c(nc(t), ...e);
  },
  get: function(c, e, t) {
    if (typeof e == "string" && c[e] === void 0)
      if (qr.has(e)) {
        const r = qr.get(e);
        return (...n) => r(t, ...n);
      } else {
        if (e === "self")
          return c;
        if (e.endsWith("Assign") && qr.has(e.slice(0, e.length - 6))) {
          const r = qr.get(e.slice(0, e.length - 6));
          return (...n) => t.assign(r(t, ...n));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = Uf(e), Me(new _a(c, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = Uf(e.slice(3).toLowerCase()), e = e.split("").sort().join(""), (r) => Me(new jm(c, e, r));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), Me(new _a(c, e));
          if (/^\d+$/.test(e) === !0)
            return Me(new Za(c, new Fn(Number(e), "uint")));
        }
      }
    return c[e];
  }
}, Zc = /* @__PURE__ */ new WeakMap(), pb = function(c, e = null) {
  const t = Ws(c);
  if (t === "node") {
    let r = Zc.get(c);
    return r === void 0 && (r = new Proxy(c, Hm), Zc.set(c, r), Zc.set(r, r)), r;
  } else {
    if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string")
      return Me($l(c, e));
    if (t === "shader")
      return Ke(c);
  }
  return c;
}, mb = function(c, e = null) {
  for (const t in c)
    c[t] = Me(c[t], e);
  return c;
}, gb = function(c, e = null) {
  const t = c.length;
  for (let r = 0; r < t; r++)
    c[r] = Me(c[r], e);
  return c;
}, yb = function(c, e = null, t = null, r = null) {
  const n = (s) => Me(r !== null ? Object.assign(s, r) : s);
  return e === null ? (...s) => n(new c(...pr(s))) : t !== null ? (t = Me(t), (...s) => n(new c(e, ...pr(s), t))) : (...s) => n(new c(e, ...pr(s)));
}, vb = function(c, ...e) {
  return Me(new c(...pr(e)));
};
class xb extends Oe {
  constructor(e, t) {
    super(), this.shaderNode = e, this.inputNodes = t;
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  call(e) {
    const { shaderNode: t, inputNodes: r } = this, n = t.jsFunc, s = r !== null ? n(nc(r), e.stack, e) : n(e.stack, e);
    return Me(s);
  }
  setup(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    return r === null ? this.call(e).build(e, t) : super.generate(e, t);
  }
}
class bb extends Oe {
  constructor(e) {
    super(), this.jsFunc = e;
  }
  call(e = null) {
    return Me(new xb(this, e));
  }
  setup() {
    return this.call();
  }
}
const Nb = [!1, !0], wb = [0, 1, 2, 3], Tb = [-1, -2], Xm = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], Ou = /* @__PURE__ */ new Map();
for (const c of Nb)
  Ou.set(c, new Fn(c));
const Iu = /* @__PURE__ */ new Map();
for (const c of wb)
  Iu.set(c, new Fn(c, "uint"));
const Pu = new Map([...Iu].map((c) => new Fn(c.value, "int")));
for (const c of Tb)
  Pu.set(c, new Fn(c, "int"));
const ec = new Map([...Pu].map((c) => new Fn(c.value)));
for (const c of Xm)
  ec.set(c, new Fn(c));
for (const c of Xm)
  ec.set(-c, new Fn(-c));
const tc = { bool: Ou, uint: Iu, ints: Pu, float: ec }, zf = new Map([...Ou, ...ec]), $l = (c, e) => zf.has(c) ? zf.get(c) : c.isNode === !0 ? c : new Fn(c, e), Sb = (c) => {
  try {
    return c.getNodeType();
  } catch {
    return;
  }
}, mt = function(c, e = null) {
  return (...t) => {
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(c) && t.every((n) => typeof n != "object")) && (t = [Eu(c, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return Me(e.get(t[0]));
    if (t.length === 1) {
      const n = $l(t[0], c);
      return Sb(n) === c ? Me(n) : Me(new Qa(n, c));
    }
    const r = t.map((n) => $l(n));
    return Me(new km(r, c));
  };
}, $m = (c) => c != null ? c.nodeType || c.convertTo || (typeof c == "string" ? c : null) : null;
function _s(c) {
  return new Proxy(new bb(c), Hm);
}
const Me = (c, e = null) => (
  /* new */
  pb(c, e)
), nc = (c, e = null) => new mb(c, e), pr = (c, e = null) => new gb(c, e), j = (...c) => new yb(...c), ce = (...c) => new vb(...c), _b = (c) => (console.warn("TSL: shader() is deprecated. Use tslFn() instead."), new _s(c)), Ke = (c) => {
  const e = new _s(c);
  return (t) => e.call(t);
};
oe("ShaderNode", _s);
const qm = new mt("color"), _e = new mt("float", tc.float), Ma = new mt("int", tc.int), Jm = new mt("uint", tc.uint), Ym = new mt("bool", tc.bool), tt = new mt("vec2"), Km = new mt("ivec2"), Zm = new mt("uvec2"), Qm = new mt("bvec2"), Re = new mt("vec3"), eg = new mt("ivec3"), tg = new mt("uvec3"), ng = new mt("bvec3"), st = new mt("vec4"), sg = new mt("ivec4"), rg = new mt("uvec4"), og = new mt("bvec4"), Ms = new mt("mat3"), ig = new mt("imat3"), ag = new mt("umat3"), cg = new mt("bmat3"), Du = new mt("mat4"), lg = new mt("imat4"), ug = new mt("umat4"), hg = new mt("bmat4"), dg = (c = "") => Me(new Fn(c, "string")), fg = (c) => Me(new Fn(c, "ArrayBuffer"));
V("color", qm);
V("float", _e);
V("int", Ma);
V("uint", Jm);
V("bool", Ym);
V("vec2", tt);
V("ivec2", Km);
V("uvec2", Zm);
V("bvec2", Qm);
V("vec3", Re);
V("ivec3", eg);
V("uvec3", tg);
V("bvec3", ng);
V("vec4", st);
V("ivec4", sg);
V("uvec4", rg);
V("bvec4", og);
V("mat3", Ms);
V("imat3", ig);
V("umat3", ag);
V("bmat3", cg);
V("mat4", Du);
V("imat4", lg);
V("umat4", ug);
V("bmat4", hg);
V("string", dg);
V("arrayBuffer", fg);
const pg = j(Za), mg = (c, e) => Me(new Qa(Me(c), e)), Mb = (c, e) => Me(new _a(Me(c), e));
V("element", pg);
V("convert", mg);
class Uu extends Fu {
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.getUniformHash(e);
    let s = e.getNodeFromHash(n);
    s === void 0 && (e.setHashNode(this, n), s = this);
    const o = s.getInputType(e), i = e.getUniformFromNode(s, o, e.shaderStage, e.context.label), a = e.getPropertyName(i);
    return e.context.label !== void 0 && delete e.context.label, e.format(a, r, t);
  }
}
const Qe = Uu, Rt = (c, e) => {
  const t = $m(e || c), r = c && c.isNode === !0 ? c.node && c.node.value || c.value : c;
  return Me(new Uu(r, t));
};
oe("UniformNode", Uu);
class gg extends Qe {
  constructor(e = []) {
    super(), this.isArrayUniformNode = !0, this.nodes = e;
  }
  getNodeType(e) {
    return this.nodes[0].getNodeType(e);
  }
}
const yg = gg;
oe("ArrayUniformNode", gg);
class sc extends Oe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: r } = this, n = this.getNodeType(e), s = e.getVaryingFromNode(this, n);
    s.needsInterpolation || (s.needsInterpolation = e.shaderStage === "fragment"), t !== null && (s.name = t);
    const o = e.getPropertyName(s, Wl.VERTEX);
    return e.flowNodeFromShaderStage(Wl.VERTEX, r, n, o), e.getPropertyName(s);
  }
}
const at = j(sc);
V("varying", at);
oe("VaryingNode", sc);
class vi extends Oe {
  constructor(e, t = null) {
    super(t), this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (t === null) {
      const r = this.getAttributeName(e);
      if (e.hasGeometryAttribute(r)) {
        const n = e.geometry.getAttribute(r);
        t = e.getTypeFromAttribute(n);
      } else
        t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), r = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t), o = e.getTypeFromAttribute(s), i = e.getAttribute(t, o);
      return e.shaderStage === "vertex" ? e.format(i.name, o, r) : at(this).build(e, r);
    } else
      return console.warn(`AttributeNode: Attribute "${t}" not found.`), e.getConst(r);
  }
}
const Ft = (c, e) => Me(new vi(c, e));
oe("AttributeNode", vi);
class zu extends Oe {
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const vg = zu, rc = j(zu);
V("bypass", rc);
oe("BypassNode", zu);
let Ab = 0;
class Cb {
  constructor() {
    this.id = Ab++, this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
}
const oc = Cb;
class Bu extends Oe {
  constructor(e, t = new oc()) {
    super(), this.isCacheNode = !0, this.node = e, this.cache = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const r = e.getCache();
    e.setCache(this.cache);
    const n = this.node.build(e, ...t);
    return e.setCache(r), n;
  }
}
const xg = Bu, Aa = j(Bu);
V("cache", Aa);
oe("CacheNode", Bu);
class xi extends Oe {
  constructor(e, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.context = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const r = this.node.build(e);
    return e.setContext(t), r;
  }
  generate(e, t) {
    const r = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const n = this.node.build(e, t);
    return e.setContext(r), n;
  }
}
const Yn = j(xi), ic = (c, e) => Yn(c, { label: e });
V("context", Yn);
V("label", ic);
oe("ContextNode", xi);
class Zn extends Oe {
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), r = this.scope;
    let n;
    if (r === Zn.VERTEX)
      n = e.getVertexIndex();
    else if (r === Zn.INSTANCE)
      n = e.getInstanceIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + r);
    let s;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? s = n : s = at(this).build(e, t), s;
  }
}
Zn.VERTEX = "vertex";
Zn.INSTANCE = "instance";
const Eb = Zn, Rb = ce(Zn, Zn.VERTEX), bg = ce(Zn, Zn.INSTANCE);
oe("IndexNode", Zn);
class Lb {
  init() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
}
const ku = Lb;
class Fb {
  constructor(e, t, r = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = r;
  }
}
const Ca = Fb;
class Ob {
  constructor(e, t, r, n = void 0) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = r.getSelf(), this.needsUpdate = n;
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
}
const Gu = Ob;
class Ib {
  constructor(e, t) {
    this.isNodeVar = !0, this.name = e, this.type = t;
  }
}
const ac = Ib;
class Pb extends ac {
  constructor(e, t) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
const Vu = Pb;
class Db {
  constructor(e, t, r = "") {
    this.name = e, this.type = t, this.code = r, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
const ju = Db;
class Ub {
  constructor() {
    this.keywords = [], this.nodes = [], this.keywordsCallback = {};
  }
  getNode(e) {
    let t = this.nodes[e];
    return t === void 0 && this.keywordsCallback[e] !== void 0 && (t = this.keywordsCallback[e](e), this.nodes[e] = t), t;
  }
  addKeyword(e, t) {
    return this.keywords.push(e), this.keywordsCallback[e] = t, this;
  }
  parse(e) {
    const t = this.keywords, r = new RegExp(`\\b${t.join("\\b|\\b")}\\b`, "g"), n = e.match(r), s = [];
    if (n !== null)
      for (const o of n) {
        const i = this.getNode(o);
        i !== void 0 && s.indexOf(i) === -1 && s.push(i);
      }
    return s;
  }
  include(e, t) {
    const r = this.parse(t);
    for (const n of r)
      n.build(e);
  }
}
const Wu = Ub;
class Pt extends Oe {
  constructor(e, t = null) {
    super(e), this.name = t;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    const t = e.getVarFromNode(this, this.getNodeType(e)), r = this.name;
    return r !== null && (t.name = r), e.getPropertyName(t);
  }
}
const Ns = (c, e) => Me(new Pt(c, e)), Xt = ce(Pt, "vec4", "DiffuseColor"), oo = ce(Pt, "float", "Roughness"), Ng = ce(Pt, "float", "Metalness"), ql = ce(Pt, "float", "Clearcoat"), Ea = ce(Pt, "float", "ClearcoatRoughness"), Jr = ce(Pt, "vec3", "Sheen"), Hu = ce(Pt, "float", "SheenRoughness"), Xu = ce(Pt, "float", "Iridescence"), wg = ce(Pt, "float", "IridescenceIOR"), Tg = ce(Pt, "float", "IridescenceThickness"), as = ce(Pt, "color", "SpecularColor"), Ra = ce(Pt, "float", "Shininess"), Sg = ce(Pt, "vec4", "Output"), io = ce(Pt, "float", "dashSize"), La = ce(Pt, "float", "gapSize");
oe("PropertyNode", Pt);
class $u extends vi {
  constructor(e = 0) {
    super(null, "vec2"), this.isUVNode = !0, this.index = e;
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const _g = $u, gt = (...c) => Me(new $u(...c));
oe("UVNode", $u);
class Mg extends Oe {
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const r = this.textureNode.build(e, "property"), n = this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${r}, ${n} )`, this.getNodeType(e), t);
  }
}
const Ag = j(Mg);
V("textureSize", Ag);
oe("TextureSizeNode", Mg);
class yt extends _t {
  constructor(e, t, r, ...n) {
    if (super(), this.op = e, n.length > 0) {
      let s = r;
      for (let o = 0; o < n.length; o++)
        s = new yt(e, s, n[o]);
      r = s;
    }
    this.aNode = t, this.bNode = r;
  }
  hasDependencies(e) {
    return this.op !== "=" ? super.hasDependencies(e) : !1;
  }
  getNodeType(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = n.getNodeType(e), i = s.getNodeType(e);
    if (o === "void" || i === "void")
      return "void";
    if (r === "=" || r === "%")
      return o;
    if (r === "&" || r === "|" || r === "^" || r === ">>" || r === "<<")
      return e.getIntegerType(o);
    if (r === "==" || r === "&&" || r === "||" || r === "^^")
      return "bool";
    if (r === "<" || r === ">" || r === "<=" || r === ">=") {
      const a = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(o), e.getTypeLength(i));
      return a > 1 ? `bvec${a}` : "bool";
    } else
      return o === "float" && e.isMatrix(i) ? i : e.isMatrix(o) && e.isVector(i) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(i) ? e.getVectorFromMatrix(i) : e.getTypeLength(i) > e.getTypeLength(o) ? i : o;
  }
  generate(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = this.getNodeType(e, t);
    let i = null, a = null;
    o !== "void" ? (i = n.getNodeType(e), a = s.getNodeType(e), r === "=" ? a = i : r === "<" || r === ">" || r === "<=" || r === ">=" || r === "==" ? e.isVector(i) ? a = i : i = a = "float" : r === ">>" || r === "<<" ? (i = o, a = e.changeComponentType(a, "uint")) : e.isMatrix(i) && e.isVector(a) ? a = e.getVectorFromMatrix(i) : e.isVector(i) && e.isMatrix(a) ? i = e.getVectorFromMatrix(a) : i = a = o) : i = a = o;
    const l = n.build(e, i), u = s.build(e, a), h = e.getTypeLength(t);
    if (t !== "void")
      return r === "=" ? (e.addLineFlowCode(`${l} ${this.op} ${u}`), l) : r === "<" && h > 1 ? e.format(`${e.getMethod("lessThan")}( ${l}, ${u} )`, o, t) : r === "<=" && h > 1 ? e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${u} )`, o, t) : r === ">" && h > 1 ? e.format(`${e.getMethod("greaterThan")}( ${l}, ${u} )`, o, t) : r === ">=" && h > 1 ? e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${u} )`, o, t) : e.format(`( ${l} ${this.op} ${u} )`, o, t);
    if (i !== "void")
      return e.format(`${l} ${this.op} ${u}`, o, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const xn = j(yt, "+"), Fa = j(yt, "-"), Kt = j(yt, "*"), mo = j(yt, "/"), Cg = j(yt, "%"), Eg = j(yt, "=="), qu = j(yt, "="), Rg = j(yt, "<"), Lg = j(yt, ">"), Fg = j(yt, "<="), Og = j(yt, ">="), Ig = j(yt, "&&"), Pg = j(yt, "||"), Dg = j(yt, "^^"), Ug = j(yt, "&"), zg = j(yt, "|"), Bg = j(yt, "^"), kg = j(yt, "<<"), Gg = j(yt, ">>");
V("add", xn);
V("sub", Fa);
V("mul", Kt);
V("div", mo);
V("remainder", Cg);
V("equal", Eg);
V("assign", qu);
V("lessThan", Rg);
V("greaterThan", Lg);
V("lessThanEqual", Fg);
V("greaterThanEqual", Og);
V("and", Ig);
V("or", Pg);
V("xor", Dg);
V("bitAnd", Ug);
V("bitOr", zg);
V("bitXor", Bg);
V("shiftLeft", kg);
V("shiftRight", Gg);
oe("OperatorNode", yt);
class z extends _t {
  constructor(e, t, r = null, n = null) {
    super(), this.method = e, this.aNode = t, this.bNode = r, this.cNode = n;
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e), r = this.bNode ? this.bNode.getNodeType(e) : null, n = this.cNode ? this.cNode.getNodeType(e) : null, s = e.isMatrix(t) ? 0 : e.getTypeLength(t), o = e.isMatrix(r) ? 0 : e.getTypeLength(r), i = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return s > o && s > i ? t : o > i ? r : i > s ? n : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === z.LENGTH || t === z.DISTANCE || t === z.DOT ? "float" : t === z.CROSS ? "vec3" : this.getInputType(e);
  }
  generate(e, t) {
    const r = this.method, n = this.getNodeType(e), s = this.getInputType(e), o = this.aNode, i = this.bNode, a = this.cNode, l = e.renderer.isWebGLRenderer === !0;
    if (r === z.TRANSFORM_DIRECTION) {
      let u = o, h = i;
      e.isMatrix(u.getNodeType(e)) ? h = st(Re(h), 0) : u = st(Re(u), 0);
      const d = Kt(u, h).xyz;
      return Ln(d).build(e, t);
    } else {
      if (r === z.NEGATE)
        return e.format("( - " + o.build(e, s) + " )", n, t);
      if (r === z.ONE_MINUS)
        return Fa(1, o).build(e, t);
      if (r === z.RECIPROCAL)
        return mo(1, o).build(e, t);
      if (r === z.DIFFERENCE)
        return ti(Fa(o, i)).build(e, t);
      {
        const u = [];
        return r === z.CROSS ? u.push(
          o.build(e, n),
          i.build(e, n)
        ) : r === z.STEP ? u.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : s),
          i.build(e, s)
        ) : l && (r === z.MIN || r === z.MAX) || r === z.MOD ? u.push(
          o.build(e, s),
          i.build(e, e.getTypeLength(i.getNodeType(e)) === 1 ? "float" : s)
        ) : r === z.REFRACT ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, "float")
        ) : r === z.MIX ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : s)
        ) : (u.push(o.build(e, s)), i !== null && u.push(i.build(e, s)), a !== null && u.push(a.build(e, s))), e.format(`${e.getMethod(r)}( ${u.join(", ")} )`, n, t);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
z.RADIANS = "radians";
z.DEGREES = "degrees";
z.EXP = "exp";
z.EXP2 = "exp2";
z.LOG = "log";
z.LOG2 = "log2";
z.SQRT = "sqrt";
z.INVERSE_SQRT = "inversesqrt";
z.FLOOR = "floor";
z.CEIL = "ceil";
z.NORMALIZE = "normalize";
z.FRACT = "fract";
z.SIN = "sin";
z.COS = "cos";
z.TAN = "tan";
z.ASIN = "asin";
z.ACOS = "acos";
z.ATAN = "atan";
z.ABS = "abs";
z.SIGN = "sign";
z.LENGTH = "length";
z.NEGATE = "negate";
z.ONE_MINUS = "oneMinus";
z.DFDX = "dFdx";
z.DFDY = "dFdy";
z.ROUND = "round";
z.RECIPROCAL = "reciprocal";
z.TRUNC = "trunc";
z.FWIDTH = "fwidth";
z.ATAN2 = "atan2";
z.MIN = "min";
z.MAX = "max";
z.MOD = "mod";
z.STEP = "step";
z.REFLECT = "reflect";
z.DISTANCE = "distance";
z.DIFFERENCE = "difference";
z.DOT = "dot";
z.CROSS = "cross";
z.POW = "pow";
z.TRANSFORM_DIRECTION = "transformDirection";
z.MIX = "mix";
z.CLAMP = "clamp";
z.REFRACT = "refract";
z.SMOOTHSTEP = "smoothstep";
z.FACEFORWARD = "faceforward";
const Be = z, Ju = _e(1e-6), zb = _e(1e6), Vg = j(z, z.RADIANS), jg = j(z, z.DEGREES), Wg = j(z, z.EXP), Hg = j(z, z.EXP2), Xg = j(z, z.LOG), $g = j(z, z.LOG2), qg = j(z, z.SQRT), Jg = j(z, z.INVERSE_SQRT), cc = j(z, z.FLOOR), Yu = j(z, z.CEIL), Ln = j(z, z.NORMALIZE), lc = j(z, z.FRACT), Yg = j(z, z.SIN), Kg = j(z, z.COS), Zg = j(z, z.TAN), Qg = j(z, z.ASIN), ey = j(z, z.ACOS), ty = j(z, z.ATAN), ti = j(z, z.ABS), ny = j(z, z.SIGN), sy = j(z, z.LENGTH), ry = j(z, z.NEGATE), oy = j(z, z.ONE_MINUS), Ku = j(z, z.DFDX), Zu = j(z, z.DFDY), iy = j(z, z.ROUND), ay = j(z, z.RECIPROCAL), cy = j(z, z.TRUNC), ly = j(z, z.FWIDTH), uy = j(z, z.ATAN2), hy = j(z, z.MIN), dy = j(z, z.MAX), Qu = j(z, z.MOD), fy = j(z, z.STEP), py = j(z, z.REFLECT), my = j(z, z.DISTANCE), gy = j(z, z.DIFFERENCE), Gs = j(z, z.DOT), yy = j(z, z.CROSS), eh = j(z, z.POW), vy = j(z, z.POW, 2), xy = j(z, z.POW, 3), by = j(z, z.POW, 4), Ny = j(z, z.TRANSFORM_DIRECTION), rn = j(z, z.MIX), ni = (c, e = 0, t = 1) => Me(new z(z.CLAMP, Me(c), Me(e), Me(t))), wy = (c) => ni(c), Ty = j(z, z.REFRACT), Ks = j(z, z.SMOOTHSTEP), Sy = j(z, z.FACEFORWARD), Bb = (c, e, t) => rn(e, t, c), kb = (c, e, t) => Ks(e, t, c);
V("radians", Vg);
V("degrees", jg);
V("exp", Wg);
V("exp2", Hg);
V("log", Xg);
V("log2", $g);
V("sqrt", qg);
V("inverseSqrt", Jg);
V("floor", cc);
V("ceil", Yu);
V("normalize", Ln);
V("fract", lc);
V("sin", Yg);
V("cos", Kg);
V("tan", Zg);
V("asin", Qg);
V("acos", ey);
V("atan", ty);
V("abs", ti);
V("sign", ny);
V("length", sy);
V("negate", ry);
V("oneMinus", oy);
V("dFdx", Ku);
V("dFdy", Zu);
V("round", iy);
V("reciprocal", ay);
V("trunc", cy);
V("fwidth", ly);
V("atan2", uy);
V("min", hy);
V("max", dy);
V("mod", Qu);
V("step", fy);
V("reflect", py);
V("distance", my);
V("dot", Gs);
V("cross", yy);
V("pow", eh);
V("pow2", vy);
V("pow3", xy);
V("pow4", by);
V("transformDirection", Ny);
V("mix", Bb);
V("clamp", ni);
V("refract", Ty);
V("smoothstep", kb);
V("faceForward", Sy);
V("difference", gy);
V("saturate", wy);
oe("MathNode", z);
const Gb = Ke((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.mul(0.9478672986).add(0.0521327014).pow(2.4), n = t.mul(0.0773993808), s = t.lessThanEqual(0.04045), o = rn(r, n, s);
  return st(o, e.a);
}), Vb = Ke((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.pow(0.41666).mul(1.055).sub(0.055), n = t.mul(12.92), s = t.lessThanEqual(31308e-7), o = rn(r, n, s);
  return st(o, e.a);
}), Bf = (c) => {
  let e = null;
  return c === Rn ? e = "Linear" : c === vn && (e = "sRGB"), e;
}, _y = (c, e) => Bf(c) + "To" + Bf(e);
class on extends _t {
  constructor(e, t) {
    super("vec4"), this.method = e, this.node = t;
  }
  setup() {
    const { method: e, node: t } = this;
    return e === on.LINEAR_TO_LINEAR ? t : jb[e]({ value: t });
  }
}
on.LINEAR_TO_LINEAR = "LinearToLinear";
on.LINEAR_TO_sRGB = "LinearTosRGB";
on.sRGB_TO_LINEAR = "sRGBToLinear";
const jb = {
  [on.LINEAR_TO_sRGB]: Vb,
  [on.sRGB_TO_LINEAR]: Gb
}, jo = on, My = (c, e) => Me(new on(_y(Rn, e), Me(c))), uc = (c, e) => Me(new on(_y(e, Rn), Me(c))), Ay = j(on, on.LINEAR_TO_sRGB), Cy = j(on, on.sRGB_TO_LINEAR);
V("linearTosRGB", Ay);
V("sRGBToLinear", Cy);
V("linearToColorSpace", My);
V("colorSpaceToLinear", uc);
oe("ColorSpaceNode", on);
class th extends Oe {
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.snippet;
    if (r === "void")
      e.addLineFlowCode(n);
    else
      return e.format(`( ${n} )`, r, t);
  }
}
const Ey = th, xo = j(th);
oe("ExpressionNode", th);
class nh extends Qe {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = r, this.compareNode = n, this.updateMatrix = !1, this.updateType = ut.NONE, this.setUpdateMatrix(t === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return gt(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    const t = this.value;
    return Rt(t.matrix).mul(Re(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? ut.FRAME : ut.NONE, this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let r = this.uvNode;
    r === null && e.context.getUVNode && (r = e.context.getUVNode(this)), r || (r = this.getDefaultUV()), this.updateMatrix === !0 && (r = this.getTransformedUV(r));
    let n = this.levelNode;
    n === null && e.context.getSamplerLevelNode && (n = e.context.getSamplerLevelNode(this)), t.uvNode = r, t.levelNode = n ? e.context.getMIPLevelAlgorithmNode(this, n) : null;
  }
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.compareNode, o = this.value;
    if (!o || o.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const i = super.generate(e, "property");
    if (t === "sampler")
      return i + "_sampler";
    if (e.isReference(t))
      return i;
    {
      const a = this.getNodeType(e), l = e.getDataFromNode(this);
      let u = l.propertyName;
      if (u === void 0) {
        const d = r.build(e, "vec2"), f = e.getVarFromNode(this, a);
        u = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(o, i, d, m);
        } else if (s !== null) {
          const m = s.build(e, "float");
          p = e.getTextureCompare(o, i, d, m);
        } else
          p = e.getTexture(o, i, d);
        e.addLineFlowCode(`${u} = ${p}`), e.context.tempWrite !== !1 && (l.snippet = p, l.propertyName = u);
      }
      let h = u;
      return e.needsColorSpaceToLinear(this.value) && (h = uc(xo(h, a), this.value.colorSpace).setup(e).build(e, a)), e.format(h, a, t);
    }
  }
  uv(e) {
    const t = this.clone();
    return t.uvNode = e, Me(t);
  }
  level(e) {
    const t = this.clone();
    return t.levelNode = e, Yn(t, {
      getMIPLevelAlgorithmNode: (r, n) => n
    });
  }
  size(e) {
    return Ag(this, e);
  }
  compare(e) {
    const t = this.clone();
    return t.compareNode = Me(e), Me(t);
  }
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value];
  }
  update() {
    const e = this.value;
    e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
}
const bi = nh, Zt = j(nh), Wb = (c) => (c.isNode === !0 ? c : Zt(c)).convert("sampler");
V("texture", Zt);
oe("TextureNode", nh);
class bo extends Oe {
  constructor(e, t, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = r, this.reference = null, this.node = null, this.updateType = ut.OBJECT, this.setNodeType(t);
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setNodeType(e) {
    let t = null;
    e === "texture" ? t = Zt(null) : t = Rt(e), this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  update() {
    this.node.value = this.reference[this.property];
  }
  setup() {
    return this.node;
  }
}
const As = (c, e, t) => Me(new bo(c, e, t));
oe("ReferenceNode", bo);
class hc extends bo {
  constructor(e, t, r = null) {
    super(e, t, r), this.material = r, this.updateType = ut.RENDER;
  }
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
  setup(e) {
    const t = this.material !== null ? this.material : e.material;
    return this.node.value = t[this.property], super.setup(e);
  }
}
const ao = (c, e, t) => Me(new hc(c, e, t));
oe("MaterialReferenceNode", hc);
const kf = /* @__PURE__ */ new Map();
class Ne extends Oe {
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, t) {
    let r = kf.get(e);
    return r === void 0 && (r = ao(e, t), kf.set(e, r)), r;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e, "texture");
  }
  setup(e) {
    const t = e.context.material, r = this.scope;
    let n = null;
    if (r === Ne.ALPHA_TEST || r === Ne.SHININESS || r === Ne.REFLECTIVITY || r === Ne.ROTATION || r === Ne.IRIDESCENCE || r === Ne.IRIDESCENCE_IOR)
      n = this.getFloat(r);
    else if (r === Ne.SPECULAR_COLOR)
      n = this.getColor("specular");
    else if (r === Ne.COLOR) {
      const s = this.getColor("color");
      t.map && t.map.isTexture === !0 ? n = s.mul(this.getTexture("map")) : n = s;
    } else if (r === Ne.OPACITY) {
      const s = this.getFloat("opacity");
      t.alphaMap && t.alphaMap.isTexture === !0 ? n = s.mul(this.getTexture("alphaMap")) : n = s;
    } else if (r === Ne.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? n = this.getTexture("specularMap").r : n = _e(1);
    else if (r === Ne.ROUGHNESS) {
      const s = this.getFloat("roughness");
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("roughnessMap").g) : n = s;
    } else if (r === Ne.METALNESS) {
      const s = this.getFloat("metalness");
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? n = s.mul(this.getTexture("metalnessMap").b) : n = s;
    } else if (r === Ne.EMISSIVE) {
      const s = this.getColor("emissive");
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? n = s.mul(this.getTexture("emissiveMap")) : n = s;
    } else if (r === Ne.CLEARCOAT) {
      const s = this.getFloat("clearcoat");
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? n = s.mul(this.getTexture("clearcoatMap").r) : n = s;
    } else if (r === Ne.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat("clearcoatRoughness");
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("clearcoatRoughnessMap").r) : n = s;
    } else if (r === Ne.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenColorMap").rgb) : n = s;
    } else if (r === Ne.SHEEN_ROUGHNESS) {
      const s = this.getFloat("sheenRoughness");
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenRoughnessMap").a) : n = s, n = n.clamp(0.07, 1);
    } else if (r === Ne.IRIDESCENCE_THICKNESS) {
      const s = As(1, "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = As(0, "float", t.iridescenceThicknessRange);
        n = s.sub(o).mul(this.getTexture("iridescenceThicknessMap").g).add(o);
      } else
        n = s;
    } else {
      const s = this.getNodeType(e);
      n = ao(r, s);
    }
    return n;
  }
}
Ne.ALPHA_TEST = "alphaTest";
Ne.COLOR = "color";
Ne.OPACITY = "opacity";
Ne.SHININESS = "shininess";
Ne.SPECULAR = "specular";
Ne.SPECULAR_STRENGTH = "specularStrength";
Ne.REFLECTIVITY = "reflectivity";
Ne.ROUGHNESS = "roughness";
Ne.METALNESS = "metalness";
Ne.CLEARCOAT = "clearcoat";
Ne.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
Ne.EMISSIVE = "emissive";
Ne.ROTATION = "rotation";
Ne.SHEEN = "sheen";
Ne.SHEEN_ROUGHNESS = "sheenRoughness";
Ne.IRIDESCENCE = "iridescence";
Ne.IRIDESCENCE_IOR = "iridescenceIOR";
Ne.IRIDESCENCE_THICKNESS = "iridescenceThickness";
const Jn = Ne, Ry = ce(Ne, Ne.ALPHA_TEST), sh = ce(Ne, Ne.COLOR), Ly = ce(Ne, Ne.SHININESS), Fy = ce(Ne, Ne.EMISSIVE), rh = ce(Ne, Ne.OPACITY), Oy = ce(Ne, Ne.SPECULAR_COLOR), Hb = ce(Ne, Ne.SPECULAR_STRENGTH), Xb = ce(Ne, Ne.REFLECTIVITY), Iy = ce(Ne, Ne.ROUGHNESS), Py = ce(Ne, Ne.METALNESS), $b = ce(Ne, Ne.CLEARCOAT), qb = ce(Ne, Ne.CLEARCOAT_ROUGHNESS), Dy = ce(Ne, Ne.ROTATION), Uy = ce(Ne, Ne.SHEEN), zy = ce(Ne, Ne.SHEEN_ROUGHNESS), Jb = ce(Ne, Ne.IRIDESCENCE), Yb = ce(Ne, Ne.IRIDESCENCE_IOR), Kb = ce(Ne, Ne.IRIDESCENCE_THICKNESS);
oe("MaterialNode", Ne);
class Ue extends Oe {
  constructor(e = Ue.VIEW_MATRIX, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = ut.OBJECT, this._uniformNode = new Qe(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === Ue.WORLD_MATRIX || e === Ue.VIEW_MATRIX)
      return "mat4";
    if (e === Ue.NORMAL_MATRIX)
      return "mat3";
    if (e === Ue.POSITION || e === Ue.VIEW_POSITION || e === Ue.DIRECTION || e === Ue.SCALE)
      return "vec3";
  }
  update(e) {
    const t = this.object3d, r = this._uniformNode, n = this.scope;
    if (n === Ue.VIEW_MATRIX)
      r.value = t.modelViewMatrix;
    else if (n === Ue.NORMAL_MATRIX)
      r.value = t.normalMatrix;
    else if (n === Ue.WORLD_MATRIX)
      r.value = t.matrixWorld;
    else if (n === Ue.POSITION)
      r.value = r.value || new ge(), r.value.setFromMatrixPosition(t.matrixWorld);
    else if (n === Ue.SCALE)
      r.value = r.value || new ge(), r.value.setFromMatrixScale(t.matrixWorld);
    else if (n === Ue.DIRECTION)
      r.value = r.value || new ge(), t.getWorldDirection(r.value);
    else if (n === Ue.VIEW_POSITION) {
      const s = e.camera;
      r.value = r.value || new ge(), r.value.setFromMatrixPosition(t.matrixWorld), r.value.applyMatrix4(s.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return t === Ue.WORLD_MATRIX || t === Ue.VIEW_MATRIX ? this._uniformNode.nodeType = "mat4" : t === Ue.NORMAL_MATRIX ? this._uniformNode.nodeType = "mat3" : (t === Ue.POSITION || t === Ue.VIEW_POSITION || t === Ue.DIRECTION || t === Ue.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Ue.VIEW_MATRIX = "viewMatrix";
Ue.NORMAL_MATRIX = "normalMatrix";
Ue.WORLD_MATRIX = "worldMatrix";
Ue.POSITION = "position";
Ue.SCALE = "scale";
Ue.VIEW_POSITION = "viewPosition";
Ue.DIRECTION = "direction";
const gn = Ue, Zb = j(Ue, Ue.DIRECTION), Qb = j(Ue, Ue.VIEW_MATRIX), eN = j(Ue, Ue.NORMAL_MATRIX), tN = j(Ue, Ue.WORLD_MATRIX), Oa = j(Ue, Ue.POSITION), nN = j(Ue, Ue.SCALE), oh = j(Ue, Ue.VIEW_POSITION);
oe("Object3DNode", Ue);
class rt extends gn {
  constructor(e = rt.POSITION) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === rt.PROJECTION_MATRIX ? "mat4" : t === rt.NEAR || t === rt.FAR ? "float" : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera, r = this._uniformNode, n = this.scope;
    n === rt.VIEW_MATRIX ? r.value = t.matrixWorldInverse : n === rt.PROJECTION_MATRIX ? r.value = t.projectionMatrix : n === rt.NEAR ? r.value = t.near : n === rt.FAR ? r.value = t.far : (this.object3d = t, super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return t === rt.PROJECTION_MATRIX ? this._uniformNode.nodeType = "mat4" : (t === rt.NEAR || t === rt.FAR) && (this._uniformNode.nodeType = "float"), super.generate(e);
  }
}
rt.PROJECTION_MATRIX = "projectionMatrix";
rt.NEAR = "near";
rt.FAR = "far";
const ih = rt, xs = ic(ce(rt, rt.PROJECTION_MATRIX), "projectionMatrix"), ma = ce(rt, rt.NEAR), ga = ce(rt, rt.FAR), Es = ce(rt, rt.VIEW_MATRIX), sN = ce(rt, rt.NORMAL_MATRIX), rN = ce(rt, rt.WORLD_MATRIX), oN = ce(rt, rt.POSITION);
oe("CameraNode", rt);
class kt extends gn {
  constructor(e = kt.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
const iN = ce(kt, kt.DIRECTION), br = ic(ce(kt, kt.VIEW_MATRIX), "modelViewMatrix"), ah = ce(kt, kt.NORMAL_MATRIX), si = ce(kt, kt.WORLD_MATRIX), aN = ce(kt, kt.POSITION), cN = ce(kt, kt.SCALE), lN = ce(kt, kt.VIEW_POSITION);
oe("ModelNode", kt);
class At extends Oe {
  constructor(e = At.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === At.GEOMETRY)
      r = Ft("normal", "vec3");
    else if (t === At.LOCAL)
      r = at(ri);
    else if (t === At.VIEW) {
      const n = ah.mul(Nr);
      r = Ln(at(n));
    } else if (t === At.WORLD) {
      const n = us.transformDirection(Es);
      r = Ln(at(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
At.GEOMETRY = "geometry";
At.LOCAL = "local";
At.VIEW = "view";
At.WORLD = "world";
const Wo = At, ri = ce(At, At.GEOMETRY), Nr = ce(At, At.LOCAL), us = ce(At, At.VIEW), dc = ce(At, At.WORLD), St = Ns("vec3", "TransformedNormalView"), By = St.transformDirection(Es).normalize(), fr = Ns("vec3", "TransformedClearcoatNormalView");
oe("NormalNode", At);
class fc extends Oe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  assign(e) {
    return e.traverse((t, r) => {
      r && t.uuid === this.uuid && r(this.node);
    }), this.node = e, this;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node, r = this.name;
    if (r === null && t.isTempNode === !0)
      return t.build(e);
    const n = e.getVectorType(this.getNodeType(e)), s = t.build(e, n), o = e.getVarFromNode(this, n);
    r !== null && (o.name = r);
    const i = e.getPropertyName(o);
    return e.addLineFlowCode(`${i} = ${s}`), i;
  }
}
const oi = j(fc);
V("temp", oi);
oe("VarNode", fc);
class Tt extends Oe {
  constructor(e = Tt.LOCAL) {
    super(), this.scope = e;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === Tt.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Tt.GEOMETRY)
      r = Ft("tangent", "vec4");
    else if (t === Tt.LOCAL)
      r = at(ii.xyz);
    else if (t === Tt.VIEW) {
      const n = br.mul(pc).xyz;
      r = Ln(at(n));
    } else if (t === Tt.WORLD) {
      const n = Ni.transformDirection(Es);
      r = Ln(at(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Tt.GEOMETRY = "geometry";
Tt.LOCAL = "local";
Tt.VIEW = "view";
Tt.WORLD = "world";
const Yr = Tt, ii = ce(Tt, Tt.GEOMETRY), pc = ce(Tt, Tt.LOCAL), Ni = ce(Tt, Tt.VIEW), ky = ce(Tt, Tt.WORLD), ch = oi(Ni, "TransformedTangentView"), uN = Ln(ch.transformDirection(Es));
oe("TangentNode", Tt);
class Ct extends Oe {
  constructor(e = Ct.LOCAL) {
    super("vec3"), this.scope = e;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r;
    t === Ct.GEOMETRY ? r = ri.cross(ii) : t === Ct.LOCAL ? r = Nr.cross(pc) : t === Ct.VIEW ? r = us.cross(Ni) : t === Ct.WORLD && (r = dc.cross(ky));
    const n = r.mul(ii.w).xyz;
    return Ln(at(n)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Ct.GEOMETRY = "geometry";
Ct.LOCAL = "local";
Ct.VIEW = "view";
Ct.WORLD = "world";
const Kr = Ct, hN = ce(Ct, Ct.GEOMETRY), dN = ce(Ct, Ct.LOCAL), Gy = ce(Ct, Ct.VIEW), fN = ce(Ct, Ct.WORLD), Vy = Ln(St.cross(ch).mul(ii.w)), pN = Ln(Vy.transformDirection(Es));
oe("BitangentNode", Ct);
class ct extends Oe {
  constructor(e = ct.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === ct.GEOMETRY)
      r = Ft("position", "vec3");
    else if (t === ct.LOCAL)
      r = at(pn);
    else if (t === ct.WORLD) {
      const n = si.mul(bn);
      r = at(n);
    } else if (t === ct.VIEW) {
      const n = br.mul(bn);
      r = at(n);
    } else if (t === ct.VIEW_DIRECTION) {
      const n = Qn.negate();
      r = Ln(at(n));
    } else if (t === ct.WORLD_DIRECTION) {
      const n = bn.transformDirection(si);
      r = Ln(at(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
ct.GEOMETRY = "geometry";
ct.LOCAL = "local";
ct.WORLD = "world";
ct.WORLD_DIRECTION = "worldDirection";
ct.VIEW = "view";
ct.VIEW_DIRECTION = "viewDirection";
const Us = ct, pn = ce(ct, ct.GEOMETRY), bn = ce(ct, ct.LOCAL), lh = ce(ct, ct.WORLD), uh = ce(ct, ct.WORLD_DIRECTION), Qn = ce(ct, ct.VIEW), Ot = ce(ct, ct.VIEW_DIRECTION);
oe("PositionNode", ct);
class hh extends Oe {
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    return e.getFrontFacing();
  }
}
const jy = hh, Wy = ce(hh), dh = _e(Wy).mul(2).sub(1);
oe("FrontFacingNode", hh);
const mN = Ke((c) => {
  const { eye_pos: e, surf_norm: t, mapN: r, uv: n } = c, s = e.dFdx(), o = e.dFdy(), i = n.dFdx(), a = n.dFdy(), l = t, u = o.cross(l), h = l.cross(s), d = u.mul(i.x).add(h.mul(a.x)), f = u.mul(i.y).add(h.mul(a.y)), p = d.dot(d).max(f.dot(f)), m = dh.mul(p.inverseSqrt());
  return xn(d.mul(r.x, m), f.mul(r.y, m), l.mul(r.z)).normalize();
});
class fh extends _t {
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = Lf;
  }
  setup(e) {
    const { normalMapType: t, scaleNode: r } = this;
    let n = this.node.mul(2).sub(1);
    r !== null && (n = Re(n.xy.mul(r), n.z));
    let s = null;
    return t === Q1 ? s = ah.mul(n).normalize() : t === Lf && (e.hasGeometryAttribute("tangent") === !0 ? s = Xy.mul(n).normalize() : s = mN({
      eye_pos: Qn,
      surf_norm: us,
      mapN: n,
      uv: gt()
    })), s;
  }
}
const Hy = fh, Jl = j(fh), Xy = Ms(Ni, Gy, us);
oe("NormalMapNode", fh);
const gN = Ke(({ bumpTexture: c, bumpScale: e }) => {
  const t = gt(), r = Zt(c, t).x;
  return tt(
    Zt(c, t.add(t.dFdx())).x.sub(r),
    Zt(c, t.add(t.dFdy())).x.sub(r)
  ).mul(e);
}), yN = Ke((c) => {
  const { surf_pos: e, surf_norm: t, dHdxy: r } = c, n = e.dFdx(), s = e.dFdy(), o = t, i = s.cross(o), a = o.cross(n), l = n.dot(i).mul(dh), u = l.sign().mul(r.x.mul(i).add(r.y.mul(a)));
  return l.abs().mul(t).sub(u).normalize();
});
class ph extends _t {
  constructor(e, t = null) {
    super("vec3"), this.texture = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = gN({ bumpTexture: this.texture, bumpScale: e });
    return yN({
      surf_pos: Qn.negate(),
      surf_norm: us,
      dHdxy: t
    });
  }
}
const vN = ph, $y = j(ph);
oe("BumpMapNode", ph);
class Cn extends Jn {
  constructor(e) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    let r = null;
    return (t === Cn.NORMAL || t === Cn.CLEARCOAT_NORMAL) && (r = "vec3"), r || super.getNodeType(e);
  }
  setup(e) {
    const t = e.material, r = this.scope;
    let n = null;
    return r === Cn.NORMAL ? t.normalMap ? n = Jl(this.getTexture("normalMap"), ao("normalScale", "vec2")) : t.bumpMap ? n = $y(t.bumpMap, ao("bumpScale", "float")) : n = us : r === Cn.CLEARCOAT_NORMAL && (n = t.clearcoatNormalMap ? Jl(this.getTexture("clearcoatNormalMap"), ao("clearcoatNormalScale", "vec2")) : us), n || super.setup(e);
  }
}
Cn.NORMAL = "normal";
Cn.CLEARCOAT_NORMAL = "clearcoatNormal";
const xN = Cn, qy = ce(Cn, Cn.NORMAL), bN = ce(Cn, Cn.CLEARCOAT_NORMAL);
oe("ExtendedMaterialNode", Cn);
class mh extends _t {
  constructor(e = bn) {
    super("vec4"), this.positionNode = e;
  }
  setup() {
    return xs.mul(br).mul(this.positionNode);
  }
}
const Jy = mh, Yy = j(mh);
oe("ModelViewProjectionNode", mh);
class gh extends Fu {
  constructor(e, t = null, r = 0, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = r, this.bufferOffset = n, this.usage = ex, this.instanced = !1, this.attribute = null, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null)
      return;
    const t = this.getNodeType(e), r = this.value, n = e.getTypeLength(t), s = this.bufferStride || n, o = this.bufferOffset, i = r.isInterleavedBuffer === !0 ? r : new cm(r, s), a = new Vs(i, n, o);
    i.setUsage(this.usage), this.attribute = a, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const t = this.getNodeType(e), r = e.getBufferAttributeFromNode(this, t), n = e.getPropertyName(r);
    let s = null;
    return e.shaderStage === "vertex" ? s = n : s = at(this).build(e, t), s;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const NN = gh, wi = (c, e, t, r) => Me(new gh(c, e, t, r)), Ky = (c, e, t, r) => wi(c, e, t, r).setUsage(xu), Zy = (c, e, t, r) => wi(c, e, t, r).setInstanced(!0), Qy = (c, e, t, r) => Ky(c, e, t, r).setInstanced(!0);
V("toAttribute", (c) => wi(c.value));
oe("BufferAttributeNode", gh);
class yh extends Oe {
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null;
  }
  setup(e) {
    let t = this.instanceMatrixNode;
    if (t === null) {
      const a = this.instanceMesh.instanceMatrix, l = new Ta(a.array, 16, 1), u = a.usage === xu ? Qy : Zy, h = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        u(l, "vec4", 16, 0),
        u(l, "vec4", 16, 4),
        u(l, "vec4", 16, 8),
        u(l, "vec4", 16, 12)
      ];
      t = Du(...h), this.instanceMatrixNode = t;
    }
    const r = t.mul(bn).xyz, n = Ms(t[0].xyz, t[1].xyz, t[2].xyz), s = Nr.div(Re(n[0].dot(n[0]), n[1].dot(n[1]), n[2].dot(n[2]))), o = n.mul(s).xyz;
    e.stack.assign(bn, r), e.stack.assign(Nr, o);
  }
}
const wN = yh, e0 = j(yh);
oe("InstanceNode", yh);
class vh extends Qe {
  constructor(e, t, r = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = r;
  }
  getInputType() {
    return "buffer";
  }
}
const xh = vh, bh = (c, e, t) => Me(new vh(c, e, t));
oe("BufferNode", vh);
class Nh extends Oe {
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = ut.OBJECT, this.skinIndexNode = Ft("skinIndex", "uvec4"), this.skinWeightNode = Ft("skinWeight", "vec4"), this.bindMatrixNode = Rt(e.bindMatrix, "mat4"), this.bindMatrixInverseNode = Rt(e.bindMatrixInverse, "mat4"), this.boneMatricesNode = bh(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length);
  }
  setup(e) {
    const { skinIndexNode: t, skinWeightNode: r, bindMatrixNode: n, bindMatrixInverseNode: s, boneMatricesNode: o } = this, i = o.element(t.x), a = o.element(t.y), l = o.element(t.z), u = o.element(t.w), h = n.mul(bn), d = xn(
      i.mul(r.x).mul(h),
      a.mul(r.y).mul(h),
      l.mul(r.z).mul(h),
      u.mul(r.w).mul(h)
    ), f = s.mul(d).xyz;
    let p = xn(
      r.x.mul(i),
      r.y.mul(a),
      r.z.mul(l),
      r.w.mul(u)
    );
    p = s.mul(p).mul(n);
    const m = p.transformDirection(Nr).xyz;
    e.stack.assign(bn, f), e.stack.assign(Nr, m), e.hasGeometryAttribute("tangent") && e.stack.assign(pc, m);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const t0 = Nh, n0 = j(Nh);
oe("SkinningNode", Nh);
class wh extends Oe {
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Rt(1), this.updateType = ut.OBJECT;
  }
  setupAttribute(e, t, r = bn) {
    const n = this.mesh, s = n.geometry.morphAttributes[t];
    e.stack.assign(r, r.mul(this.morphBaseInfluence));
    for (let o = 0; o < s.length; o++) {
      const i = s[o], a = wi(i.array, "vec3"), l = As(o, "float", n.morphTargetInfluences);
      e.stack.assign(r, r.add(a.mul(l)));
    }
  }
  setup(e) {
    this.setupAttribute(e, "position");
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, r) => t + r, 0);
  }
}
const TN = wh, s0 = j(wh);
oe("MorphNode", wh);
class Th extends Oe {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return Ot.negate().reflect(St).transformDirection(Es);
  }
}
const r0 = Th, o0 = ce(Th);
oe("ReflectVectorNode", Th);
class Sh extends bi {
  constructor(e, t = null, r = null) {
    super(e, t, r), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return o0;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.value;
    if (!s || s.isCubeTexture !== !0)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const o = Qe.prototype.generate.call(this, e, "cubeTexture");
    if (t === "sampler")
      return o + "_sampler";
    if (e.isReference(t))
      return o;
    {
      const i = this.getNodeType(e), a = e.getDataFromNode(this);
      let l = a.propertyName;
      if (l === void 0) {
        const d = Re(r.x.negate(), r.yz).build(e, "vec3"), f = e.getVarFromNode(this, "vec4");
        l = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(this, o, d, m);
        } else
          p = e.getTexture(this, o, d);
        e.addLineFlowCode(`${l} = ${p}`), e.context.tempWrite !== !1 && (a.snippet = p, a.propertyName = l);
      }
      let u = l;
      return e.needsColorSpaceToLinear(this.value) && (u = uc(xo(u, i), this.value.colorSpace).setup(e).build(e, i)), e.format(u, "vec4", t);
    }
  }
}
const i0 = Sh, mc = j(Sh);
V("cubeTexture", mc);
oe("CubeTextureNode", Sh);
class a0 extends Oe {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Ti = a0;
oe("LightingNode", a0);
let Qc = null;
class c0 extends Ti {
  constructor(e = null) {
    super(), this.updateType = ut.FRAME, this.light = e, this.rtt = null, this.shadowNode = null, this.color = new He(), this.colorNode = Rt(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    let t = this.shadowNode;
    if (t === null) {
      Qc === null && (Qc = e.createNodeMaterial("MeshBasicNodeMaterial"));
      const r = this.light.shadow, n = e.getRenderTarget(r.mapSize.width, r.mapSize.height), s = new lm();
      s.minFilter = js, s.magFilter = js, s.image.width = r.mapSize.width, s.image.height = r.mapSize.height, s.compareFunction = tx, n.depthTexture = s, r.camera.updateProjectionMatrix();
      const o = As("bias", "float", r), i = As("normalBias", "float", r);
      let a = Rt(r.matrix).mul(lh.add(dc.mul(i)));
      a = a.xyz.div(a.w);
      const l = a.x.greaterThanEqual(0).and(a.x.lessThanEqual(1)).and(a.y.greaterThanEqual(0)).and(a.y.lessThanEqual(1)).and(a.z.lessThanEqual(1));
      a = Re(
        a.x,
        a.y.oneMinus(),
        // WebGPU: Flip Y
        a.z.add(o).mul(2).sub(1)
        // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
      ), t = ((h, d, f) => Zt(h, d).compare(f))(s, a.xy, a.z), this.rtt = n, this.colorNode = this.colorNode.mul(l.mix(1, t)), this.shadowNode = t, this.updateBeforeType = ut.RENDER;
    }
  }
  setup(e) {
    this.light.castShadow && this.setupShadow(e);
  }
  updateShadow(e) {
    const { rtt: t, light: r } = this, { renderer: n, scene: s } = e;
    s.overrideMaterial = Qc, t.setSize(r.shadow.mapSize.width, r.shadow.mapSize.height), r.shadow.updateMatrices(r), n.setRenderTarget(t), n.render(s, r.shadow.camera), n.setRenderTarget(null), s.overrideMaterial = null;
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const sr = c0;
oe("AnalyticLightNode", c0);
const Ia = /* @__PURE__ */ new WeakMap(), SN = (c) => c.sort((e, t) => e.id - t.id);
class _h extends Oe {
  constructor(e = []) {
    super("vec3"), this.lightNodes = e, this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  setup(e) {
    const t = this.lightNodes;
    for (const r of t)
      r.build(e);
  }
  getHash(e) {
    if (this._hash === null) {
      let t = "";
      const r = this.lightNodes;
      for (const n of r)
        t += n.getHash(e) + " ";
      this._hash = t;
    }
    return this._hash;
  }
  getLightNodeByHash(e) {
    const t = this.lightNodes;
    for (const r of t)
      if (r.light.uuid === e)
        return r;
    return null;
  }
  fromLights(e = []) {
    const t = [];
    e = SN(e);
    for (const r of e) {
      let n = this.getLightNodeByHash(r.uuid);
      if (n === null) {
        const s = r.constructor, o = Ia.has(s) ? Ia.get(s) : sr;
        n = Me(new o(r));
      }
      t.push(n);
    }
    return this.lightNodes = t, this._hash = null, this;
  }
}
const l0 = _h, _N = (c) => Me(new _h().fromLights(c)), u0 = j(_h);
function Sr(c, e) {
  if (Ia.has(c))
    throw new Error(`Redefinition of light node ${e.type}`);
  if (typeof c != "function")
    throw new Error(`Light ${c.name} is not a class`);
  if (typeof e != "function" || !e.type)
    throw new Error(`Light node ${e.type} is not a class`);
  Ia.set(c, e);
}
class h0 extends Ti {
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    const r = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(r);
  }
}
const Mh = h0;
oe("AONode", h0);
class Ah extends xi {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.lightingModel = t, this.backdropNode = r, this.backdropAlphaNode = n;
  }
  getNodeType() {
    return "vec3";
  }
  setup(e) {
    const { lightingModel: t, backdropNode: r, backdropAlphaNode: n } = this, s = this.context = {}, o = e.getNodeProperties(this), i = Re().temp(), a = Re().temp(), l = Re().temp(), u = Re().temp();
    let h = xn(i, l);
    r !== null && (h = Re(n !== null ? rn(h, r, n) : r));
    const d = xn(a, u), f = xn(h, d).temp(), p = {
      directDiffuse: i,
      directSpecular: a,
      indirectDiffuse: l,
      indirectSpecular: u,
      total: f
    }, m = {
      radiance: Re().temp(),
      irradiance: Re().temp(),
      iblIrradiance: Re().temp(),
      ambientOcclusion: _e(1).temp()
    };
    return s.reflectedLight = p, s.lightingModel = t || s.lightingModel, Object.assign(o, p, m), Object.assign(s, m), t && (t.init(s, e.stack, e), t.indirectDiffuse(s, e.stack, e), t.indirectSpecular(s, e.stack, e), t.ambientOcclusion(s, e.stack, e)), super.setup(e);
  }
  generate(e) {
    const { context: t } = this, r = this.getNodeType(e);
    return super.generate(e, r), t.reflectedLight.total.build(e, r);
  }
}
const MN = Ah, Ch = j(Ah);
V("lightingContext", Ch);
oe("LightingContextNode", Ah);
class Eh extends _t {
  constructor(e = uh) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, t = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), r = e.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return tt(t, r);
  }
}
const d0 = Eh, gc = j(Eh);
oe("EquirectUVNode", Eh);
class Rh extends Qe {
  constructor(e) {
    super(0), this.textureNode = e, this.updateType = ut.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, r = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (r && r.width !== void 0) {
      const { width: n, height: s } = r;
      this.value = Math.log2(Math.max(n, s));
    }
  }
}
const f0 = Rh, Lh = j(Rh);
oe("MaxMipLevelNode", Rh);
class Fh extends Oe {
  constructor(e, t = null) {
    super("float"), this.textureNode = e, this.roughnessNode = t;
  }
  setup() {
    const { textureNode: e, roughnessNode: t } = this, r = Lh(e), n = t.mul(t).mul(Math.PI).div(t.add(1));
    return r.add(n.log2()).clamp(0, r);
  }
}
const p0 = Fh, Oh = j(Fh);
oe("SpecularMIPLevelNode", Fh);
const Gf = /* @__PURE__ */ new WeakMap();
class m0 extends Ti {
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    let t = this.envNode;
    const r = e.getNodeProperties(this);
    if (t.isTextureNode && t.value.isCubeTexture !== !0) {
      let l = Gf.get(t.value);
      if (l === void 0) {
        const u = t.value, h = e.renderer, d = e.getCubeRenderTarget(512).fromEquirectangularTexture(h, u);
        l = mc(d.texture), Gf.set(t.value, l);
      }
      t = l;
    }
    const n = As("envMapIntensity", "float", e.material), s = Yn(t, Vf(oo, St)).mul(n), o = Yn(t, AN(By)).mul(Math.PI).mul(n), i = Aa(s);
    e.context.radiance.addAssign(i), e.context.iblIrradiance.addAssign(o);
    const a = e.context.lightingModel.clearcoatRadiance;
    if (a) {
      const l = Yn(t, Vf(Ea, fr)).mul(n), u = Aa(l);
      a.addAssign(u);
    }
    r.radiance = i, r.irradiance = o;
  }
}
const Vf = (c, e) => {
  let t = null, r = null;
  return {
    getUVNode: (n) => {
      let s = null;
      return t === null && (t = Ot.negate().reflect(e), t = c.mul(c).mix(t, e).normalize(), t = t.transformDirection(Es)), n.isCubeTextureNode ? s = t : n.isTextureNode && (r === null && (r = gc(t)), s = r), s;
    },
    getSamplerLevelNode: () => c,
    getMIPLevelAlgorithmNode: (n, s) => Oh(n, s)
  };
}, AN = (c) => {
  let e = null;
  return {
    getUVNode: (t) => {
      let r = null;
      return t.isCubeTextureNode ? r = c : t.isTextureNode && (e === null && (e = gc(c), e = tt(e.x, e.y.oneMinus())), r = e), r;
    },
    getSamplerLevelNode: () => _e(1),
    getMIPLevelAlgorithmNode: (t, r) => Oh(t, r)
  };
}, Ih = m0;
oe("EnvironmentNode", m0);
const Yl = /* @__PURE__ */ new Map();
class en extends ls {
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.unlit = this.constructor === en.prototype.constructor, this.fog = !0, this.lights = !0, this.normals = !0, this.colorSpace = !0, this.lightsNode = null, this.envNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.outputNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + Ka(this);
  }
  build(e) {
    this.setup(e);
  }
  setup(e) {
    e.addStack(), e.stack.outputNode = this.setupPosition(e), e.addFlow("vertex", e.removeStack()), e.addStack();
    let t;
    if (this.unlit === !1) {
      this.normals === !0 && this.setupNormal(e), this.setupDiffuseColor(e), this.setupVariants(e);
      const r = this.setupLighting(e);
      t = this.setupOutput(e, st(r, Xt.a)), e.stack.assign(Sg, t), this.outputNode !== null && (t = this.outputNode);
    } else
      t = this.setupOutput(e, this.outputNode || st(0, 0, 0, 1));
    e.stack.outputNode = t, e.addFlow("fragment", e.removeStack());
  }
  setupPosition(e) {
    const t = e.object, r = t.geometry;
    return e.addStack(), (r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color) && e.stack.add(s0(t)), t.isSkinnedMesh === !0 && e.stack.add(n0(t)), t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && e.isAvailable("instance") === !0 && e.stack.add(e0(t)), this.positionNode !== null && e.stack.assign(bn, this.positionNode), e.context.vertex = e.removeStack(), this.vertexNode || Yy();
  }
  setupDiffuseColor({ stack: e, geometry: t }) {
    let r = this.colorNode ? st(this.colorNode) : sh;
    this.vertexColors === !0 && t.hasAttribute("color") && (r = st(r.xyz.mul(Ft("color")), r.a)), e.assign(Xt, r);
    const n = this.opacityNode ? _e(this.opacityNode) : rh;
    if (e.assign(Xt.a, Xt.a.mul(n)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const s = this.alphaTestNode !== null ? _e(this.alphaTestNode) : Ry;
      e.add(Xt.a.lessThanEqual(s).discard());
    }
  }
  setupVariants() {
  }
  setupNormal({ stack: e }) {
    if (this.flatShading === !0) {
      const t = Ku(Qn), r = Zu(Qn), n = t.cross(r).normalize();
      e.assign(St, n);
    } else {
      const t = this.normalNode ? Re(this.normalNode) : qy;
      e.assign(St, t);
    }
  }
  getEnvNode(e) {
    let t = null;
    return this.envNode ? t = this.envNode : this.envMap ? t = this.envMap.isCubeTexture ? mc(this.envMap) : Zt(this.envMap) : e.environmentNode && (t = e.environmentNode), t;
  }
  setupLights(e) {
    const t = this.getEnvNode(e), r = [];
    t && r.push(new Ih(t)), e.material.aoMap && r.push(new Mh(Zt(e.material.aoMap)));
    let n = this.lightsNode || e.lightsNode;
    return r.length > 0 && (n = u0([...n.lightNodes, ...r])), n;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: t } = e, { backdropNode: r, backdropAlphaNode: n, emissiveNode: s } = this, i = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let a = Xt.rgb;
    if (i && i.hasLight !== !1) {
      const l = this.setupLightingModel(e);
      a = Ch(i, l, r, n);
    } else
      r !== null && (a = Re(n !== null ? rn(a, r, n) : r));
    return (s && s.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (a = a.add(Re(s || Fy))), a;
  }
  setupOutput(e, t) {
    const r = e.renderer, n = e.toneMappingNode;
    if (n && (t = st(n.context({ color: t.rgb }), t.a)), this.fog === !0) {
      const s = e.fogNode;
      s && (t = st(s.mixAssign(t.rgb), t.a));
    }
    if (this.colorSpace === !0) {
      const s = r.getRenderTarget();
      let o;
      s !== null ? Array.isArray(s.texture) ? o = s.texture[0].colorSpace : o = s.texture.colorSpace : o = r.outputColorSpace, o !== Rn && o !== um && (t = t.linearToColorSpace(o));
    }
    return t;
  }
  setDefaultValues(e) {
    for (const r in e) {
      const n = e[r];
      this[r] === void 0 && (this[r] = n, n && n.clone && (this[r] = n.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const r in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, r) === void 0 && t[r].get !== void 0 && Object.defineProperty(this.constructor.prototype, r, t[r]);
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const r = Bn.prototype.toJSON.call(this, e), n = ei(this);
    r.inputNodes = {};
    for (const { property: o, childNode: i } of n)
      r.inputNodes[o] = i.toJSON(e).uuid;
    function s(o) {
      const i = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, i.push(l);
      }
      return i;
    }
    if (t) {
      const o = s(e.textures), i = s(e.images), a = s(e.nodes);
      o.length > 0 && (r.textures = o), i.length > 0 && (r.images = i), a.length > 0 && (r.nodes = a);
    }
    return r;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.outputNode = e.outputNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
  static fromMaterial(e) {
    if (e.isNodeMaterial === !0)
      return e;
    const t = e.type.replace("Material", "NodeMaterial"), r = No(t);
    if (r === void 0)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const n in e)
      r[n] = e[n];
    return r;
  }
}
function wn(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node material ${c} is not a class`);
  if (Yl.has(c))
    throw new Error(`Redefinition of node material ${c}`);
  Yl.set(c, e), e.type = c;
}
function No(c) {
  const e = Yl.get(c);
  if (e !== void 0)
    return new e();
}
wn("NodeMaterial", en);
const CN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addNodeMaterial: wn,
  createNodeMaterialFromType: No,
  default: en
}, Symbol.toStringTag, { value: "Module" }));
class _r {
  constructor(e, t = null) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class EN extends _r {
  constructor(e, t = 0) {
    super(e, t), this.isFloatUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class RN extends _r {
  constructor(e, t = new Nt()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class LN extends _r {
  constructor(e, t = new ge()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class FN extends _r {
  constructor(e, t = new pt()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class ON extends _r {
  constructor(e, t = new He()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class IN extends _r {
  constructor(e, t = new bs()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class PN extends _r {
  constructor(e, t = new je()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class DN extends EN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class UN extends RN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class zN extends LN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class BN extends FN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class kN extends ON {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class GN extends IN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class VN extends PN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Ph extends Oe {
  constructor(e, t, r = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = r;
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const r = this.elseNode.getNodeType(e);
      if (e.getTypeLength(r) > e.getTypeLength(t))
        return r;
    }
    return t;
  }
  generate(e) {
    const t = this.getNodeType(e), r = { tempWrite: !1 }, { ifNode: n, elseNode: s } = this, o = n.getNodeType(e) !== "void" || s && s.getNodeType(e) !== "void", i = o ? Ns(t).build(e) : "", a = Yn(
      this.condNode
      /*, context*/
    ).build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${a} ) {

`).addFlowTab();
    let l = Yn(this.ifNode, r).build(e, t);
    if (l = o ? i + " = " + l + ";" : l, e.removeFlowTab().addFlowCode(e.tab + "	" + l + `

` + e.tab + "}"), s !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let u = Yn(s, r).build(e, t);
      u = i ? i + " = " + u + ";" : u, e.removeFlowTab().addFlowCode(e.tab + "	" + u + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return i;
  }
}
const Dh = Ph, mr = j(Ph);
V("cond", mr);
oe("CondNode", Ph);
class Uh extends Oe {
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode("i".charCodeAt() + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0)
      return t;
    const r = {};
    for (let n = 0, s = this.params.length - 1; n < s; n++) {
      const o = this.getVarName(n);
      r[o] = xo(o, "int");
    }
    return t.returnsNode = this.params[this.params.length - 1](r, e.addStack(), e), t.stackNode = e.removeStack(), t;
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e), r = { tempWrite: !1 }, n = this.params, s = t.stackNode;
    for (let a = 0, l = n.length - 1; a < l; a++) {
      const u = n[a], h = this.getVarName(a);
      let d = null, f = null, p = null;
      u.isNode ? (d = "0", f = u.build(e, "int"), p = "forward") : (d = u.start, f = u.end, p = u.direction, typeof d == "number" ? d = d.toString() : d && d.isNode && (d = d.build(e, "int")), typeof f == "number" ? f = f.toString() : f && f.isNode && (f = f.build(e, "int")), d !== void 0 && f === void 0 ? (d = d + " - 1", f = "0", p = "backwards") : f !== void 0 && d === void 0 && (d = "0", p = "forward"), p === void 0 && (Number(d) > Number(f) ? p = "backwards" : p = "forward"));
      const m = { start: d, end: f, direction: p }, g = m.start, b = m.end;
      let x = "", y = "", v = "";
      x += e.getVar("int", h) + " = " + g, m.direction === "backwards" ? (y += h + " >= " + b, v += h + " --") : (y += h + " < " + b, v += h + " ++");
      const N = `for ( ${x}; ${y}; ${v} )`;
      e.addFlowCode((a === 0 ? `
` : "") + e.tab + N + ` {

`).addFlowTab();
    }
    const o = Yn(s, r).build(e, "void"), i = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + o);
    for (let a = 0, l = this.params.length - 1; a < l; a++)
      e.addFlowCode((a === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), i;
  }
}
const jN = Uh, zh = (...c) => Me(new Uh(pr(c, "int")));
V("loop", (c, ...e) => rc(c, zh(...e)));
oe("LoopNode", Uh);
class Bh extends Oe {
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(rc(xo(), e)), this;
  }
  if(e, t) {
    const r = new _s(t);
    return this._currentCond = mr(e, r), this.add(this._currentCond);
  }
  elseif(e, t) {
    const r = new _s(t), n = mr(e, r);
    return this._currentCond.elseNode = n, this._currentCond = n, this;
  }
  else(e) {
    return this._currentCond.elseNode = new _s(e), this;
  }
  assign(e, t) {
    return this.add(qu(e, t));
  }
  loop(...e) {
    return this.add(zh(...e));
  }
  build(e, ...t) {
    for (const r of this.nodes)
      r.build(e, "void");
    return this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
  }
}
const WN = Bh, Kl = j(Bh);
oe("StackNode", Bh);
class HN extends nx {
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, t) {
    const r = t.minFilter, n = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const s = new Xa(5, 5, 5), o = gc(uh), i = No("MeshBasicNodeMaterial");
    i.colorNode = Zt(t, o, 0), i.side = bu, i.blending = sx;
    const a = new Qt(s, i), l = new $a();
    return l.add(a), t.minFilter === yo && (t.minFilter = uo), new rx(1, 10, this).update(e, l), t.minFilter = r, t.currentGenerateMipmaps = n, a.geometry.dispose(), a.material.dispose(), this;
  }
}
const XN = HN, $N = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), qN = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), JN = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]), Vi = (c) => (c = Number(c), c + (c % 1 ? "" : ".0"));
class YN {
  constructor(e, t, r, n = null, s = null) {
    this.object = e, this.material = s || e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = r, this.scene = n, this.nodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.hashNodes = {}, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.toneMappingNode = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: [] }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.codes = { vertex: [], fragment: [], compute: [] }, this.bindings = { vertex: [], fragment: [], compute: [] }, this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }, this.bindingsArray = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.vars = { vertex: [], fragment: [], compute: [] }, this.flow = { code: "" }, this.chaining = [], this.stack = Kl(), this.tab = "	", this.context = {
      keywords: new Wu(),
      material: this.material,
      getMIPLevelAlgorithmNode: (o, i) => i.mul(Lh(o))
    }, this.cache = new oc(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  getRenderTarget(e, t, r) {
    return new ox(e, t, r);
  }
  getCubeRenderTarget(e, t) {
    return new XN(e, t);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  getBindings() {
    let e = this.bindingsArray;
    if (e === null) {
      const t = this.bindings;
      this.bindingsArray = e = this.material !== null ? [...t.vertex, ...t.fragment] : t.compute;
    }
    return e;
  }
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  buildUpdateNodes() {
    for (const e of this.nodes) {
      const t = e.getUpdateType(), r = e.getUpdateBeforeType();
      t !== ut.NONE && this.updateNodes.push(e.getSelf()), r !== ut.NONE && this.updateBeforeNodes.push(e);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new He() : e === "vec2" ? t = new Nt() : e === "vec3" ? t = new ge() : e === "vec4" && (t = new pt())), e === "float")
      return Vi(t);
    if (e === "int")
      return `${Math.round(t)}`;
    if (e === "uint")
      return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool")
      return t ? "true" : "false";
    if (e === "color")
      return `${this.getType("vec3")}( ${Vi(t.r)}, ${Vi(t.g)}, ${Vi(t.b)} )`;
    const r = this.getTypeLength(e), n = this.getComponentType(e), s = (o) => this.getConst(n, o);
    if (r === 2)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (r === 3)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (r === 4)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (r > 4 && t && (t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (r > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  generateMethod(e) {
    return e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, t) {
    const r = this.attributes;
    for (const s of r)
      if (s.name === e)
        return s;
    const n = new Ca(e, t);
    return r.push(n), n;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(e) {
    return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."), this.getTextureColorSpaceFromMap(e) === vn ? ix : ax;
  }
  getTextureColorSpaceFromMap(e) {
    let t;
    return e && e.isTexture ? t = e.colorSpace : e && e.isWebGLRenderTarget ? t = e.texture.colorSpace : t = um, t;
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint")
      return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" ? "vec4" : e;
  }
  getTypeFromLength(e, t = "float") {
    if (e === 1)
      return t;
    const r = $N.get(e);
    return (t === "float" ? "" : t[0]) + r;
  }
  getTypeFromArray(e) {
    return qN.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const r = t.array, n = JN.has(r.constructor) ? e.itemSize : t.stride || e.itemSize, s = e.normalized;
    let o;
    return !(e instanceof cx) && s !== !0 && (o = this.getTypeFromArray(r)), this.getTypeFromLength(n, o);
  }
  getTypeLength(e) {
    const t = this.getVectorType(e), r = /vec([2-4])/.exec(t);
    return r !== null ? Number(r[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = Kl(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, e;
  }
  getDataFromNode(e, t = this.shaderStage) {
    const r = e.isGlobal(this) ? this.globalCache : this.cache;
    let n = r.getNodeData(e);
    return n === void 0 && (n = {}, r.setNodeData(e, n)), n[t] === void 0 && (n[t] = {}), n[t];
  }
  getNodeProperties(e, t = "any") {
    const r = this.getDataFromNode(e, t);
    return r.properties || (r.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, t) {
    const r = this.getDataFromNode(e);
    let n = r.bufferAttribute;
    if (n === void 0) {
      const s = this.uniforms.index++;
      n = new Ca("nodeAttribute" + s, t, e), this.bufferAttributes.push(n), r.bufferAttribute = n;
    }
    return n;
  }
  getStructTypeFromNode(e, t = this.shaderStage, r = null) {
    const n = this.getDataFromNode(e, t);
    if (n.structType === void 0) {
      const o = this.structs.index++;
      e.name = `StructType${o}`, this.structs[t].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, t, r = this.shaderStage, n = null) {
    const s = this.getDataFromNode(e, r);
    let o = s.uniform;
    if (o === void 0) {
      const i = this.uniforms.index++;
      o = new Gu(n || "nodeUniform" + i, t, e), this.uniforms[r].push(o), s.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e, r);
    let s = n.variable;
    if (s === void 0) {
      const o = this.vars[r], i = o.length;
      s = new ac("nodeVar" + i, t), o.push(s), n.variable = s;
    }
    return s;
  }
  getVaryingFromNode(e, t) {
    const r = this.getDataFromNode(e, "any");
    let n = r.varying;
    if (n === void 0) {
      const s = this.varyings, o = s.length;
      n = new Vu("nodeVarying" + o, t), s.push(n), r.varying = n;
    }
    return n;
  }
  getCodeFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e);
    let s = n.code;
    if (s === void 0) {
      const o = this.codes[r], i = o.length;
      s = new ju("nodeCode" + i, t), o.push(s), n.code = s;
    }
    return s;
  }
  addLineFlowCode(e) {
    return e === "" ? this : (e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const t = e.getNodeType(this), r = this.flowChildNode(e, t);
    return this.flowsData.set(e, r), r;
  }
  flowChildNode(e, t = null) {
    const r = this.flow, n = {
      code: ""
    };
    return this.flow = n, n.result = e.build(this, t), this.flow = r, n;
  }
  flowNodeFromShaderStage(e, t, r = null, n = null) {
    const s = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(t, r);
    return n !== null && (o.code += `${this.tab + n} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(s), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, t) {
    return `${this.getType(e)} ${t}`;
  }
  getVars(e) {
    let t = "";
    const r = this.vars[e];
    for (const n of r)
      t += `${this.getVar(n.type, n.name)}; `;
    return t;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const t = this.codes[e];
    let r = "";
    for (const n of t)
      r += n.code + `
`;
    return r;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const e of Om) {
      this.setBuildStage(e), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const t of Im) {
        this.setShaderStage(t);
        const r = this.flowNodes[t];
        for (const n of r)
          e === "generate" ? this.flowNode(n) : n.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, t) {
    if (t === "float")
      return new DN(e);
    if (t === "vec2")
      return new UN(e);
    if (t === "vec3")
      return new zN(e);
    if (t === "vec4")
      return new BN(e);
    if (t === "color")
      return new kN(e);
    if (t === "mat3")
      return new GN(e);
    if (t === "mat4")
      return new VN(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  createNodeMaterial(e) {
    return No(e);
  }
  format(e, t, r) {
    if (t = this.getVectorType(t), r = this.getVectorType(r), t === r || r === null || this.isReference(r))
      return e;
    const n = this.getTypeLength(t), s = this.getTypeLength(r);
    return n > 4 || s > 4 || s === 0 ? e : n === s ? `${this.getType(r)}( ${e} )` : n > s ? this.format(`${e}.${"xyz".slice(0, s)}`, this.getTypeFromLength(s, this.getComponentType(t)), r) : s === 4 ? `${this.getType(r)}( ${this.format(e, t, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(r)}( ${this.format(e, t, "vec2")}, 0.0 )` : `${this.getType(r)}( ${e} )`;
  }
  getSignature() {
    return `// Three.js r${lx} - NodeMaterial System
`;
  }
}
const g0 = YN;
class KN {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, t) {
    let r = e.get(t);
    return r === void 0 && (r = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(t, r)), r;
  }
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateBeforeMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.updateBefore(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.updateBefore(this)) : t === ut.OBJECT && e.updateBefore(this);
  }
  updateNode(e) {
    const t = e.getUpdateType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.update(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.update(this)) : t === ut.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
const kh = KN;
class y0 {
  constructor(e, t, r = null, n = "", s = !1) {
    this.type = e, this.name = t, this.count = r, this.qualifier = n, this.isConst = s;
  }
}
y0.isNodeFunctionInput = !0;
const Gh = y0;
class v0 extends Oe {
  constructor(e) {
    super(), this.types = e, this.isStructTypeNode = !0;
  }
  getMemberTypes() {
    return this.types;
  }
}
const ZN = v0;
oe("StructTypeNode", v0);
class Vh extends Oe {
  constructor(...e) {
    super(), this.isOutputStructNode = !0, this.members = e;
  }
  setup(e) {
    super.setup(e);
    const t = this.members, r = [];
    for (let n = 0; n < t.length; n++)
      r.push(t[n].getNodeType(e));
    this.nodeType = e.getStructTypeFromNode(new ZN(r)).name;
  }
  generate(e, t) {
    const r = e.getVarFromNode(this, this.nodeType);
    r.isOutputStructVar = !0;
    const n = e.getPropertyName(r), s = this.members, o = n !== "" ? n + "." : "";
    for (let i = 0; i < s.length; i++) {
      const a = s[i].build(e, t);
      e.addLineFlowCode(`${o}m${i} = ${a}`);
    }
    return n;
  }
}
const QN = Vh, ew = j(Vh);
oe("OutputStructNode", Vh);
class jh extends Oe {
  constructor(e) {
    super(), this.seedNode = e;
  }
  setup() {
    const e = this.seedNode.uint().mul(747796405).add(2891336453), t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
    return t.shiftRight(22).bitXor(t).float().mul(1 / 2 ** 32);
  }
}
const tw = jh, x0 = j(jh);
V("hash", x0);
oe("HashNode", jh);
let el;
class Wh extends Dh {
  constructor(e) {
    el = el || xo("discard"), super(e, el);
  }
}
const nw = Wh, b0 = j(Wh);
V("discard", b0);
oe("DiscardNode", Wh);
class Hh extends _t {
  constructor() {
    super("vec2");
  }
  setup() {
    const e = Re(Ot.z, 0, Ot.x.negate()).normalize(), t = Ot.cross(e);
    return tt(e.dot(St), t.dot(St)).mul(0.495).add(0.5);
  }
}
const N0 = Hh, sw = ce(Hh);
oe("MatcapUVNode", Hh);
class Lt extends Qe {
  constructor(e = Lt.LOCAL, t = 1, r = 0) {
    super(r), this.scope = e, this.scale = t, this.updateType = ut.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(e) {
    const t = this.scope, r = this.scale;
    t === Lt.LOCAL ? this.value += e.deltaTime * r : t === Lt.DELTA ? this.value = e.deltaTime * r : t === Lt.FRAME ? this.value = e.frameId : this.value = e.time * r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope, e.scale = this.scale;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope, this.scale = e.scale;
  }
}
Lt.LOCAL = "local";
Lt.GLOBAL = "global";
Lt.DELTA = "delta";
Lt.FRAME = "frame";
const Xh = (c, e = 0) => Me(new Lt(Lt.LOCAL, c, e)), rw = (c, e = 0) => Me(new Lt(Lt.GLOBAL, c, e)), ow = (c, e = 0) => Me(new Lt(Lt.DELTA, c, e)), iw = ce(Lt, Lt.FRAME).uint();
oe("TimerNode", Lt);
class Et extends Oe {
  constructor(e = Et.SINE, t = Xh()) {
    super(), this.method = e, this.timeNode = t;
  }
  getNodeType(e) {
    return this.timeNode.getNodeType(e);
  }
  setup() {
    const e = this.method, t = Me(this.timeNode);
    let r = null;
    return e === Et.SINE ? r = t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5) : e === Et.SQUARE ? r = t.fract().round() : e === Et.TRIANGLE ? r = t.add(0.5).fract().mul(2).sub(1).abs() : e === Et.SAWTOOTH && (r = t.fract()), r;
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Et.SINE = "sine";
Et.SQUARE = "square";
Et.TRIANGLE = "triangle";
Et.SAWTOOTH = "sawtooth";
const Zr = Et, aw = j(Et, Et.SINE), cw = j(Et, Et.SQUARE), lw = j(Et, Et.TRIANGLE), uw = j(Et, Et.SAWTOOTH);
oe("OscNode", Et);
class es extends _t {
  constructor(e, t) {
    super(), this.scope = e, this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup() {
    const { scope: e, node: t } = this;
    let r = null;
    return e === es.DIRECTION_TO_COLOR ? r = t.mul(0.5).add(0.5) : e === es.COLOR_TO_DIRECTION && (r = t.mul(2).sub(1)), r;
  }
}
es.DIRECTION_TO_COLOR = "directionToColor";
es.COLOR_TO_DIRECTION = "colorToDirection";
const hw = es, $h = j(es, es.DIRECTION_TO_COLOR), w0 = j(es, es.COLOR_TO_DIRECTION);
V("directionToColor", $h);
V("colorToDirection", w0);
oe("PackingNode", es);
class yc extends Oe {
  constructor(e, t, r, n, s) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = r, this.outLowNode = n, this.outHighNode = s, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: r, outLowNode: n, outHighNode: s, doClamp: o } = this;
    let i = e.sub(t).div(r.sub(t));
    return o === !0 && (i = i.clamp()), i.mul(s.sub(n)).add(n);
  }
}
const T0 = yc, S0 = j(yc, null, null, { doClamp: !1 }), _0 = j(yc);
V("remap", S0);
V("remapClamp", _0);
oe("RemapNode", yc);
class qh extends _t {
  constructor(e, t, r = tt(0.5)) {
    super("vec2"), this.uvNode = e, this.rotationNode = t, this.centerNode = r;
  }
  setup() {
    const { uvNode: e, rotationNode: t, centerNode: r } = this, n = t.cos(), s = t.sin(), o = e.sub(r);
    return tt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      tt(n, s).dot(o),
      tt(s.negate(), n).dot(o)
    ).add(r);
  }
}
const M0 = qh, A0 = j(qh);
V("rotateUV", A0);
oe("RotateUVNode", qh);
class Jh extends Oe {
  constructor(e, t = gt(), r = _e(0)) {
    super("vec2"), this.countNode = e, this.uvNode = t, this.frameNode = r;
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: r } = this, { width: n, height: s } = r, o = e.mod(n.mul(s)).floor(), i = o.mod(n), a = s.sub(o.add(1).div(n).ceil()), l = r.reciprocal(), u = tt(i, a);
    return t.add(u).mul(l);
  }
}
const C0 = Jh, E0 = j(Jh);
oe("SpriteSheetUVNode", Jh);
class Yh extends Oe {
  constructor(e, t = null, r = null, n = _e(1), s = lh, o = dc) {
    super("vec4"), this.textureXNode = e, this.textureYNode = t, this.textureZNode = r, this.scaleNode = n, this.positionNode = s, this.normalNode = o;
  }
  setup() {
    const { textureXNode: e, textureYNode: t, textureZNode: r, scaleNode: n, positionNode: s, normalNode: o } = this;
    let i = o.abs().normalize();
    i = i.div(i.dot(Re(1)));
    const a = s.yz.mul(n), l = s.zx.mul(n), u = s.xy.mul(n), h = e.value, d = t !== null ? t.value : h, f = r !== null ? r.value : h, p = Zt(h, a).mul(i.x), m = Zt(d, l).mul(i.y), g = Zt(f, u).mul(i.z);
    return xn(p, m, g);
  }
}
const R0 = Yh, L0 = j(Yh), F0 = (...c) => L0(...c);
V("triplanarTexture", F0);
oe("TriplanarTexturesNode", Yh);
class $t extends Jn {
  setup() {
    return this.getFloat(this.scope);
  }
}
$t.SCALE = "scale";
$t.DASH_SIZE = "dashSize";
$t.GAP_SIZE = "gapSize";
$t.LINEWIDTH = "linewidth";
$t.DASH_OFFSET = "dashOffset";
const dw = $t, Pa = ce($t, $t.SCALE), Zl = ce($t, $t.DASH_OFFSET), Kh = ce($t, $t.DASH_SIZE), Zh = ce($t, $t.GAP_SIZE), Hr = ce($t, $t.LINEWIDTH);
oe("LineMaterialNode", $t);
const vc = 1 / 6, O0 = (c) => Kt(vc, Kt(c, Kt(c, c.negate().add(3)).sub(3)).add(1)), Ql = (c) => Kt(vc, Kt(c, Kt(c, Kt(3, c).sub(6))).add(4)), I0 = (c) => Kt(vc, Kt(c, Kt(c, Kt(-3, c).add(3)).add(3)).add(1)), eu = (c) => Kt(vc, eh(c, 3)), jf = (c) => O0(c).add(Ql(c)), Wf = (c) => I0(c).add(eu(c)), Hf = (c) => xn(-1, Ql(c).div(O0(c).add(Ql(c)))), Xf = (c) => xn(1, eu(c).div(I0(c).add(eu(c)))), $f = (c, e, t) => {
  const r = c.uvNode, n = Kt(r, e.zw).add(0.5), s = cc(n), o = lc(n), i = jf(o.x), a = Wf(o.x), l = Hf(o.x), u = Xf(o.x), h = Hf(o.y), d = Xf(o.y), f = tt(s.x.add(l), s.y.add(h)).sub(0.5).mul(e.xy), p = tt(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy), m = tt(s.x.add(l), s.y.add(d)).sub(0.5).mul(e.xy), g = tt(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy), b = jf(o.y).mul(xn(i.mul(c.uv(f).level(t)), a.mul(c.uv(p).level(t)))), x = Wf(o.y).mul(xn(i.mul(c.uv(m).level(t)), a.mul(c.uv(g).level(t))));
  return b.add(x);
}, fw = (c, e) => {
  const t = tt(c.size(Ma(e))), r = tt(c.size(Ma(e.add(1)))), n = mo(1, t), s = mo(1, r), o = $f(c, st(n, t), cc(e)), i = $f(c, st(s, r), Yu(e));
  return lc(e).mix(o, i);
};
class Qh extends _t {
  constructor(e, t = _e(3)) {
    super("vec4"), this.textureNode = e, this.blurNode = t;
  }
  setup() {
    return fw(this.textureNode, this.blurNode);
  }
}
const pw = Qh, P0 = j(Qh);
V("bicubic", P0);
oe("TextureBicubicNode", Qh);
class ed extends Oe {
  constructor() {
    super("vec2"), this.isPointUVNode = !0;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const D0 = ed, U0 = ce(ed);
oe("PointUVNode", ed);
class kn extends Oe {
  constructor(e = kn.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  setup(e) {
    const t = this.scope, r = this.scene !== null ? this.scene : e.scene;
    let n;
    return t === kn.BACKGROUND_BLURRINESS ? n = As("backgroundBlurriness", "float", r) : t === kn.BACKGROUND_INTENSITY ? n = As("backgroundIntensity", "float", r) : console.error("THREE.SceneNode: Unknown scope:", t), n;
  }
}
kn.BACKGROUND_BLURRINESS = "backgroundBlurriness";
kn.BACKGROUND_INTENSITY = "backgroundIntensity";
const mw = kn, gw = ce(kn, kn.BACKGROUND_BLURRINESS), yw = ce(kn, kn.BACKGROUND_INTENSITY);
oe("SceneNode", kn);
class td extends xh {
  constructor(e, t, r = 0) {
    super(e, t, r), this.isStorageBufferNode = !0;
  }
  getInputType() {
    return "storageBuffer";
  }
}
const vw = td, xw = (c, e, t) => Me(new td(c, e, t));
oe("StorageBufferNode", td);
class nd extends bi {
  constructor(e, t, r = null) {
    super(e, t), this.storeNode = r, this.isStoreTextureNode = !0;
  }
  getNodeType() {
    return "void";
  }
}
const bw = nd, Nw = j(nd);
oe("TextureStoreNode", nd);
class sd extends bo {
  constructor(e, t, r = null) {
    super(e, t, r), this.userData = r;
  }
  update(e) {
    this.reference = this.userData !== null ? this.userData : e.object.userData, super.update(e);
  }
}
const ww = sd, Tw = (c, e, t) => Me(new sd(c, e, t));
oe("UserDataNode", sd);
const Sw = Ke(({ base: c, blend: e }) => {
  const t = (r) => e[r].lessThan(Ju).cond(e[r], c[r].oneMinus().div(e[r]).oneMinus().max(0));
  return Re(t("x"), t("y"), t("z"));
}), _w = Ke(({ base: c, blend: e }) => {
  const t = (r) => e[r].equal(1).cond(e[r], c[r].div(e[r].oneMinus()).max(0));
  return Re(t("x"), t("y"), t("z"));
}), Mw = Ke(({ base: c, blend: e }) => {
  const t = (r) => c[r].oneMinus().mul(e[r].oneMinus()).oneMinus();
  return Re(t("x"), t("y"), t("z"));
}), Aw = Ke(({ base: c, blend: e }) => {
  const t = (r) => c[r].lessThan(0.5).cond(c[r].mul(e[r], 2), c[r].oneMinus().mul(e[r].oneMinus()).oneMinus());
  return Re(t("x"), t("y"), t("z"));
});
class It extends _t {
  constructor(e, t, r) {
    super(), this.blendMode = e, this.baseNode = t, this.blendNode = r;
  }
  setup() {
    const { blendMode: e, baseNode: t, blendNode: r } = this, n = { base: t, blend: r };
    let s = null;
    return e === It.BURN ? s = Sw(n) : e === It.DODGE ? s = _w(n) : e === It.SCREEN ? s = Mw(n) : e === It.OVERLAY && (s = Aw(n)), s;
  }
}
It.BURN = "burn";
It.DODGE = "dodge";
It.SCREEN = "screen";
It.OVERLAY = "overlay";
const Qr = It, z0 = j(It, It.BURN), B0 = j(It, It.DODGE), k0 = j(It, It.OVERLAY), G0 = j(It, It.SCREEN);
V("burn", z0);
V("dodge", B0);
V("overlay", k0);
V("screen", G0);
oe("BlendModeNode", It);
const Cw = Ke(({ color: c, adjustment: e }) => e.mix(X0(c), c)), Ew = Ke(({ color: c, adjustment: e }) => {
  const t = xn(c.r, c.g, c.b).div(3), r = c.r.max(c.g.max(c.b)), n = r.sub(t).mul(e).mul(-3);
  return rn(c, r, n);
}), Rw = Ke(({ color: c, adjustment: e }) => {
  const t = Ms(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135), r = Ms(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046), n = t.mul(c), s = n.z.atan2(n.y).add(e), o = n.yz.length();
  return r.mul(Re(n.x, o.mul(s.cos()), o.mul(s.sin())));
});
class sn extends _t {
  constructor(e, t, r = _e(1)) {
    super("vec3"), this.method = e, this.colorNode = t, this.adjustmentNode = r;
  }
  setup() {
    const { method: e, colorNode: t, adjustmentNode: r } = this, n = { color: t, adjustment: r };
    let s = null;
    return e === sn.SATURATION ? s = Cw(n) : e === sn.VIBRANCE ? s = Ew(n) : e === sn.HUE ? s = Rw(n) : console.error(`${this.type}: Method "${this.method}" not supported!`), s;
  }
}
sn.SATURATION = "saturation";
sn.VIBRANCE = "vibrance";
sn.HUE = "hue";
const Ho = sn, V0 = j(sn, sn.SATURATION), j0 = j(sn, sn.VIBRANCE), W0 = j(sn, sn.HUE), H0 = Re(0.2125, 0.7154, 0.0721), X0 = (c, e = H0) => Gs(c, e);
V("saturation", V0);
V("vibrance", j0);
V("hue", W0);
oe("ColorAdjustmentNode", sn);
class rd extends _t {
  constructor(e, t) {
    super(), this.sourceNode = e, this.stepsNode = t;
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const $0 = rd, q0 = j(rd);
V("posterize", q0);
oe("PosterizeNode", rd);
const Lw = Ke(({ color: c, exposure: e }) => c.mul(e).clamp()), Fw = Ke(({ color: c, exposure: e }) => (c = c.mul(e), c.div(c.add(1)).clamp())), Ow = Ke(({ color: c, exposure: e }) => {
  c = c.mul(e), c = c.sub(4e-3).max(0);
  const t = c.mul(c.mul(6.2).add(0.5)), r = c.mul(c.mul(6.2).add(1.7)).add(0.06);
  return t.div(r).pow(2.2);
}), Iw = Ke(({ color: c }) => {
  const e = c.mul(c.add(0.0245786)).sub(90537e-9), t = c.mul(c.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), Pw = Ke(({ color: c, exposure: e }) => {
  const t = Ms(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), r = Ms(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return c = c.mul(e).div(0.6), c = t.mul(c), c = Iw({ color: c }), c = r.mul(c), c.clamp();
}), Dw = {
  [ux]: Lw,
  [hx]: Fw,
  [dx]: Ow,
  [hm]: Pw
};
class od extends _t {
  constructor(e = Ff, t = _e(1), r = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = r;
  }
  getCacheKey() {
    let e = super.getCacheKey();
    return e = "{toneMapping:" + this.toneMapping + ",nodes:" + e + "}", e;
  }
  setup(e) {
    const t = this.colorNode || e.context.color, r = this.toneMapping;
    if (r === Ff)
      return t;
    const n = { exposure: this.exposureNode, color: t }, s = Dw[r];
    let o = null;
    return s ? o = s(n) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", r), o = t), o;
  }
}
const J0 = od, Uw = (c, e, t) => Me(new od(c, Me(e), Me(t)));
oe("ToneMappingNode", od);
let tl, nl;
class Je extends Oe {
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Je.COORDINATE || this.scope === Je.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = ut.NONE;
    return (this.scope === Je.RESOLUTION || this.scope === Je.VIEWPORT) && (e = ut.FRAME), this.updateType = e, e;
  }
  update({ renderer: e }) {
    this.scope === Je.VIEWPORT ? e.getViewport(nl) : e.getDrawingBufferSize(tl);
  }
  setup(e) {
    const t = this.scope;
    if (t === Je.COORDINATE)
      return;
    let r = null;
    if (t === Je.RESOLUTION)
      r = Rt(tl || (tl = new Nt()));
    else if (t === Je.VIEWPORT)
      r = Rt(nl || (nl = new pt()));
    else {
      const n = tt(new Je(Je.COORDINATE)), s = new Je(Je.RESOLUTION);
      r = n.div(s);
      let o = r.x, i = r.y;
      (/top/i.test(t) && e.isFlipY() || /bottom/i.test(t) && e.isFlipY() === !1) && (i = i.oneMinus()), /right/i.test(t) && (o = o.oneMinus()), r = tt(o, i);
    }
    return r;
  }
  generate(e) {
    return this.scope === Je.COORDINATE ? e.getFragCoord() : super.generate(e);
  }
}
Je.COORDINATE = "coordinate";
Je.RESOLUTION = "resolution";
Je.VIEWPORT = "viewport";
Je.TOP_LEFT = "topLeft";
Je.BOTTOM_LEFT = "bottomLeft";
Je.TOP_RIGHT = "topRight";
Je.BOTTOM_RIGHT = "bottomRight";
const zs = Je, zw = ce(Je, Je.COORDINATE), Bw = ce(Je, Je.RESOLUTION), ya = ce(Je, Je.VIEWPORT), xc = ce(Je, Je.TOP_LEFT), kw = ce(Je, Je.BOTTOM_LEFT), Gw = ce(Je, Je.TOP_RIGHT), Vw = ce(Je, Je.BOTTOM_RIGHT);
oe("ViewportNode", Je);
const Fo = new Nt();
class bc extends bi {
  constructor(e = xc, t = null, r = null) {
    r === null && (r = new dm(), r.minFilter = yo), super(r, e, t), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = ut.FRAME;
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(Fo);
    const r = this.value;
    (r.image.width !== Fo.width || r.image.height !== Fo.height) && (r.image.width = Fo.width, r.image.height = Fo.height, r.needsUpdate = !0);
    const n = r.generateMipmaps;
    r.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(r), r.generateMipmaps = n;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
}
const id = bc, Y0 = j(bc), K0 = j(bc, null, null, { generateMipmaps: !0 });
V("viewportTexture", Y0);
V("viewportMipTexture", K0);
oe("ViewportTextureNode", bc);
let sl = null;
class ad extends id {
  constructor(e = xc, t = null) {
    sl === null && (sl = new dm()), super(e, t, sl);
  }
}
const jw = ad, Z0 = j(ad);
V("viewportSharedTexture", Z0);
oe("ViewportSharedTextureNode", ad);
let Fr = null;
class cd extends id {
  constructor(e = xc, t = null) {
    Fr === null && (Fr = new lm(), Fr.minFilter = yo, Fr.type = fx, Fr.format = px), super(e, t, Fr);
  }
}
const Ww = cd, ld = j(cd);
V("viewportDepthTexture", ld);
oe("ViewportDepthTextureNode", cd);
class ts extends Oe {
  constructor(e, t = null) {
    super("float"), this.scope = e, this.textureNode = t, this.isViewportDepthNode = !0;
  }
  setup() {
    const { scope: e } = this;
    let t = null;
    if (e === ts.DEPTH)
      t = tu(Qn.z, ma, ga);
    else if (e === ts.DEPTH_TEXTURE) {
      const r = this.textureNode || ld(), n = Q0(r, ma, ga);
      t = tu(n, ma, ga);
    }
    return t;
  }
}
const tu = (c, e, t) => c.add(e).div(e.sub(t)), Hw = (c, e, t) => e.sub(t).mul(c).sub(e), Xw = (c, e, t) => e.add(c).mul(t).div(e.sub(t).mul(c)), Q0 = (c, e, t) => e.mul(t).div(t.sub(e).mul(c).sub(t));
ts.DEPTH = "depth";
ts.DEPTH_TEXTURE = "depthTexture";
const $w = ts, qw = ce(ts, ts.DEPTH), Jw = j(ts, ts.DEPTH_TEXTURE);
oe("ViewportDepthNode", ts);
class ud extends Oe {
  constructor(e = "", t = [], r = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = r, this._includes = t;
  }
  setIncludes(e) {
    return this._includes = e, this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const n of t)
      n.build(e);
    const r = e.getCodeFromNode(this, this.getNodeType(e));
    return r.code = this.code, r.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
const hd = ud, Nc = j(ud), Yw = (c, e) => Nc(c, e, "js"), Kw = (c, e) => Nc(c, e, "wgsl"), dd = (c, e) => Nc(c, e, "glsl");
oe("CodeNode", ud);
class fd extends _t {
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [], r = this.functionNode, n = r.getInputs(e), s = this.parameters;
    if (Array.isArray(s))
      for (let i = 0; i < s.length; i++) {
        const a = n[i], l = s[i];
        t.push(l.build(e, a.type));
      }
    else
      for (const i of n) {
        const a = s[i.name];
        if (a !== void 0)
          t.push(a.build(e, i.type));
        else
          throw new Error(`FunctionCallNode: Input '${i.name}' not found in FunctionNode.`);
      }
    return `${r.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const Zw = fd, ev = (c, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? pr(e) : nc(e[0]), Me(new fd(Me(c), e)));
V("call", ev);
oe("FunctionCallNode", fd);
class pd extends hd {
  constructor(e = "", t = [], r = "") {
    super(e, t, r), this.keywords = {};
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let r = t.nodeFunction;
    return r === void 0 && (r = e.parser.parseFunction(this.code), t.nodeFunction = r), r;
  }
  generate(e, t) {
    super.generate(e);
    const r = this.getNodeFunction(e), n = r.name, s = r.type, o = e.getCodeFromNode(this, s);
    n !== "" && (o.name = n);
    const i = e.getPropertyName(o);
    let a = this.getNodeFunction(e).getCode(i);
    const l = this.keywords, u = Object.keys(l);
    if (u.length > 0)
      for (const h of u) {
        const d = new RegExp(`\\b${h}\\b`, "g"), f = l[h].build(e, "property");
        a = a.replace(d, f);
      }
    return o.code = a, t === "property" ? i : e.format(`${i}()`, s, t);
  }
}
const tv = pd, nv = (c, e = [], t = "") => {
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof o == "function" && (e[s] = o.functionNode);
  }
  const r = Me(new pd(c, e, t)), n = (...s) => r.call(...s);
  return n.functionNode = r, n;
}, an = (c, e) => nv(c, e, "glsl"), Qw = (c, e) => nv(c, e, "wgsl");
oe("FunctionNode", pd);
class md extends Oe {
  constructor(e = null) {
    super(), this._value = e, this._cache = null, this.inputType = null, this.outpuType = null, this.events = new vu(), this.isScriptableValueNode = !0;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e && (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer && (URL.revokeObjectURL(this._cache), this._cache = null), this._value = e, this.events.dispatchEvent({ type: "change" }), this.refresh());
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const e = this.value;
    if (e && this._cache === null && this.inputType === "URL" && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (e && e.value !== null && e.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof e.value == "string" || this.inputType === "Number" && typeof e.value == "number" || this.inputType === "Vector2" && e.value.isVector2 || this.inputType === "Vector3" && e.value.isVector3 || this.inputType === "Vector4" && e.value.isVector4 || this.inputType === "Color" && e.value.isColor || this.inputType === "Matrix3" && e.value.isMatrix3 || this.inputType === "Matrix4" && e.value.isMatrix4))
      return e.value;
    return this._cache || e;
  }
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : _e();
  }
  serialize(e) {
    super.serialize(e), this.value !== null ? this.inputType === "ArrayBuffer" ? e.value = Ru(this.value) : e.value = this.value ? this.value.toJSON(e.meta).uuid : null : e.value = null, e.inputType = this.inputType, e.outputType = this.outputType;
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null && (e.inputType === "ArrayBuffer" ? t = Lu(e.value) : e.inputType === "Texture" ? t = e.meta.textures[e.value] : t = e.meta.nodes[e.value] || null), this.value = t, this.inputType = e.inputType, this.outputType = e.outputType;
  }
}
const e2 = md, Xo = j(md);
V("scriptableValue", Xo);
oe("ScriptableValueNode", md);
class sv extends Map {
  get(e, t = null, ...r) {
    if (this.has(e))
      return super.get(e);
    if (t !== null) {
      const n = t(...r);
      return this.set(e, n), n;
    }
  }
}
class t2 {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const va = new sv();
class gd extends Oe {
  constructor(e = null, t = {}) {
    super(), this.codeNode = e, this.parameters = t, this._local = new sv(), this._output = Xo(), this._outputs = {}, this._source = this.source, this._method = null, this._object = null, this._value = null, this._needsOutputUpdate = !0, this.onRefresh = this.onRefresh.bind(this), this.isScriptableNode = !0;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  getLocal(e) {
    return this._local.get(e);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e))
        return t;
  }
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e))
        return t;
  }
  setOutput(e, t) {
    const r = this._outputs;
    return r[e] === void 0 ? r[e] = Xo(t) : r[e].value = t, this;
  }
  getOutput(e) {
    return this._outputs[e];
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    const r = this.parameters;
    return t && t.isScriptableNode ? (this.deleteParameter(e), r[e] = t, r[e].getDefaultOutput().events.addEventListener("refresh", this.onRefresh)) : t && t.isScriptableValueNode ? (this.deleteParameter(e), r[e] = t, r[e].events.addEventListener("refresh", this.onRefresh)) : r[e] === void 0 ? (r[e] = Xo(t), r[e].events.addEventListener("refresh", this.onRefresh)) : r[e].value = t, this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(e) {
    let t = this.parameters[e];
    return t && (t.isScriptableNode && (t = t.getDefaultOutput()), t.events.removeEventListener("refresh", this.onRefresh)), this;
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters))
      this.deleteParameter(e);
    return this.needsUpdate = !0, this;
  }
  call(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n(...t);
  }
  async callAsync(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n.constructor.name === "AsyncFunction" ? await n(...t) : n(...t);
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  getObject() {
    if (this.needsUpdate && this.dispose(), this._object !== null)
      return this._object;
    const e = () => this.refresh(), t = (l, u) => this.setOutput(l, u), r = new t2(this), n = va.get("THREE"), s = va.get("TSL"), o = this.getMethod(this.codeNode), i = [r, this._local, va, e, t, n, s];
    this._object = o(...i);
    const a = this._object.layout;
    if (a && (a.cache === !1 && this._local.clear(), this._output.outputType = a.outputType || null, Array.isArray(a.elements)))
      for (const l of a.elements) {
        const u = l.id || l.name;
        l.inputType && (this.getParameter(u) === void 0 && this.setParameter(u, null), this.getParameter(u).inputType = l.inputType), l.outputType && (this.getOutput(u) === void 0 && this.setOutput(u, null), this.getOutput(u).outputType = l.outputType);
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let r = this.parameters[t];
      r.isScriptableNode && (r = r.getDefaultOutput()), r.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : _e();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate && this.dispose(), this._method !== null)
      return this._method;
    const e = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"], r = ["layout", "init", "main", "dispose"].join(", "), n = "var " + r + `; var output = {};
`, s = `
return { ...output, ` + r + " };", o = n + this.codeNode.code + s;
    return this._method = new Function(...e, o), this._method;
  }
  dispose() {
    this._method !== null && (this._object && typeof this._object.dispose == "function" && this._object.dispose(), this._method = null, this._object = null, this._source = null, this._value = null, this._needsOutputUpdate = !0, this._output.value = null, this._outputs = {});
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    return this.codeNode === null ? this : (this._needsOutputUpdate === !0 && (this._value = this.call("main"), this._needsOutputUpdate = !1), this._output.value = this._value, this);
  }
  _refresh() {
    this.needsUpdate = !0, this._exec(), this._output.refresh();
  }
}
const n2 = gd, rv = j(gd);
V("scriptable", rv);
oe("ScriptableNode", gd);
class yd extends Oe {
  constructor(e, t) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = t;
  }
  mixAssign(e) {
    return this.mix(e, this.colorNode);
  }
  setup() {
    return this.factorNode;
  }
}
const wc = yd, ov = j(yd);
V("fog", ov);
oe("FogNode", yd);
class vd extends wc {
  constructor(e, t, r) {
    super(e), this.isFogRangeNode = !0, this.nearNode = t, this.farNode = r;
  }
  setup() {
    return Ks(this.nearNode, this.farNode, Qn.z.negate());
  }
}
const iv = vd, av = j(vd);
V("rangeFog", av);
oe("FogRangeNode", vd);
class xd extends wc {
  constructor(e, t) {
    super(e), this.isFogExp2Node = !0, this.densityNode = t;
  }
  setup() {
    const e = Qn.z.negate(), t = this.densityNode;
    return t.mul(t, e, e).negate().exp().oneMinus();
  }
}
const cv = xd, lv = j(xd);
V("densityFog", lv);
oe("FogExp2Node", xd);
let or = null, ir = null;
class bd extends Oe {
  constructor(e = _e(), t = _e()) {
    super(), this.minNode = e, this.maxNode = t;
  }
  getVectorLength(e) {
    const t = e.getTypeLength(Ws(this.minNode.value)), r = e.getTypeLength(Ws(this.maxNode.value));
    return t > r ? t : r;
  }
  getNodeType(e) {
    return e.object.isInstancedMesh === !0 ? e.getTypeFromLength(this.getVectorLength(e)) : "float";
  }
  setup(e) {
    const t = e.object;
    let r = null;
    if (t.isInstancedMesh === !0) {
      const n = this.minNode.value, s = this.maxNode.value, o = e.getTypeLength(Ws(n)), i = e.getTypeLength(Ws(s));
      or = or || new pt(), ir = ir || new pt(), or.setScalar(0), ir.setScalar(0), o === 1 ? or.setScalar(n) : n.isColor ? or.set(n.r, n.g, n.b) : or.set(n.x, n.y, n.z || 0, n.w || 0), i === 1 ? ir.setScalar(s) : s.isColor ? ir.set(s.r, s.g, s.b) : ir.set(s.x, s.y, s.z || 0, s.w || 0);
      const a = 4, l = a * t.count, u = new Float32Array(l);
      for (let d = 0; d < l; d++) {
        const f = d % a, p = or.getComponent(f), m = ir.getComponent(f);
        u[d] = Yt.lerp(p, m, Math.random());
      }
      const h = this.getNodeType(e);
      r = bh(u, "vec4", t.count).element(bg).convert(h);
    } else
      r = _e(0);
    return r;
  }
}
const uv = bd, s2 = j(bd);
oe("RangeNode", bd);
class Nd extends Oe {
  constructor(e, t, r = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = t, this.workgroupSize = r, this.dispatchCount = 0, this.version = 1, this.updateType = ut.OBJECT, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let r = t[0];
    for (let n = 1; n < t.length; n++)
      r *= t[n];
    this.dispatchCount = Math.ceil(e / r);
  }
  onInit() {
  }
  update({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: t } = e;
    if (t === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r);
    }
  }
}
const hv = Nd, dv = (c, e, t) => Me(new Nd(Me(c), e, t));
V("compute", dv);
oe("ComputeNode", Nd);
class Zs extends Oe {
  constructor(e = Zs.TARGET_DIRECTION, t = null) {
    super(), this.scope = e, this.light = t;
  }
  setup() {
    const { scope: e, light: t } = this;
    let r = null;
    return e === Zs.TARGET_DIRECTION && (r = Es.transformDirection(Oa(t).sub(Oa(t.target)))), r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Zs.TARGET_DIRECTION = "targetDirection";
const r2 = Zs, wd = j(Zs, Zs.TARGET_DIRECTION);
oe("LightNode", Zs);
const Td = Ke((c) => {
  const { lightDistance: e, cutoffDistance: t, decayExponent: r } = c, n = e.pow(r).max(0.01).reciprocal();
  return t.greaterThan(0).cond(
    n.mul(e.div(t).pow4().oneMinus().clamp().pow2()),
    n
  );
});
class Sd extends sr {
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Rt(0), this.decayExponentNode = Rt(0);
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  setup(e) {
    const { colorNode: t, cutoffDistanceNode: r, decayExponentNode: n, light: s } = this, o = e.context.lightingModel, i = oh(s).sub(Qn), a = i.normalize(), l = i.length(), u = Td({
      lightDistance: l,
      cutoffDistance: r,
      decayExponent: n
    }), h = t.mul(u), d = e.context.reflectedLight;
    o.direct({
      lightDirection: a,
      lightColor: h,
      reflectedLight: d
    });
  }
}
const fv = Sd;
oe("PointLightNode", Sd);
Sr(Zo, Sd);
class _d extends sr {
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, r = this.colorNode, n = wd(this.light), s = e.context.reflectedLight;
    t.direct({
      lightDirection: n,
      lightColor: r,
      reflectedLight: s
    });
  }
}
const o2 = _d;
oe("DirectionalLightNode", _d);
Sr(pi, _d);
class Md extends sr {
  constructor(e = null) {
    super(e), this.coneCosNode = Rt(0), this.penumbraCosNode = Rt(0), this.cutoffDistanceNode = Rt(0), this.decayExponentNode = Rt(0);
  }
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: t, penumbraCosNode: r } = this;
    return Ks(t, r, e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, { colorNode: r, cutoffDistanceNode: n, decayExponentNode: s, light: o } = this, i = oh(o).sub(Qn), a = i.normalize(), l = a.dot(wd(o)), u = this.getSpotAttenuation(l), h = i.length(), d = Td({
      lightDistance: h,
      cutoffDistance: n,
      decayExponent: s
    }), f = r.mul(u).mul(d), p = e.context.reflectedLight;
    t.direct({
      lightDirection: a,
      lightColor: f,
      reflectedLight: p
    });
  }
}
const pv = Md;
oe("SpotLightNode", Md);
Sr(mi, Md);
class i2 extends mi {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, n, s, o), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
const a2 = i2;
class Ad extends pv {
  getSpotAttenuation(e) {
    const t = this.light.iesMap;
    let r = null;
    if (t && t.isTexture === !0) {
      const n = e.acos().mul(1 / Math.PI);
      r = Zt(t, tt(n, 0), 0).r;
    } else
      r = super.getSpotAttenuation(e);
    return r;
  }
}
const c2 = Ad;
oe("IESSpotLightNode", Ad);
Sr(a2, Ad);
class Cd extends sr {
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
const l2 = Cd;
oe("AmbientLightNode", Cd);
Sr(Nu, Cd);
class Ed extends sr {
  constructor(e = null) {
    super(e), this.lightPositionNode = Oa(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Rt(new He());
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: r, lightDirectionNode: n } = this, o = us.dot(n).mul(0.5).add(0.5), i = rn(r, t, o);
    e.context.irradiance.addAssign(i);
  }
}
const mv = Ed;
oe("HemisphereLightNode", Ed);
Sr(fm, Ed);
const u2 = Ke((c) => {
  const e = c.uv.mul(2), t = e.x.floor(), r = e.y.floor();
  return t.add(r).mod(2).sign();
});
class Rd extends _t {
  constructor(e = gt()) {
    super("float"), this.uvNode = e;
  }
  setup() {
    return u2({ uv: this.uvNode });
  }
}
const gv = Rd, yv = j(Rd);
V("checker", yv);
oe("CheckerNode", Rd);
class h2 extends vr {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, n) {
    const s = new Js(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      try {
        t(this.parse(JSON.parse(o)));
      } catch (i) {
        n ? n(i) : console.error(i), this.manager.itemError(e);
      }
    }, r, n);
  }
  parseNodes(e) {
    const t = {};
    if (e !== void 0) {
      for (const n of e) {
        const { uuid: s, type: o } = n;
        t[s] = Me(Xl(o)), t[s].uuid = s;
      }
      const r = { nodes: t, textures: this.textures };
      for (const n of e)
        n.meta = r, t[n.uuid].deserialize(n), delete n.meta;
    }
    return t;
  }
  parse(e) {
    const t = Me(Xl(e.type));
    t.uuid = e.uuid;
    const n = { nodes: this.parseNodes(e.nodes), textures: this.textures };
    return e.meta = n, t.deserialize(e), delete e.meta, t;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
const vv = h2, d2 = new wu();
class xv extends en {
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(d2), this.setValues(e);
  }
}
const bv = xv;
wn("LineBasicNodeMaterial", xv);
const f2 = new pm();
class Nv extends en {
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(f2), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants({ stack: e }) {
    const t = this.offsetNode, r = this.dashScaleNode ? _e(this.dashScaleNode) : Pa, n = this.dashSizeNode ? _e(this.dashSizeNode) : Kh, s = this.dashSizeNode ? _e(this.dashGapNode) : Zh;
    e.assign(io, n), e.assign(La, s);
    const o = at(Ft("lineDistance").mul(r)), i = t ? o.add(t) : o;
    e.add(i.mod(io.add(La)).greaterThan(io).discard());
  }
}
const p2 = Nv;
wn("LineDashedNodeMaterial", Nv);
const m2 = new pm();
class wv extends en {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.setDefaultValues(m2), this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.useDash = e.dashed, this.useWorldUnits = !1, this.dashOffset = 0, this.lineWidth = 1, this.lineColorNode = null, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor, r = this.dashed, n = this.worldUnits, s = Ke(({ start: i, end: a }) => {
      const l = xs.element(2).element(2), d = xs.element(3).element(2).mul(-0.5).div(l).sub(i.z).div(a.z.sub(i.z));
      return st(rn(i.xyz, a.xyz, d), a.w);
    });
    this.vertexNode = new _s((i) => {
      i.assign(at(tt(), "vUv"), gt());
      const a = Ft("instanceStart"), l = Ft("instanceEnd"), u = Ns("vec4", "start"), h = Ns("vec4", "end");
      i.assign(u, br.mul(st(a, 1))), i.assign(h, br.mul(st(l, 1))), n && (i.assign(at(Re(), "worldStart"), u.xyz), i.assign(at(Re(), "worldEnd"), h.xyz));
      const d = ya.z.div(ya.w), f = xs.element(2).element(3).equal(-1);
      i.if(f, (v) => {
        v.if(u.z.lessThan(0).and(h.z.greaterThan(0)), (N) => {
          N.assign(h, s({ start: u, end: h }));
        }).elseif(h.z.lessThan(0).and(u.z.greaterThanEqual(0)), (N) => {
          N.assign(u, s({ start: h, end: u }));
        });
      });
      const p = xs.mul(u), m = xs.mul(h), g = p.xyz.div(p.w), b = m.xyz.div(m.w), x = b.xy.sub(g.xy);
      i.assign(x.x, x.x.mul(d)), i.assign(x, x.normalize());
      const y = oi(st());
      if (n) {
        const v = h.xyz.sub(u.xyz).normalize(), N = pn.y.lessThan(0.5).cond(
          u.xyz.cross(v).normalize(),
          h.xyz.cross(v).normalize()
        );
        i.assign(N, pn.x.lessThan(0).cond(N.negate(), N));
        const w = v.dot(Re(0, 0, 1));
        r || (i.assign(u, u.sub(st(v.mul(Hr).mul(0.5), 0))), i.assign(h, h.add(st(v.mul(Hr).mul(0.5), 0))), i.assign(N, N.sub(Re(x.mul(w), 0))), i.assign(N.z, N.z.add(0.5))), i.if(pn.y.greaterThan(1).or(pn.y.lessThan(0)), (A) => {
          A.assign(N, N.add(Re(x.mul(2).mul(w), 0)));
        }), i.assign(N, N.mul(Hr).mul(0.5));
        const T = at(st(), "worldPos");
        i.assign(T, pn.y.lessThan(0.5).cond(u, h)), i.assign(T, T.add(st(N, 0))), i.assign(y, xs.mul(T));
        const S = oi(Re());
        i.assign(S, pn.y.lessThan(0.5).cond(g, b)), i.assign(y.z, S.z.mul(y.w));
      } else {
        const v = Ns("vec2", "offset");
        i.assign(v, tt(x.y, x.x.negate())), i.assign(x.x, x.x.div(d)), i.assign(v.x, v.x.div(d)), i.assign(v, pn.x.lessThan(0).cond(v.negate(), v)), i.if(pn.y.lessThan(0), (N) => {
          N.assign(v, v.sub(x));
        }).elseif(pn.y.greaterThan(1), (N) => {
          N.assign(v, v.add(x));
        }), i.assign(v, v.mul(Hr)), i.assign(v, v.div(ya.w)), i.assign(y, pn.y.lessThan(0.5).cond(p, m)), i.assign(v, v.mul(y.w)), i.assign(y, y.add(st(v, 0, 0)));
      }
      return y;
    });
    const o = Ke(({ p1: i, p2: a, p3: l, p4: u }) => {
      const h = i.sub(l), d = u.sub(l), f = a.sub(i), p = Gs(h, d), m = Gs(d, f), g = Gs(h, f), b = Gs(d, d), y = Gs(f, f).mul(b).sub(m.mul(m)), v = p.mul(m).sub(g.mul(b)), N = ni(v.div(y), 0, 1), w = ni(p.add(m.mul(N)).div(b), 0, 1);
      return tt(N, w);
    });
    this.colorNode = new _s((i) => {
      const a = at(tt(), "vUv");
      if (r) {
        const h = this.offsetNode ? _e(this.offsetNodeNode) : Zl, d = this.dashScaleNode ? _e(this.dashScaleNode) : Pa, f = this.dashSizeNode ? _e(this.dashSizeNode) : Kh, p = this.dashSizeNode ? _e(this.dashGapNode) : Zh;
        i.assign(io, f), i.assign(La, p);
        const m = Ft("instanceDistanceStart"), g = Ft("instanceDistanceEnd"), b = pn.y.lessThan(0.5).cond(d.mul(m), Pa.mul(g)), x = at(b.add(Zl)), y = h ? x.add(h) : x;
        i.add(a.y.lessThan(-1).or(a.y.greaterThan(1)).discard()), i.add(Qu(y, io.add(La)).greaterThan(io).discard());
      }
      const l = Ns("float", "alpha");
      if (i.assign(l, 1), n) {
        let h = at(Re(), "worldStart"), d = at(Re(), "worldEnd");
        const f = at(st(), "worldPos").xyz.normalize().mul(1e5), p = d.sub(h), m = o({ p1: h, p2: d, p3: Re(0, 0, 0), p4: f }), g = h.add(p.mul(m.x)), b = f.mul(m.y), v = g.sub(b).length().div(Hr);
        if (!r)
          if (e) {
            const N = v.fwidth();
            i.assign(l, Ks(N.negate().add(0.5), N.add(0.5), v).oneMinus());
          } else
            i.add(v.greaterThan(0.5).discard());
      } else if (e) {
        const h = a.x, d = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1)), f = h.mul(h).add(d.mul(d)), p = Ns("float", "dlen");
        i.assign(p, f.fwidth()), i.if(ti(a.y).greaterThan(1), (m) => {
          m.assign(l, Ks(p.oneMinus(), p.add(1), f).oneMinus());
        });
      } else
        i.if(ti(a.y).greaterThan(1), (h) => {
          const d = a.x, f = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1)), p = d.mul(d).add(f.mul(f));
          h.add(p.greaterThan(1).discard());
        });
      let u;
      if (this.lineColorNode)
        u = this.lineColorNode;
      else if (t) {
        const h = Ft("instanceColorStart"), d = Ft("instanceColorEnd");
        u = at(pn.y.lessThan(0.5).cond(h, d));
      } else
        u = sh;
      return st(u, l);
    }), this.needsUpdate = !0;
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(e) {
    this.useWorldUnits !== e && (this.useWorldUnits = e, this.setupShaders());
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(e) {
    this.useDash !== e && (this.useDash = e, this.setupShaders());
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const g2 = wv;
wn("Line2NodeMaterial", wv);
const y2 = new mx();
class Tv extends en {
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.colorSpace = !1, this.setDefaultValues(y2), this.setValues(e);
  }
  setupDiffuseColor({ stack: e }) {
    const t = this.opacityNode ? _e(this.opacityNode) : rh;
    e.assign(Xt, st($h(St), t));
  }
}
const v2 = Tv;
wn("MeshNormalNodeMaterial", Tv);
const x2 = new An();
class Sv extends en {
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(x2), this.setValues(e);
  }
}
const _v = Sv;
wn("MeshBasicNodeMaterial", Sv);
const b2 = Ke(({ f0: c, f90: e, dotVH: t }) => {
  const r = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return c.mul(r.oneMinus()).add(e.mul(r));
}), go = b2, N2 = Ke((c) => c.diffuseColor.mul(1 / Math.PI)), ai = N2, w2 = () => _e(0.25), T2 = Ke(({ dotNH: c }) => Ra.mul(0.5 / Math.PI).add(1).mul(c.pow(Ra))), S2 = Ke(({ lightDirection: c }) => {
  const e = c.add(Ot).normalize(), t = St.dot(e).clamp(), r = Ot.dot(e).clamp(), n = go({ f0: as, f90: 1, dotVH: r }), s = w2(), o = T2({ dotNH: t });
  return n.mul(s).mul(o);
});
class _2 extends ku {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = St.dot(e).clamp().mul(t);
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: Xt.rgb }))), this.specular === !0 && r.directSpecular.addAssign(s.mul(S2({ lightDirection: e })).mul(Hb));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: Xt })));
  }
}
const Ld = _2, M2 = new mm();
class Mv extends en {
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(M2), this.setValues(e);
  }
  setupLightingModel() {
    return new Ld(!1);
  }
}
const A2 = Mv;
wn("MeshLambertNodeMaterial", Mv);
const C2 = new fa();
class Av extends en {
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(C2), this.setValues(e);
  }
  setupLightingModel() {
    return new Ld();
  }
  setupVariants({ stack: e }) {
    const t = (this.shininessNode ? _e(this.shininessNode) : Ly).max(1e-4);
    e.assign(Ra, t);
    const r = this.specularNode || Oy;
    e.assign(as, r);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const E2 = Av;
wn("MeshPhongNodeMaterial", Av);
const R2 = Ke(() => {
  const c = ri.dFdx().abs().max(ri.dFdy().abs());
  return c.x.max(c.y).max(c.z);
}), Cv = R2, L2 = Ke((c) => {
  const { roughness: e } = c, t = Cv();
  let r = e.max(0.0525);
  return r = r.add(t), r = r.min(1), r;
}), Ev = L2, F2 = Ke((c) => {
  const { alpha: e, dotNL: t, dotNV: r } = c, n = e.pow2(), s = t.mul(n.add(n.oneMinus().mul(r.pow2())).sqrt()), o = r.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt());
  return mo(0.5, s.add(o).max(Ju));
}), Rv = F2, O2 = Ke((c) => {
  const { alpha: e, dotNH: t } = c, r = e.pow2(), n = t.pow2().mul(r.oneMinus()).oneMinus();
  return r.div(n.pow2()).mul(1 / Math.PI);
}), Lv = O2, I2 = Ke((c) => {
  const { lightDirection: e, f0: t, f90: r, roughness: n, iridescenceFresnel: s } = c, o = c.normalView || St, i = n.pow2(), a = e.add(Ot).normalize(), l = o.dot(e).clamp(), u = o.dot(Ot).clamp(), h = o.dot(a).clamp(), d = Ot.dot(a).clamp();
  let f = go({ f0: t, f90: r, dotVH: d });
  s && (f = Xu.mix(f, s));
  const p = Rv({ alpha: i, dotNL: l, dotNV: u }), m = Lv({ alpha: i, dotNH: h });
  return f.mul(p).mul(m);
}), nu = I2, P2 = Ke((c) => {
  const { roughness: e } = c, t = c.dotNV || St.dot(Ot).clamp(), r = st(-1, -0.0275, -0.572, 0.022), n = st(1, 0.0425, 1.04, -0.04), s = e.mul(r).add(n), o = s.x.mul(s.x).min(t.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return tt(-1.04, 1.04).mul(o).add(s.zw);
}), Fd = P2, D2 = Ke((c) => {
  const { dotNV: e, specularColor: t, specularF90: r, roughness: n } = c, s = Fd({ dotNV: e, roughness: n });
  return t.mul(s.x).add(r.mul(s.y));
}), U2 = D2, z2 = Ke(({ f: c, f90: e, dotVH: t }) => {
  const r = t.oneMinus().saturate(), n = r.mul(r), s = r.mul(n, n).clamp(0, 0.9999);
  return c.sub(Re(e).mul(s)).div(s.oneMinus());
}), Fv = z2, B2 = (c, e) => {
  const t = c.pow2(), r = _e(1).div(t), s = e.pow2().oneMinus().max(78125e-7);
  return _e(2).add(r).mul(s.pow(r.mul(0.5))).div(2 * Math.PI);
}, k2 = (c, e) => _e(1).div(_e(4).mul(e.add(c).sub(e.mul(c)))), G2 = Ke(({ lightDirection: c }) => {
  const e = c.add(Ot).normalize(), t = St.dot(c).clamp(), r = St.dot(Ot).clamp(), n = St.dot(e).clamp(), s = B2(Hu, n), o = k2(r, t);
  return Jr.mul(s).mul(o);
}), V2 = G2, j2 = Ms(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), W2 = (c) => {
  const e = c.sqrt();
  return Re(1).add(e).div(Re(1).sub(e));
}, qf = (c, e) => c.sub(e).div(c.add(e)).pow2(), H2 = (c, e) => {
  const t = c.mul(2 * Math.PI * 1e-9), r = Re(54856e-17, 44201e-17, 52481e-17), n = Re(1681e3, 1795300, 2208400), s = Re(43278e5, 93046e5, 66121e5), o = _e(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let i = r.mul(s.mul(2 * Math.PI).sqrt()).mul(n.mul(t).add(e).cos()).mul(t.pow2().negate().mul(s).exp());
  return i = Re(i.x.add(o), i.y, i.z).div(10685e-11), j2.mul(i);
}, X2 = (c, e, t, r, n) => {
  const s = rn(c, e, Ks(0, 0.03, r)), o = c.div(s).pow2().mul(_e(1).sub(t.pow2())), a = _e(1).sub(o).sqrt(), l = qf(s, c), u = go({ f0: l, f90: 1, dotVH: t }), h = u.oneMinus(), d = s.lessThan(c).cond(Math.PI, 0), f = _e(Math.PI).sub(d), p = W2(n.clamp(0, 0.9999)), m = qf(p, s.vec3()), g = go({ f0: m, f90: 1, dotVH: a }), b = Re(
    p.x.lessThan(s).cond(Math.PI, 0),
    p.y.lessThan(s).cond(Math.PI, 0),
    p.z.lessThan(s).cond(Math.PI, 0)
  ), x = s.mul(r, a, 2), y = Re(f).add(b), v = u.mul(g).clamp(1e-5, 0.9999), N = v.sqrt(), w = h.pow2().mul(g).div(Re(1).sub(v));
  let S = u.add(w), A = w.sub(h);
  for (let R = 1; R <= 2; ++R) {
    A = A.mul(N);
    const O = H2(_e(R).mul(x), _e(R).mul(y)).mul(2);
    S = S.add(A.mul(O));
  }
  return S.max(Re(0));
}, $2 = (c, e, t) => {
  const r = c.dot(e).saturate(), n = t.pow2(), s = mr(
    t.lessThan(0.25),
    _e(-339.2).mul(n).add(_e(161.4).mul(t)).sub(25.9),
    _e(-8.48).mul(n).add(_e(14.3).mul(t)).sub(9.95)
  ), o = mr(
    t.lessThan(0.25),
    _e(44).mul(n).sub(_e(23.7).mul(t)).add(3.26),
    _e(1.97).mul(n).sub(_e(3.27).mul(t)).add(0.72)
  );
  return mr(t.lessThan(0.25), 0, _e(0.1).mul(t).sub(0.025)).add(s.mul(r).add(o).exp()).mul(1 / Math.PI).saturate();
}, rl = Re(0.04), ol = Re(1);
class q2 extends ku {
  constructor(e = !0, t = !0, r = !0) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = r, this.clearcoatRadiance = null, this.clearcoatSpecular = null, this.sheenSpecular = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  init({ reflectedLight: e }) {
    if (this.clearcoat === !0) {
      this.clearcoatRadiance = Re().temp(), this.clearcoatSpecular = Re().temp();
      const t = fr.dot(Ot).clamp(), r = go({
        dotVH: t,
        f0: rl,
        f90: ol
      }), n = e.total, s = n.mul(ql.mul(r).oneMinus()).add(this.clearcoatSpecular.mul(ql));
      n.assign(s);
    }
    if (this.sheen === !0) {
      this.sheenSpecular = Re().temp();
      const t = e.total, r = Jr.r.max(Jr.g).max(Jr.b).mul(0.157).oneMinus(), n = t.mul(r).add(this.sheenSpecular);
      t.assign(n);
    }
    if (this.iridescence === !0) {
      const t = St.dot(Ot).clamp();
      this.iridescenceFresnel = X2(_e(1), wg, t, Tg, as), this.iridescenceF0 = Fv({ f: this.iridescenceFresnel, f90: 1, dotVH: t });
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, r = _e(1)) {
    const n = Fd({ roughness: oo }), o = (this.iridescenceF0 ? Xu.mix(as, this.iridescenceF0) : as).mul(n.x).add(r.mul(n.y)), a = n.x.add(n.y).oneMinus(), l = as.add(as.oneMinus().mul(0.047619)), u = o.mul(l).div(a.mul(l).oneMinus());
    e.addAssign(o), t.addAssign(u.mul(a));
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = St.dot(e).clamp().mul(t);
    if (this.sheen === !0 && this.sheenSpecular.addAssign(s.mul(V2({ lightDirection: e }))), this.clearcoat === !0) {
      const i = fr.dot(e).clamp().mul(t);
      this.clearcoatSpecular.addAssign(i.mul(nu({ lightDirection: e, f0: rl, f90: ol, roughness: Ea, normalView: fr })));
    }
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: Xt.rgb }))), r.directSpecular.addAssign(s.mul(nu({ lightDirection: e, f0: as, f90: 1, roughness: oo, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: Xt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: r }) {
    if (this.sheen === !0 && this.sheenSpecular.addAssign(t.mul(
      Jr,
      $2(St, Ot, Hu)
    )), this.clearcoat === !0) {
      const l = fr.dot(Ot).clamp(), u = U2({
        dotNV: l,
        specularColor: rl,
        specularF90: ol,
        roughness: Ea
      });
      this.clearcoatSpecular.addAssign(this.clearcoatRadiance.mul(u));
    }
    const n = Re().temp(), s = Re().temp(), o = t.mul(1 / Math.PI);
    this.computeMultiscattering(n, s);
    const i = n.add(s), a = Xt.mul(i.r.max(i.g).max(i.b).oneMinus());
    r.indirectSpecular.addAssign(e.mul(n)), r.indirectSpecular.addAssign(s.mul(o)), r.indirectDiffuse.addAssign(a.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
    const n = St.dot(Ot).clamp().add(e), s = oo.mul(-16).oneMinus().negate().exp2(), o = e.sub(n.pow(s).oneMinus()).clamp();
    t.indirectDiffuse.mulAssign(e), t.indirectSpecular.mulAssign(o);
  }
}
const Od = q2, J2 = new Vn();
class Ov extends en {
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(J2), this.setValues(e);
  }
  setupLightingModel() {
    return new Od(!1, !1);
  }
  setupVariants({ stack: e }) {
    const t = this.metalnessNode ? _e(this.metalnessNode) : Py;
    e.assign(Ng, t);
    let r = this.roughnessNode ? _e(this.roughnessNode) : Iy;
    r = Ev({ roughness: r }), e.assign(oo, r);
    const n = rn(Re(0.04), Xt.rgb, t);
    e.assign(as, n), e.assign(Xt, st(Xt.rgb.mul(t.oneMinus()), Xt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const Id = Ov;
wn("MeshStandardNodeMaterial", Ov);
const Y2 = new Cs();
class Iv extends Id {
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.setDefaultValues(Y2), this.setValues(e);
  }
  setupLightingModel() {
    return new Od();
  }
  setupVariants(e) {
    super.setupVariants(e);
    const { stack: t } = e, r = this.clearcoatNode ? _e(this.clearcoatNode) : $b, n = this.clearcoatRoughnessNode ? _e(this.clearcoatRoughnessNode) : qb;
    t.assign(ql, r), t.assign(Ea, n);
    const s = this.sheenNode ? Re(this.sheenNode) : Uy, o = this.sheenRoughnessNode ? _e(this.sheenRoughnessNode) : zy;
    t.assign(Jr, s), t.assign(Hu, o);
    const i = this.iridescenceNode ? _e(this.iridescenceNode) : Jb, a = this.iridescenceIORNode ? _e(this.iridescenceIORNode) : Yb, l = this.iridescenceThicknessNode ? _e(this.iridescenceThicknessNode) : Kb;
    t.assign(Xu, i), t.assign(wg, a), t.assign(Tg, l);
  }
  setupNormal(e) {
    super.setupNormal(e);
    const t = this.clearcoatNormalNode ? Re(this.clearcoatNormalNode) : bN;
    e.stack.assign(fr, t);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, super.copy(e);
  }
}
const Pv = Iv;
wn("MeshPhysicalNodeMaterial", Iv);
const K2 = new gm();
class Dv extends en {
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.normals = !1, this.transparent = !0, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.sizeNode = null, this.positionNode = null, this.setDefaultValues(K2), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
const Pd = Dv;
wn("PointsNodeMaterial", Dv);
const Z2 = new gx();
class Uv extends en {
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this.normals = !1, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(Z2), this.setValues(e);
  }
  setupPosition({ object: e, context: t }) {
    const { positionNode: r, rotationNode: n, scaleNode: s } = this, o = bn;
    let i = br.mul(Re(r || 0)), a = tt(si[0].xyz.length(), si[1].xyz.length());
    s !== null && (a = a.mul(s));
    let l = o.xy;
    e.center && e.center.isVector2 === !0 && (l = l.sub(Rt(e.center).sub(0.5))), l = l.mul(a);
    const u = _e(n || Dy), h = u.cos(), d = u.sin(), f = tt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      tt(h, d.negate()).dot(l),
      tt(d, h).dot(l)
    );
    i = st(i.xy.add(f), i.zw);
    const p = xs.mul(i);
    return t.vertex = o, p;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
}
const zv = Uv;
wn("SpriteNodeMaterial", Uv);
const Q2 = gi.createMaterialFromType;
gi.createMaterialFromType = function(c) {
  const e = No(c);
  return e !== void 0 ? e : Q2.call(this, c);
};
class eT extends gi {
  constructor(e) {
    super(e), this.nodes = {};
  }
  parse(e) {
    const t = super.parse(e), r = this.nodes, n = e.inputNodes;
    for (const s in n) {
      const o = n[s];
      t[s] = r[o];
    }
    return t;
  }
  setNodes(e) {
    return this.nodes = e, this;
  }
}
const Da = eT;
class tT extends yx {
  constructor(e) {
    super(e), this._nodesJSON = null;
  }
  parse(e, t) {
    this._nodesJSON = e.nodes;
    const r = super.parse(e, t);
    return this._nodesJSON = null, r;
  }
  parseNodes(e, t) {
    if (e !== void 0) {
      const r = new vv();
      return r.setTextures(t), r.parseNodes(e);
    }
    return {};
  }
  parseMaterials(e, t) {
    const r = {};
    if (e !== void 0) {
      const n = this.parseNodes(this._nodesJSON, t), s = new Da();
      s.setTextures(t), s.setNodes(n);
      for (let o = 0, i = e.length; o < i; o++) {
        const a = e[o];
        r[a.uuid] = s.parse(a);
      }
    }
    return r;
  }
}
const nT = tT;
class sT {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
const rT = sT;
class Bv {
  constructor(e, t, r = "", n = "") {
    this.type = e, this.inputs = t, this.name = r, this.presicion = n;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
Bv.isNodeFunction = !0;
const oT = Bv, iT = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, aT = /[a-z_0-9]+/ig, Jf = "#pragma main", cT = (c) => {
  c = c.trim();
  const e = c.indexOf(Jf), t = e !== -1 ? c.slice(e + Jf.length) : c, r = t.match(iT);
  if (r !== null && r.length === 5) {
    const n = r[4], s = [];
    let o = null;
    for (; (o = aT.exec(n)) !== null; )
      s.push(o);
    const i = [];
    let a = 0;
    for (; a < s.length; ) {
      const p = s[a][0] === "const";
      p === !0 && a++;
      let m = s[a][0];
      m === "in" || m === "out" || m === "inout" ? a++ : m = "";
      const g = s[a++][0];
      let b = Number.parseInt(s[a][0]);
      Number.isNaN(b) === !1 ? a++ : b = null;
      const x = s[a++][0];
      i.push(new Gh(g, x, b, m, p));
    }
    const l = t.substring(r[0].length), u = r[3] !== void 0 ? r[3] : "", h = r[2], d = r[1] !== void 0 ? r[1] : "", f = e !== -1 ? c.slice(0, e) : "";
    return {
      type: h,
      inputs: i,
      name: u,
      presicion: d,
      inputsCode: n,
      blockCode: l,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class lT extends oT {
  constructor(e) {
    const { type: t, inputs: r, name: n, presicion: s, inputsCode: o, blockCode: i, headerCode: a } = cT(e);
    super(t, r, n, s), this.inputsCode = o, this.blockCode = i, this.headerCode = a;
  }
  getCode(e = this.name) {
    let t;
    const r = this.blockCode;
    if (r !== "") {
      const { type: n, inputsCode: s, headerCode: o, presicion: i } = this;
      let a = `${n} ${e} ( ${s.trim()} )`;
      i !== "" && (a = `${i} ${a}`), t = o + a + r;
    } else
      t = "";
    return t;
  }
}
const uT = lT;
class hT extends rT {
  parseFunction(e) {
    return new uT(e);
  }
}
const kv = hT, dT = dd(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`), ns = [dT], Gv = an("float mx_perlin_noise_float( any p )", ns), fT = an("vec2 mx_perlin_noise_vec2( any p )", ns), Vv = an("vec3 mx_perlin_noise_vec3( any p )", ns), pT = an("float mx_cell_noise_float( vec3 p )", ns), mT = an("float mx_worley_noise_float( any p, float jitter, int metric )", ns), gT = an("float mx_worley_noise_vec2( any p, float jitter, int metric )", ns), yT = an("float mx_worley_noise_vec3( any p, float jitter, int metric )", ns), vT = an("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", ns), xT = an("float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", ns), bT = an("float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", ns), NT = an("float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", ns), wT = an(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`), TT = an(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`), ST = dd(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`), _T = [ST], MT = an("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", _T), jv = (c, e) => {
  c = _e(c), e = _e(e);
  const t = tt(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476);
  return Ks(c.sub(t), c.add(t), e);
}, Wv = (c, e, t, r) => rn(c, e, t[r].clamp()), AT = (c, e, t = gt()) => Wv(c, e, t, "x"), CT = (c, e, t = gt()) => Wv(c, e, t, "y"), Hv = (c, e, t, r, n) => rn(c, e, jv(t, r[n])), ET = (c, e, t, r = gt()) => Hv(c, e, t, r, "x"), RT = (c, e, t, r = gt()) => Hv(c, e, t, r, "y"), LT = (c = 1, e = 0, t = gt()) => t.mul(c).add(e), FT = (c, e = 1) => (c = _e(c), c.abs().pow(e).mul(c.sign())), OT = (c, e = 1, t = 0.5) => _e(c).sub(t).mul(e).add(t), IT = (c = gt(), e = 1, t = 0) => Gv(c.convert("vec2|vec3")).mul(e).add(t), PT = (c = gt(), e = 1, t = 0) => fT(c.convert("vec2|vec3")).mul(e).add(t), DT = (c = gt(), e = 1, t = 0) => Vv(c.convert("vec2|vec3")).mul(e).add(t), UT = (c = gt(), e = 1, t = 0) => (c = c.convert("vec2|vec3"), st(Vv(c), Gv(c.add(tt(19, 73)))).mul(e).add(t)), zT = (c = gt(), e = 1) => mT(c.convert("vec2|vec3"), e, 1), BT = (c = gt(), e = 1) => gT(c.convert("vec2|vec3"), e, 1), kT = (c = gt(), e = 1) => yT(c.convert("vec2|vec3"), e, 1), GT = (c = gt()) => pT(c.convert("vec2|vec3")), VT = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => vT(c, e, t, r).mul(n), jT = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => xT(c, e, t, r).mul(n), WT = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => bT(c, e, t, r).mul(n), HT = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => NT(c, e, t, r).mul(n), Xv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AONode: Mh,
  AmbientLightNode: l2,
  AnalyticLightNode: sr,
  ArrayElementNode: Za,
  ArrayUniformNode: yg,
  AttributeNode: vi,
  BRDF_GGX: nu,
  BRDF_Lambert: ai,
  BitangentNode: Kr,
  BlendModeNode: Qr,
  BufferAttributeNode: NN,
  BufferNode: xh,
  BumpMapNode: vN,
  BypassNode: vg,
  CacheNode: xg,
  CameraNode: ih,
  CheckerNode: gv,
  CodeNode: hd,
  ColorAdjustmentNode: Ho,
  ColorSpaceNode: jo,
  ComputeNode: hv,
  CondNode: Dh,
  ConstNode: Fn,
  ContextNode: xi,
  ConvertNode: Qa,
  CubeTextureNode: i0,
  DFGApprox: Fd,
  D_GGX: Lv,
  DirectionalLightNode: o2,
  DiscardNode: nw,
  EPSILON: Ju,
  EnvironmentNode: Ih,
  EquirectUVNode: d0,
  ExpressionNode: Ey,
  ExtendedMaterialNode: xN,
  F_Schlick: go,
  FogExp2Node: cv,
  FogNode: wc,
  FogRangeNode: iv,
  FrontFacingNode: jy,
  FunctionCallNode: Zw,
  FunctionNode: tv,
  GLSLNodeParser: kv,
  HashNode: tw,
  HemisphereLightNode: mv,
  IESSpotLightNode: c2,
  INFINITY: zb,
  IndexNode: Eb,
  InstanceNode: wN,
  JoinNode: km,
  LightNode: r2,
  LightingContextNode: MN,
  LightingModel: ku,
  LightingNode: Ti,
  LightsNode: l0,
  Line2NodeMaterial: g2,
  LineBasicNodeMaterial: bv,
  LineDashedNodeMaterial: p2,
  LineMaterialNode: dw,
  LoopNode: jN,
  MatcapUVNode: N0,
  MaterialNode: Jn,
  MaterialReferenceNode: hc,
  MathNode: Be,
  MaxMipLevelNode: f0,
  MeshBasicNodeMaterial: _v,
  MeshLambertNodeMaterial: A2,
  MeshNormalNodeMaterial: v2,
  MeshPhongNodeMaterial: E2,
  MeshPhysicalNodeMaterial: Pv,
  MeshStandardNodeMaterial: Id,
  ModelNode: kt,
  ModelViewProjectionNode: Jy,
  MorphNode: TN,
  Node: Oe,
  NodeAttribute: Ca,
  NodeBuilder: g0,
  NodeCache: oc,
  NodeCode: ju,
  NodeFrame: kh,
  NodeFunctionInput: Gh,
  NodeKeywords: Wu,
  NodeLoader: vv,
  NodeMaterial: en,
  NodeMaterialLoader: Da,
  NodeObjectLoader: nT,
  NodeShaderStage: Wl,
  NodeType: lb,
  NodeUniform: Gu,
  NodeUpdateType: ut,
  NodeUtils: ub,
  NodeVar: ac,
  NodeVarying: Vu,
  NormalMapNode: Hy,
  NormalNode: Wo,
  Object3DNode: gn,
  OperatorNode: yt,
  OscNode: Zr,
  OutputStructNode: QN,
  PackingNode: hw,
  PhongLightingModel: Ld,
  PhysicalLightingModel: Od,
  PointLightNode: fv,
  PointUVNode: D0,
  PointsNodeMaterial: Pd,
  PositionNode: Us,
  PosterizeNode: $0,
  PropertyNode: Pt,
  RangeNode: uv,
  ReferenceNode: bo,
  ReflectVectorNode: r0,
  RemapNode: T0,
  RotateUVNode: M0,
  SceneNode: mw,
  Schlick_to_F0: Fv,
  ScriptableNode: n2,
  ScriptableValueNode: e2,
  SetNode: jm,
  ShaderNode: _s,
  SkinningNode: t0,
  SpecularMIPLevelNode: p0,
  SplitNode: _a,
  SpotLightNode: pv,
  SpriteNodeMaterial: zv,
  SpriteSheetUVNode: C0,
  StackNode: WN,
  StorageBufferNode: vw,
  TBNViewMatrix: Xy,
  TangentNode: Yr,
  TempNode: _t,
  TextureBicubicNode: pw,
  TextureNode: bi,
  TextureStoreNode: bw,
  TimerNode: Lt,
  ToneMappingNode: J0,
  TriplanarTexturesNode: R0,
  UVNode: _g,
  UniformNode: Qe,
  UserDataNode: ww,
  V_GGX_SmithCorrelated: Rv,
  VarNode: fc,
  VaryingNode: sc,
  ViewportDepthNode: $w,
  ViewportDepthTextureNode: Ww,
  ViewportNode: zs,
  ViewportSharedTextureNode: jw,
  ViewportTextureNode: id,
  abs: ti,
  acos: ey,
  add: xn,
  addLightNode: Sr,
  addNodeClass: oe,
  addNodeElement: V,
  addNodeMaterial: wn,
  and: Ig,
  arrayBuffer: fg,
  asin: Qg,
  assign: qu,
  atan: ty,
  atan2: uy,
  attribute: Ft,
  backgroundBlurriness: gw,
  backgroundIntensity: yw,
  bitAnd: Ug,
  bitOr: zg,
  bitXor: Bg,
  bitangentGeometry: hN,
  bitangentLocal: dN,
  bitangentView: Gy,
  bitangentWorld: fN,
  bmat3: cg,
  bmat4: hg,
  bool: Ym,
  buffer: bh,
  bufferAttribute: wi,
  bumpMap: $y,
  burn: z0,
  bvec2: Qm,
  bvec3: ng,
  bvec4: og,
  bypass: rc,
  cache: Aa,
  call: ev,
  cameraFar: ga,
  cameraNear: ma,
  cameraNormalMatrix: sN,
  cameraPosition: oN,
  cameraProjectionMatrix: xs,
  cameraViewMatrix: Es,
  cameraWorldMatrix: rN,
  ceil: Yu,
  checker: yv,
  clamp: ni,
  code: Nc,
  color: qm,
  colorSpaceToLinear: uc,
  colorToDirection: w0,
  compute: dv,
  cond: mr,
  context: Yn,
  convert: mg,
  cos: Kg,
  createNodeFromType: Xl,
  createNodeMaterialFromType: No,
  cross: yy,
  cubeTexture: mc,
  dFdx: Ku,
  dFdy: Zu,
  defaultBuildStages: Om,
  defaultShaderStages: $r,
  degrees: jg,
  densityFog: lv,
  depth: qw,
  depthTexture: Jw,
  difference: gy,
  diffuseColor: Xt,
  directionToColor: $h,
  discard: b0,
  distance: my,
  div: mo,
  dodge: B0,
  dot: Gs,
  dynamicBufferAttribute: Ky,
  element: pg,
  equal: Eg,
  equirectUV: gc,
  exp: Wg,
  exp2: Hg,
  expression: xo,
  faceDirection: dh,
  faceForward: Sy,
  float: _e,
  floor: cc,
  fog: ov,
  fract: lc,
  frameId: iw,
  frontFacing: Wy,
  fwidth: ly,
  getConstNodeType: $m,
  getDistanceAttenuation: Td,
  getGeometryRoughness: Cv,
  getRoughness: Ev,
  global: va,
  glsl: dd,
  glslFn: an,
  greaterThan: Lg,
  greaterThanEqual: Og,
  hash: x0,
  hue: W0,
  imat3: ig,
  imat4: lg,
  instance: e0,
  instanceIndex: bg,
  instancedBufferAttribute: Zy,
  instancedDynamicBufferAttribute: Qy,
  int: Ma,
  inverseSqrt: Jg,
  ivec2: Km,
  ivec3: eg,
  ivec4: sg,
  js: Yw,
  label: ic,
  length: sy,
  lessThan: Rg,
  lessThanEqual: Fg,
  lightTargetDirection: wd,
  lightingContext: Ch,
  lights: _N,
  lightsWithoutWrap: u0,
  linearToColorSpace: My,
  linearTosRGB: Ay,
  log: Xg,
  log2: $g,
  loop: zh,
  lumaCoeffs: H0,
  luminance: X0,
  mat3: Ms,
  mat4: Du,
  matcapUV: sw,
  materialAlphaTest: Ry,
  materialColor: sh,
  materialEmissive: Fy,
  materialLineDashOffset: Zl,
  materialLineDashSize: Kh,
  materialLineGapSize: Zh,
  materialLineScale: Pa,
  materialLineWidth: Hr,
  materialMetalness: Py,
  materialNormal: qy,
  materialOpacity: rh,
  materialReference: ao,
  materialReflectivity: Xb,
  materialRotation: Dy,
  materialRoughness: Iy,
  materialSheen: Uy,
  materialSheenRoughness: zy,
  materialShininess: Ly,
  materialSpecularColor: Oy,
  max: dy,
  maxMipLevel: Lh,
  metalness: Ng,
  min: hy,
  mix: rn,
  mod: Qu,
  modelDirection: iN,
  modelNormalMatrix: ah,
  modelPosition: aN,
  modelScale: cN,
  modelViewMatrix: br,
  modelViewPosition: lN,
  modelViewProjection: Yy,
  modelWorldMatrix: si,
  morph: s0,
  mul: Kt,
  mx_aastep: jv,
  mx_cell_noise_float: GT,
  mx_contrast: OT,
  mx_fractal_noise_float: VT,
  mx_fractal_noise_vec2: jT,
  mx_fractal_noise_vec3: WT,
  mx_fractal_noise_vec4: HT,
  mx_hsvtorgb: wT,
  mx_noise_float: IT,
  mx_noise_vec2: PT,
  mx_noise_vec3: DT,
  mx_noise_vec4: UT,
  mx_ramplr: AT,
  mx_ramptb: CT,
  mx_rgbtohsv: TT,
  mx_safepower: FT,
  mx_splitlr: ET,
  mx_splittb: RT,
  mx_srgb_texture_to_lin_rec709: MT,
  mx_transform_uv: LT,
  mx_worley_noise_float: zT,
  mx_worley_noise_vec2: BT,
  mx_worley_noise_vec3: kT,
  negate: ry,
  nodeArray: pr,
  nodeImmutable: ce,
  nodeObject: Me,
  nodeObjects: nc,
  nodeProxy: j,
  normalGeometry: ri,
  normalLocal: Nr,
  normalMap: Jl,
  normalView: us,
  normalWorld: dc,
  normalize: Ln,
  objectDirection: Zb,
  objectNormalMatrix: eN,
  objectPosition: Oa,
  objectScale: nN,
  objectViewMatrix: Qb,
  objectViewPosition: oh,
  objectWorldMatrix: tN,
  oneMinus: oy,
  or: Pg,
  orthographicDepthToViewZ: Hw,
  oscSawtooth: uw,
  oscSine: aw,
  oscSquare: cw,
  oscTriangle: lw,
  output: Sg,
  outputStruct: ew,
  overlay: k0,
  perspectiveDepthToViewZ: Q0,
  pointUV: U0,
  positionGeometry: pn,
  positionLocal: bn,
  positionView: Qn,
  positionViewDirection: Ot,
  positionWorld: lh,
  positionWorldDirection: uh,
  posterize: q0,
  pow: eh,
  pow2: vy,
  pow3: xy,
  pow4: by,
  property: Ns,
  radians: Vg,
  range: s2,
  rangeFog: av,
  reciprocal: ay,
  reference: As,
  reflect: py,
  reflectVector: o0,
  refract: Ty,
  remainder: Cg,
  remap: S0,
  remapClamp: _0,
  rotateUV: A0,
  roughness: oo,
  round: iy,
  sRGBToLinear: Cy,
  sampler: Wb,
  saturate: wy,
  saturation: V0,
  screen: G0,
  scriptable: rv,
  scriptableValue: Xo,
  shader: _b,
  shaderStages: Im,
  shiftLeft: kg,
  shiftRight: Gg,
  shininess: Ra,
  sign: ny,
  sin: Yg,
  skinning: n0,
  smoothstep: Ks,
  specularColor: as,
  specularMIPLevel: Oh,
  split: Mb,
  spritesheetUV: E0,
  sqrt: qg,
  stack: Kl,
  step: fy,
  storage: xw,
  string: dg,
  sub: Fa,
  tan: Zg,
  tangentGeometry: ii,
  tangentLocal: pc,
  tangentView: Ni,
  tangentWorld: ky,
  temp: oi,
  texture: Zt,
  textureBicubic: P0,
  textureStore: Nw,
  timerDelta: ow,
  timerGlobal: rw,
  timerLocal: Xh,
  toneMapping: Uw,
  transformDirection: Ny,
  transformedBitangentView: Vy,
  transformedBitangentWorld: pN,
  transformedClearcoatNormalView: fr,
  transformedNormalView: St,
  transformedNormalWorld: By,
  transformedTangentView: ch,
  transformedTangentWorld: uN,
  triplanarTexture: F0,
  triplanarTextures: L0,
  trunc: cy,
  tslFn: Ke,
  uint: Jm,
  umat3: ag,
  umat4: ug,
  uniform: Rt,
  userData: Tw,
  uv: gt,
  uvec2: Zm,
  uvec3: tg,
  uvec4: rg,
  varying: at,
  vec2: tt,
  vec3: Re,
  vec4: st,
  vectorComponents: Ya,
  vertexIndex: Rb,
  vibrance: j0,
  viewZToOrthographicDepth: tu,
  viewZToPerspectiveDepth: Xw,
  viewport: ya,
  viewportBottomLeft: kw,
  viewportBottomRight: Vw,
  viewportCoordinate: zw,
  viewportDepthTexture: ld,
  viewportMipTexture: K0,
  viewportResolution: Bw,
  viewportSharedTexture: Z0,
  viewportTexture: Y0,
  viewportTopLeft: xc,
  viewportTopRight: Gw,
  wgsl: Kw,
  wgslFn: Qw,
  xor: Dg
}, Symbol.toStringTag, { value: "Module" })), $v = {
  BitangentNodeScope: {
    LOCAL: Kr.LOCAL,
    VIEW: Kr.VIEW,
    WORLD: Kr.WORLD,
    GEOMETRY: Kr.GEOMETRY
  },
  Blending: { AdditiveBlending: M.AdditiveBlending, CustomBlending: M.CustomBlending, MultiplyBlending: M.MultiplyBlending, NoBlending: M.NoBlending, NormalBlending: M.NormalBlending, SubtractiveBlending: M.SubtractiveBlending },
  BlendingDstFactor: { DstAlphaFactor: M.DstAlphaFactor, DstColorFactor: M.DstColorFactor, OneFactor: M.OneFactor, OneMinusDstAlphaFactor: M.OneMinusDstAlphaFactor, OneMinusDstColorFactor: M.OneMinusDstColorFactor, OneMinusSrcAlphaFactor: M.OneMinusSrcAlphaFactor, OneMinusSrcColorFactor: M.OneMinusSrcColorFactor, SrcAlphaFactor: M.SrcAlphaFactor, SrcColorFactor: M.SrcColorFactor, ZeroFactor: M.ZeroFactor },
  BlendingSrcFactor: { SrcAlphaSaturateFactor: M.SrcAlphaSaturateFactor },
  BlendingEquation: { AddEquation: M.AddEquation, MaxEquation: M.MaxEquation, MinEquation: M.MinEquation, ReverseSubtractEquation: M.ReverseSubtractEquation, SubtractEquation: M.SubtractEquation },
  BlendMode: {
    BURN: Qr.BURN,
    DODGE: Qr.DODGE,
    SCREEN: Qr.SCREEN,
    OVERLAY: Qr.OVERLAY
  },
  CameraNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION,
    PROJECTION_MATRIX: ih.PROJECTION_MATRIX
  },
  ColorAdjustmentMethod: {
    SATURATION: Ho.SATURATION,
    VIBRANCE: Ho.VIBRANCE,
    HUE: Ho.HUE
  },
  ColorSpace: { DisplayP3ColorSpace: M.DisplayP3ColorSpace, LinearDisplayP3ColorSpace: M.LinearDisplayP3ColorSpace, LinearSRGBColorSpace: M.LinearSRGBColorSpace, NoColorSpace: M.NoColorSpace, SRGBColorSpace: M.SRGBColorSpace },
  ColorSpaceNodeMethod: {
    LINEAR_TO_LINEAR: jo.LINEAR_TO_LINEAR,
    LINEAR_TO_sRGB: jo.LINEAR_TO_sRGB,
    sRGB_TO_LINEAR: jo.sRGB_TO_LINEAR
  },
  Combine: { AddOperation: M.AddOperation, MixOperation: M.MixOperation, MultiplyOperation: M.MultiplyOperation },
  CompressedPixelFormat: { RED_GREEN_RGTC2_Format: M.RED_GREEN_RGTC2_Format, RED_RGTC1_Format: M.RED_RGTC1_Format, RGBA_ASTC_10x10_Format: M.RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format: M.RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format: M.RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format: M.RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format: M.RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format: M.RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format: M.RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format: M.RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format: M.RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format: M.RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format: M.RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format: M.RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format: M.RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format: M.RGBA_ASTC_8x8_Format, RGBA_BPTC_Format: M.RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: M.RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format: M.RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format: M.RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format: M.RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format: M.RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format: M.RGBA_S3TC_DXT5_Format, RGB_BPTC_SIGNED_Format: M.RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format: M.RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format: M.RGB_ETC1_Format, RGB_ETC2_Format: M.RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format: M.RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format: M.RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: M.RGB_S3TC_DXT1_Format, SIGNED_RED_GREEN_RGTC2_Format: M.SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format: M.SIGNED_RED_RGTC1_Format },
  CoordinateSystem: { WebGLCoordinateSystem: M.WebGLCoordinateSystem, WebGPUCoordinateSystem: M.WebGPUCoordinateSystem },
  CubeTextureMapping: { CubeReflectionMapping: M.CubeReflectionMapping, CubeRefractionMapping: M.CubeRefractionMapping, CubeUVReflectionMapping: M.CubeUVReflectionMapping },
  DeepTexturePixelFormat: { DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat },
  DepthModes: { AlwaysDepth: M.AlwaysDepth, EqualDepth: M.EqualDepth, GreaterDepth: M.GreaterDepth, GreaterEqualDepth: M.GreaterEqualDepth, LessDepth: M.LessDepth, LessEqualDepth: M.LessEqualDepth, NeverDepth: M.NeverDepth, NotEqualDepth: M.NotEqualDepth },
  DepthPackingStrategies: { BasicDepthPacking: M.BasicDepthPacking, RGBADepthPacking: M.RGBADepthPacking },
  GLSLVersion: { GLSL1: M.GLSL1, GLSL3: M.GLSL3 },
  MagnificationTextureFilter: { LinearFilter: M.LinearFilter, NearestFilter: M.NearestFilter },
  Mapping: { EquirectangularReflectionMapping: M.EquirectangularReflectionMapping, EquirectangularRefractionMapping: M.EquirectangularRefractionMapping, UVMapping: M.UVMapping },
  MaterialNodeScope: {
    ALPHA_TEST: Jn.ALPHA_TEST,
    COLOR: Jn.COLOR,
    OPACITY: Jn.OPACITY,
    ROUGHNESS: Jn.ROUGHNESS,
    METALNESS: Jn.METALNESS,
    EMISSIVE: Jn.EMISSIVE,
    ROTATION: Jn.ROTATION
  },
  MathNodeMethod1: {
    RADIANS: Be.RADIANS,
    DEGREES: Be.DEGREES,
    EXP: Be.EXP,
    EXP2: Be.EXP2,
    LOG: Be.LOG,
    LOG2: Be.LOG2,
    SQRT: Be.SQRT,
    INVERSE_SQRT: Be.INVERSE_SQRT,
    FLOOR: Be.FLOOR,
    CEIL: Be.CEIL,
    NORMALIZE: Be.NORMALIZE,
    FRACT: Be.FRACT,
    SIN: Be.SIN,
    COS: Be.COS,
    TAN: Be.TAN,
    ASIN: Be.ASIN,
    ACOS: Be.ACOS,
    ATAN: Be.ATAN,
    ABS: Be.ABS,
    SIGN: Be.SIGN,
    LENGTH: Be.LENGTH,
    NEGATE: Be.NEGATE,
    ONE_MINUS: Be.ONE_MINUS,
    DFDX: Be.DFDX,
    DFDY: Be.DFDY,
    ROUND: Be.ROUND
  },
  MathNodeMethod2: {
    ATAN2: Be.ATAN2,
    MIN: Be.MIN,
    MAX: Be.MAX,
    MOD: Be.MOD,
    STEP: Be.STEP,
    REFLECT: Be.REFLECT,
    DISTANCE: Be.DISTANCE,
    DOT: Be.DOT,
    CROSS: Be.CROSS,
    POW: Be.POW,
    TRANSFORM_DIRECTION: Be.TRANSFORM_DIRECTION
  },
  MathNodeMethod3: {
    MIX: Be.MIX,
    CLAMP: Be.CLAMP,
    REFRACT: Be.REFRACT,
    SMOOTHSTEP: Be.SMOOTHSTEP,
    FACEFORWARD: Be.FACEFORWARD
  },
  MinificationTextureFilter: { LinearFilter: M.LinearFilter, LinearMipMapLinearFilter: M.LinearMipMapLinearFilter, LinearMipMapNearestFilter: M.LinearMipMapNearestFilter, LinearMipmapLinearFilter: M.LinearMipmapLinearFilter, LinearMipmapNearestFilter: M.LinearMipmapNearestFilter, NearestFilter: M.NearestFilter, NearestMipMapLinearFilter: M.NearestMipMapLinearFilter, NearestMipMapNearestFilter: M.NearestMipMapNearestFilter, NearestMipmapLinearFilter: M.NearestMipmapLinearFilter, NearestMipmapNearestFilter: M.NearestMipmapNearestFilter },
  NodeTypeOption: "void,bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","),
  NormalMapTypes: { ObjectSpaceNormalMap: M.ObjectSpaceNormalMap, TangentSpaceNormalMap: M.TangentSpaceNormalMap },
  NormalNodeScope: {
    GEOMETRY: Wo.GEOMETRY,
    LOCAL: Wo.LOCAL,
    VIEW: Wo.VIEW
  },
  Object3DNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION
  },
  OperatorNodeOp: ["=", "%", "&", "|", "^", ">>", "<<", "==", "&&", "||", "^^", "<", ">", "<=", ">=", "+", "-", "*", "/"],
  OscNodeMethod: {
    SINE: Zr.SINE,
    SQUARE: Zr.SQUARE,
    TRIANGLE: Zr.TRIANGLE,
    SAWTOOTH: Zr.SAWTOOTH
  },
  PixelFormatGPU: ["ALPHA", "DEPTH24_STENCIL8", "DEPTH32F_STENCIL8", "DEPTH_COMPONENT16", "DEPTH_COMPONENT24", "DEPTH_COMPONENT32F", "LUMINANCE", "LUMINANCE_ALPHA", "R11F_G11F_B10F", "R16F", "R16I", "R16UI", "R32F", "R32I", "R32UI", "R8", "R8I", "R8UI", "R8_SNORM", "RED_INTEGER", "RG16F", "RG16I", "RG16UI", "RG32F", "RG32I", "RG32UI", "RG8", "RG8I", "RG8UI", "RG8_SNORM", "RGB", "RGB10_A2", "RGB10_A2UI", "RGB16F", "RGB16I", "RGB16UI", "RGB32F", "RGB32I", "RGB32UI", "RGB565", "RGB5_A1", "RGB8", "RGB8I", "RGB8UI", "RGB8_SNORM", "RGB9_E5", "RGBA", "RGBA16F", "RGBA16I", "RGBA16UI", "RGBA32F", "RGBA32I", "RGBA32UI", "RGBA4", "RGBA8", "RGBA8I", "RGBA8UI", "RGBA8_SNORM", "SRGB8", "SRGB8_ALPHA8"],
  PositionNodeScope: {
    GEOMETRY: Us.GEOMETRY,
    LOCAL: Us.LOCAL,
    WORLD: Us.WORLD,
    WORLD_DIRECTION: Us.WORLD_DIRECTION,
    VIEW: Us.VIEW,
    VIEW_DIRECTION: Us.VIEW_DIRECTION
  },
  Precision: ["highp", "mediump", "lowp"],
  Side: { BackSide: M.BackSide, DoubleSide: M.DoubleSide, FrontSide: M.FrontSide, TwoPassDoubleSide: M.TwoPassDoubleSide },
  StencilFunc: { AlwaysStencilFunc: M.AlwaysStencilFunc, EqualStencilFunc: M.EqualStencilFunc, GreaterEqualStencilFunc: M.GreaterEqualStencilFunc, GreaterStencilFunc: M.GreaterStencilFunc, LessEqualStencilFunc: M.LessEqualStencilFunc, LessStencilFunc: M.LessStencilFunc, NeverStencilFunc: M.NeverStencilFunc, NotEqualStencilFunc: M.NotEqualStencilFunc },
  StencilOp: { DecrementStencilOp: M.DecrementStencilOp, DecrementWrapStencilOp: M.DecrementWrapStencilOp, IncrementStencilOp: M.IncrementStencilOp, IncrementWrapStencilOp: M.IncrementWrapStencilOp, InvertStencilOp: M.InvertStencilOp, KeepStencilOp: M.KeepStencilOp, ReplaceStencilOp: M.ReplaceStencilOp, ZeroStencilOp: M.ZeroStencilOp },
  TangentNodeScope: {
    LOCAL: Yr.LOCAL,
    VIEW: Yr.VIEW,
    WORLD: Yr.WORLD,
    GEOMETRY: Yr.GEOMETRY
  },
  TextureComparisonFunction: { AlwaysCompare: M.AlwaysCompare, EqualCompare: M.EqualCompare, GreaterCompare: M.GreaterCompare, GreaterEqualCompare: M.GreaterEqualCompare, LessCompare: M.LessCompare, LessEqualCompare: M.LessEqualCompare, NeverCompare: M.NeverCompare, NotEqualCompare: M.NotEqualCompare },
  TextureDataType: { ByteType: M.ByteType, FloatType: M.FloatType, HalfFloatType: M.HalfFloatType, IntType: M.IntType, ShortType: M.ShortType, UnsignedByteType: M.UnsignedByteType, UnsignedInt248Type: M.UnsignedInt248Type, UnsignedIntType: M.UnsignedIntType, UnsignedShort4444Type: M.UnsignedShort4444Type, UnsignedShort5551Type: M.UnsignedShort5551Type, UnsignedShortType: M.UnsignedShortType },
  TextureEncoding: { LinearEncoding: M.LinearEncoding, sRGBEncoding: M.sRGBEncoding },
  ToneMapping: {
    NoToneMapping: M.NoToneMapping,
    LinearToneMapping: M.LinearToneMapping,
    ReinhardToneMapping: M.ReinhardToneMapping,
    CineonToneMapping: M.CineonToneMapping,
    ACESFilmicToneMapping: M.ACESFilmicToneMapping,
    CustomToneMapping: M.CustomToneMapping
  },
  ViewportNodeScope: {
    COORDINATE: zs.COORDINATE,
    RESOLUTION: zs.RESOLUTION,
    TOP_LEFT: zs.TOP_LEFT,
    BOTTOM_LEFT: zs.BOTTOM_LEFT,
    TOP_RIGHT: zs.TOP_RIGHT,
    BOTTOM_RIGHT: zs.BOTTOM_RIGHT
  },
  WebGL1PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGFormat: M.RGFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  WebGL2PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGBAFormat: M.RGBAFormat, RGBAIntegerFormat: M.RGBAIntegerFormat, RGFormat: M.RGFormat, RGIntegerFormat: M.RGIntegerFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  Wrapping: { ClampToEdgeWrapping: M.ClampToEdgeWrapping, MirroredRepeatWrapping: M.MirroredRepeatWrapping, RepeatWrapping: M.RepeatWrapping }
}, Ua = {
  AmbientLight: {
    cls: M.AmbientLight,
    isAmbientLight: !0,
    members: {
      // type: "string | 'AmbientLight'"
    },
    proto: "Light"
  },
  AmbientLightProbe: {
    // cls: THREE.AmbientLightProbe,
    isAmbientLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  ArrayCamera: {
    cls: M.ArrayCamera,
    isArrayCamera: !0,
    members: { cameras: "PerspectiveCamera[]" },
    proto: "PerspectiveCamera"
  },
  Audio: {
    cls: M.Audio,
    members: {},
    proto: "Object3D"
  },
  AudioListener: {
    cls: M.AudioListener,
    members: {},
    proto: "Object3D"
  },
  Camera: {
    cls: M.Camera,
    isCamera: !0,
    members: {
      coordinateSystem: "types.CoordinateSystem",
      // layers: 'Layers',
      matrixWorldInverse: "Matrix4",
      projectionMatrix: "Matrix4",
      projectionMatrixInverse: "Matrix4"
      // type: "string | 'Camera'"
    },
    proto: "Object3D"
  },
  CanvasTexture: {
    cls: M.CanvasTexture,
    isCanvasTexture: !0,
    members: {},
    proto: "Texture"
  },
  CompressedArrayTexture: {
    cls: M.CompressedArrayTexture,
    isCompressedArrayTexture: !0,
    members: { wrapR: "types.Wrapping" },
    proto: "CompressedTexture"
  },
  CompressedTexture: {
    cls: M.CompressedTexture,
    isCompressedTexture: !0,
    members: {
      flipY: "boolean",
      format: "types.CompressedPixelFormat",
      generateMipmaps: "boolean"
      // mipmaps: 'ImageData[]'
    },
    proto: "Texture"
  },
  CubeCamera: {
    cls: M.CubeCamera,
    members: {
      coordinateSystem: "types.CoordinateSystem"
      // renderTarget: 'WebGLCubeRenderTarget',
      // type: "string | 'CubeCamera'"
    },
    proto: "Object3D"
  },
  CubeTexture: {
    cls: M.CubeTexture,
    isCubeTexture: !0,
    members: {
      flipY: "boolean",
      mapping: "types.CubeTextureMapping"
    },
    proto: "Texture"
  },
  Data3DTexture: {
    cls: M.Data3DTexture,
    isData3DTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "types.Wrapping"
    },
    proto: "Texture"
  },
  DataArrayTexture: {
    cls: M.DataArrayTexture,
    isDataArrayTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "boolean"
    },
    proto: "Texture"
  },
  DataTexture: {
    cls: M.DataTexture,
    isDataTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number"
    },
    proto: "Texture"
  },
  DepthTexture: {
    cls: M.DepthTexture,
    isDepthTexture: !0,
    members: {
      compareFunction: "types.TextureComparisonFunction | null",
      flipY: "boolean",
      format: "types.DeepTexturePixelFormat",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      type: "types.TextureDataType"
    },
    proto: "Texture"
  },
  DirectionalLight: {
    cls: M.DirectionalLight,
    isDirectionalLight: !0,
    members: {
      castShadow: "boolean",
      position: "Vector3",
      // shadow: 'DirectionalLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'DirectionalLight'"
    },
    proto: "Light"
  },
  DirectionalLightShadow: {
    cls: M.DirectionalLightShadow,
    isDirectionalLightShadow: !0,
    members: {
      camera: "OrthographicCamera"
    },
    proto: "LightShadow"
  },
  Fog: {
    cls: M.Fog,
    isFog: !0,
    members: {
      color: "Color",
      far: "number",
      // name: 'string',
      near: "number"
    },
    proto: "FogBase"
  },
  FogExp2: {
    cls: M.FogExp2,
    isFogExp2: !0,
    members: {
      color: "Color",
      density: "number"
      // name: 'string'
    },
    proto: "FogBase"
  },
  FramebufferTexture: {
    cls: M.FramebufferTexture,
    isFramebufferTexture: !0,
    members: {
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter"
    },
    proto: "Texture"
  },
  HemisphereLight: {
    cls: M.HemisphereLight,
    isHemisphereLight: !0,
    members: {
      color: "Color",
      groundColor: "Color",
      position: "Vector3"
      // type: "string | 'HemisphereLight'"
    },
    proto: "Light"
  },
  HemisphereLightProbe: {
    // cls: THREE.HemisphereLightProbe,
    isHemisphereLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  InstancedMesh: {
    cls: M.InstancedMesh,
    members: {
      count: "number"
    },
    proto: "Mesh"
  },
  Light: {
    cls: M.Light,
    isLight: !0,
    members: {
      color: "Color",
      intensity: "number",
      shadow: "LightShadow"
      // type: "string | 'Light'"
    },
    proto: "Object3D"
  },
  LightProbe: {
    cls: M.LightProbe,
    isLightProbe: !0,
    members: {
      sh: "SphericalHarmonics3"
    },
    proto: "Light"
  },
  LightShadow: {
    cls: M.LightShadow,
    members: {
      // autoUpdate: 'boolean',
      bias: "number",
      blurSamples: "number",
      camera: "Camera",
      // map: 'WebGLRenderTarget | null',
      // mapPass: 'WebGLRenderTarget | null',
      mapSize: "Vector2",
      matrix: "Matrix4",
      // needsUpdate: 'boolean',
      normalBias: "number",
      radius: "number"
    }
  },
  LineBasicMaterial: {
    cls: M.LineBasicMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      linecap: "string",
      linejoin: "string",
      linewidth: "number",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  LineDashedMaterial: {
    cls: M.LineDashedMaterial,
    isLineDashedMaterial: !0,
    members: {
      dashSize: "number",
      gapSize: "number",
      scale: "number"
      // type: 'string'
    },
    proto: "LineBasicMaterial"
  },
  Material: {
    cls: M.Material,
    isMaterial: !0,
    members: {
      alphaHash: "boolean",
      // alphaTest: 'number',
      // alphaToCoverage: 'boolean',
      // blendDst: 'types.BlendingDstFactor',
      // blendDstAlpha: 'number | null',
      // blendEquation: 'types.BlendingEquation',
      // blendEquationAlpha: 'number | null',
      blendSrc: "types.BlendingSrcFactor | types.BlendingDstFactor",
      blendSrcAlpha: "number | null",
      blending: "types.Blending",
      // clipIntersection: 'boolean',
      // clipShadows: 'boolean',
      // clippingPlanes: 'Plane[]',
      // colorWrite: 'boolean',
      // defines: 'undefined | { [key: string]: any }',
      depthFunc: "types.DepthModes",
      depthTest: "boolean",
      depthWrite: "boolean",
      // dithering: 'boolean',
      // forceSinglePass: 'boolean',
      // id: 'number',
      // name: 'string',
      // needsUpdate: 'boolean',
      opacity: "number",
      // polygonOffset: 'boolean',
      // polygonOffsetFactor: 'number',
      // polygonOffsetUnits: 'number',
      precision: "types.Precision | null",
      premultipliedAlpha: "boolean",
      shadowSide: "types.Side | null",
      side: "types.Side",
      stencilFail: "types.StencilOp",
      stencilFunc: "types.StencilFunc",
      stencilFuncMask: "number",
      stencilRef: "number",
      stencilWrite: "boolean",
      stencilWriteMask: "number",
      stencilZFail: "types.StencilOp",
      stencilZPass: "types.StencilOp",
      toneMapped: "boolean",
      transparent: "boolean",
      // type: 'string',
      // userData: 'any',
      // uuid: 'string',
      // version: 'number',
      // vertexColors: 'boolean',
      visible: "boolean"
    },
    proto: "EventDispatcher"
  },
  Mesh: {
    cls: M.Mesh,
    members: {
      castShadow: "boolean",
      receiveShadow: "boolean",
      material: "Material"
    },
    proto: "Object3D"
  },
  MeshBasicMaterial: {
    cls: M.MeshBasicMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      color: "Color",
      combine: "types.Combine",
      envMap: "Texture | null",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDepthMaterial: {
    cls: M.MeshDepthMaterial,
    members: {
      alphaMap: "Texture | null",
      depthPacking: "types.DepthPackingStrategies",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDistanceMaterial: {
    cls: M.MeshDistanceMaterial,
    members: {
      alphaMap: "Texture | null",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshLambertMaterial: {
    cls: M.MeshLambertMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshMatcapMaterial: {
    cls: M.MeshMatcapMaterial,
    members: {
      alphaMap: "Texture | null",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      fog: "boolean",
      map: "Texture | null",
      matcap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshNormalMaterial: {
    cls: M.MeshNormalMaterial,
    members: {
      bumpMap: "Texture | null",
      bumpScale: "number",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhongMaterial: {
    cls: M.MeshPhongMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metal: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      shininess: "number",
      specular: "Color",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhysicalMaterial: {
    cls: M.MeshPhysicalMaterial,
    members: {
      anisotropy: "number",
      anisotropyMap: "Texture | null",
      anisotropyRotation: "number",
      attenuationColor: "Color",
      attenuationDistance: "number",
      clearcoat: "number",
      clearcoatMap: "Texture | null",
      clearcoatNormalMap: "Texture | null",
      clearcoatNormalScale: "Vector2",
      clearcoatRoughness: "number",
      clearcoatRoughnessMap: "Texture | null",
      // defines: '{ [key: string]: any }',
      ior: "number",
      iridescence: "number",
      iridescenceIOR: "number",
      iridescenceMap: "Texture | null",
      iridescenceThicknessMap: "Texture | null",
      iridescenceThicknessRange: "number[]",
      reflectivity: "number",
      sheen: "number",
      sheenColor: "Color",
      sheenColorMap: "Texture | null",
      sheenRoughness: "number",
      sheenRoughnessMap: "Texture | null",
      specularColor: "Color",
      specularColorMap: "Texture | null",
      specularIntensity: "number",
      specularIntensityMap: "Texture | null",
      thickness: "number",
      thicknessMap: "Texture | null",
      transmission: "number",
      transmissionMap: "Texture | null"
      // type: 'string'
    },
    proto: "MeshStandardMaterial"
  },
  MeshStandardMaterial: {
    cls: M.MeshStandardMaterial,
    isMeshStandardMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }', 
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      envMapIntensity: "number",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metalness: "number",
      metalnessMap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      roughness: "number",
      roughnessMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshToonMaterial: {
    cls: M.MeshToonMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      fog: "boolean",
      gradientMap: "Texture | null",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  Object3D: {
    cls: M.Object3D,
    isObject3D: !0,
    members: {
      up: "Vector3",
      position: "Vector3",
      rotation: "Euler",
      scale: "Vector3",
      visible: "Boolean"
    }
  },
  OrthographicCamera: {
    cls: M.OrthographicCamera,
    isOrthographicCamera: !0,
    members: {
      bottom: "number",
      far: "number",
      left: "number",
      near: "number",
      right: "number",
      top: "number",
      // type: "string | 'OrthographicCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PerspectiveCamera: {
    cls: M.PerspectiveCamera,
    isPerspectiveCamera: !0,
    members: {
      aspect: "number",
      far: "number",
      filmGauge: "number",
      filmOffset: "number",
      focus: "number",
      fov: "number",
      near: "number",
      //   type: "string | 'PerspectiveCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PointLight: {
    cls: M.PointLight,
    members: {
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      power: "number",
      // shadow: 'PointLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number"
      // type: 'string'
    },
    proto: "Light"
  },
  PointLightShadow: {
    cls: M.PointLightShadow,
    isPointLightShadow: !0,
    members: {},
    proto: "LightShadow"
  },
  Points: {
    cls: M.Points,
    members: {
      material: "Material"
    },
    proto: "Object3D"
  },
  PointsMaterial: {
    cls: M.PointsMaterial,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      size: "number",
      sizeAttenuation: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  PositionalAudio: {
    cls: M.PositionalAudio,
    members: {},
    proto: "Audio"
  },
  RawShaderMaterial: {
    cls: M.RawShaderMaterial,
    members: {},
    proto: "ShaderMaterial"
  },
  RectAreaLight: {
    cls: M.RectAreaLight,
    isRectAreaLight: !0,
    members: {
      height: "number",
      intensity: "number",
      power: "number",
      // type: "string | 'RectAreaLight'",
      width: "number"
    },
    proto: "Light"
  },
  Scene: {
    cls: M.Scene,
    isScene: !0,
    members: {
      background: "Color | Texture | CubeTexture | null",
      backgroundBlurriness: "number",
      backgroundIntensity: "number",
      environment: "Texture | null",
      fog: "FogBase | null",
      overrideMaterial: "Material | null"
      // type: "'Scene'"
    },
    proto: "Object3D"
  },
  ShaderMaterial: {
    cls: M.ShaderMaterial,
    isShaderMaterial: !0,
    members: {
      // clipping: 'boolean',
      //   defaultAttributeValues: 'any',
      //   defines: '{ [key: string]: any }', derivatives: 'any',
      //   extensions: `{
      //     derivatives: boolean;
      //     fragDepth: boolean;
      //     drawBuffers: boolean;
      //     shaderTextureLOD: boolean;
      // }`,
      fog: "boolean",
      // fragmentShader: 'string',
      // glslVersion: 'types.GLSLVersion | null',
      // index0AttributeName: 'string | undefined', lights: 'boolean', linewidth: 'number',
      // type: 'string',
      // uniforms: '{ [uniform: string]: IUniform }',
      // uniformsGroups: 'UniformsGroup[]',
      // uniformsNeedUpdate: 'boolean',
      // vertexShader: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  ShadowMaterial: {
    cls: M.ShadowMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  Source: {
    cls: M.Source,
    isSource: !0,
    members: {
      // data: 'any', id: 'number', uuid: 'string', version: 'number'
    }
  },
  SphericalHarmonics3: {
    cls: M.SphericalHarmonics3,
    isSphericalHarmonics3: !0,
    members: { coefficients: "Vector3[]" }
  },
  SpotLight: {
    cls: M.SpotLight,
    isSpotLight: !0,
    members: {
      angle: "number",
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      map: "Texture | null",
      penumbra: "number",
      position: "Vector3",
      power: "number",
      // shadow: 'SpotLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'SpotLight'"
    },
    proto: "Light"
  },
  SpotLightShadow: {
    cls: M.SpotLightShadow,
    isSpotLightShadow: !0,
    members: { camera: "PerspectiveCamera", focus: "number" },
    proto: "LightShadow"
  },
  SpriteMaterial: {
    cls: M.SpriteMaterial,
    isSpriteMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      rotation: "number",
      sizeAttenuation: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  StereoCamera: {
    cls: M.StereoCamera,
    members: {
      aspect: "number",
      cameraL: "PerspectiveCamera",
      cameraR: "PerspectiveCamera",
      eyeSep: "number"
      // type: "'StereoCamera'"
    },
    proto: "Camera"
  },
  Texture: {
    cls: M.Texture,
    isTexture: !0,
    members: {
      anisotropy: "number",
      center: "Vector2",
      channel: "number",
      colorSpace: "types.ColorSpace",
      encoding: "types.TextureEncoding",
      flipY: "boolean",
      format: "types.WebGL1PixelFormat | types.WebGL2PixelFormat | types.DeepTexturePixelFormat | types.CompressedPixelFormat",
      generateMipmaps: "boolean",
      // id: 'number',
      image: "Image",
      internalFormat: "types.PixelFormatGPU | null",
      // isRenderTargetTexture: 'boolean',
      magFilter: "types.MagnificationTextureFilter",
      mapping: "types.Mapping | types.CubeTextureMapping",
      matrix: "Matrix3",
      // matrixAutoUpdate: 'boolean', minFilter: 'types.MinificationTextureFilter', mipmaps: 'any[]',
      // name: 'string',
      // needsPMREMUpdate: 'boolean',
      offset: "Vector2",
      // onUpdate: '() => void',
      premultiplyAlpha: "boolean",
      repeat: "Vector2",
      rotation: "number",
      // source: 'Source',
      type: "types.TextureDataType",
      unpackAlignment: "number",
      // userData: 'any',
      // uuid: 'string', version: 'number',
      wrapS: "types.Wrapping",
      wrapT: "types.Wrapping"
    },
    proto: "EventDispatcher"
  },
  VideoTexture: {
    cls: M.VideoTexture,
    isVideoTexture: !0,
    members: { generateMipmaps: "boolean", magFilter: "types.MagnificationTextureFilter", minFilter: "types.MinificationTextureFilter" },
    proto: "Texture"
  }
}, ci = {
  AONode: {
    cls: Mh,
    group: "lighting",
    members: { aoNode: "Node | null" },
    proto: "LightingNode"
  },
  AnalyticLightNode: {
    cls: sr,
    group: "lighting",
    members: { colorNode: "Node", light: "Light | null" },
    proto: "LightingNode"
  },
  ArrayElementNode: {
    cls: Za,
    group: "utils",
    members: { indexNode: "Node", node: "Node" },
    proto: "TempNode"
  },
  ArrayUniformNode: {
    cls: yg,
    group: "core",
    isArrayUniformNode: !0,
    members: { nodes: "Node[]" },
    proto: "UniformNode"
  },
  AttributeNode: {
    cls: vi,
    group: "core",
    members: {},
    proto: "Node"
  },
  BitangentNode: {
    cls: Kr,
    group: "accessors",
    members: { scope: "types.BitangentNodeScope" },
    proto: "Node"
  },
  BlendModeNode: {
    cls: Qr,
    group: "display",
    members: { baseNode: "Node", blendMode: "types.BlendMode", blendNode: "Node" },
    proto: "TempNode"
  },
  BufferNode: {
    cls: xh,
    group: "accessors",
    isBufferNode: !0,
    members: { bufferCount: "number", bufferType: "string" },
    proto: "UniformNode"
  },
  BypassNode: {
    cls: vg,
    group: "core",
    isBypassNode: !0,
    members: { callNode: "Node", outputNode: "Node" },
    proto: "Node"
  },
  CacheNode: {
    cls: xg,
    group: "core",
    isCacheNode: !0,
    members: { cache: "NodeCache", node: "Node" },
    proto: "Node"
  },
  CameraNode: {
    cls: ih,
    group: "accessors",
    members: { scope: "types.CameraNodeScope" },
    proto: "Object3DNode"
  },
  CheckerNode: {
    cls: gv,
    group: "procedural",
    members: { uvNode: "Node" },
    proto: "TempNode"
  },
  CodeNode: {
    cls: hd,
    group: "code",
    isCodeNode: !0,
    members: { code: "string" },
    proto: "Node"
  },
  ColorAdjustmentNode: {
    cls: Ho,
    group: "display",
    members: { adjustmentNode: "Node", colorNode: "Node", method: "types.ColorAdjustmentMethod" },
    proto: "TempNode"
  },
  ColorSpaceNode: {
    cls: jo,
    group: "display",
    members: { method: "types.ColorSpaceNodeMethod", node: "Node" },
    proto: "TempNode"
  },
  ComputeNode: {
    cls: hv,
    group: "gpgpu",
    isComputeNode: !0,
    members: { count: "number", dispatchCount: "number", workgroupSize: "number[]" },
    proto: "Node"
  },
  CondNode: {
    cls: Dh,
    group: "math",
    members: { condNode: "Node", elseNode: "Node", ifNode: "Node" },
    proto: "Node"
  },
  ConstNode: {
    cls: Fn,
    group: "core",
    isConstNode: !0,
    members: {},
    proto: "InputNode"
  },
  ContextNode: {
    cls: xi,
    group: "core",
    isContextNode: !0,
    members: { context: "Object", node: "Node" },
    proto: "Node"
  },
  ConvertNode: {
    cls: Qa,
    group: "utils",
    members: { convertTo: "types.NodeTypeOption", node: "Node" },
    proto: "Node"
  },
  CubeTextureNode: {
    cls: i0,
    group: "accessors",
    isCubeTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "CubeTexture" },
    proto: "TextureNode"
  },
  EnvironmentNode: {
    cls: Ih,
    group: "lighting",
    members: { envNode: "Node | null" },
    proto: "LightingNode"
  },
  EquirectUVNode: {
    cls: d0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  ExpressionNode: {
    cls: Ey,
    group: "code",
    members: { snipped: "string" },
    proto: "TempNode"
  },
  FogExp2Node: {
    cls: cv,
    group: "fog",
    isFogExp2Node: !0,
    members: { densityNode: "Node" },
    proto: "FogNode"
  },
  FogNode: {
    cls: wc,
    group: "fog",
    isFogNode: !0,
    members: { colorNode: "Node", factorNode: "Node" },
    proto: "Node"
  },
  FogRangeNode: {
    cls: iv,
    group: "fog",
    isFogRangeNode: !0,
    members: { farNode: "Node", nearNode: "Node" },
    proto: "FogNode"
  },
  FrontFacingNode: {
    cls: jy,
    group: "display",
    isFrontFacingNode: !0,
    members: {},
    proto: "Node"
  },
  // FunctionCallNode: {
  //   cls: Nodes.FunctionCallNode,
  //   group: 'code',
  //   members: {
  //     functionNode: 'FunctionNode<P>',
  //     parameters: '{ [name: string]: Node }'
  //   },
  //   proto: 'TempNode'
  // },
  FunctionNode: {
    cls: tv,
    group: "code",
    members: { keywords: "{ [key: string]: Node }" },
    proto: "CodeNode"
  },
  HemisphereLightNode: {
    cls: mv,
    group: "lighting",
    members: { groundColorNode: "Node", lightDirectionNode: "Node", lightPositionNode: "Object3DNode" },
    proto: "AnalyticLightNode"
  },
  InputNode: {
    // cls: Nodes.InputNode,
    group: "core",
    isInputNode: !0,
    members: { precision: "types.Precision | null", value: "Color | Vector2 | Vector3 | Vector4 | Matrix3 | Matrix4 | boolean | number" },
    proto: "Node"
  },
  // InstanceNode: {
  //   cls: Nodes.InstanceNode,
  //   group: 'accessors',
  //   members: { instanceMatrixNode: 'Node', instanceMesh: 'InstancedMesh' },
  //   proto: 'Node'
  // },
  // LightingContextNode: {
  //   cls: Nodes.LightingContextNode,
  //   group: 'lighting',
  //   members: { lightingModelNode: 'LightingModelNode | null' },
  //   proto: 'ContextNode'
  // },
  LightingNode: {
    cls: Ti,
    group: "lighting",
    members: {},
    proto: "Node"
  },
  LightsNode: {
    cls: l0,
    group: "lighting",
    members: { lightNodes: "LightingNode[]" },
    proto: "Node"
  },
  LineBasicNodeMaterial: {
    cls: bv,
    group: "materials",
    isLineBasicNodeMaterial: !0,
    members: {},
    proto: ["LineBasicMaterial", "NodeMaterial"]
  },
  MatcapUVNode: {
    cls: N0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  MaterialNode: {
    cls: Jn,
    group: "accessors",
    members: { scope: "types.MaterialNodeScope" },
    proto: "Node"
  },
  MaterialReferenceNode: {
    cls: hc,
    group: "accessors",
    members: {},
    proto: "ReferenceNode"
  },
  MathNode: {
    cls: Be,
    group: "math",
    members: { aNode: "Node", bNode: "Node | null", cNode: "Node | null", method: "types.MathNodeMethod1 | types.MathNodeMethod2 | types.MathNodeMethod3" },
    proto: "TempNode"
  },
  MaxMipLevelNode: {
    cls: f0,
    group: "utils",
    members: { textureNode: "TextureNode" },
    proto: "UniformNode"
  },
  MeshBasicNodeMaterial: {
    cls: _v,
    group: "materials",
    isMeshBasicNodeMaterial: !0,
    members: { lights: "true" },
    proto: ["MeshBasicMaterial", "NodeMaterial"]
  },
  MeshPhysicalNodeMaterial: {
    cls: Pv,
    group: "materials",
    members: { attenuationColorNode: "Node | null", attenuationDistanceNode: "Node | null", iridescenceIORNode: "null | Node", iridescenceNode: "null | CheckerNode", iridescenceThicknessNode: "null | Node", specularColorNode: "Node | null", specularIntensityNode: "Node | null", thicknessNode: "Node | null", transmissionNode: "Node | null" },
    proto: ["MeshPhysicalMaterial", "MeshStandardNodeMaterial"]
  },
  MeshStandardNodeMaterial: {
    cls: Id,
    group: "materials",
    isMeshStandardNodeMaterial: !0,
    members: { clearcoatNode: "Node | null", clearcoatRoughnessNode: "Node | null", emissiveNode: "Node | null", metalnessNode: "Node | null", roughnessNode: "Node | null" },
    proto: ["MeshStandardMaterial", "NodeMaterial"]
  },
  ModelViewProjectionNode: {
    cls: Jy,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  Node: {
    cls: Oe,
    group: "core",
    isNode: !0,
    members: {
      // id: 'number',
      // nodeType: 'NodeTypeOption | null',
      // type: 'string',
      // updateType: 'NodeUpdateTypeOption',
      // uuid: 'string'
    }
  },
  NodeAttribute: {
    cls: Ca,
    group: "core",
    isNodeAttribute: !0,
    members: { name: "string", type: "string" }
  },
  // NodeBuilder: {
  //   cls: Nodes.NodeBuilder,
  //   group: 'core',
  //   members: { buildStage: 'BuildStageOption | null', cache: 'NodeCache', computeShader: 'string', flowsData: 'any', fogNode: 'FogNode', fragmentShader: 'string', geometry: 'BufferGeometry', globalCache: 'NodeCache', hashNodes: '{ [hash: string]: Node }', lightsNode: 'LightsNode', material: 'Material', nodes: 'Node[]', object: 'Object3D', parser: 'NodeParser', renderer: 'Renderer', shaderStage: 'NodeShaderStageOption | null', stack: 'Node[]', updateNodes: 'Node[]', vertexShader: 'string' }
  // },
  NodeCache: {
    cls: oc,
    group: "core",
    members: {
      // id: 'number', nodesData: 'WeakMap<Node, NodeData>' 
    }
  },
  NodeCode: {
    cls: ju,
    group: "core",
    isNodeCode: !0,
    members: {}
  },
  // NodeFrame: {
  //   cls: Nodes.NodeFrame,
  //   group: 'core',
  //   members: { camera: 'null | Camera', deltaTime: 'number', frameId: 'number', material: 'null | Material', object: 'null | Object3D', renderer: 'null | Renderer', startTime: 'null | number', time: 'number' }
  // },
  NodeFunction: {
    // cls: Nodes.NodeFunction,
    group: "core",
    isNodeFunction: !0,
    members: { inputs: "NodeFunctionInput[]", name: "string", presicion: "string", type: "string" }
  },
  NodeFunctionInput: {
    cls: Gh,
    group: "core",
    isNodeFunctionInput: !0,
    members: { count: "null | number", isConst: "boolean", qualifier: "string" }
  },
  NodeKeywords: {
    cls: Wu,
    group: "core",
    members: {
      keywords: "string[]",
      // keywordsCallback: '{ [name: string]: (name: string) => Node }',
      nodes: "Node[]"
    }
  },
  // NodeLoader: {
  //   cls: Nodes.NodeLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'Loader<NodeLoaderResult>'
  // },
  NodeMaterial: {
    cls: en,
    group: "materials",
    isNodeMaterial: !0,
    members: {
      alphaTestNode: "Node | null",
      backdropAlphaNode: "Node | null",
      backdropNode: "Node | null",
      colorNode: "Node | null",
      envNode: "Node | null",
      lights: "true",
      lightsNode: "Node | null",
      normalNode: "Node | null",
      normals: "true",
      opacityNode: "Node | null",
      positionNode: "Node | null"
      // type: 'string'
    },
    proto: "ShaderMaterial"
  },
  // NodeMaterialLoader: {
  //   cls: Nodes.NodeMaterialLoader,
  //   group: 'loaders',
  //   members: { nodes: 'NodeLoaderResult' },
  //   proto: 'MaterialLoader'
  // },
  // NodeObjectLoader: {
  //   cls: Nodes.NodeObjectLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'ObjectLoader'
  // },
  // NodeParser: {
  //   // cls: Nodes.NodeParser,
  //   group: 'core',
  //   members: {}
  // },
  NodeUniform: {
    cls: Gu,
    group: "core",
    isNodeUniform: !0,
    members: { name: "string", needsUpdate: "boolean", node: "InputNode", type: "string", value: "NodeValueOption" }
  },
  NodeVar: {
    cls: ac,
    group: "core",
    isNodeVar: !0,
    members: { name: "string", type: "string" }
  },
  NodeVarying: {
    cls: Vu,
    group: "core",
    isNodeVarying: !0,
    members: { needsInterpolation: "false" },
    proto: "NodeVar"
  },
  NormalMapNode: {
    cls: Hy,
    group: "display",
    members: { node: "Node", normalMapType: "types.NormalMapTypes", scaleNode: "Node | null" },
    proto: "TempNode"
  },
  NormalNode: {
    cls: Wo,
    group: "accessors",
    members: { scope: "types.NormalNodeScope" },
    proto: "Node"
  },
  Object3DNode: {
    cls: gn,
    group: "accessors",
    members: { object3d: "Object3D | null", scope: "types.Object3DNodeScope" },
    proto: "Node"
  },
  OperatorNode: {
    cls: yt,
    group: "math",
    members: { aNode: "Node", bNode: "Node", op: "types.OperatorNodeOp" },
    proto: "TempNode"
  },
  OscNode: {
    cls: Zr,
    group: "utils",
    members: { method: "types.OscNodeMethod", timeNode: "Node" },
    proto: "Node"
  },
  PointLightNode: {
    cls: fv,
    group: "lighting",
    members: { coneCosNode: "Node", cutoffDistanceNode: "Node", decayExponentNode: "Node", directionNode: "Node", penumbraCosNode: "Node" },
    proto: "AnalyticLightNode"
  },
  PointUVNode: {
    cls: D0,
    group: "accessors",
    isPointUVNode: !0,
    members: {},
    proto: "Node"
  },
  PointsNodeMaterial: {
    cls: Pd,
    group: "materials",
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", isPointsNodeMateria: "true", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", sizeNode: "Node | null" },
    proto: ["PointsMaterial", "NodeMaterial"]
  },
  PositionNode: {
    cls: Us,
    group: "accessors",
    members: { scope: "types.PositionNodeScope" },
    proto: "Node"
  },
  PosterizeNode: {
    cls: $0,
    group: "display",
    members: { sourceNode: "Node", stepsNode: "Node" },
    proto: "Node"
  },
  PropertyNode: {
    cls: Pt,
    group: "core",
    members: {},
    proto: "Node"
  },
  RangeNode: {
    cls: uv,
    group: "geometry",
    members: { max: "number | Color | Vector2 | Vector3 | Vector4", min: "number | Color | Vector2 | Vector3 | Vector4" },
    proto: "Node"
  },
  ReferenceNode: {
    cls: bo,
    group: "accessors",
    members: { node: "Node | null", object: "Object", property: "string", uniformType: "string" },
    proto: "Node"
  },
  ReflectVectorNode: {
    cls: r0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  RemapNode: {
    cls: T0,
    group: "utils",
    members: { doClamp: "boolean", inHighNode: "Node", inLowNode: "Node", node: "Node", outHighNode: "Node", outLowNode: "Node" },
    proto: "Node"
  },
  RotateUVNode: {
    cls: M0,
    group: "utils",
    members: { centerNode: "Node", rotationNode: "Node", uvNode: "Node" },
    proto: "TempNode"
  },
  SkinningNode: {
    cls: t0,
    group: "accessors",
    members: { bindMatrixInverseNode: "Node", bindMatrixNode: "Node", boneMatricesNode: "Node", skinIndexNode: "Node", skinWeightNode: "Node" },
    proto: "Node"
  },
  SpecularMIPLevelNode: {
    cls: p0,
    group: "utils",
    members: { roughnessNode: "Node | null", textureNode: "TextureNode" },
    proto: "Node"
  },
  SpriteNodeMaterial: {
    cls: zv,
    group: "materials",
    isSpriteNodeMaterial: !0,
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", rotationNode: "Node | null", scaleNode: "Node | null" },
    proto: ["SpriteMaterial", "NodeMaterial"]
  },
  SpriteSheetUVNode: {
    cls: C0,
    group: "utils",
    members: { countNode: "Node", frameNode: "Node", uvNode: "Node" },
    proto: "Node"
  },
  // StackNode: {
  //   cls: Nodes.StackNode,
  //   group: 'core',
  //   isStackNode: true,
  //   members: { nodes: 'Node[]', outputNode: 'Node | null' },
  //   proto: 'Node'
  // },
  // StorageBufferNode: {
  //   // cls: Nodes.StorageBufferNode,
  //   group: 'accessors',
  //   members: {},
  //   proto: 'BufferNode'
  // },
  TangentNode: {
    cls: Yr,
    group: "accessors",
    members: { scope: "types.TangentNodeScope" },
    proto: "Node"
  },
  TempNode: {
    cls: _t,
    group: "core",
    isTempNode: !0,
    members: {},
    proto: "Node"
  },
  TextureNode: {
    cls: bi,
    group: "accessors",
    isTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "Texture" },
    proto: "UniformNode"
  },
  TimerNode: {
    cls: Lt,
    group: "utils",
    members: {
      scale: "number"
      // scope: 'TimerNodeScope'
    },
    proto: "UniformNode"
  },
  ToneMappingNode: {
    cls: J0,
    group: "display",
    members: { colorNode: "Node | null", exposureNode: "Node", toneMapping: "types.ToneMapping" },
    proto: "TempNode"
  },
  TriplanarTexturesNode: {
    cls: R0,
    group: "utils",
    members: {
      normalNode: "PositionNode",
      positionNode: "PositionNode",
      scaleNode: "Node",
      textureXNode: "TextureNode",
      textureYNode: "TextureNode | null",
      textureZNode: "TextureNode | null"
    },
    proto: "Node"
  },
  UVNode: {
    cls: _g,
    group: "accessors",
    isUVNode: !0,
    members: { index: "number" },
    proto: "AttributeNode"
  },
  UniformNode: {
    cls: Qe,
    group: "core",
    isUniformNode: !0,
    members: {},
    proto: "InputNode"
  },
  // UserDataNode: {
  //   cls: Nodes.UserDataNode,
  //   group: 'accessors',
  //   members: { userData: 'NodeUserData | null' },
  //   proto: 'ReferenceNode<NodeUserData>'
  // },
  VarNode: {
    cls: fc,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  VaryingNode: {
    cls: sc,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  ViewportNode: {
    cls: zs,
    group: "display",
    isViewportNode: !0,
    members: { scope: "types.ViewportNodeScope" },
    proto: "Node"
  }
};
let Oo = console;
const ke = {
  debug(...c) {
    Oo.debug(...c);
  },
  notice(...c) {
    Oo.info(...c);
  },
  warn(...c) {
    Oo.warn(...c);
  },
  error(...c) {
    Oo.error(...c);
  },
  panic(...c) {
    return Oo.error(...c), `${c}`;
  }
}, Yf = {};
function Kf(c) {
  const e = Object.entries(c);
  return e.forEach((t) => delete c[t[0]]), e.sort((t, r) => t[0].localeCompare(r[0])), e.forEach((t) => c[t[0]] = t[1]), c;
}
function Tc(c) {
  return /Material$/.test(c) || !!ci[c];
}
const XT = new Set("bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","));
function $T(c) {
  return XT.has(c);
}
const qT = new Set("void,Boolean,Number,String,Script,Color,Vector2,Vector3,Vector4,Matrix3,Matrix4,Euler,Audio,Image,Texture,CubeTexture,Material,Object3D,Object".split(","));
function JT(c) {
  return qT.has(c.split("[")[0]);
}
function YT(c) {
  return $T(c) || JT(c);
}
function KT(c, e) {
  for (const t of c)
    if (!e.includes(t))
      return !1;
  return !0;
}
function ZT(c, e) {
  return c[`is${e}`];
}
function su(c, e) {
  if (c === e)
    return !0;
  const t = Dd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (su(r, e))
        return !0;
    return !1;
  }
  return su(t.proto, e);
}
function QT(c, e) {
  if (e.includes(c))
    return !0;
  for (const t of e)
    if (su(c, t))
      return !0;
  return !1;
}
function li(c, e) {
  if (c === e)
    return !0;
  const t = Dd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (li(r, e))
        return !0;
    return !1;
  }
  return li(t.proto, e);
}
function eS(c) {
  let e = null, t = null;
  const r = [];
  for (const n of c) {
    if (/^".+"$/.test(n)) {
      const i = /^"(.+)"$/.exec(n)[1];
      t ? t.push(i) : (t = [i], r.push(t));
      continue;
    }
    const [, s, o] = /^([^[\]]+)(\[\])?$/.exec(n) || [];
    if (s.startsWith("types.")) {
      const i = $v[s.substring(6)];
      if (!i)
        throw ke.panic(`type[${s}] not found`);
      Array.isArray(i) ? t ? t.push(...i) : (t = [...i], r.push(t)) : e ? Object.assign(e, i) : (e = { ...i }, r.push(e));
    } else
      n === "null" ? r.push(null) : s === "boolean" || /true|false/i.test(n) ? r.push("Boolean" + (o || "")) : s === "string" ? r.push("String" + (o || "")) : s === "number" ? r.push("Number" + (o || "")) : (!YT(s) && !Tc(s) && ke.warn(`type[${n}] unsupported!`), r.push(n));
  }
  return r;
}
function Zf(c, e, t) {
  for (const [r, n] of Object.entries(e)) {
    const s = eS(n.replace(/\s/mg, "").split("|")), [, o, i] = /^(.+)(Node)$/.exec(r) || [, r], a = !!i || s.findIndex((u) => typeof u == "string" && Tc(u)) !== -1, l = c[o] || (c[o] = { types: s, direct: t });
    a && (l.nname = r), tS(l.types, s);
  }
  return c;
}
function tS(c, e) {
  const t = c.filter((r) => r !== null && !Tc(r) && !e.includes(r));
  for (const r of e)
    c.includes(r) || c.push(JSON.parse(JSON.stringify(r)));
  t.forEach((r) => c.splice(c.indexOf(r), 1));
}
function nS(c, e) {
  for (const t of e)
    c.includes(t) || c.push(JSON.parse(JSON.stringify(t)));
}
function Qf(c, e) {
  for (const [t, r] of Object.entries(e)) {
    const n = c[t];
    if (!n) {
      c[t] = JSON.parse(JSON.stringify(r));
      continue;
    }
    if (n.nname && r.nname && n.nname !== r.nname)
      throw ke.panic("type mismatched!");
    n.nname || (n.nname = r.nname), nS(n.types, r.types);
  }
  return c;
}
function za(c) {
  const e = (t) => {
    const r = Yf[t];
    if (r)
      return r;
    const n = { in: {}, out: {} }, s = ci[t] || Ua[t];
    if (!s)
      return n;
    let o = s.proto;
    if (o) {
      o = Array.isArray(o) ? o : [o];
      for (const i of o) {
        const a = e(i);
        Qf(n.in, a.in), Qf(n.out, a.out);
      }
    }
    return Zf(n.in, s.members, "in"), s.out && Zf(n.out, s.out, "out"), Kf(n.in), Kf(n.out), Yf[t] = n, n;
  };
  return e(c);
}
function ep(c) {
  const e = oS(c);
  if (!e)
    throw ke.panic(`Node constructor[${c}] not found!`);
  return e.clsName;
}
function sS(c) {
  const e = Dd(c);
  if (e)
    return e.proto;
}
function Dd(c) {
  return ci[c] || Ua[c];
}
function rr(c, e, t, r, n) {
  if (ci[c])
    throw ke.panic(`class[${c}] exists`);
  if (oe(c, e), ci[c] = { cls: e, members: t || {}, proto: r }, n)
    for (const [o, i] of Object.entries(n))
      Ud(o, i);
}
const rS = [], Ba = {};
function Ud(c, e) {
  if (Ba[c])
    throw ke.panic(`Node Constructor[${c}] aready exists`);
  const r = (e.group || `Others.${c}`).split(".");
  let n = rS;
  const s = r.pop();
  for (const l of r) {
    let u = n.find((h) => h.name === l);
    u || (u = {
      name: l,
      icon: "",
      children: []
    }, n.push(u)), n = u.children;
  }
  if (n.find((l) => l.name === c))
    throw ke.panic(`Node Constructor[${c}] aready exists`);
  const i = za(e.clsName), a = {
    name: c,
    ...e,
    title: s || c,
    in: { ...i.in },
    out: { ...i.out }
  };
  Ba[c] = a, n.push(a);
}
function oS(c) {
  return Ba[c];
}
function ru(c, e) {
  const t = Ba[c];
  if (!t)
    throw ke.panic(`Node Constructor[${c}] not found`);
  const r = t.func();
  if (e)
    if (r.copy)
      r.copy(e);
    else
      for (const n of [...Object.keys(t.in), ...Object.keys(t.out)]) {
        const s = e[n], o = typeof s, i = r[n];
        o === "undefined" || s === null || o === "boolean" || o === "string" || o === "number" ? r[n] = s : s.clone ? r[n] = s.clone() : i && i.copy ? i.copy(s) : r[n] = s;
      }
  return r;
}
const { createNodeMaterialFromType: iS } = CN, aS = gi.createMaterialFromType, ka = {};
gi.createMaterialFromType = function(c) {
  const e = iS(c);
  return e || (ka[c] ? new ka[c]() : aS.call(this, c));
};
function cS(c, e) {
  if (ka[c])
    throw ke.panic(`Material[${c}] aready exists`);
  ka[c] = e;
}
const tp = {};
function Ye(c, e) {
  if (tp[c])
    throw ke.panic(`Class[${c}] aready exists`);
  if (tp[c] = e, Ua[c] || (Ua[c] = e), li(c, "Object3D")) {
    if (Ga[c])
      return;
    Ga[c] = (t) => e.create(t || {});
  }
}
const Ga = {
  AmbientLight: (c) => new M.AmbientLight(c.color, c.intensity),
  Bone: (c) => new M.Bone(),
  DirectionalLight: (c) => new M.DirectionalLight(c.color, c.intensity),
  HemisphereLight: (c) => new M.HemisphereLight(c.color, c.groundColor, c.intensity),
  Group: (c) => new M.Group(),
  InstancedMesh: (c) => {
    const e = new M.InstancedMesh(c.geometry, c.material, c.count), t = c.instanceMatrix, r = c.instanceColor;
    return e.instanceMatrix = new M.InstancedBufferAttribute(new Float32Array(t.array), 16), r !== void 0 && (e.instanceColor = new M.InstancedBufferAttribute(new Float32Array(r.array), r.itemSize)), e;
  },
  LOD: (c) => new M.LOD(),
  Line: (c) => new M.Line(c.geometry, c.material),
  LineLoop: (c) => new M.LineLoop(c.geometry, c.material),
  LineSegments: (c) => new M.LineSegments(c.geometry, c.material),
  LightProbe: (c) => new M.LightProbe().fromJSON(c),
  Mesh: (c) => new M.Mesh(c.geometry, c.material),
  Object3D: (c) => new M.Object3D(),
  OrthographicCamera: (c) => new M.OrthographicCamera(c.left, c.right, c.top, c.bottom, c.near, c.far),
  PerspectiveCamera: (c) => new M.PerspectiveCamera(c.fov, c.aspect, c.near, c.far),
  PointCloud: (c) => new M.Points(c.geometry, c.material),
  PointLight: (c) => new M.PointLight(c.color, c.intensity, c.distance, c.decay),
  Points: (c) => new M.Points(c.geometry, c.material),
  RectAreaLight: (c) => new M.RectAreaLight(c.color, c.intensity, c.width, c.height),
  Scene: (c) => new M.Scene(),
  SpotLight: (c) => new M.SpotLight(c.color, c.intensity, c.distance, c.angle, c.penumbra, c.decay),
  SkinnedMesh: (c) => new M.SkinnedMesh(c.geometry, c.material),
  Sprite: (c) => new M.Sprite(c.material)
}, lS = new Set(Object.keys(Ga));
function uS(c, e) {
  const t = Ga[c];
  if (t)
    return t(e);
  throw ke.panic(`object class[${c}] not found`);
}
function qv(c) {
  if (lS.has(c))
    return c;
  const e = sS(c);
  if (e)
    return qv(e);
}
function Ts(c) {
  Object.keys(c).forEach((e) => delete c[e]);
}
const Bt = Symbol("getProxyRawObject");
function zd(c, e) {
  return new Proxy(c, {
    get(t, r, n) {
      if (r === Bt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      if (Reflect.get(t, r, s) === n)
        return !0;
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else
        i = Reflect.set(t, r, n, t);
      return i && e && e(r, n), i;
    }
  });
}
function Qs(c, e) {
  e || (e = {});
  for (const [t, r] of Object.entries(c))
    r && typeof r == "object" && r.toArray ? e[t] = r.toArray() : e[t] = c[t];
  return e;
}
function er(c, e) {
  const t = [];
  for (const [r, n] of Object.entries(c)) {
    const s = e[r];
    s == null || s === n || (t.push(r), typeof n == "object" && n.fromArray ? n.fromArray(s) : c[r] = s);
  }
  return t;
}
Ye("Object3D", {
  // cls: Object3D,
  create: () => new En(),
  members: {},
  group: "Objects.Empty Object3D",
  icon: "box"
});
const ji = new M.Matrix4();
let il, np, sp;
function Jv(c, e, t) {
  var l, u;
  if (!t || !t.geometry)
    return 0;
  il || (il = new Ammo.btVector3(), np = new Ammo.btVector3(), sp = new Ammo.btVector3());
  const r = t.geometry, n = ((l = r.attributes.position) == null ? void 0 : l.array) || [], s = ((u = r.index) == null ? void 0 : u.array) || [];
  let o = 0, i;
  if (e && e !== t) {
    let h;
    e.quaternion ? h = e.quaternion : e.rotation ? h = new M.Quaternion().setFromEuler(e.rotation) : h = new M.Quaternion().identity();
    const d = new M.Matrix4().compose(new M.Vector3(1, 1, 1), h, e.position);
    ji.copy(d.invert()), t.updateWorldMatrix(!1, !1), i = t.matrixWorld.clone().multiply(ji);
  } else
    ji.makeScale(t.scale.x, t.scale.y, t.scale.z), i = ji;
  const a = s.length / 3;
  for (let h = 0; h < a; h++) {
    const d = [];
    for (let f = 0; f < 3; f++) {
      let p = new M.Vector3(n[s[h * 3 + f] * 3 + 0], n[s[h * 3 + f] * 3 + 1], n[s[h * 3 + f] * 3 + 2]);
      p = p.applyMatrix4(i);
      let m;
      f == 0 ? m = il : f == 1 ? m = np : m = sp, m.setValue(p.x, p.y, p.z), d.push(m);
    }
    c.addTriangle(d[0], d[1], d[2]), o++;
  }
  return t.children.forEach((h) => {
    o += Jv(c, e, h);
  }), o;
}
var Xs;
((c) => {
  function e(o) {
    return new ammo.btVector3(o.x, o.y, o.z);
  }
  c.t2aVector3 = e;
  function t(o) {
    return new M.Vector3(o.x(), o.y(), o.z());
  }
  c.a2tVector3 = t;
  function r(o) {
    var a, l;
    const i = o.geometry;
    if (i)
      if (i.type === "PlaneGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = new ammo.btBoxShape(new ammo.btVector3(d, f, 0));
        return p.setMargin(0.01), p;
      } else if (i.type === "BoxGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = h.depth !== void 0 ? h.depth / 2 : 0.5, m = new ammo.btBoxShape(new ammo.btVector3(d, f, p));
        return m.setMargin(1e-3), m;
      } else if (i.type === "CylinderGeometry") {
        const h = i.parameters, d = new ammo.btCylinderShape(new ammo.btVector3(h.radiusBottom, h.height, h.radiusTop));
        return d.setMargin(0.01), d;
      } else if (i.type === "ConeGeometry") {
        const h = i.parameters, d = new ammo.btConeShape(h.radius, h.height);
        return d.setMargin(0.01), d;
      } else if (i.type === "CapsuleGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = h.length !== void 0 ? h.length : 1, p = new ammo.btCapsuleShape(d, f);
        return p.setMargin(0.01), p;
      } else if (i.type === "SphereGeometry" || i.type === "IcosahedronGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = new ammo.btSphereShape(d);
        return f.setMargin(1e-3), f;
      } else {
        const u = new ammo.btTriangleMesh(!0, !0), h = ((a = i.attributes.position) == null ? void 0 : a.array) || [], d = ((l = i.index) == null ? void 0 : l.array) || [];
        for (let p = 0; p * 3 < d.length; p += 1)
          u.addTriangle(
            new ammo.btVector3(
              h[d[p * 3] * 3],
              h[d[p * 3] * 3 + 1],
              h[d[p * 3] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 1] * 3],
              h[d[p * 3 + 1] * 3 + 1],
              h[d[p * 3 + 1] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 2] * 3],
              h[d[p * 3 + 2] * 3 + 1],
              h[d[p * 3 + 2] * 3 + 2]
            ),
            !1
          );
        const f = new ammo.btConvexTriangleMeshShape(u, !0);
        return f.setMargin(1e-3), f;
      }
    else {
      const u = new ammo.btTriangleMesh(!0, !0), d = Jv(u, o, o) ? new Ammo.btBvhTriangleMeshShape(u, !0) : new Ammo.btCompoundShape();
      return d.setMargin(0.01), d;
    }
  }
  c.createShape = r;
  function n(o, i = 0, a) {
    const l = a || r(o);
    function u(d, f, p) {
      const m = d.position, g = d.quaternion, b = new ammo.btTransform();
      b.setIdentity(), b.setOrigin(new ammo.btVector3(m.x, m.y, m.z)), b.setRotation(new ammo.btQuaternion(g.x, g.y, g.z, g.w));
      const x = new ammo.btDefaultMotionState(b), y = new ammo.btVector3(0, 0, 0);
      p.calculateLocalInertia(f, y);
      const v = new ammo.btRigidBodyConstructionInfo(f, x, p, y);
      return new ammo.btRigidBody(v);
    }
    function h(d, f, p) {
      const m = d.instanceMatrix.array, g = [];
      for (let b = 0; b < d.count; b++) {
        const x = b * 16, y = new ammo.btTransform();
        y.setFromOpenGLMatrix(dS(m, x, x + 16));
        const v = new ammo.btDefaultMotionState(y), N = new ammo.btVector3(0, 0, 0);
        p.calculateLocalInertia(f, N);
        const w = new ammo.btRigidBodyConstructionInfo(f, v, p, N), T = new ammo.btRigidBody(w);
        g.push(T);
      }
      return g;
    }
    return o.isInstancedMesh ? h(o, i, l) : (o.isMesh, u(o, i, l));
  }
  c.createBody = n;
  function s(o) {
    ammo.destroy(o);
  }
  c.destroyBody = s;
})(Xs || (Xs = {}));
class hS {
  constructor(e = -9.82) {
    B(this, "world");
    B(this, "collisionConfiguration");
    B(this, "dispatcher");
    B(this, "broadphase");
    B(this, "solver");
    B(this, "softBodySolver");
    B(this, "softBodyHelpers");
    B(this, "worldTransform");
    B(this, "destroyed", !1);
    B(this, "meshes", []);
    B(this, "meshMap", /* @__PURE__ */ new WeakMap());
    B(this, "meshIdx", {});
    B(this, "conllisionMap", /* @__PURE__ */ new Set());
    this.collisionConfiguration = new ammo.btDefaultCollisionConfiguration(), this.dispatcher = new ammo.btCollisionDispatcher(this.collisionConfiguration), this.broadphase = new ammo.btDbvtBroadphase(), this.solver = new ammo.btSequentialImpulseConstraintSolver(), this.softBodySolver = new ammo.btDefaultSoftBodySolver(), this.softBodyHelpers = new Ammo.btSoftBodyHelpers(), this.world = new ammo.btSoftRigidDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collisionConfiguration, this.softBodySolver), this.world.setGravity(new ammo.btVector3(0, e, 0)), this.worldTransform = new ammo.btTransform();
  }
  dispose() {
    if (!this.destroyed) {
      for (const e of this.meshes) {
        const t = this.meshMap.get(e);
        this.meshMap.delete(e), ammo.destroy(t);
      }
      this.meshes.length = 0, ammo.destroy(this.collisionConfiguration), ammo.destroy(this.dispatcher), ammo.destroy(this.broadphase), ammo.destroy(this.solver), ammo.destroy(this.softBodySolver), ammo.destroy(this.softBodyHelpers), ammo.destroy(this.world), ammo.destroy(this.worldTransform), this.destroyed = !0;
    }
  }
  addMesh(e, t) {
    if (t) {
      if (Array.isArray(t))
        for (const r of t)
          this.world.addRigidBody(r);
      else
        this.world.addRigidBody(t);
      this.meshes.push(e), this.meshMap.set(e, t), e.id && (this.meshIdx[e.id] = e);
    }
    e.world = this;
  }
  removeMesh(e) {
    const t = this.meshMap.get(e), r = this.meshes.indexOf(e);
    if (!t) {
      e.world = void 0;
      return;
    }
    if (r !== -1 && this.meshes.splice(r, 1), this.meshMap.delete(e), delete this.meshIdx[e.id], Array.isArray(t))
      for (const n of t)
        this.world.removeRigidBody(n);
    else
      this.world.removeRigidBody(t);
    e.world = void 0;
  }
  findBody(e) {
    return this.meshMap.get(e);
  }
  setMeshPosition(e, t, r = 0) {
    if (e.isInstancedMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      const s = n[r];
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), s.setWorldTransform(this.worldTransform);
    } else if (e.isMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), n.setWorldTransform(this.worldTransform);
    }
  }
  detectCollision() {
    const e = this.dispatcher.getNumManifolds(), t = /* @__PURE__ */ new Set();
    for (let n = 0; n < e; n++) {
      const s = this.dispatcher.getManifoldByIndexInternal(n), o = s.getBody0().getUserIndex(), i = s.getBody1().getUserIndex();
      t.add(`${o}:${i}`);
    }
    for (const n of t) {
      if (this.conllisionMap.has(n))
        continue;
      this.conllisionMap.add(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionEnter", target: a }), a.dispatchEvent({ type: "onCollisionEnter", target: i }));
    }
    const r = [];
    for (const n of this.conllisionMap)
      t.has(n) || r.push(n);
    for (const n of r) {
      this.conllisionMap.delete(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionLeave", target: a }), a.dispatchEvent({ type: "onCollisionLeave", target: i }));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  step(e, t) {
    if (e) {
      this.world.stepSimulation(e, 10), this.detectCollision();
      for (let r = 0, n = this.meshes.length; r < n; r++) {
        const s = this.meshes[r];
        if (s.mass) {
          if (s.isInstancedMesh) {
            const o = s.instanceMatrix.array, i = this.meshMap.get(s);
            for (let a = 0; a < i.length; a++) {
              i[a].getMotionState().getWorldTransform(this.worldTransform);
              const h = this.worldTransform.getOrigin(), d = this.worldTransform.getRotation();
              fS(h, d, o, a * 16);
            }
            s.instanceMatrix.needsUpdate = !0, s.computeBoundingSphere();
          } else if (s.isMesh) {
            this.meshMap.get(s).getMotionState().getWorldTransform(this.worldTransform);
            const a = this.worldTransform.getOrigin(), l = this.worldTransform.getRotation();
            s.position.set(a.x(), a.y(), a.z()), s.quaternion.set(l.x(), l.y(), l.z(), l.w());
          }
        }
      }
    }
  }
}
function dS(c, e, t) {
  const r = [], n = e + t;
  for (let s = e; s < n; s++)
    r.push(c[s]);
  return r;
}
function fS(c, e, t, r) {
  const n = e.x(), s = e.y(), o = e.z(), i = e.w(), a = n + n, l = s + s, u = o + o, h = n * a, d = n * l, f = n * u, p = s * l, m = s * u, g = o * u, b = i * a, x = i * l, y = i * u;
  t[r + 0] = 1 - (p + g), t[r + 1] = d + y, t[r + 2] = f - x, t[r + 3] = 0, t[r + 4] = d - y, t[r + 5] = 1 - (h + g), t[r + 6] = m + b, t[r + 7] = 0, t[r + 8] = f + x, t[r + 9] = m - b, t[r + 10] = 1 - (h + p), t[r + 11] = 0, t[r + 12] = c.x(), t[r + 13] = c.y(), t[r + 14] = c.z(), t[r + 15] = 1;
}
var Sc = /* @__PURE__ */ ((c) => (c[c.Ghost = 0] = "Ghost", c[c.RigidBody = 1] = "RigidBody", c))(Sc || {});
$v.BodyType = {
  Ghost: 0,
  RigidBody: 1
  // SoftBody: 2,
};
const ar = 1e-3;
class Nn extends Qt {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Xa(), r || new An({ wireframe: !0 }));
    B(this, "isEntity", !0);
    B(this, "geo");
    B(this, "geoMatrix", new je().identity());
    B(this, "physicalBody", null);
    B(this, "world");
    B(this, "_tmpAmmoVectorA", new Ammo.btVector3(0, 0, 0));
    B(this, "_tmpAmmoQuaternion", new Ammo.btQuaternion(0, 0, 0, 1));
    this._bodyType = n, this._mass = s, this.type = "Entity", t || this.rebuildBody(), this.geo = zd(Object.assign({}, this.parameters), () => {
      this.rebuildGeometry();
    });
  }
  get mass() {
    return this._mass;
  }
  set mass(t) {
    this._mass !== t && (this._mass === 0 || t === 0 ? (this._mass = t, this.rebuildBody()) : this.physicalBody.setMassProps(t));
  }
  get bodyType() {
    return this._bodyType;
  }
  set bodyType(t) {
    this._bodyType !== t && (this._bodyType = t, this.rebuildBody());
  }
  get parameters() {
    return this.geometry.parameters || {};
  }
  moveTo(t) {
    this.physicalBody && this.setPhysicsBodyTransformation(t), this.position.copy(t);
  }
  applyTranslation(t) {
    return this.applyGeoMatrix4(new je().makeTranslation(t));
  }
  applyRotationFromEuler(t) {
    return this.applyGeoMatrix4(new je().makeRotationFromEuler(t));
  }
  applyScale(t) {
    return this.applyGeoMatrix4(new je().makeScale(t.x, t.y, t.z));
  }
  applyGeoMatrix4(t) {
    this.geoMatrix.premultiply(t), this.geometry.applyMatrix4(t);
  }
  clone(t) {
    const r = super.clone(t), n = this._mass || 0, s = this._bodyType || 0;
    (n !== this._mass || s !== this._bodyType) && (r._mass = n, r._bodyType = s, r.rebuildBody());
    const o = r.geo[Bt];
    return Object.assign(o, this.parameters), r.geoMatrix.copy(this.geoMatrix), r;
  }
  serialize(t) {
    t.mass = this._mass, t.bodyType = this._bodyType, t.geoMatrix = this.geoMatrix.toArray();
  }
  deserialize(t) {
    const r = t.mass || 0, n = t.bodyType || 0;
    (r !== this._mass || n !== this._bodyType) && (this._mass = r, this._bodyType = n, this.rebuildBody());
    const s = this.geo[Bt];
    Object.assign(s, this.parameters), t.geoMatrix && (this.geoMatrix.fromArray(t.geoMatrix), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox()), this.setPhysicsBodyTransformation(this.position);
  }
  dispose() {
    if (this.material instanceof Bn)
      this.material.dispose();
    else if (Array.isArray(this.material))
      for (const t of this.material)
        t.material.dispose();
    this.physicalBody && (this.world && this.world.removeMesh(this), Xs.destroyBody(this.physicalBody), this.physicalBody = null);
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose(), this.geometry = t.fromJSON(this.geo[Bt]), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
  rebuildBody() {
    const t = this.world;
    this.physicalBody && (this.world && this.world.removeMesh(this), Xs.destroyBody(this.physicalBody)), this._bodyType !== 0 ? (this.physicalBody = Xs.createBody(this, this._mass), this.physicalBody.setUserIndex(this.id), t && t.addMesh(this, this.physicalBody)) : this.physicalBody = null;
  }
  /**
   * Sets the babylon object's position/rotation from the physics body's position/rotation
   * @param impostor imposter containing the physics body and babylon object
   * @param newPosition new position
   * @param newRotation new rotation
   */
  setPhysicsBodyTransformation(t, r) {
    if (!this.physicalBody)
      return;
    const n = this.physicalBody.getWorldTransform();
    if (Math.abs(n.getOrigin().x() - t.x) > ar || Math.abs(n.getOrigin().y() - t.y) > ar || Math.abs(n.getOrigin().z() - t.z) > ar || r && (Math.abs(n.getRotation().x() - r.x) > ar || Math.abs(n.getRotation().y() - r.y) > ar || Math.abs(n.getRotation().z() - r.z) > ar || Math.abs(n.getRotation().w() - r.w) > ar))
      if (this._tmpAmmoVectorA.setValue(t.x, t.y, t.z), n.setOrigin(this._tmpAmmoVectorA), r && (this._tmpAmmoQuaternion.setValue(r.x, r.y, r.z, r.w), n.setRotation(this._tmpAmmoQuaternion)), this.physicalBody.setWorldTransform(n), this.mass == 0) {
        const s = this.physicalBody.getMotionState();
        s && s.setWorldTransform(n);
      } else
        this.physicalBody.activate();
  }
}
Ye("Entity", {
  create: ({ material: c, geometry: e } = {}) => new Nn(e, c),
  members: {
    mass: "Number",
    bodyType: "types.BodyType"
  },
  proto: "Mesh",
  group: "",
  icon: ""
});
const pS = 1024, mS = 1024, al = new ge(), gS = new ge(), nn = {
  /** world time delta */
  delta: 0,
  /** world current time */
  now: 0,
  /** to y axis */
  gravity: new ge(0, -9.8, 0),
  windForce: new ge(),
  scene: null,
  gpuComputeRender: null,
  /** wait for x miliseconds */
  wait(c) {
    return new Promise((e) => {
      setTimeout(e, c, !0);
    });
  },
  calcObjectPosition(c, e, t, r) {
    if (t <= 0)
      return [c, e];
    const n = r ? al.copy(e).normalize().multiply(e).multiply(e).multiplyScalar(-r) : al.set(0, 0, 0);
    n.add(this.windForce);
    const s = n.divideScalar(t);
    s.add(this.gravity);
    const o = s.multiplyScalar(this.delta).add(e);
    return [gS.copy(o).add(e).multiplyScalar(0.5 * this.delta).add(c), al];
  },
  combineBuffer(c, e, t) {
    let r = 0, n = 3;
    c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        n = f.itemSize, r += f.array.length;
      }
    });
    const s = r / n, o = t && s > t ? Math.ceil(s / t) : 1, i = Math.ceil(r / (n * o)), a = new Float32Array(i * n);
    let l = 0, u = 0, h = 0;
    return c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        if (o === 1)
          a.set(f.array, h * n), l += f.array.length, h += f.array.length / n, u = l / n;
        else {
          const p = f.count;
          for (let m = 0; m < p; m++)
            u % o === 0 && (a[h * n] = f.array[m * n], a[h * n + 1] = f.array[m * n + 1], a[h * n + 2] = f.array[m * n + 2], h++), u++;
          l += f.array.length;
        }
      }
    }), new no(a, n);
  }
};
class Yv extends $a {
  constructor() {
    super();
    B(this, "isPhysicalScene", !0);
    B(this, "physics");
    B(this, "windForce", new ge());
    /** to y axis */
    B(this, "_gravity", -9.8);
    B(this, "objectsTrash", {});
    this.type = "PhysicalScene", this.physics = new hS(this._gravity);
  }
  get gravity() {
    return this._gravity;
  }
  set gravity(t) {
    this._gravity !== t && (this._gravity = t, this.physics.world.setGravity(new Ammo.btVector3(0, this._gravity, 0)));
  }
  update(t, r, n, s, o = !1) {
    nn.scene = this, nn.gravity.y = this._gravity;
    const i = this.windForce.clone().multiplyScalar(0.5 + 0.5 * Math.sin(s / 2e3));
    if (nn.windForce.copy(i), !o) {
      for (const a of this.children)
        a.visible && a.graph && a.graph.update(t, r, n, s);
      this.physics.step(n, s);
    }
  }
  add(...t) {
    super.add(...t);
    for (const r of t)
      delete this.objectsTrash[r.id], r instanceof Nn && this.physics.addMesh(r, r.physicalBody), r.dispatchEvent({ type: "onBorn", source: this, object: r });
    return this;
  }
  remove(...t) {
    super.remove(...t);
    for (const r of t)
      r instanceof Nn && this.physics.removeMesh(r), r.dispatchEvent({ type: "onDead", source: this, object: r }), this.objectsTrash[r.id] = r;
    return this;
  }
  serialize(t) {
    t.gravity = this.gravity, t.windForce = this.windForce.toArray();
  }
  deserialize(t) {
    t.gravity && (this.gravity = t.gravity), t.windForce && this.windForce.fromArray(t.windForce);
  }
  active() {
    this.dispatchEvent({ type: "onBorn", source: this, object: this });
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onBorn", source: this, object: t });
  }
  deactive() {
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onDead", source: this, object: t });
    this.dispatchEvent({ type: "onDead", source: this, object: this });
  }
  dispose() {
    for (const t of Object.values(this.objectsTrash))
      t.traverse((r) => {
        if (r.dispose)
          r.dispose();
        else if (r.geometry instanceof Ss && r.geometry.dispose(), r.material instanceof Bn)
          r.material.dispose();
        else if (Array.isArray(r.material))
          for (const n of r.material)
            n.dispose();
      });
    this.physics.dispose();
  }
}
Ye("PhysicalScene", {
  // cls: PhysicalScene,
  members: {
    gravity: "Number",
    windForce: "Vector3"
  },
  proto: "Scene",
  group: "Scenes.Physical Scene",
  icon: "scene",
  create: () => new Yv()
});
const rp = new tr(), Wi = new ge();
class Kv extends ym {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new yn(e, 3)), this.setAttribute("uv", new yn(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Ta(t, 6, 1);
    return this.setAttribute("instanceStart", new Vs(r, 3, 0)), this.setAttribute("instanceEnd", new Vs(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Ta(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Vs(r, 3, 0)), this.setAttribute("instanceColorEnd", new Vs(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new vx(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new tr());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), rp.setFromBufferAttribute(t), this.boundingBox.union(rp));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Wi.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Wi)), Wi.fromBufferAttribute(t, s), n = Math.max(n, r.distanceToSquared(Wi));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
so.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Nt(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
is.line = {
  uniforms: nr.merge([
    so.common,
    so.fog,
    so.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Bd extends ls {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: nr.clone(is.line.uniforms),
      vertexShader: is.line.vertexShader,
      fragmentShader: is.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const op = new ge(), ip = new ge(), Vt = new pt(), jt = new pt(), rs = new pt(), cl = new ge(), ll = new je(), Ht = new xx(), ap = new ge(), Hi = new tr(), Xi = new yi(), os = new pt();
let cs, gr;
function cp(c, e, t) {
  return os.set(0, 0, -e, 1).applyMatrix4(c.projectionMatrix), os.multiplyScalar(1 / os.w), os.x = gr / t.width, os.y = gr / t.height, os.applyMatrix4(c.projectionMatrixInverse), os.multiplyScalar(1 / os.w), Math.abs(Math.max(os.x, os.y));
}
function yS(c, e) {
  const t = c.matrixWorld, r = c.geometry, n = r.attributes.instanceStart, s = r.attributes.instanceEnd, o = Math.min(r.instanceCount, n.count);
  for (let i = 0, a = o; i < a; i++) {
    Ht.start.fromBufferAttribute(n, i), Ht.end.fromBufferAttribute(s, i), Ht.applyMatrix4(t);
    const l = new ge(), u = new ge();
    cs.distanceSqToSegment(Ht.start, Ht.end, u, l), u.distanceTo(l) < gr * 0.5 && e.push({
      point: u,
      pointOnLine: l,
      distance: cs.origin.distanceTo(u),
      object: c,
      face: null,
      faceIndex: i,
      uv: null,
      uv1: null
    });
  }
}
function vS(c, e, t) {
  const r = e.projectionMatrix, s = c.material.resolution, o = c.matrixWorld, i = c.geometry, a = i.attributes.instanceStart, l = i.attributes.instanceEnd, u = Math.min(i.instanceCount, a.count), h = -e.near;
  cs.at(1, rs), rs.w = 1, rs.applyMatrix4(e.matrixWorldInverse), rs.applyMatrix4(r), rs.multiplyScalar(1 / rs.w), rs.x *= s.x / 2, rs.y *= s.y / 2, rs.z = 0, cl.copy(rs), ll.multiplyMatrices(e.matrixWorldInverse, o);
  for (let d = 0, f = u; d < f; d++) {
    if (Vt.fromBufferAttribute(a, d), jt.fromBufferAttribute(l, d), Vt.w = 1, jt.w = 1, Vt.applyMatrix4(ll), jt.applyMatrix4(ll), Vt.z > h && jt.z > h)
      continue;
    if (Vt.z > h) {
      const y = Vt.z - jt.z, v = (Vt.z - h) / y;
      Vt.lerp(jt, v);
    } else if (jt.z > h) {
      const y = jt.z - Vt.z, v = (jt.z - h) / y;
      jt.lerp(Vt, v);
    }
    Vt.applyMatrix4(r), jt.applyMatrix4(r), Vt.multiplyScalar(1 / Vt.w), jt.multiplyScalar(1 / jt.w), Vt.x *= s.x / 2, Vt.y *= s.y / 2, jt.x *= s.x / 2, jt.y *= s.y / 2, Ht.start.copy(Vt), Ht.start.z = 0, Ht.end.copy(jt), Ht.end.z = 0;
    const m = Ht.closestPointToPointParameter(cl, !0);
    Ht.at(m, ap);
    const g = Yt.lerp(Vt.z, jt.z, m), b = g >= -1 && g <= 1, x = cl.distanceTo(ap) < gr * 0.5;
    if (b && x) {
      Ht.start.fromBufferAttribute(a, d), Ht.end.fromBufferAttribute(l, d), Ht.start.applyMatrix4(o), Ht.end.applyMatrix4(o);
      const y = new ge(), v = new ge();
      cs.distanceSqToSegment(Ht.start, Ht.end, v, y), t.push({
        point: v,
        pointOnLine: y,
        distance: cs.origin.distanceTo(v),
        object: c,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class xS extends Qt {
  constructor(e = new Kv(), t = new Bd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, i = 0, a = t.count; o < a; o++, i += 2)
      op.fromBufferAttribute(t, o), ip.fromBufferAttribute(r, o), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + op.distanceTo(ip);
    const s = new Ta(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Vs(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Vs(s, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, n = e.camera;
    n === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    cs = e.ray;
    const o = this.matrixWorld, i = this.geometry, a = this.material;
    gr = a.linewidth + s, i.boundingSphere === null && i.computeBoundingSphere(), Xi.copy(i.boundingSphere).applyMatrix4(o);
    let l;
    if (r)
      l = gr * 0.5;
    else {
      const h = Math.max(n.near, Xi.distanceToPoint(cs.origin));
      l = cp(n, h, a.resolution);
    }
    if (Xi.radius += l, cs.intersectsSphere(Xi) === !1)
      return;
    i.boundingBox === null && i.computeBoundingBox(), Hi.copy(i.boundingBox).applyMatrix4(o);
    let u;
    if (r)
      u = gr * 0.5;
    else {
      const h = Math.max(n.near, Hi.distanceToPoint(cs.origin));
      u = cp(n, h, a.resolution);
    }
    Hi.expandByScalar(u), cs.intersectsBox(Hi) !== !1 && (r ? yS(this, t) : vS(this, n, t));
  }
}
class Zv extends Kv {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class bS extends xS {
  constructor(e = new Zv(), t = new Bd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class ul extends Zv {
  constructor() {
    super(...arguments);
    B(this, "isBezieoLineGeometry", !0);
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    return t.uuid = this.uuid, t.type = "BufferGeometry", t.data = {}, t;
  }
}
class Va extends Bd {
  constructor() {
    super();
    B(this, "isBezierLineMaterial", !0);
    this.type = "BezierLineMaterial";
  }
}
class NS extends bS {
  constructor() {
    super(new ul(), new Va());
    B(this, "isBezierLine", !0);
    B(this, "fromPosition", new ge());
    B(this, "toPosition", new ge(1, 1, 0));
    B(this, "ctrl1", new ge(0.2, 0.1, 0));
    B(this, "ctrl2", new ge(0.8, 0.9, 0));
    B(this, "density", 10);
    B(this, "_tmpSize", new Nt());
    this.type = "BezierLine", this.material.worldUnits = !0, this.material.linewidth = 0.1, this.onBeforeRender = (t, r, n, s, o, i) => {
      const { x: a, y: l } = t.getSize(this._tmpSize);
      (this.material.resolution.x !== a || this.material.resolution.y !== l) && (this.material.resolution.set(a, l), this.material.uniformsNeedUpdate = !0);
    }, this.updatePositions();
  }
  updatePositions() {
    const t = new bx(this.fromPosition, this.ctrl1, this.ctrl2, this.toPosition), r = Math.abs(this.fromPosition.clone().distanceTo(this.toPosition)), n = t.getPoints(this.density * r);
    this.geometry.setPositions(n.map((s) => [s.x, s.y, s.z]).flat()), this.computeLineDistances();
  }
  serialize(t) {
    t.type = "BezierLine", t.fromPosition = this.fromPosition.toArray(), t.toPosition = this.toPosition.toArray(), t.ctrl1 = this.ctrl1.toArray(), t.ctrl2 = this.ctrl2.toArray(), t.density = this.density;
  }
  deserialize(t) {
    this.fromPosition.fromArray(t.fromPosition), this.toPosition.fromArray(t.toPosition), this.ctrl1.fromArray(t.ctrl1), this.ctrl2.fromArray(t.ctrl2), this.density = t.density, this.geometry instanceof ul || (this.geometry = new ul()), this.updatePositions();
  }
}
cS("BezierLineMaterial", Va);
Ye("BezierLine", {
  // cls: BezierLine,
  create: () => new NS(),
  members: {
    fromPosition: "Vector3",
    toPosition: "Vector3",
    ctrl1: "Vector3",
    ctrl2: "Vector3",
    density: "Number"
  },
  proto: "Mesh",
  group: "Objects.Bezier Line",
  icon: "line"
});
rr("BezierLineMaterial", Va, {
  color: "Color",
  dashed: "Boolean",
  dashScale: "Number",
  dashSize: "Number",
  dashOffset: "Number",
  gapSize: "Number",
  opacity: "Number",
  linewidth: "Number",
  alphaToCoverage: "Boolean",
  worldUnits: "Boolean"
}, "ShaderMaterial", {
  bezierLineMaterial: { clsName: "bezierLineMaterial", func: () => new Va(), group: "Material.Bezier Line Material", icon: "brand-medium" }
});
Ye("PerspectiveCamera", {
  // cls: PerspectiveCamera,
  create: () => new xr(),
  members: {},
  group: "Cameras.Perspective Camera",
  icon: "camera"
});
Ye("OrthographicCamera", {
  // cls: OrthographicCamera,
  create: () => new qa(),
  members: {},
  group: "Cameras.Orthographic Camera",
  icon: "camera"
});
class wS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isBox", !0);
    this.type = "Box";
  }
}
Ye("Box", {
  create: ({ material: c, geometry: e } = {}) => new wS(e, c || new Vn()),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.depthSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Box",
  icon: "box"
});
class TS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isCapsule", !0);
    this.type = "Capsule";
  }
}
Ye("Capsule", {
  create: ({ material: c, geometry: e } = {}) => new TS(e || new vm(), c || new Vn()),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Capsule",
  icon: "capsule"
});
class SS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isCone", !0);
    this.type = "Cone";
  }
}
Ye("Cone", {
  create: ({ material: c, geometry: e } = {}) => new SS(e || new Nx(), c || new Vn()),
  members: {
    "geo.radius": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cone",
  icon: "cone"
});
class _S extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isCylinder", !0);
    this.type = "Cylinder";
  }
}
Ye("Cylinder", {
  create: ({ material: c, geometry: e } = {}) => new _S(e || new wx(), c || new Vn()),
  members: {
    "geo.radiusTop": "Number",
    "geo.radiusBottom": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cylinder",
  icon: "cylinder"
});
let MS = class extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isSphere", !0);
    this.type = "Sphere";
  }
};
Ye("Sphere", {
  create: ({ material: c, geometry: e } = {}) => new MS(e || new Ja(), c || new Vn()),
  members: {
    "geo.radius": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.phiStart": "Number",
    "geo.phiLength": "Number",
    "geo.phiSegments": "Number",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Sphere",
  icon: "sphere"
});
class AS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isTorus", !0);
    this.type = "Torus";
  }
}
Ye("Torus", {
  create: ({ material: c, geometry: e } = {}) => new AS(e || new Tx(), c || new Vn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.arc": "Number"
  },
  proto: "Entity",
  group: "Entities.Torus",
  icon: "ring"
});
class CS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    B(this, "isTorusKnot", !0);
    this.type = "TorusKnot";
  }
}
Ye("TorusKnot", {
  create: ({ material: c, geometry: e } = {}) => new CS(e || new Sx(), c || new Vn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.p": "Number",
    "geo.q": "Number"
  },
  proto: "Entity",
  group: "Entities.TorusKnot",
  icon: "pipe"
});
const ES = {
  curveSegments: 12,
  steps: 1,
  depth: 1,
  bevelEnabled: !0,
  bevelThickness: 0.2,
  bevelSize: 0.1,
  bevelOffset: 0,
  bevelSegments: 3
};
let Mr = class extends Nn {
  constructor(t, r, n, s = 0, o = 0) {
    super(t || new xm(), r || new Vn(), s, o);
    B(this, "isShape", !0);
    B(this, "shapes", []);
    B(this, "props");
    this.type = "Shape", this.props = zd({ ...n }, () => {
      this.rebuildShapes();
    }), t || this.rebuildShapes();
  }
  get parameters() {
    var r;
    const t = ((r = this.geometry.parameters) == null ? void 0 : r.options) || {};
    return Object.keys(t).length ? t : { ...ES };
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Bt], s = Qs(n), o = r.props[Bt];
    return er(o, s), r;
  }
  serialize(t) {
    super.serialize(t);
    const r = this.props[Bt];
    t.props = Qs(r);
  }
  deserialize(t) {
    if (super.deserialize(t), t.props) {
      const r = this.props[Bt];
      er(r, t.props);
    }
    this.shapes = Array.isArray(this.geometry.parameters.shapes) ? this.geometry.parameters.shapes : [this.geometry.parameters.shapes];
  }
  rebuildShapes() {
    this.rebuildGeometry();
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose();
    const r = this.geo[Bt];
    this.geometry = t.fromJSON({ shapes: this.shapes.map((n, s) => s), options: r }, this.shapes), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
};
Ye("Shape", {
  create: ({ material: c, geometry: e } = {}) => new Mr(e, c),
  members: {
    "geo.curveSegments": "Number",
    "geo.steps": "Number",
    "geo.depth": "Number",
    "geo.bevelEnabled": "Boolean",
    "geo.bevelThickness": "Number",
    "geo.bevelSize": "Number",
    "geo.bevelOffset": "Number",
    "geo.bevelSegments": "Number"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class RS extends Nn {
  constructor(t, r) {
    super(t || new Tr(), r || new Vn(), Sc.Ghost, 0);
    B(this, "isPlane", !0);
    this.type = "Plane";
  }
}
Ye("Plane", {
  create: ({ material: c, geometry: e } = {}) => new RS(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number"
  },
  /** yes, we hide mass and body-type properties */
  proto: "Mesh",
  group: "Shapes.Plane",
  icon: "plane"
});
class LS extends Mr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { vec1: new Nt(0, 0), vec2: new Nt(1, 0), vec3: new Nt(0, 1) }, n, s);
    B(this, "isShapeTriangle", !0);
    this.type = "ShapeTriangle";
  }
  rebuildShapes() {
    const t = new Tu(), r = new vo();
    t.subPaths.push(r);
    const { vec1: n, vec2: s, vec3: o } = this.props;
    r.moveTo(n.x, n.y), r.lineTo(s.x, s.y), r.lineTo(o.x, o.y), r.lineTo(n.x, n.y), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeTriangle", {
  create: ({ material: c, geometry: e } = {}) => new LS(e, c),
  members: {
    "props.vec1": "Vector2",
    "props.vec2": "Vector2",
    "props.vec3": "Vector2"
  },
  proto: "Shape",
  group: "Shapes.Triangle",
  icon: "triangle"
});
class FS extends Mr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { size: 1 }, n, s);
    B(this, "isShapeSquare", !0);
    this.type = "ShapeSquare";
  }
  rebuildShapes() {
    const t = new vo(), { size: r } = this.props;
    t.moveTo(0, 0), t.lineTo(r, 0), t.lineTo(r, r), t.lineTo(0, r), t.lineTo(0, 0), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeSquare", {
  create: ({ material: c, geometry: e } = {}) => new FS(e, c),
  members: {
    "props.size": "Number"
  },
  proto: "Shape",
  group: "Shapes.Square",
  icon: "square"
});
class OS extends Mr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { width: 1, height: 1, radius: 0.2 }, n, s);
    B(this, "isShapeTriangle", !0);
    this.type = "ShapeRounded";
  }
  rebuildShapes() {
    const t = new Tu(), r = new vo();
    t.subPaths.push(r);
    const { width: n, height: s, radius: o } = this.props;
    r.moveTo(0, o), r.lineTo(0, s - o), r.quadraticCurveTo(0, s, o, s), r.lineTo(0 + n - o, s), r.quadraticCurveTo(n, s, n, s - o), r.lineTo(0 + n, o), r.quadraticCurveTo(n, 0, n - o, 0), r.lineTo(o, 0), r.quadraticCurveTo(0, 0, 0, o), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeRounded", {
  create: ({ material: c, geometry: e } = {}) => new OS(e, c),
  members: {
    "props.width": "Number",
    "props.height": "Number",
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Rounded rectangle",
  icon: "square"
});
class IS extends Mr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1 }, n, s);
    B(this, "isShapeTriangle", !0);
    this.type = "ShapeCircle";
  }
  rebuildShapes() {
    const t = new vo(), { radius: r } = this.props;
    t.moveTo(0, r).quadraticCurveTo(r, r, r, 0).quadraticCurveTo(r, -r, 0, -r).quadraticCurveTo(-r, -r, -r, 0).quadraticCurveTo(-r, r, 0, r), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeCircle", {
  create: ({ material: c, geometry: e } = {}) => new IS(e, c),
  members: {
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Circle",
  icon: "ring"
});
class PS extends Mr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1, innerRadius: 0.5 }, n, s);
    B(this, "isShapeTriangle", !0);
    this.type = "ShapeArc";
  }
  rebuildShapes() {
    const t = new vo(), { radius: r, innerRadius: n } = this.props;
    t.moveTo(r, 0).absarc(0, 0, r, 0, Math.PI * 2, !1);
    const s = new _x().moveTo(n, 0).absarc(0, 0, n, 0, Math.PI * 2, !0);
    t.holes.push(s), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeArc", {
  create: ({ material: c, geometry: e } = {}) => new PS(e, c),
  members: {
    "props.radius": "Number",
    "props.innerRadius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Arc Circle",
  icon: "ring"
});
Ye("PointLight", {
  // cls: PointLight,
  create: () => {
    const c = new Zo();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Point Light",
  icon: "bulb"
});
Ye("SpotLight", {
  // cls: SpotLight,
  create: () => {
    const c = new mi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Spot Light",
  icon: "bulb"
});
Ye("DirectionalLight", {
  // cls: DirectionalLight,
  create: () => {
    const c = new pi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c.shadow.bias = -0.1, c;
  },
  members: {},
  group: "Lights.Directional Light",
  icon: "bulb"
});
Ye("AmbientLight", {
  // cls: AmbientLight,
  create: () => new Nu(),
  members: {},
  group: "Lights.Ambient Light",
  icon: "bulb"
});
Ye("HemisphereLight", {
  // cls: HemisphereLight,
  create: () => new fm(),
  members: {},
  group: "Lights.Hemisphere Light",
  icon: "bulb"
});
function DS() {
  var c = /* @__PURE__ */ Object.create(null);
  function e(n, s) {
    var o = n.id, i = n.name, a = n.dependencies;
    a === void 0 && (a = []);
    var l = n.init;
    l === void 0 && (l = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !c[o])
      try {
        a = a.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = c[d.id].value), d;
        }), l = r("<" + i + ">.init", l), u && (u = r("<" + i + ">.getTransferables", u));
        var h = null;
        typeof l == "function" ? h = l.apply(void 0, a) : console.error("worker module init function failed to rehydrate"), c[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, s(h);
      } catch (d) {
        d && d.noLog || console.error(d), s(d);
      }
  }
  function t(n, s) {
    var o, i = n.id, a = n.args;
    (!c[i] || typeof c[i].value != "function") && s(new Error("Worker module " + i + ": not found or its 'init' did not return a function"));
    try {
      var l = (o = c[i]).value.apply(o, a);
      l && typeof l.then == "function" ? l.then(u, function(h) {
        return s(h instanceof Error ? h : new Error("" + h));
      }) : u(l);
    } catch (h) {
      s(h);
    }
    function u(h) {
      try {
        var d = c[i].getTransferables && c[i].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), s(h, d);
      } catch (f) {
        console.error(f), s(f);
      }
    }
  }
  function r(n, s) {
    var o = void 0;
    self.troikaDefine = function(a) {
      return o = a;
    };
    var i = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(i);
    } catch (a) {
      console.error(a);
    }
    return URL.revokeObjectURL(i), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var s = n.data, o = s.messageId, i = s.action, a = s.data;
    try {
      i === "registerModule" && e(a, function(l) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof l == "function" }
        });
      }), i === "callModule" && t(a, function(l, u) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: l
        }, u || void 0);
      });
    } catch (l) {
      postMessage({
        messageId: o,
        success: !1,
        error: l.stack
      });
    }
  });
}
function US(c) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = c.dependencies, r = c.init;
    t = Array.isArray(t) ? t.map(
      function(s) {
        return s && s._getInitResult ? s._getInitResult() : s;
      }
    ) : [];
    var n = Promise.all(t).then(function(s) {
      return r.apply(null, s);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var Qv = function() {
  var c = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), c = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return Qv = function() {
    return c;
  }, c;
}, zS = 0, BS = 0, hl = !1, $o = /* @__PURE__ */ Object.create(null), qo = /* @__PURE__ */ Object.create(null), ou = /* @__PURE__ */ Object.create(null);
function hs(c) {
  if ((!c || typeof c.init != "function") && !hl)
    throw new Error("requires `options.init` function");
  var e = c.dependencies, t = c.init, r = c.getTransferables, n = c.workerId;
  if (!Qv())
    return US(c);
  n == null && (n = "#default");
  var s = "workerModule" + ++zS, o = c.name || s, i = null;
  e = e && e.map(function(l) {
    return typeof l == "function" && !l.workerModuleData && (hl = !0, l = hs({
      workerId: n,
      name: "<" + o + "> function dependency: " + l.name,
      init: `function(){return (
` + xa(l) + `
)}`
    }), hl = !1), l && l.workerModuleData && (l = l.workerModuleData), l;
  });
  function a() {
    for (var l = [], u = arguments.length; u--; )
      l[u] = arguments[u];
    if (!i) {
      i = lp(n, "registerModule", a.workerModuleData);
      var h = function() {
        i = null, qo[n].delete(h);
      };
      (qo[n] || (qo[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return i.then(function(d) {
      var f = d.isCallable;
      if (f)
        return lp(n, "callModule", { id: s, args: l });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return a.workerModuleData = {
    isWorkerModule: !0,
    id: s,
    name: o,
    dependencies: e,
    init: xa(t),
    getTransferables: r && xa(r)
  }, a;
}
function kS(c) {
  qo[c] && qo[c].forEach(function(e) {
    e();
  }), $o[c] && ($o[c].terminate(), delete $o[c]);
}
function xa(c) {
  var e = c.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function GS(c) {
  var e = $o[c];
  if (!e) {
    var t = xa(DS);
    e = $o[c] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + c.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var n = r.data, s = n.messageId, o = ou[s];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete ou[s], o(n);
    };
  }
  return e;
}
function lp(c, e, t) {
  return new Promise(function(r, n) {
    var s = ++BS;
    ou[s] = function(o) {
      o.success ? r(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, GS(c).postMessage({
      messageId: s,
      action: e,
      data: t
    });
  });
}
function e1() {
  var c = function(e) {
    function t(U, k, C, P, X, Y, W, ie) {
      var J = 1 - W;
      ie.x = J * J * U + 2 * J * W * C + W * W * X, ie.y = J * J * k + 2 * J * W * P + W * W * Y;
    }
    function r(U, k, C, P, X, Y, W, ie, J, se) {
      var ue = 1 - J;
      se.x = ue * ue * ue * U + 3 * ue * ue * J * C + 3 * ue * J * J * X + J * J * J * W, se.y = ue * ue * ue * k + 3 * ue * ue * J * P + 3 * ue * J * J * Y + J * J * J * ie;
    }
    function n(U, k) {
      for (var C = /([MLQCZ])([^MLQCZ]*)/g, P, X, Y, W, ie; P = C.exec(U); ) {
        var J = P[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(se) {
          return parseFloat(se);
        });
        switch (P[1]) {
          case "M":
            W = X = J[0], ie = Y = J[1];
            break;
          case "L":
            (J[0] !== W || J[1] !== ie) && k("L", W, ie, W = J[0], ie = J[1]);
            break;
          case "Q": {
            k("Q", W, ie, W = J[2], ie = J[3], J[0], J[1]);
            break;
          }
          case "C": {
            k("C", W, ie, W = J[4], ie = J[5], J[0], J[1], J[2], J[3]);
            break;
          }
          case "Z":
            (W !== X || ie !== Y) && k("L", W, ie, X, Y);
            break;
        }
      }
    }
    function s(U, k, C) {
      C === void 0 && (C = 16);
      var P = { x: 0, y: 0 };
      n(U, function(X, Y, W, ie, J, se, ue, le, $) {
        switch (X) {
          case "L":
            k(Y, W, ie, J);
            break;
          case "Q": {
            for (var I = Y, ne = W, Z = 1; Z < C; Z++)
              t(
                Y,
                W,
                se,
                ue,
                ie,
                J,
                Z / (C - 1),
                P
              ), k(I, ne, P.x, P.y), I = P.x, ne = P.y;
            break;
          }
          case "C": {
            for (var Q = Y, ee = W, xe = 1; xe < C; xe++)
              r(
                Y,
                W,
                se,
                ue,
                le,
                $,
                ie,
                J,
                xe / (C - 1),
                P
              ), k(Q, ee, P.x, P.y), Q = P.x, ee = P.y;
            break;
          }
        }
      });
    }
    var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", i = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", a = /* @__PURE__ */ new WeakMap(), l = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(U, k) {
      var C = U.getContext ? U.getContext("webgl", l) : U, P = a.get(C);
      if (!P) {
        let ue = function(Q) {
          var ee = Y[Q];
          if (!ee && (ee = Y[Q] = C.getExtension(Q), !ee))
            throw new Error(Q + " not supported");
          return ee;
        }, le = function(Q, ee) {
          var xe = C.createShader(ee);
          return C.shaderSource(xe, Q), C.compileShader(xe), xe;
        }, $ = function(Q, ee, xe, te) {
          if (!W[Q]) {
            var de = {}, re = {}, K = C.createProgram();
            C.attachShader(K, le(ee, C.VERTEX_SHADER)), C.attachShader(K, le(xe, C.FRAGMENT_SHADER)), C.linkProgram(K), W[Q] = {
              program: K,
              transaction: function(fe) {
                C.useProgram(K), fe({
                  setUniform: function(ye, ae) {
                    for (var Fe = [], he = arguments.length - 2; he-- > 0; )
                      Fe[he] = arguments[he + 2];
                    var pe = re[ae] || (re[ae] = C.getUniformLocation(K, ae));
                    C["uniform" + ye].apply(C, [pe].concat(Fe));
                  },
                  setAttribute: function(ye, ae, Fe, he, pe) {
                    var Ie = de[ye];
                    Ie || (Ie = de[ye] = {
                      buf: C.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: C.getAttribLocation(K, ye),
                      data: null
                    }), C.bindBuffer(C.ARRAY_BUFFER, Ie.buf), C.vertexAttribPointer(Ie.loc, ae, C.FLOAT, !1, 0, 0), C.enableVertexAttribArray(Ie.loc), X ? C.vertexAttribDivisor(Ie.loc, he) : ue("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ie.loc, he), pe !== Ie.data && (C.bufferData(C.ARRAY_BUFFER, pe, Fe), Ie.data = pe);
                  }
                });
              }
            };
          }
          W[Q].transaction(te);
        }, I = function(Q, ee) {
          J++;
          try {
            C.activeTexture(C.TEXTURE0 + J);
            var xe = ie[Q];
            xe || (xe = ie[Q] = C.createTexture(), C.bindTexture(C.TEXTURE_2D, xe), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MIN_FILTER, C.NEAREST), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MAG_FILTER, C.NEAREST)), C.bindTexture(C.TEXTURE_2D, xe), ee(xe, J);
          } finally {
            J--;
          }
        }, ne = function(Q, ee, xe) {
          var te = C.createFramebuffer();
          se.push(te), C.bindFramebuffer(C.FRAMEBUFFER, te), C.activeTexture(C.TEXTURE0 + ee), C.bindTexture(C.TEXTURE_2D, Q), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_2D, Q, 0);
          try {
            xe(te);
          } finally {
            C.deleteFramebuffer(te), C.bindFramebuffer(C.FRAMEBUFFER, se[--se.length - 1] || null);
          }
        }, Z = function() {
          Y = {}, W = {}, ie = {}, J = -1, se.length = 0;
        };
        var X = typeof WebGL2RenderingContext < "u" && C instanceof WebGL2RenderingContext, Y = {}, W = {}, ie = {}, J = -1, se = [];
        C.canvas.addEventListener("webglcontextlost", function(Q) {
          Z(), Q.preventDefault();
        }, !1), a.set(C, P = {
          gl: C,
          isWebGL2: X,
          getExtension: ue,
          withProgram: $,
          withTexture: I,
          withTextureFramebuffer: ne,
          handleContextLoss: Z
        });
      }
      k(P);
    }
    function h(U, k, C, P, X, Y, W, ie) {
      W === void 0 && (W = 15), ie === void 0 && (ie = null), u(U, function(J) {
        var se = J.gl, ue = J.withProgram, le = J.withTexture;
        le("copy", function($, I) {
          se.texImage2D(se.TEXTURE_2D, 0, se.RGBA, X, Y, 0, se.RGBA, se.UNSIGNED_BYTE, k), ue("copy", o, i, function(ne) {
            var Z = ne.setUniform, Q = ne.setAttribute;
            Q("aUV", 2, se.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", I), se.bindFramebuffer(se.FRAMEBUFFER, ie || null), se.disable(se.BLEND), se.colorMask(W & 8, W & 4, W & 2, W & 1), se.viewport(C, P, X, Y), se.scissor(C, P, X, Y), se.drawArrays(se.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(U, k, C) {
      var P = U.width, X = U.height;
      u(U, function(Y) {
        var W = Y.gl, ie = new Uint8Array(P * X * 4);
        W.readPixels(0, 0, P, X, W.RGBA, W.UNSIGNED_BYTE, ie), U.width = k, U.height = C, h(W, ie, 0, 0, P, X);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function p(U, k, C, P, X, Y) {
      Y === void 0 && (Y = 1);
      var W = new Uint8Array(U * k), ie = P[2] - P[0], J = P[3] - P[1], se = [];
      s(C, function(Q, ee, xe, te) {
        se.push({
          x1: Q,
          y1: ee,
          x2: xe,
          y2: te,
          minX: Math.min(Q, xe),
          minY: Math.min(ee, te),
          maxX: Math.max(Q, xe),
          maxY: Math.max(ee, te)
        });
      }), se.sort(function(Q, ee) {
        return Q.maxX - ee.maxX;
      });
      for (var ue = 0; ue < U; ue++)
        for (var le = 0; le < k; le++) {
          var $ = ne(
            P[0] + ie * (ue + 0.5) / U,
            P[1] + J * (le + 0.5) / k
          ), I = Math.pow(1 - Math.abs($) / X, Y) / 2;
          $ < 0 && (I = 1 - I), I = Math.max(0, Math.min(255, Math.round(I * 255))), W[le * U + ue] = I;
        }
      return W;
      function ne(Q, ee) {
        for (var xe = 1 / 0, te = 1 / 0, de = se.length; de--; ) {
          var re = se[de];
          if (re.maxX + te <= Q)
            break;
          if (Q + te > re.minX && ee - te < re.maxY && ee + te > re.minY) {
            var K = b(Q, ee, re.x1, re.y1, re.x2, re.y2);
            K < xe && (xe = K, te = Math.sqrt(xe));
          }
        }
        return Z(Q, ee) && (te = -te), te;
      }
      function Z(Q, ee) {
        for (var xe = 0, te = se.length; te--; ) {
          var de = se[te];
          if (de.maxX <= Q)
            break;
          var re = de.y1 > ee != de.y2 > ee && Q < (de.x2 - de.x1) * (ee - de.y1) / (de.y2 - de.y1) + de.x1;
          re && (xe += de.y1 < de.y2 ? 1 : -1);
        }
        return xe !== 0;
      }
    }
    function m(U, k, C, P, X, Y, W, ie, J, se) {
      Y === void 0 && (Y = 1), ie === void 0 && (ie = 0), J === void 0 && (J = 0), se === void 0 && (se = 0), g(U, k, C, P, X, Y, W, null, ie, J, se);
    }
    function g(U, k, C, P, X, Y, W, ie, J, se, ue) {
      Y === void 0 && (Y = 1), J === void 0 && (J = 0), se === void 0 && (se = 0), ue === void 0 && (ue = 0);
      for (var le = p(U, k, C, P, X, Y), $ = new Uint8Array(le.length * 4), I = 0; I < le.length; I++)
        $[I * 4 + ue] = le[I];
      h(W, $, J, se, U, k, 1 << 3 - ue, ie);
    }
    function b(U, k, C, P, X, Y) {
      var W = X - C, ie = Y - P, J = W * W + ie * ie, se = J ? Math.max(0, Math.min(1, ((U - C) * W + (k - P) * ie) / J)) : 0, ue = U - (C + se * W), le = k - (P + se * ie);
      return ue * ue + le * le;
    }
    var x = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: p,
      generateIntoCanvas: m,
      generateIntoFramebuffer: g
    }), y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", v = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", N = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", w = new Float32Array([0, 0, 2, 0, 0, 2]), T = null, S = !1, A = {}, R = /* @__PURE__ */ new WeakMap();
    function O(U) {
      if (!S && !D(U))
        throw new Error("WebGL generation not supported");
    }
    function _(U, k, C, P, X, Y, W) {
      if (Y === void 0 && (Y = 1), W === void 0 && (W = null), !W && (W = T, !W)) {
        var ie = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!ie)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        W = T = ie.getContext("webgl", { depth: !1 });
      }
      O(W);
      var J = new Uint8Array(U * k * 4);
      u(W, function($) {
        var I = $.gl, ne = $.withTexture, Z = $.withTextureFramebuffer;
        ne("readable", function(Q, ee) {
          I.texImage2D(I.TEXTURE_2D, 0, I.RGBA, U, k, 0, I.RGBA, I.UNSIGNED_BYTE, null), Z(Q, ee, function(xe) {
            E(
              U,
              k,
              C,
              P,
              X,
              Y,
              I,
              xe,
              0,
              0,
              0
              // red channel
            ), I.readPixels(0, 0, U, k, I.RGBA, I.UNSIGNED_BYTE, J);
          });
        });
      });
      for (var se = new Uint8Array(U * k), ue = 0, le = 0; ue < J.length; ue += 4)
        se[le++] = J[ue];
      return se;
    }
    function L(U, k, C, P, X, Y, W, ie, J, se) {
      Y === void 0 && (Y = 1), ie === void 0 && (ie = 0), J === void 0 && (J = 0), se === void 0 && (se = 0), E(U, k, C, P, X, Y, W, null, ie, J, se);
    }
    function E(U, k, C, P, X, Y, W, ie, J, se, ue) {
      Y === void 0 && (Y = 1), J === void 0 && (J = 0), se === void 0 && (se = 0), ue === void 0 && (ue = 0), O(W);
      var le = [];
      s(C, function($, I, ne, Z) {
        le.push($, I, ne, Z);
      }), le = new Float32Array(le), u(W, function($) {
        var I = $.gl, ne = $.isWebGL2, Z = $.getExtension, Q = $.withProgram, ee = $.withTexture, xe = $.withTextureFramebuffer, te = $.handleContextLoss;
        if (ee("rawDistances", function(de, re) {
          (U !== de._lastWidth || k !== de._lastHeight) && I.texImage2D(
            I.TEXTURE_2D,
            0,
            I.RGBA,
            de._lastWidth = U,
            de._lastHeight = k,
            0,
            I.RGBA,
            I.UNSIGNED_BYTE,
            null
          ), Q("main", y, v, function(K) {
            var Ce = K.setAttribute, fe = K.setUniform, me = !ne && Z("ANGLE_instanced_arrays"), ye = !ne && Z("EXT_blend_minmax");
            Ce("aUV", 2, I.STATIC_DRAW, 0, w), Ce("aLineSegment", 4, I.DYNAMIC_DRAW, 1, le), fe.apply(void 0, ["4f", "uGlyphBounds"].concat(P)), fe("1f", "uMaxDistance", X), fe("1f", "uExponent", Y), xe(de, re, function(ae) {
              I.enable(I.BLEND), I.colorMask(!0, !0, !0, !0), I.viewport(0, 0, U, k), I.scissor(0, 0, U, k), I.blendFunc(I.ONE, I.ONE), I.blendEquationSeparate(I.FUNC_ADD, ne ? I.MAX : ye.MAX_EXT), I.clear(I.COLOR_BUFFER_BIT), ne ? I.drawArraysInstanced(I.TRIANGLES, 0, 3, le.length / 4) : me.drawArraysInstancedANGLE(I.TRIANGLES, 0, 3, le.length / 4);
            });
          }), Q("post", o, N, function(K) {
            K.setAttribute("aUV", 2, I.STATIC_DRAW, 0, w), K.setUniform("1i", "tex", re), I.bindFramebuffer(I.FRAMEBUFFER, ie), I.disable(I.BLEND), I.colorMask(ue === 0, ue === 1, ue === 2, ue === 3), I.viewport(J, se, U, k), I.scissor(J, se, U, k), I.drawArrays(I.TRIANGLES, 0, 3);
          });
        }), I.isContextLost())
          throw te(), new Error("webgl context lost");
      });
    }
    function D(U) {
      var k = !U || U === T ? A : U.canvas || U, C = R.get(k);
      if (C === void 0) {
        S = !0;
        var P = null;
        try {
          var X = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], Y = _(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            U
          );
          C = Y && X.length === Y.length && Y.every(function(W, ie) {
            return W === X[ie];
          }), C || (P = "bad trial run results", console.info(X, Y));
        } catch (W) {
          C = !1, P = W.message;
        }
        P && console.warn("WebGL SDF generation not supported:", P), S = !1, R.set(k, C);
      }
      return C;
    }
    var F = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: _,
      generateIntoCanvas: L,
      generateIntoFramebuffer: E,
      isSupported: D
    });
    function H(U, k, C, P, X, Y) {
      X === void 0 && (X = Math.max(P[2] - P[0], P[3] - P[1]) / 2), Y === void 0 && (Y = 1);
      try {
        return _.apply(F, arguments);
      } catch (W) {
        return console.info("WebGL SDF generation failed, falling back to JS", W), p.apply(x, arguments);
      }
    }
    function q(U, k, C, P, X, Y, W, ie, J, se) {
      X === void 0 && (X = Math.max(P[2] - P[0], P[3] - P[1]) / 2), Y === void 0 && (Y = 1), ie === void 0 && (ie = 0), J === void 0 && (J = 0), se === void 0 && (se = 0);
      try {
        return L.apply(F, arguments);
      } catch (ue) {
        return console.info("WebGL SDF generation failed, falling back to JS", ue), m.apply(x, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = H, e.generateIntoCanvas = q, e.javascript = x, e.pathToLineSegments = s, e.webgl = F, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
function t1() {
  var c = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, n = {};
    r.L = 1, n[1] = "L", Object.keys(t).forEach(function(te, de) {
      r[te] = 1 << de + 1, n[r[te]] = te;
    }), Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI, o = r.L | r.R | r.AL, i = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, a = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, l = r.S | r.WS | r.B | s | r.PDI | a, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var te = function(re) {
          if (t.hasOwnProperty(re)) {
            var K = 0;
            t[re].split(",").forEach(function(Ce) {
              var fe = Ce.split("+"), me = fe[0], ye = fe[1];
              me = parseInt(me, 36), ye = ye ? parseInt(ye, 36) : 0, u.set(K += me, r[re]);
              for (var ae = 0; ae < ye; ae++)
                u.set(++K, r[re]);
            });
          }
        };
        for (var de in t)
          te(de);
      }
    }
    function d(te) {
      return h(), u.get(te.codePointAt(0)) || r.L;
    }
    function f(te) {
      return n[d(te)];
    }
    var p = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(te, de) {
      var re = 36, K = 0, Ce = /* @__PURE__ */ new Map(), fe = de && /* @__PURE__ */ new Map(), me;
      return te.split(",").forEach(function ye(ae) {
        if (ae.indexOf("+") !== -1)
          for (var Fe = +ae; Fe--; )
            ye(me);
        else {
          me = ae;
          var he = ae.split(">"), pe = he[0], Ie = he[1];
          pe = String.fromCodePoint(K += parseInt(pe, re)), Ie = String.fromCodePoint(K += parseInt(Ie, re)), Ce.set(pe, Ie), de && fe.set(Ie, pe);
        }
      }), { map: Ce, reverseMap: fe };
    }
    var g, b, x;
    function y() {
      if (!g) {
        var te = m(p.pairs, !0), de = te.map, re = te.reverseMap;
        g = de, b = re, x = m(p.canonical, !1).map;
      }
    }
    function v(te) {
      return y(), g.get(te) || null;
    }
    function N(te) {
      return y(), b.get(te) || null;
    }
    function w(te) {
      return y(), x.get(te) || null;
    }
    var T = r.L, S = r.R, A = r.EN, R = r.ES, O = r.ET, _ = r.AN, L = r.CS, E = r.B, D = r.S, F = r.ON, H = r.BN, q = r.NSM, U = r.AL, k = r.LRO, C = r.RLO, P = r.LRE, X = r.RLE, Y = r.PDF, W = r.LRI, ie = r.RLI, J = r.FSI, se = r.PDI;
    function ue(te, de) {
      for (var re = 125, K = new Uint32Array(te.length), Ce = 0; Ce < te.length; Ce++)
        K[Ce] = d(te[Ce]);
      var fe = /* @__PURE__ */ new Map();
      function me(hn, Hn) {
        var dn = K[hn];
        K[hn] = Hn, fe.set(dn, fe.get(dn) - 1), dn & i && fe.set(i, fe.get(i) - 1), fe.set(Hn, (fe.get(Hn) || 0) + 1), Hn & i && fe.set(i, (fe.get(i) || 0) + 1);
      }
      for (var ye = new Uint8Array(te.length), ae = /* @__PURE__ */ new Map(), Fe = [], he = null, pe = 0; pe < te.length; pe++)
        he || Fe.push(he = {
          start: pe,
          end: te.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: de === "rtl" ? 1 : de === "ltr" ? 0 : Ef(pe, !1)
        }), K[pe] & E && (he.end = pe, he = null);
      for (var Ie = X | P | C | k | s | se | Y | E, Ge = function(hn) {
        return hn + (hn & 1 ? 1 : 2);
      }, Se = function(hn) {
        return hn + (hn & 1 ? 2 : 1);
      }, ot = 0; ot < Fe.length; ot++) {
        he = Fe[ot];
        var be = [{
          _level: he.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], De = void 0, Xe = 0, We = 0, lt = 0;
        fe.clear();
        for (var ve = he.start; ve <= he.end; ve++) {
          var Te = K[ve];
          if (De = be[be.length - 1], fe.set(Te, (fe.get(Te) || 0) + 1), Te & i && fe.set(i, (fe.get(i) || 0) + 1), Te & Ie)
            if (Te & (X | P)) {
              ye[ve] = De._level;
              var Dt = (Te === X ? Se : Ge)(De._level);
              Dt <= re && !Xe && !We ? be.push({
                _level: Dt,
                _override: 0,
                _isolate: 0
              }) : Xe || We++;
            } else if (Te & (C | k)) {
              ye[ve] = De._level;
              var Ae = (Te === C ? Se : Ge)(De._level);
              Ae <= re && !Xe && !We ? be.push({
                _level: Ae,
                _override: Te & C ? S : T,
                _isolate: 0
              }) : Xe || We++;
            } else if (Te & s) {
              Te & J && (Te = Ef(ve + 1, !0) === 1 ? ie : W), ye[ve] = De._level, De._override && me(ve, De._override);
              var Le = (Te === ie ? Se : Ge)(De._level);
              Le <= re && Xe === 0 && We === 0 ? (lt++, be.push({
                _level: Le,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: ve
              })) : Xe++;
            } else if (Te & se) {
              if (Xe > 0)
                Xe--;
              else if (lt > 0) {
                for (We = 0; !be[be.length - 1]._isolate; )
                  be.pop();
                var nt = be[be.length - 1]._isolInitIndex;
                nt != null && (ae.set(nt, ve), ae.set(ve, nt)), be.pop(), lt--;
              }
              De = be[be.length - 1], ye[ve] = De._level, De._override && me(ve, De._override);
            } else
              Te & Y ? (Xe === 0 && (We > 0 ? We-- : !De._isolate && be.length > 1 && (be.pop(), De = be[be.length - 1])), ye[ve] = De._level) : Te & E && (ye[ve] = he.level);
          else
            ye[ve] = De._level, De._override && Te !== H && me(ve, De._override);
        }
        for (var Ve = [], we = null, ze = he.start; ze <= he.end; ze++) {
          var ht = K[ze];
          if (!(ht & a)) {
            var it = ye[ze], et = ht & s, Gt = ht === se;
            we && it === we._level ? (we._end = ze, we._endsWithIsolInit = et) : Ve.push(we = {
              _start: ze,
              _end: ze,
              _level: it,
              _startsWithPDI: Gt,
              _endsWithIsolInit: et
            });
          }
        }
        for (var jn = [], cn = 0; cn < Ve.length; cn++) {
          var ln = Ve[cn];
          if (!ln._startsWithPDI || ln._startsWithPDI && !ae.has(ln._start)) {
            for (var Tn = [we = ln], On = void 0; we && we._endsWithIsolInit && (On = ae.get(we._end)) != null; )
              for (var xt = cn + 1; xt < Ve.length; xt++)
                if (Ve[xt]._start === On) {
                  Tn.push(we = Ve[xt]);
                  break;
                }
            for (var un = [], Lc = 0; Lc < Tn.length; Lc++)
              for (var lf = Tn[Lc], Fc = lf._start; Fc <= lf._end; Fc++)
                un.push(Fc);
            for (var H1 = ye[un[0]], uf = he.level, Ci = un[0] - 1; Ci >= 0; Ci--)
              if (!(K[Ci] & a)) {
                uf = ye[Ci];
                break;
              }
            var Oc = un[un.length - 1], X1 = ye[Oc], hf = he.level;
            if (!(K[Oc] & s)) {
              for (var Ei = Oc + 1; Ei <= he.end; Ei++)
                if (!(K[Ei] & a)) {
                  hf = ye[Ei];
                  break;
                }
            }
            jn.push({
              _seqIndices: un,
              _sosType: Math.max(uf, H1) % 2 ? S : T,
              _eosType: Math.max(hf, X1) % 2 ? S : T
            });
          }
        }
        for (var Ic = 0; Ic < jn.length; Ic++) {
          var Pc = jn[Ic], Pe = Pc._seqIndices, wo = Pc._sosType, $1 = Pc._eosType, Cr = ye[Pe[0]] & 1 ? S : T;
          if (fe.get(q))
            for (var Ri = 0; Ri < Pe.length; Ri++) {
              var df = Pe[Ri];
              if (K[df] & q) {
                for (var Dc = wo, Li = Ri - 1; Li >= 0; Li--)
                  if (!(K[Pe[Li]] & a)) {
                    Dc = K[Pe[Li]];
                    break;
                  }
                me(df, Dc & (s | se) ? F : Dc);
              }
            }
          if (fe.get(A))
            for (var Fi = 0; Fi < Pe.length; Fi++) {
              var ff = Pe[Fi];
              if (K[ff] & A)
                for (var Oi = Fi - 1; Oi >= -1; Oi--) {
                  var pf = Oi === -1 ? wo : K[Pe[Oi]];
                  if (pf & o) {
                    pf === U && me(ff, _);
                    break;
                  }
                }
            }
          if (fe.get(U))
            for (var Uc = 0; Uc < Pe.length; Uc++) {
              var mf = Pe[Uc];
              K[mf] & U && me(mf, S);
            }
          if (fe.get(R) || fe.get(L))
            for (var To = 1; To < Pe.length - 1; To++) {
              var zc = Pe[To];
              if (K[zc] & (R | L)) {
                for (var Er = 0, Bc = 0, kc = To - 1; kc >= 0 && (Er = K[Pe[kc]], !!(Er & a)); kc--)
                  ;
                for (var Gc = To + 1; Gc < Pe.length && (Bc = K[Pe[Gc]], !!(Bc & a)); Gc++)
                  ;
                Er === Bc && (K[zc] === R ? Er === A : Er & (A | _)) && me(zc, Er);
              }
            }
          if (fe.get(A))
            for (var ss = 0; ss < Pe.length; ss++) {
              var q1 = Pe[ss];
              if (K[q1] & A) {
                for (var Ii = ss - 1; Ii >= 0 && K[Pe[Ii]] & (O | a); Ii--)
                  me(Pe[Ii], A);
                for (ss++; ss < Pe.length && K[Pe[ss]] & (O | a | A); ss++)
                  K[Pe[ss]] !== A && me(Pe[ss], A);
              }
            }
          if (fe.get(O) || fe.get(R) || fe.get(L))
            for (var So = 0; So < Pe.length; So++) {
              var gf = Pe[So];
              if (K[gf] & (O | R | L)) {
                me(gf, F);
                for (var Pi = So - 1; Pi >= 0 && K[Pe[Pi]] & a; Pi--)
                  me(Pe[Pi], F);
                for (var Di = So + 1; Di < Pe.length && K[Pe[Di]] & a; Di++)
                  me(Pe[Di], F);
              }
            }
          if (fe.get(A))
            for (var Vc = 0, yf = wo; Vc < Pe.length; Vc++) {
              var vf = Pe[Vc], jc = K[vf];
              jc & A ? yf === T && me(vf, T) : jc & o && (yf = jc);
            }
          if (fe.get(i)) {
            var _o = S | A | _, xf = _o | T, Ui = [];
            {
              for (var Rr = [], Lr = 0; Lr < Pe.length; Lr++)
                if (K[Pe[Lr]] & i) {
                  var Mo = te[Pe[Lr]], bf = void 0;
                  if (v(Mo) !== null)
                    if (Rr.length < 63)
                      Rr.push({ char: Mo, seqIndex: Lr });
                    else
                      break;
                  else if ((bf = N(Mo)) !== null)
                    for (var Ao = Rr.length - 1; Ao >= 0; Ao--) {
                      var Wc = Rr[Ao].char;
                      if (Wc === bf || Wc === N(w(Mo)) || v(w(Wc)) === Mo) {
                        Ui.push([Rr[Ao].seqIndex, Lr]), Rr.length = Ao;
                        break;
                      }
                    }
                }
              Ui.sort(function(hn, Hn) {
                return hn[0] - Hn[0];
              });
            }
            for (var Hc = 0; Hc < Ui.length; Hc++) {
              for (var Nf = Ui[Hc], zi = Nf[0], Xc = Nf[1], wf = !1, Wn = 0, $c = zi + 1; $c < Xc; $c++) {
                var Tf = Pe[$c];
                if (K[Tf] & xf) {
                  wf = !0;
                  var Sf = K[Tf] & _o ? S : T;
                  if (Sf === Cr) {
                    Wn = Sf;
                    break;
                  }
                }
              }
              if (wf && !Wn) {
                Wn = wo;
                for (var qc = zi - 1; qc >= 0; qc--) {
                  var _f = Pe[qc];
                  if (K[_f] & xf) {
                    var Mf = K[_f] & _o ? S : T;
                    Mf !== Cr ? Wn = Mf : Wn = Cr;
                    break;
                  }
                }
              }
              if (Wn) {
                if (K[Pe[zi]] = K[Pe[Xc]] = Wn, Wn !== Cr) {
                  for (var Co = zi + 1; Co < Pe.length; Co++)
                    if (!(K[Pe[Co]] & a)) {
                      d(te[Pe[Co]]) & q && (K[Pe[Co]] = Wn);
                      break;
                    }
                }
                if (Wn !== Cr) {
                  for (var Eo = Xc + 1; Eo < Pe.length; Eo++)
                    if (!(K[Pe[Eo]] & a)) {
                      d(te[Pe[Eo]]) & q && (K[Pe[Eo]] = Wn);
                      break;
                    }
                }
              }
            }
            for (var Rs = 0; Rs < Pe.length; Rs++)
              if (K[Pe[Rs]] & i) {
                for (var Af = Rs, Jc = Rs, Yc = wo, Ro = Rs - 1; Ro >= 0; Ro--)
                  if (K[Pe[Ro]] & a)
                    Af = Ro;
                  else {
                    Yc = K[Pe[Ro]] & _o ? S : T;
                    break;
                  }
                for (var Cf = $1, Lo = Rs + 1; Lo < Pe.length; Lo++)
                  if (K[Pe[Lo]] & (i | a))
                    Jc = Lo;
                  else {
                    Cf = K[Pe[Lo]] & _o ? S : T;
                    break;
                  }
                for (var Kc = Af; Kc <= Jc; Kc++)
                  K[Pe[Kc]] = Yc === Cf ? Yc : Cr;
                Rs = Jc;
              }
          }
        }
        for (var Sn = he.start; Sn <= he.end; Sn++) {
          var J1 = ye[Sn], Bi = K[Sn];
          if (J1 & 1 ? Bi & (T | A | _) && ye[Sn]++ : Bi & S ? ye[Sn]++ : Bi & (_ | A) && (ye[Sn] += 2), Bi & a && (ye[Sn] = Sn === 0 ? he.level : ye[Sn - 1]), Sn === he.end || d(te[Sn]) & (D | E))
            for (var ki = Sn; ki >= 0 && d(te[ki]) & l; ki--)
              ye[ki] = he.level;
        }
      }
      return {
        levels: ye,
        paragraphs: Fe
      };
      function Ef(hn, Hn) {
        for (var dn = hn; dn < te.length; dn++) {
          var Ls = K[dn];
          if (Ls & (S | U))
            return 1;
          if (Ls & (E | T) || Hn && Ls === se)
            return 0;
          if (Ls & s) {
            var Rf = Y1(dn);
            dn = Rf === -1 ? te.length : Rf;
          }
        }
        return 0;
      }
      function Y1(hn) {
        for (var Hn = 1, dn = hn + 1; dn < te.length; dn++) {
          var Ls = K[dn];
          if (Ls & E)
            break;
          if (Ls & se) {
            if (--Hn === 0)
              return dn;
          } else
            Ls & s && Hn++;
        }
        return -1;
      }
    }
    var le = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", $;
    function I() {
      if (!$) {
        var te = m(le, !0), de = te.map, re = te.reverseMap;
        re.forEach(function(K, Ce) {
          de.set(Ce, K);
        }), $ = de;
      }
    }
    function ne(te) {
      return I(), $.get(te) || null;
    }
    function Z(te, de, re, K) {
      var Ce = te.length;
      re = Math.max(0, re == null ? 0 : +re), K = Math.min(Ce - 1, K == null ? Ce - 1 : +K);
      for (var fe = /* @__PURE__ */ new Map(), me = re; me <= K; me++)
        if (de[me] & 1) {
          var ye = ne(te[me]);
          ye !== null && fe.set(me, ye);
        }
      return fe;
    }
    function Q(te, de, re, K) {
      var Ce = te.length;
      re = Math.max(0, re == null ? 0 : +re), K = Math.min(Ce - 1, K == null ? Ce - 1 : +K);
      var fe = [];
      return de.paragraphs.forEach(function(me) {
        var ye = Math.max(re, me.start), ae = Math.min(K, me.end);
        if (ye < ae) {
          for (var Fe = de.levels.slice(ye, ae + 1), he = ae; he >= ye && d(te[he]) & l; he--)
            Fe[he] = me.level;
          for (var pe = me.level, Ie = 1 / 0, Ge = 0; Ge < Fe.length; Ge++) {
            var Se = Fe[Ge];
            Se > pe && (pe = Se), Se < Ie && (Ie = Se | 1);
          }
          for (var ot = pe; ot >= Ie; ot--)
            for (var be = 0; be < Fe.length; be++)
              if (Fe[be] >= ot) {
                for (var De = be; be + 1 < Fe.length && Fe[be + 1] >= ot; )
                  be++;
                be > De && fe.push([De + ye, be + ye]);
              }
        }
      }), fe;
    }
    function ee(te, de, re, K) {
      var Ce = xe(te, de, re, K), fe = [].concat(te);
      return Ce.forEach(function(me, ye) {
        fe[ye] = (de.levels[me] & 1 ? ne(te[me]) : null) || te[me];
      }), fe.join("");
    }
    function xe(te, de, re, K) {
      for (var Ce = Q(te, de, re, K), fe = [], me = 0; me < te.length; me++)
        fe[me] = me;
      return Ce.forEach(function(ye) {
        for (var ae = ye[0], Fe = ye[1], he = fe.slice(ae, Fe + 1), pe = he.length; pe--; )
          fe[Fe - pe] = he[pe];
      }), fe;
    }
    return e.closingToOpeningBracket = N, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = w, e.getEmbeddingLevels = ue, e.getMirroredCharacter = ne, e.getMirroredCharactersMap = Z, e.getReorderSegments = Q, e.getReorderedIndices = xe, e.getReorderedString = ee, e.openingToClosingBracket = v, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
const n1 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function iu(c) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, n) {
    let s = bm[n];
    return s ? iu(s) : r;
  }
  return c.replace(e, t);
}
const Wt = [];
for (let c = 0; c < 256; c++)
  Wt[c] = (c < 16 ? "0" : "") + c.toString(16);
function VS() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Wt[c & 255] + Wt[c >> 8 & 255] + Wt[c >> 16 & 255] + Wt[c >> 24 & 255] + "-" + Wt[e & 255] + Wt[e >> 8 & 255] + "-" + Wt[e >> 16 & 15 | 64] + Wt[e >> 24 & 255] + "-" + Wt[t & 63 | 128] + Wt[t >> 8 & 255] + "-" + Wt[t >> 16 & 255] + Wt[t >> 24 & 255] + Wt[r & 255] + Wt[r >> 8 & 255] + Wt[r >> 16 & 255] + Wt[r >> 24 & 255]).toUpperCase();
}
const cr = Object.assign || function() {
  let c = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (c[n] = r[n]);
  }
  return c;
}, jS = Date.now(), up = /* @__PURE__ */ new WeakMap(), hp = /* @__PURE__ */ new Map();
let WS = 1e10;
function au(c, e) {
  const t = qS(e);
  let r = up.get(c);
  if (r || up.set(c, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const n = `_onBeforeCompile${t}`, s = function(l, u) {
    c.onBeforeCompile.call(this, l, u);
    const h = this.customProgramCacheKey() + "|" + l.vertexShader + "|" + l.fragmentShader;
    let d = hp[h];
    if (!d) {
      const f = HS(this, l, e, t);
      d = hp[h] = f;
    }
    l.vertexShader = d.vertexShader, l.fragmentShader = d.fragmentShader, cr(l.uniforms, this.uniforms), e.timeUniform && (l.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - jS;
      }
    }), this[n] && this[n](l);
  }, o = function() {
    return i(e.chained ? c : c.clone());
  }, i = function(l) {
    const u = Object.create(l, a);
    return Object.defineProperty(u, "baseMaterial", { value: c }), Object.defineProperty(u, "id", { value: WS++ }), u.uuid = VS(), u.uniforms = cr({}, l.uniforms, e.uniforms), u.defines = cr({}, l.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = cr({}, l.extensions, e.extensions), u._listeners = void 0, u;
  }, a = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return c.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(l) {
        this[n] = l;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(l) {
        return c.copy.call(this, l), !c.isShaderMaterial && !c.isDerivedMaterial && (cr(this.extensions, l.extensions), cr(this.defines, l.defines), cr(this.uniforms, nr.clone(l.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const l = new c.constructor();
        return i(l).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._depthMaterial;
        return l || (l = this._depthMaterial = au(
          c.isDerivedMaterial ? c.getDepthMaterial() : new Mx({ depthPacking: Ax }),
          e
        ), l.defines.IS_DEPTH_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._distanceMaterial;
        return l || (l = this._distanceMaterial = au(
          c.isDerivedMaterial ? c.getDistanceMaterial() : new Cx(),
          e
        ), l.defines.IS_DISTANCE_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: l, _distanceMaterial: u } = this;
        l && l.dispose(), u && u.dispose(), c.dispose.call(this);
      }
    }
  };
  return r[t] = o, new o();
}
function HS(c, { vertexShader: e, fragmentShader: t }, r, n) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: i,
    vertexTransform: a,
    fragmentDefs: l,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: p
  } = r;
  if (s = s || "", o = o || "", i = i || "", l = l || "", u = u || "", h = h || "", (a || f) && (e = iu(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = iu(t)), f) {
    let m = f({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (d) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (m.push(g), "")
    ), h = `${d}
${m.join(`
`)}
${h}`;
  }
  if (p) {
    const m = `
uniform float ${p};
`;
    s = m + s, l = m + l;
  }
  return a && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, s = `${s}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${a}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, g, b, x) => /\battribute\s+vec[23]\s+$/.test(x.substr(0, b)) ? g : `troika_${g}_${n}`), c.map && c.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = dp(e, n, s, o, i), t = dp(t, n, l, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function dp(c, e, t, r, n) {
  return (r || n || t) && (c = c.replace(
    n1,
    `
${t}
void troikaOrigMain${e}() {`
  ), c += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${n}
}`), c;
}
function XS(c, e) {
  return c === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let $S = 0;
const fp = /* @__PURE__ */ new Map();
function qS(c) {
  const e = JSON.stringify(c, XS);
  let t = fp.get(e);
  return t == null && fp.set(e, t = ++$S), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function JS() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var x = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, x, m), f.FDArray.push(x);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var v = i.readUshort(n, s);
        for (s += 2, u = 0; u < v + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, x = 15 & g;
            if (b != 15 && m.push(b), x != 15 && m.push(x), x == 15)
              break;
          }
          for (var y = "", v = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += v[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var x = i.readUshort(n, p);
          x == 0 ? b = e.cmap.parse0(n, p) : x == 4 ? b = e.cmap.parse4(n, p) : x == 6 ? b = e.cmap.parse6(n, p) : x == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + x, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var x = 0, y = 0;
        for (u = 0; u < d; u++)
          x += l.xs[u], y += l.ys[u], l.xs[u] = x, l.ys[u] = y;
      } else {
        var v;
        l.parts = [];
        do {
          v = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & v) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & v ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & v ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & v ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & v && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & v);
        if (256 & v) {
          var S = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < S; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var x = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, x);
            x += 2;
            for (var v = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, x);
              x += 2, d != 0 && (_ = e.GPOS.readValueRecord(n, x, d), x += 2 * f), p != 0 && (L = e.GPOS.readValueRecord(n, x, p), x += 2 * m), v.push({ gid2: w, val1: _, val2: L });
            }
            u.pairsets.push(v);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var S = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          o += 2;
          var R = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + S), u.matrix = [], b = 0; b < A; b++) {
            var O = [];
            for (N = 0; N < R; N++) {
              var _ = null, L = null;
              d != 0 && (_ = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (L = e.GPOS.readValueRecord(n, o, p), o += 2 * m), O.push({ val1: _, val2: L });
            }
            u.matrix.push(O);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var x = [], y = 0; y < d; y++)
              x.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = x), f == 1 && (u.inptCvg = x), f == 2 && (u.ahedCvg = x);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var v = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = v;
          else if (i.ltype != v)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var x = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var v, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          v = i.readUnicode(n, w, x / 2);
        else if (p == 3 && m == 0)
          v = i.readUnicode(n, w, x / 2);
        else if (m == 0)
          v = i.readASCII(n, w, x);
        else if (m == 1)
          v = i.readUnicode(n, w, x / 2);
        else if (m == 3)
          v = i.readUnicode(n, w, x / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          v = i.readASCII(n, w, x), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = v, a[T]._lang = g;
      }
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 1033)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 0)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 3084)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null)
          return a[S];
      for (var S in a) {
        u = S;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, x = m.tabs[g];
                    if ((!x.coverage || (b = e._lctf.coverageIndex(x.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (x.fmt == 1) {
                          var v = x.pairsets[b];
                          for (d = 0; d < v.length; d++)
                            v[d].gid2 == o && (y = v[d]);
                        } else if (x.fmt == 2) {
                          var N = e.U._getGlyphClass(s, x.classDef1), w = e.U._getGlyphClass(o, x.classDef2);
                          y = x.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var S = n.kern.glyph1.indexOf(s);
        if (S != -1) {
          var A = n.kern.rval[S].glyph2.indexOf(o);
          if (A != -1)
            return n.kern.rval[S].vals[A];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, x = 0; x < m; x++) {
                    for (; n[s + b + (1 + x)] == -1; )
                      b++;
                    p.chain[x] != n[s + b + (1 + x)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, x = 0; x < m + b; x++)
                      n[s + x + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), v = h.cDef[y + 2], N = h.scset[v], w = 0; w < N.length; w++) {
                var T = N[w], S = T.input;
                if (!(S.length > a)) {
                  for (g = !0, x = 0; x < S.length; x++) {
                    var A = e._lctf.getInterval(h.cDef, n[s + 1 + x]);
                    if (y == -1 && h.cDef[A + 2] != S[x]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var R = T.substLookupRecords;
                    for (f = 0; f < R.length; f += 2)
                      R[f], R[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var O = h.lookupRec;
              for (w = 0; w < O.length; w += 2) {
                y = O[w];
                var _ = i[O[w + 1]];
                e.U._applySubs(n, s + y, _, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, x = 0, y = 0, v = 0, N = 0, w = 0, T = 0, S = 0, A = 0, R = 0, O = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, O);
        var _ = O.val;
        if (p += O.size, _ == "o1" || _ == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (_ == "o3" || _ == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (_ == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (_ == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (_ == "o6" || _ == "o7")
          for (var L = l.length, E = _ == "o6", D = 0; D < L; D++) {
            var F = l.shift();
            E ? m += F : g += F, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (_ == "o8" || _ == "o24") {
          L = l.length;
          for (var H = 0; H + 6 <= L; )
            b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g), H += 6;
          _ == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (_ == "o11")
            break;
          if (_ == "o1234" || _ == "o1235" || _ == "o1236" || _ == "o1237")
            _ == "o1234" && (x = g, y = (b = m + l.shift()) + l.shift(), R = v = x + l.shift(), w = v, S = g, m = (T = (N = (A = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1235" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), A = y + l.shift(), R = v + l.shift(), N = A + l.shift(), w = R + l.shift(), T = N + l.shift(), S = w + l.shift(), m = T + l.shift(), g = S + l.shift(), l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1236" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), R = v = x + l.shift(), w = v, T = (N = (A = y + l.shift()) + l.shift()) + l.shift(), S = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1237" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), A = y + l.shift(), R = v + l.shift(), N = A + l.shift(), w = R + l.shift(), T = N + l.shift(), S = w + l.shift(), Math.abs(T - m) > Math.abs(S - g) ? m = T + l.shift() : g = S + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g));
          else if (_ == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var q = l.shift(), U = l.shift(), k = l.shift(), C = l.shift(), P = e.CFF.glyphBySE(o, k), X = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[P], s, o, i, a), s.x = q, s.y = U, e.U._drawCFF(o.CharStrings[X], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (_ == "o19" || _ == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (_ == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (_ == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (_ == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g);
          } else if (_ == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, x = g + l.shift(), m = y = b + l.shift(), g = (v = x + l.shift()) + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g);
          else if (_ == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              x = g, y = (b = m + l.shift()) + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v, e.U.P.curveTo(a, b, x, y, v, m, g);
          else if (_ == "o10" || _ == "o29") {
            var Y = _ == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var W = l.pop(), ie = Y.Subrs[W + Y.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(ie, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (_ == "o30" || _ == "o31") {
            var J = l.length, se = (H = 0, _ == "o31");
            for (H += J - (L = -3 & J); H < L; )
              se ? (x = g, y = (b = m + l.shift()) + l.shift(), g = (v = x + l.shift()) + l.shift(), L - H == 5 ? (m = y + l.shift(), H++) : m = y, se = !1) : (b = m, x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), L - H == 5 ? (g = v + l.shift(), H++) : g = v, se = !0), e.U.P.curveTo(a, b, x, y, v, m, g), H += 4;
          } else {
            if ((_ + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + _, n), _;
            l.push(_);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function YS() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(_, L) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = L += 1 << _[D - 1];
      var F = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var H = E[D]; H < E[D + 1]; ++H)
          F[H] = H - E[D] << 5 | D;
      return [E, F];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(_, L, E) {
      for (var D = _.length, F = 0, H = new t(L); F < D; ++F)
        ++H[_[F] - 1];
      var q, U = new t(L);
      for (F = 0; F < L; ++F)
        U[F] = U[F - 1] + H[F - 1] << 1;
      if (E) {
        q = new t(1 << L);
        var k = 15 - L;
        for (F = 0; F < D; ++F)
          if (_[F])
            for (var C = F << 4 | _[F], P = L - _[F], X = U[_[F] - 1]++ << P, Y = X | (1 << P) - 1; X <= Y; ++X)
              q[d[X] >>> k] = C;
      } else
        for (q = new t(D), F = 0; F < D; ++F)
          _[F] && (q[F] = d[U[_[F] - 1]++] >>> 15 - _[F]);
      return q;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var x = m(g, 9, 1), y = m(b, 5, 1), v = function(_) {
      for (var L = _[0], E = 1; E < _.length; ++E)
        _[E] > L && (L = _[E]);
      return L;
    }, N = function(_, L, E) {
      var D = L / 8 | 0;
      return (_[D] | _[D + 1] << 8) >> (7 & L) & E;
    }, w = function(_, L) {
      var E = L / 8 | 0;
      return (_[E] | _[E + 1] << 8 | _[E + 2] << 16) >> (7 & L);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], S = function(_, L, E) {
      var D = new Error(L || T[_]);
      if (D.code = _, Error.captureStackTrace && Error.captureStackTrace(D, S), !E)
        throw D;
      return D;
    }, A = function(_, L, E) {
      var D = _.length;
      if (!D || E && !E.l && D < 5)
        return L || new e(0);
      var F = !L || E, H = !E || E.i;
      E || (E = {}), L || (L = new e(3 * D));
      var q, U = function(De) {
        var Xe = L.length;
        if (De > Xe) {
          var We = new e(Math.max(2 * Xe, De));
          We.set(L), L = We;
        }
      }, k = E.f || 0, C = E.p || 0, P = E.b || 0, X = E.l, Y = E.d, W = E.m, ie = E.n, J = 8 * D;
      do {
        if (!X) {
          E.f = k = N(_, C, 1);
          var se = N(_, C + 1, 3);
          if (C += 3, !se) {
            var ue = _[(re = ((q = C) / 8 | 0) + (7 & q && 1) + 4) - 4] | _[re - 3] << 8, le = re + ue;
            if (le > D) {
              H && S(0);
              break;
            }
            F && U(P + ue), L.set(_.subarray(re, le), P), E.b = P += ue, E.p = C = 8 * le;
            continue;
          }
          if (se == 1)
            X = x, Y = y, W = 9, ie = 5;
          else if (se == 2) {
            var $ = N(_, C, 31) + 257, I = N(_, C + 10, 15) + 4, ne = $ + N(_, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(ne), Q = new e(19), ee = 0; ee < I; ++ee)
              Q[o[ee]] = N(_, C + 3 * ee, 7);
            C += 3 * I;
            var xe = v(Q), te = (1 << xe) - 1, de = m(Q, xe, 1);
            for (ee = 0; ee < ne; ) {
              var re, K = de[N(_, C, te)];
              if (C += 15 & K, (re = K >>> 4) < 16)
                Z[ee++] = re;
              else {
                var Ce = 0, fe = 0;
                for (re == 16 ? (fe = 3 + N(_, C, 3), C += 2, Ce = Z[ee - 1]) : re == 17 ? (fe = 3 + N(_, C, 7), C += 3) : re == 18 && (fe = 11 + N(_, C, 127), C += 7); fe--; )
                  Z[ee++] = Ce;
              }
            }
            var me = Z.subarray(0, $), ye = Z.subarray($);
            W = v(me), ie = v(ye), X = m(me, W, 1), Y = m(ye, ie, 1);
          } else
            S(1);
          if (C > J) {
            H && S(0);
            break;
          }
        }
        F && U(P + 131072);
        for (var ae = (1 << W) - 1, Fe = (1 << ie) - 1, he = C; ; he = C) {
          var pe = (Ce = X[w(_, C) & ae]) >>> 4;
          if ((C += 15 & Ce) > J) {
            H && S(0);
            break;
          }
          if (Ce || S(2), pe < 256)
            L[P++] = pe;
          else {
            if (pe == 256) {
              he = C, X = null;
              break;
            }
            var Ie = pe - 254;
            if (pe > 264) {
              var Ge = n[ee = pe - 257];
              Ie = N(_, C, (1 << Ge) - 1) + l[ee], C += Ge;
            }
            var Se = Y[w(_, C) & Fe], ot = Se >>> 4;
            if (Se || S(3), C += 15 & Se, ye = h[ot], ot > 3 && (Ge = s[ot], ye += w(_, C) & (1 << Ge) - 1, C += Ge), C > J) {
              H && S(0);
              break;
            }
            F && U(P + 131072);
            for (var be = P + Ie; P < be; P += 4)
              L[P] = L[P - ye], L[P + 1] = L[P + 1 - ye], L[P + 2] = L[P + 2 - ye], L[P + 3] = L[P + 3 - ye];
            P = be;
          }
        }
        E.l = X, E.p = he, E.b = P, X && (k = 1, E.m = W, E.d = Y, E.n = ie);
      } while (!k);
      return P == L.length ? L : function(De, Xe, We) {
        (Xe == null || Xe < 0) && (Xe = 0), (We == null || We > De.length) && (We = De.length);
        var lt = new (De instanceof t ? t : De instanceof r ? r : e)(We - Xe);
        return lt.set(De.subarray(Xe, We)), lt;
      }(L, 0, P);
    }, R = new e(0), O = typeof TextDecoder < "u" && new TextDecoder();
    try {
      O.decode(R, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(_) {
      var L = new DataView(_), E = 0;
      function D() {
        var $ = L.getUint16(E);
        return E += 2, $;
      }
      function F() {
        var $ = L.getUint32(E);
        return E += 4, $;
      }
      function H($) {
        ue.setUint16(le, $), le += 2;
      }
      function q($) {
        ue.setUint32(le, $), le += 4;
      }
      for (var U = { signature: F(), flavor: F(), length: F(), numTables: D(), reserved: D(), totalSfntSize: F(), majorVersion: D(), minorVersion: D(), metaOffset: F(), metaLength: F(), metaOrigLength: F(), privOffset: F(), privLength: F() }, k = 0; Math.pow(2, k) <= U.numTables; )
        k++;
      k--;
      for (var C = 16 * Math.pow(2, k), P = 16 * U.numTables - C, X = 12, Y = [], W = 0; W < U.numTables; W++)
        Y.push({ tag: F(), offset: F(), compLength: F(), origLength: F(), origChecksum: F() }), X += 16;
      var ie, J = new Uint8Array(12 + 16 * Y.length + Y.reduce(function($, I) {
        return $ + I.origLength + 4;
      }, 0)), se = J.buffer, ue = new DataView(se), le = 0;
      return q(U.flavor), H(U.numTables), H(C), H(k), H(P), Y.forEach(function($) {
        q($.tag), q($.origChecksum), q(X), q($.origLength), $.outOffset = X, (X += $.origLength) % 4 != 0 && (X += 4 - X % 4);
      }), Y.forEach(function($) {
        var I, ne = _.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          I = new Uint8Array(ne, 2), A(I, Z);
        } else
          Z = new Uint8Array(ne);
        J.set(Z, $.outOffset);
        var Q = 0;
        (X = $.outOffset + $.origLength) % 4 != 0 && (Q = 4 - X % 4), J.set(new Uint8Array(Q).buffer, $.outOffset + $.origLength), ie = X + Q;
      }), se.slice(0, ie);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function KS(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let S = 0;
        r[T].split(",").forEach((A) => {
          let [R, O] = A.split("+");
          R = parseInt(R, 36), O = O ? parseInt(O, 36) : 0, u.set(S += R, w[T]);
          for (let _ = O; _--; )
            u.set(++S, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, S = d, A = -1;
    for (let R = 0; R < N.length; R++) {
      const O = N.codePointAt(R);
      let _ = h(O) | 0, L = d;
      _ & i || (T & (n | o | a) ? _ & (s | o | a) ? (L = p, (S === d || S === p) && w[A]++) : _ & (n | l) && (S === f || S === m) && w[A]-- : T & (s | l) && (S === f || S === m) && w[A]--, S = w[R] = L, T = _, A = R, O > 65535 && R++);
    }
    return w;
  }
  function x(N, w) {
    const T = [];
    for (let A = 0; A < w.length; A++) {
      const R = w.codePointAt(A);
      R > 65535 && A++, T.push(c.U.codeToGlyph(N, R));
    }
    const S = N.GSUB;
    if (S) {
      const { lookupList: A, featureList: R } = S;
      let O;
      const _ = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, L = [];
      R.forEach((E) => {
        if (_.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (L[E.tab[D]])
              continue;
            L[E.tab[D]] = !0;
            const F = A[E.tab[D]], H = /^(isol|init|fina|medi)$/.test(E.tag);
            H && !O && (O = b(w));
            for (let q = 0; q < T.length; q++)
              (!O || !H || g[O[q]] === E.tag) && c.U._applySubs(T, q, F, A);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function v(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], S = N.hhea, A = N.head.unitsPerEm, R = y(T && T.sTypoAscender, S && S.ascender, A), O = {
      unitsPerEm: A,
      ascender: R,
      descender: y(T && T.sTypoDescender, S && S.descender, 0),
      capHeight: y(T && T.sCapHeight, R),
      xHeight: y(T && T.sxHeight, R),
      lineGap: y(T && T.sTypoLineGap, S && S.lineGap),
      supportsCodePoint(_) {
        return c.U.codeToGlyph(N, _) > 0;
      },
      forEachGlyph(_, L, E, D) {
        let F = 0;
        const H = 1 / O.unitsPerEm * L, q = x(N, _);
        let U = 0, k = -1;
        return q.forEach((C, P) => {
          if (C !== -1) {
            let X = w[C];
            if (!X) {
              const { cmds: Y, crds: W } = c.U.glyphToPath(N, C);
              let ie = "", J = 0;
              for (let I = 0, ne = Y.length; I < ne; I++) {
                const Z = t[Y[I]];
                ie += Y[I];
                for (let Q = 1; Q <= Z; Q++)
                  ie += (Q > 1 ? "," : "") + W[J++];
              }
              let se, ue, le, $;
              if (W.length) {
                se = ue = 1 / 0, le = $ = -1 / 0;
                for (let I = 0, ne = W.length; I < ne; I += 2) {
                  let Z = W[I], Q = W[I + 1];
                  Z < se && (se = Z), Q < ue && (ue = Q), Z > le && (le = Z), Q > $ && ($ = Q);
                }
              } else
                se = le = ue = $ = 0;
              X = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: se,
                yMin: ue,
                xMax: le,
                yMax: $,
                path: ie,
                pathCommandCount: Y.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            k !== -1 && (F += c.U.getPairAdjustment(N, k, C) * H), D.call(null, X, F, U), X.advanceWidth && (F += X.advanceWidth * H), E && (F += E * L), k = C;
          }
          U += _.codePointAt(U) > 65535 ? 2 : 1;
        }), F;
      }
    };
    return O;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), S = c._bin.readASCII(T, 0, 4);
    if (S === "wOFF")
      w = e(w);
    else if (S === "wOF2")
      throw new Error("woff2 fonts not supported");
    return v(c.parse(w)[0]);
  };
}
const ZS = /* @__PURE__ */ hs({
  name: "Typr Font Parser",
  dependencies: [JS, YS, KS],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v0.3.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function QS() {
  return function(c) {
    class e {
      constructor() {
        this.buckets = /* @__PURE__ */ new Map();
      }
      add(v) {
        const N = v >> 5;
        this.buckets.set(N, (this.buckets.get(N) || 0) | 1 << (31 & v));
      }
      has(v) {
        const N = this.buckets.get(v >> 5);
        return N !== void 0 && (N & 1 << (31 & v)) != 0;
      }
      serialize() {
        const v = [];
        return this.buckets.forEach((N, w) => {
          v.push(`${(+w).toString(36)}:${N.toString(36)}`);
        }), v.join(",");
      }
      deserialize(v) {
        this.buckets.clear(), v.split(",").forEach((N) => {
          const w = N.split(":");
          this.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
        });
      }
    }
    const t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      const v = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return `codepoint-index/plane${y >> 16}/${v}-${N}.json`;
    }
    function o(y, v) {
      const N = y & r;
      let w = v.codePointAt(N / 6 | 0);
      return w = (w || 48) - 48, (w & 1 << N % 6) != 0;
    }
    function i(y, v) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map((w) => w.split("-").map((T) => parseInt(T.trim(), 16)))).forEach(([w, T = w]) => {
        v(w, T);
      });
    }
    function a(y, v) {
      i(y, (N, w) => {
        for (let T = N; T <= w; T++)
          v(T);
      });
    }
    let l = {}, u = {};
    const h = /* @__PURE__ */ new WeakMap();
    function d(y) {
      let v = h.get(y);
      return v || (v = new e(), a(y.ranges, (N) => v.add(N)), h.set(y, v)), v;
    }
    const f = /* @__PURE__ */ new Map();
    function p(y) {
      let v = f.get(y);
      return v || (v = fetch(y).then((N) => N.json()), f.set(y, v)), v;
    }
    function m(y, v, N) {
      return y[v] ? v : y[N] ? N : function(w) {
        for (const T in w)
          return T;
      }(y);
    }
    function g(y, v) {
      let N = v;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (let w = 0; w < y.length; w++)
          Math.abs(y[w] - v) < Math.abs(N - v) && (N = y[w]);
      }
      return N;
    }
    let b;
    function x(y) {
      return b || (b = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", (v) => {
        b.add(v);
      })), b.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, v = {}) {
      const { lang: N = "en", category: w = "sans-serif", style: T = "normal", weight: S = 400 } = v, A = (v.dataUrl || "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v0.3.2/packages/data").replace(/\/$/g, ""), R = /* @__PURE__ */ new Map(), O = new Uint8Array(y.length), _ = {}, L = {}, E = new Array(y.length), D = /* @__PURE__ */ new Map();
      for (let F = 0; F < y.length; F++) {
        const H = y.codePointAt(F), q = s(H);
        E[F] = q, l[q] || D.has(q) || D.set(q, p(`${A}/${q}`).then((U) => {
          l[q] = U;
        })), H > 65535 && F++;
      }
      return Promise.all(D.values()).then(() => {
        D.clear();
        for (let F = 0; F < y.length; F++) {
          const H = y.codePointAt(F);
          let q = null;
          const U = l[E[F]];
          e:
            for (let k in U) {
              let C = L[k];
              if (C === void 0 && (C = L[k] = new RegExp(k).test(N)), C) {
                for (let P in U[k])
                  if (o(H, U[k][P])) {
                    q = P;
                    break e;
                  }
              }
            }
          q || (console.debug(`No font coverage for U+${H.toString(16)}`), q = "latin"), E[F] = q, u[q] || D.has(q) || D.set(q, p(`${A}/font-meta/${q}.json`).then((k) => {
            u[q] = k;
          })), H > 65535 && F++;
        }
        return Promise.all(D.values());
      }).then(() => {
        var F;
        let H = null;
        for (let q = 0; q < y.length; q++) {
          const U = y.codePointAt(q);
          if (H && (x(U) || d(H).has(U)))
            O[q] = O[q - 1];
          else {
            H = u[E[q]];
            let k = _[H.id];
            if (!k) {
              const { typeforms: P } = H, X = m(P, w, "sans-serif"), Y = m(P[X], T, "normal"), W = g((F = P[X]) === null || F === void 0 ? void 0 : F[Y], S);
              k = _[H.id] = `${A}/font-files/${H.id}/${X}.${Y}.${W}.woff`;
            }
            let C = R.get(k);
            C == null && (C = R.size, R.set(k, C)), O[q] = C;
          }
          U > 65535 && (q++, O[q] = O[q - 1]);
        }
        return { fontUrls: Array.from(R.keys()), chars: O };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function e_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, { lang: a, fonts: l = [], style: u = "normal", weight: h = "normal" } = {}) {
    const d = new Uint8Array(o.length), f = [];
    o.length || b();
    const p = /* @__PURE__ */ new Map(), m = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((y) => !y.lang || y.lang.test(a)).reverse(), l.length) {
      let w = 0;
      (function T(S = 0) {
        for (let A = S, R = o.length; A < R; A++) {
          const O = o.codePointAt(A);
          if (w === 1 && f[d[A - 1]].supportsCodePoint(O) || /\s/.test(o[A]))
            d[A] = d[A - 1], w === 2 && (m[m.length - 1][1] = A);
          else
            for (let _ = d[A], L = l.length; _ <= L; _++)
              if (_ === L) {
                const E = w === 2 ? m[m.length - 1] : m[m.length] = [A, A];
                E[1] = A, w = 2;
              } else {
                d[A] = _;
                const { src: E, unicodeRange: D } = l[_];
                if (!D || x(O, D)) {
                  const F = t[E];
                  if (!F) {
                    s(E, () => {
                      T(A);
                    });
                    return;
                  }
                  if (F.supportsCodePoint(O)) {
                    let H = p.get(F);
                    typeof H != "number" && (H = f.length, f.push(F), p.set(F, H)), d[A] = H, w = 1;
                    break;
                  }
                }
              }
          O > 65535 && A + 1 < R && (d[A + 1] = d[A], A++, w === 2 && (m[m.length - 1][1] = A));
        }
        g();
      })();
    } else
      m.push([0, o.length - 1]), g();
    function g() {
      if (m.length) {
        const y = m.map((v) => o.substring(v[0], v[1] + 1)).join(`
`);
        e.getFontsForString(y, { lang: a, style: u, weight: h }).then(({ fontUrls: v, chars: N }) => {
          const w = f.length;
          let T = 0;
          m.forEach((A) => {
            for (let R = 0, O = A[1] - A[0]; R <= O; R++)
              d[A[0] + R] = N[T++] + w;
            T++;
          });
          let S = 0;
          v.forEach((A, R) => {
            s(A, (O) => {
              f[R + w] = O, ++S === v.length && b();
            });
          });
        });
      } else
        b();
    }
    function b() {
      i({
        chars: d,
        fonts: f
      });
    }
    function x(y, v) {
      for (let N = 0; N < v.length; N++) {
        const [w, T = w] = v[N];
        if (w <= y && y <= T)
          return !0;
      }
      return !1;
    }
  };
}
const t_ = /* @__PURE__ */ hs({
  name: "FontResolver",
  dependencies: [
    e_,
    ZS,
    QS
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function n_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: x, preResolvedFonts: y }, v) {
    const N = ({ chars: w, fonts: T }) => {
      let S, A;
      const R = [];
      for (let O = 0; O < w.length; O++)
        w[O] !== A ? (A = w[O], R.push(S = { start: O, end: O, fontObj: T[w[O]] })) : S.end = O;
      v(R);
    };
    y ? N(y) : c(
      p,
      N,
      { lang: m, fonts: g, style: b, weight: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g = "en",
    sdfGlyphSize: b = 64,
    fontSize: x = 400,
    fontWeight: y = 1,
    fontStyle: v = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: S,
    textAlign: A = "left",
    textIndent: R = 0,
    whiteSpace: O = "normal",
    overflowWrap: _ = "normal",
    anchorX: L = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    preResolvedFonts: F = null,
    includeCaretPositions: H = !1,
    chunkedBoundsSize: q = 8192,
    colorRanges: U = null
  }, k) {
    const C = h(), P = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), x = +x, N = +N, T = +T, w = w || "normal", R = +R, o({
      text: p,
      lang: g,
      style: v,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      preResolvedFonts: F
    }, (X) => {
      P.fontLoad = h() - C;
      const Y = isFinite(T);
      let W = null, ie = null, J = null, se = null, ue = null, le = null, $ = null, I = null, ne = 0, Z = 0, Q = O !== "nowrap";
      const ee = /* @__PURE__ */ new Map(), xe = h();
      let te = R, de = 0, re = new d();
      const K = [re];
      X.forEach((ae) => {
        const { fontObj: Fe } = ae, { ascender: he, descender: pe, unitsPerEm: Ie, lineGap: Ge, capHeight: Se, xHeight: ot } = Fe;
        let be = ee.get(Fe);
        if (!be) {
          const ve = x / Ie, Te = w === "normal" ? (he - pe + Ge) * ve : w * x, Dt = (Te - (he - pe) * ve) / 2, Ae = Math.min(Te, (he - pe) * ve), Le = (he + pe) / 2 * ve + Ae / 2;
          be = {
            index: ee.size,
            src: Fe.src,
            fontObj: Fe,
            fontSizeMult: ve,
            unitsPerEm: Ie,
            ascender: he * ve,
            descender: pe * ve,
            capHeight: Se * ve,
            xHeight: ot * ve,
            lineHeight: Te,
            baseline: -Dt - he * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (he + pe) / 2 * ve + Ae / 2,
            caretBottom: Le - Ae
          }, ee.set(Fe, be);
        }
        const { fontSizeMult: De } = be, Xe = p.slice(ae.start, ae.end + 1);
        let We, lt;
        Fe.forEachGlyph(Xe, x, N, (ve, Te, Dt) => {
          Te += de, Dt += ae.start, We = Te, lt = ve;
          const Ae = p.charAt(Dt), Le = ve.advanceWidth * De, nt = re.count;
          let Ve;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ae && new RegExp(n).test(Ae), ve.canBreakAfter = !!Ae && s.test(Ae), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || r.test(Ae)), !ve.isWhitespace && !ve.isEmpty && Z++, Q && Y && !ve.isWhitespace && Te + Le + te > T && nt) {
            if (re.glyphAt(nt - 1).glyphObj.canBreakAfter)
              Ve = new d(), te = -Te;
            else
              for (let ze = nt; ze--; )
                if (ze === 0 && _ === "break-word") {
                  Ve = new d(), te = -Te;
                  break;
                } else if (re.glyphAt(ze).glyphObj.canBreakAfter) {
                  Ve = re.splitAt(ze + 1);
                  const ht = Ve.glyphAt(0).x;
                  te -= ht;
                  for (let it = Ve.count; it--; )
                    Ve.glyphAt(it).x -= ht;
                  break;
                }
            Ve && (re.isSoftWrapped = !0, re = Ve, K.push(re), ne = T);
          }
          let we = re.glyphAt(re.count);
          we.glyphObj = ve, we.x = Te + te, we.width = Le, we.charIndex = Dt, we.fontData = be, Ae === `
` && (re = new d(), K.push(re), te = -(Te + Le + N * x) + R);
        }), de = We + lt.advanceWidth * De + N * x;
      });
      let Ce = 0;
      K.forEach((ae) => {
        let Fe = !0;
        for (let he = ae.count; he--; ) {
          const pe = ae.glyphAt(he);
          Fe && !pe.glyphObj.isWhitespace && (ae.width = pe.x + pe.width, ae.width > ne && (ne = ae.width), Fe = !1);
          let { lineHeight: Ie, capHeight: Ge, xHeight: Se, baseline: ot } = pe.fontData;
          Ie > ae.lineHeight && (ae.lineHeight = Ie);
          const be = ot - ae.baseline;
          be < 0 && (ae.baseline += be, ae.cap += be, ae.ex += be), ae.cap = Math.max(ae.cap, ae.baseline + Ge), ae.ex = Math.max(ae.ex, ae.baseline + Se);
        }
        ae.baseline -= Ce, ae.cap -= Ce, ae.ex -= Ce, Ce += ae.lineHeight;
      });
      let fe = 0, me = 0;
      if (L && (typeof L == "number" ? fe = -L : typeof L == "string" && (fe = -ne * (L === "left" ? 0 : L === "center" ? 0.5 : L === "right" ? 1 : l(L)))), E && (typeof E == "number" ? me = -E : typeof E == "string" && (me = E === "top" ? 0 : E === "top-baseline" ? -K[0].baseline : E === "top-cap" ? -K[0].cap : E === "top-ex" ? -K[0].ex : E === "middle" ? Ce / 2 : E === "bottom" ? Ce : E === "bottom-baseline" ? K[K.length - 1].baseline : l(E) * Ce)), !D) {
        const ae = e.getEmbeddingLevels(p, S);
        W = new Uint16Array(Z), ie = new Uint8Array(Z), J = new Float32Array(Z * 2), se = {}, $ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], I = [], H && (le = new Float32Array(p.length * 4)), U && (ue = new Uint8Array(Z * 3));
        let Fe = 0, he = -1, pe = -1, Ie, Ge;
        if (K.forEach((Se, ot) => {
          let { count: be, width: De } = Se;
          if (be > 0) {
            let Xe = 0;
            for (let Ae = be; Ae-- && Se.glyphAt(Ae).glyphObj.isWhitespace; )
              Xe++;
            let We = 0, lt = 0;
            if (A === "center")
              We = (ne - De) / 2;
            else if (A === "right")
              We = ne - De;
            else if (A === "justify" && Se.isSoftWrapped) {
              let Ae = 0;
              for (let Le = be - Xe; Le--; )
                Se.glyphAt(Le).glyphObj.isWhitespace && Ae++;
              lt = (ne - De) / Ae;
            }
            if (lt || We) {
              let Ae = 0;
              for (let Le = 0; Le < be; Le++) {
                let nt = Se.glyphAt(Le);
                const Ve = nt.glyphObj;
                nt.x += We + Ae, lt !== 0 && Ve.isWhitespace && Le < be - Xe && (Ae += lt, nt.width += lt);
              }
            }
            const ve = e.getReorderSegments(
              p,
              ae,
              Se.glyphAt(0).charIndex,
              Se.glyphAt(Se.count - 1).charIndex
            );
            for (let Ae = 0; Ae < ve.length; Ae++) {
              const [Le, nt] = ve[Ae];
              let Ve = 1 / 0, we = -1 / 0;
              for (let ze = 0; ze < be; ze++)
                if (Se.glyphAt(ze).charIndex >= Le) {
                  let ht = ze, it = ze;
                  for (; it < be; it++) {
                    let et = Se.glyphAt(it);
                    if (et.charIndex > nt)
                      break;
                    it < be - Xe && (Ve = Math.min(Ve, et.x), we = Math.max(we, et.x + et.width));
                  }
                  for (let et = ht; et < it; et++) {
                    const Gt = Se.glyphAt(et);
                    Gt.x = we - (Gt.x + Gt.width - Ve);
                  }
                  break;
                }
            }
            let Te;
            const Dt = (Ae) => Te = Ae;
            for (let Ae = 0; Ae < be; Ae++) {
              const Le = Se.glyphAt(Ae);
              Te = Le.glyphObj;
              const nt = Te.index, Ve = ae.levels[Le.charIndex] & 1;
              if (Ve) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, Dt);
              }
              if (H) {
                const { charIndex: we, fontData: ze } = Le, ht = Le.x + fe, it = Le.x + Le.width + fe;
                le[we * 4] = Ve ? it : ht, le[we * 4 + 1] = Ve ? ht : it, le[we * 4 + 2] = Se.baseline + ze.caretBottom + me, le[we * 4 + 3] = Se.baseline + ze.caretTop + me;
                const et = we - he;
                et > 1 && u(le, he, et), he = we;
              }
              if (U) {
                const { charIndex: we } = Le;
                for (; we > pe; )
                  pe++, U.hasOwnProperty(pe) && (Ge = U[pe]);
              }
              if (!Te.isWhitespace && !Te.isEmpty) {
                const we = Fe++, { fontSizeMult: ze, src: ht, index: it } = Le.fontData, et = se[ht] || (se[ht] = {});
                et[nt] || (et[nt] = {
                  path: Te.path,
                  pathBounds: [Te.xMin, Te.yMin, Te.xMax, Te.yMax]
                });
                const Gt = Le.x + fe, jn = Se.baseline + me;
                J[we * 2] = Gt, J[we * 2 + 1] = jn;
                const cn = Gt + Te.xMin * ze, ln = jn + Te.yMin * ze, Tn = Gt + Te.xMax * ze, On = jn + Te.yMax * ze;
                cn < $[0] && ($[0] = cn), ln < $[1] && ($[1] = ln), Tn > $[2] && ($[2] = Tn), On > $[3] && ($[3] = On), we % q === 0 && (Ie = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, I.push(Ie)), Ie.end++;
                const xt = Ie.rect;
                if (cn < xt[0] && (xt[0] = cn), ln < xt[1] && (xt[1] = ln), Tn > xt[2] && (xt[2] = Tn), On > xt[3] && (xt[3] = On), W[we] = nt, ie[we] = it, U) {
                  const un = we * 3;
                  ue[un] = Ge >> 16 & 255, ue[un + 1] = Ge >> 8 & 255, ue[un + 2] = Ge & 255;
                }
              }
            }
          }
        }), le) {
          const Se = p.length - he;
          Se > 1 && u(le, he, Se);
        }
      }
      const ye = [];
      ee.forEach(({ index: ae, src: Fe, unitsPerEm: he, ascender: pe, descender: Ie, lineHeight: Ge, capHeight: Se, xHeight: ot }) => {
        ye[ae] = { src: Fe, unitsPerEm: he, ascender: pe, descender: Ie, lineHeight: Ge, capHeight: Se, xHeight: ot };
      }), P.typesetting = h() - xe, k({
        glyphIds: W,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: ie,
        //index into fontData for each glyph
        glyphPositions: J,
        //x,y of each glyph's origin in layout
        glyphData: se,
        //dict holding data about each glyph appearing in the text
        fontData: ye,
        //data about each font used in the text
        caretPositions: le,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ue,
        //color for each glyph, if color ranges supplied
        chunkedBounds: I,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: x,
        //calculated em height
        topBaseline: me + K[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          fe,
          me - Ce,
          fe + ne,
          me
        ],
        visibleBounds: $,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: P
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, x, y, v] = g.blockBounds;
      m({
        width: y - b,
        height: v - x
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], x = p[m * 4 + 1], y = p[m * 4 + 2], v = p[m * 4 + 3], N = (x - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = v;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(x) {
      this.data[this.index * f.length + g] = x;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const yr = () => (self.performance || Date).now(), _c = /* @__PURE__ */ e1();
let pp;
function s_(c, e, t, r, n, s, o, i, a, l, u = !0) {
  return u ? o_(c, e, t, r, n, s, o, i, a, l).then(
    null,
    (h) => (pp || (console.warn("WebGL SDF generation failed, falling back to JS", h), pp = !0), gp(c, e, t, r, n, s, o, i, a, l))
  ) : gp(c, e, t, r, n, s, o, i, a, l);
}
const ba = [], r_ = 5;
let cu = 0;
function s1() {
  const c = yr();
  for (; ba.length && yr() - c < r_; )
    ba.shift()();
  cu = ba.length ? setTimeout(s1, 0) : 0;
}
const o_ = (...c) => new Promise((e, t) => {
  ba.push(() => {
    const r = yr();
    try {
      _c.webgl.generateIntoCanvas(...c), e({ timing: yr() - r });
    } catch (n) {
      t(n);
    }
  }), cu || (cu = setTimeout(s1, 0));
}), i_ = 4, a_ = 2e3, mp = {};
let c_ = 0;
function gp(c, e, t, r, n, s, o, i, a, l) {
  const u = "TroikaTextSDFGenerator_JS_" + c_++ % i_;
  let h = mp[u];
  return h || (h = mp[u] = {
    workerModule: hs({
      name: u,
      workerId: u,
      dependencies: [
        e1,
        yr
      ],
      init(d, f) {
        const p = d().javascript.generate;
        return function(...m) {
          const g = f();
          return {
            textureData: p(...m),
            timing: f() - g
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(c, e, t, r, n, s).then(({ textureData: d, timing: f }) => {
    const p = yr(), m = new Uint8Array(d.length * 4);
    for (let g = 0; g < d.length; g++)
      m[g * 4 + l] = d[g];
    return _c.webglUtils.renderImageData(o, m, i, a, c, e, 1 << 3 - l), f += yr() - p, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      kS(u);
    }, a_)), { timing: f };
  });
}
function l_(c) {
  c._warm || (_c.webgl.isSupported(c), c._warm = !0);
}
const u_ = _c.webglUtils.resizeWebGLCanvasWithoutClearing, Vo = {
  defaultFontURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, h_ = /* @__PURE__ */ new He();
function Or() {
  return (self.performance || Date).now();
}
const yp = /* @__PURE__ */ Object.create(null);
function d_(c, e) {
  c = p_({}, c);
  const t = Or(), { defaultFontURL: r } = Vo, n = [];
  if (r && n.push({ label: "default", src: vp(r) }), c.font && n.push({ label: "user", src: vp(c.font) }), c.font = n, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || Vo.sdfGlyphSize, c.colorRanges != null) {
    let d = {};
    for (let f in c.colorRanges)
      if (c.colorRanges.hasOwnProperty(f)) {
        let p = c.colorRanges[f];
        typeof p != "number" && (p = h_.set(p).getHex()), d[f] = p;
      }
    c.colorRanges = d;
  }
  Object.freeze(c);
  const { textureWidth: s, sdfExponent: o } = Vo, { sdfGlyphSize: i } = c, a = s / i * 4;
  let l = yp[i];
  if (!l) {
    const d = document.createElement("canvas");
    d.width = s, d.height = i * 256 / a, l = yp[i] = {
      glyphCount: 0,
      sdfGlyphSize: i,
      sdfCanvas: d,
      sdfTexture: new Gn(
        d,
        void 0,
        void 0,
        void 0,
        uo,
        uo
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, f_(l);
  }
  const { sdfTexture: u, sdfCanvas: h } = l;
  g_(c).then((d) => {
    const { glyphIds: f, glyphFontIndices: p, fontData: m, glyphPositions: g, fontSize: b, timings: x } = d, y = [], v = new Float32Array(f.length * 4);
    let N = 0, w = 0;
    const T = Or(), S = m.map((L) => {
      let E = l.glyphsByFont.get(L.src);
      return E || l.glyphsByFont.set(L.src, E = /* @__PURE__ */ new Map()), E;
    });
    f.forEach((L, E) => {
      const D = p[E], { src: F, unitsPerEm: H } = m[D];
      let q = S[D].get(L);
      if (!q) {
        const { path: X, pathBounds: Y } = d.glyphData[F][L], W = Math.max(Y[2] - Y[0], Y[3] - Y[1]) / i * (Vo.sdfMargin * i + 0.5), ie = l.glyphCount++, J = [
          Y[0] - W,
          Y[1] - W,
          Y[2] + W,
          Y[3] + W
        ];
        S[D].set(L, q = { path: X, atlasIndex: ie, sdfViewBox: J }), y.push(q);
      }
      const { sdfViewBox: U } = q, k = g[w++], C = g[w++], P = b / H;
      v[N++] = k + U[0] * P, v[N++] = C + U[1] * P, v[N++] = k + U[2] * P, v[N++] = C + U[3] * P, f[E] = q.atlasIndex;
    }), x.quads = (x.quads || 0) + (Or() - T);
    const A = Or();
    x.sdf = {};
    const R = h.height, O = Math.ceil(l.glyphCount / a), _ = Math.pow(2, Math.ceil(Math.log2(O * i)));
    _ > R && (console.info(`Increasing SDF texture size ${R}->${_}`), u_(h, s, _), u.dispose()), Promise.all(y.map(
      (L) => r1(L, l, c.gpuAccelerateSDF).then(({ timing: E }) => {
        x.sdf[L.atlasIndex] = E;
      })
    )).then(() => {
      y.length && !l.contextLost && (o1(l), u.needsUpdate = !0), x.sdfTotal = Or() - A, x.total = Or() - t, e(Object.freeze({
        parameters: c,
        sdfTexture: u,
        sdfGlyphSize: i,
        sdfExponent: o,
        glyphBounds: v,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || l_(h);
  });
}
function r1({ path: c, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: n, contextLost: s }, o) {
  if (s)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: i, sdfExponent: a } = Vo, l = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (i / r) * r, d = Math.floor(u / (i / r)) * r, f = e % 4;
  return s_(r, r, c, t, l, a, n, h, d, f, o);
}
function f_(c) {
  const e = c.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), c.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), c.contextLost = !1;
    const r = [];
    c.glyphsByFont.forEach((n) => {
      n.forEach((s) => {
        r.push(r1(s, c, !0));
      });
    }), Promise.all(r).then(() => {
      o1(c), c.sdfTexture.needsUpdate = !0;
    });
  });
}
function p_(c, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (c[t] = e[t]);
  return c;
}
let $i;
function vp(c) {
  return $i || ($i = typeof document > "u" ? {} : document.createElement("a")), $i.href = c, $i.href;
}
function o1(c) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = c, { width: r, height: n } = e, s = c.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== r * n * 4) && (o = new Uint8Array(r * n * 4), t.image = { width: r, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, r, n, s.RGBA, s.UNSIGNED_BYTE, o);
  }
}
const m_ = /* @__PURE__ */ hs({
  name: "Typesetter",
  dependencies: [
    n_,
    t_,
    t1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), g_ = /* @__PURE__ */ hs({
  name: "Typesetter",
  dependencies: [
    m_
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (let t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), xp = {};
function y_(c) {
  let e = xp[c];
  if (!e) {
    const t = new Tr(1, 1, c, c), r = t.clone(), n = t.attributes, s = r.attributes, o = new Ss(), i = n.uv.count;
    for (let a = 0; a < i; a++)
      s.position.array[a * 3] *= -1, s.normal.array[a * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((a) => {
      o.setAttribute(
        a,
        new yn(
          [...n[a].array, ...s[a].array],
          n[a].itemSize
        )
      );
    }), o.setIndex([...t.index.array, ...r.index.array.map((a) => a + i)]), o.translate(0.5, 0.5, 0), e = xp[c] = o;
  }
  return e;
}
const v_ = "aTroikaGlyphBounds", bp = "aTroikaGlyphIndex", x_ = "aTroikaGlyphColor";
class i1 extends ym {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new yi(), this.boundingBox = new tr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === bu ? t / 2 : 0, e === Su ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = y_(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, r, n, s) {
    dl(this, v_, e, 4), dl(this, bp, t, 1), dl(this, x_, s, 3), this._blockBounds = r, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: n, floor: s, min: o, max: i, sin: a, cos: l } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, p = e[2] / d, m = s((f + u) / h) !== s((p + u) / h) ? -d : o(a(f) * d, a(p) * d), g = s((f - u) / h) !== s((p - u) / h) ? d : i(a(f) * d, a(p) * d), b = s((f + n) / h) !== s((p + n) / h) ? d * 2 : i(d - l(f) * d, d - l(p) * d);
        r.min.set(m, e[1], t < 0 ? -b : 0), r.max.set(g, e[3], t < 0 ? 0 : b);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(bp).count, r = this._chunkedBounds;
    if (r)
      for (let n = r.length; n--; ) {
        t = r[n].end;
        let s = r[n].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function dl(c, e, t, r) {
  const n = c.getAttribute(e);
  t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (c.setAttribute(e, new Ex(t, r)), delete c._maxInstanceCount, c.dispose()) : n && c.deleteAttribute(e);
}
const b_ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, N_ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, w_ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, T_ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function S_(c) {
  const e = au(c, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Nt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new pt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new pt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Nt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new He() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new bs() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: b_,
    vertexTransform: N_,
    fragmentDefs: w_,
    fragmentColorTransform: T_,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(r) && (r = r.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        n1,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const kd = /* @__PURE__ */ new An({
  color: 16777215,
  side: Su,
  transparent: !0
}), Np = 8421504, wp = /* @__PURE__ */ new je(), qi = /* @__PURE__ */ new ge(), fl = /* @__PURE__ */ new ge(), Io = [], __ = /* @__PURE__ */ new ge(), pl = "+x+y";
function Tp(c) {
  return Array.isArray(c) ? c[0] : c;
}
let a1 = () => {
  const c = new Qt(
    new Tr(1, 1),
    kd
  );
  return a1 = () => c, c;
}, c1 = () => {
  const c = new Qt(
    new Tr(1, 1, 32, 1),
    kd
  );
  return c1 = () => c, c;
};
const M_ = { type: "syncstart" }, A_ = { type: "synccomplete" }, l1 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], C_ = l1.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class u1 extends Qt {
  constructor() {
    const e = new i1();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = "en", this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Np, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = pl, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(M_), d_({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((n) => n && n());
      })), this.dispatchEvent(A_), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, r, n, s, o) {
    this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s), s._hadOwnSide = s.hasOwnProperty("side"), this.geometry.setSide(s._actualSide = s.side), s.side = Nm;
  }
  onAfterRender(e, t, r, n, s, o) {
    s._hadOwnSide ? s.side = s._actualSide : delete s.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = kd.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = S_(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Tp(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Tp(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: i, blockBounds: a } = n;
      r.uTroikaSDFTexture.value = i, r.uTroikaSDFTextureSize.value.set(i.image.width, i.image.height), r.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, r.uTroikaSDFExponent.value = n.sdfExponent, r.uTroikaTotalBounds.value.fromArray(a), r.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let l = 0, u = 0, h = 0, d, f, p, m = 0, g = 0;
      if (t) {
        let { outlineWidth: x, outlineOffsetX: y, outlineOffsetY: v, outlineBlur: N, outlineOpacity: w } = this;
        l = this._parsePercent(x) || 0, u = Math.max(0, this._parsePercent(N) || 0), d = w, m = this._parsePercent(y) || 0, g = this._parsePercent(v) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (p = this.strokeColor, r.uTroikaStrokeColor.value.set(p ?? Np), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      r.uTroikaDistanceOffset.value = l, r.uTroikaPositionOffset.value.set(m, g), r.uTroikaBlurRadius.value = u, r.uTroikaStrokeWidth.value = h, r.uTroikaStrokeOpacity.value = f, r.uTroikaFillOpacity.value = d ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let b = this.clipRect;
      if (b && Array.isArray(b) && b.length === 4)
        r.uTroikaClipRect.value.fromArray(b);
      else {
        const x = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          a[0] - x,
          a[1] - x,
          a[2] + x,
          a[3] + x
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null)
      delete e.color;
    else {
      const i = e.hasOwnProperty("color") ? e.color : e.color = new He();
      (s !== i._input || typeof s == "object") && i.set(i._input = s);
    }
    let o = this.orientation || pl;
    if (o !== e._orientation) {
      let i = r.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let a = o !== pl && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (a) {
        let [, l, u, h, d] = a;
        qi.set(0, 0, 0)[u] = l === "-" ? 1 : -1, fl.set(0, 0, 0)[d] = h === "-" ? -1 : 1, wp.lookAt(__, qi.cross(fl), fl), i.setFromMatrix4(wp);
      } else
        i.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Nt()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Nt()) {
    return qi.copy(e), this.localPositionToTextCoords(this.worldToLocal(qi), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: n } = this;
    if (r) {
      const s = r.blockBounds, o = n ? c1() : a1(), i = o.geometry, { position: a, uv: l } = i.attributes;
      for (let u = 0; u < l.count; u++) {
        let h = s[0] + l.getX(u) * (s[2] - s[0]);
        const d = s[1] + l.getY(u) * (s[3] - s[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), a.setXYZ(u, h, d, f);
      }
      i.boundingSphere = this.geometry.boundingSphere, i.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, Io.length = 0, o.raycast(e, Io);
      for (let u = 0; u < Io.length; u++)
        Io[u].object = this, t.push(Io[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, C_.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
l1.forEach((c) => {
  const e = "_private_" + c;
  Object.defineProperty(u1.prototype, c, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const ja = {
  text: "String",
  anchorX: 'number|"left"|"center"|"right"',
  anchorY: 'number|"top"|"top-baseline"|"top-cap"|"top-ex"|"middle"|"bottom-baseline"|"bottom"',
  curveRadius: "number",
  direction: '"auto"|"ltr"|"rtl"',
  font: "string",
  fontSize: "number",
  fontWeight: 'number|"normal" | "bold"',
  fontStyle: '"normal"|"italic"',
  letterSpacing: "number",
  lineHeight: 'number|"normal"',
  maxWidth: "number",
  overflowWrap: '"normal" | "break-word"',
  textAlign: '"left" | "right" | "center" | "justify"',
  textIndent: "number",
  whiteSpace: '"normal"| "nowrap"',
  color: "Color",
  outlineWidth: "number",
  outlineColor: "Color",
  outlineOpacity: "number",
  outlineBlur: "number",
  outlineOffsetX: "number",
  outlineOffsetY: "number",
  strokeWidth: "number",
  strokeColor: "Color",
  strokeOpacity: "number",
  fillOpacity: "number",
  depthOffset: "number",
  clipRect: "number[]",
  orientation: "string",
  glyphGeometryDetail: "number",
  sdfGlyphSize: "number|null",
  gpuAccelerateSDF: "boolean"
};
class h1 extends u1 {
  constructor() {
    super();
    B(this, "isTextMesh", !0);
    this.type = "TextMesh", this.text = "text", this.font = "/assets/fonts/STFangsong.ttf", this.color = new He(), this.outlineColor = new He(), this.strokeColor = new He();
  }
  serialize(t) {
    for (const [r, n] of Object.entries(ja))
      if (n === "Color") {
        const s = this[r];
        t[r] = (s instanceof He ? s : new He(s)).toArray();
      } else
        t[r] = this[r];
    t.geo = {
      detail: this.geometry.detail,
      curveRadius: this.geometry.curveRadius,
      groups: this.geometry.groups,
      boundingSphere: { center: this.geometry.boundingSphere.center.toArray(), radius: this.geometry.boundingSphere.radius },
      boundingBox: { min: this.geometry.boundingBox.min.toArray(), max: this.geometry.boundingBox.max.toArray() }
    };
  }
  deserialize(t) {
    const r = new i1();
    r.copy(this.geometry), this.geometry = r, t.geo && (r.detail = t.geo.detail, r.curveRadius = t.geo.curveRadius, r.groups = t.geo.groups, r.boundingSphere.set(new ge().fromArray(t.geo.boundingSphere.center), t.geo.boundingSphere.radius), r.boundingBox = new tr(new ge().fromArray(t.geo.boundingBox.min), new ge().fromArray(t.geo.boundingBox.max)));
    for (const [n, s] of Object.entries(ja)) {
      const o = t[n];
      o !== void 0 && (s === "Color" ? this[n] = new He().fromArray(o) : this[n] = o);
    }
    this.sync();
  }
}
Ye("TextMesh", {
  // cls: TextMesh,
  create: () => new h1(),
  members: ja,
  proto: "Mesh",
  group: "Text.Text",
  icon: "text"
});
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function E_() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var x = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, x, m), f.FDArray.push(x);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var v = i.readUshort(n, s);
        for (s += 2, u = 0; u < v + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, x = 15 & g;
            if (b != 15 && m.push(b), x != 15 && m.push(x), x == 15)
              break;
          }
          for (var y = "", v = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += v[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var x = i.readUshort(n, p);
          x == 0 ? b = e.cmap.parse0(n, p) : x == 4 ? b = e.cmap.parse4(n, p) : x == 6 ? b = e.cmap.parse6(n, p) : x == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + x, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var x = 0, y = 0;
        for (u = 0; u < d; u++)
          x += l.xs[u], y += l.ys[u], l.xs[u] = x, l.ys[u] = y;
      } else {
        var v;
        l.parts = [];
        do {
          v = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & v) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & v ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & v ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & v ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & v && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & v);
        if (256 & v) {
          var S = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < S; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var x = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, x);
            x += 2;
            for (var v = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, x);
              x += 2, d != 0 && (_ = e.GPOS.readValueRecord(n, x, d), x += 2 * f), p != 0 && (L = e.GPOS.readValueRecord(n, x, p), x += 2 * m), v.push({ gid2: w, val1: _, val2: L });
            }
            u.pairsets.push(v);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var S = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          o += 2;
          var R = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + S), u.matrix = [], b = 0; b < A; b++) {
            var O = [];
            for (N = 0; N < R; N++) {
              var _ = null, L = null;
              d != 0 && (_ = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (L = e.GPOS.readValueRecord(n, o, p), o += 2 * m), O.push({ val1: _, val2: L });
            }
            u.matrix.push(O);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var x = [], y = 0; y < d; y++)
              x.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = x), f == 1 && (u.inptCvg = x), f == 2 && (u.ahedCvg = x);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var v = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = v;
          else if (i.ltype != v)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var x = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var v, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          v = i.readUnicode(n, w, x / 2);
        else if (p == 3 && m == 0)
          v = i.readUnicode(n, w, x / 2);
        else if (m == 0)
          v = i.readASCII(n, w, x);
        else if (m == 1)
          v = i.readUnicode(n, w, x / 2);
        else if (m == 3)
          v = i.readUnicode(n, w, x / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          v = i.readASCII(n, w, x), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = v, a[T]._lang = g;
      }
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 1033)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 0)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null && a[S]._lang == 3084)
          return a[S];
      for (var S in a)
        if (a[S].postScriptName != null)
          return a[S];
      for (var S in a) {
        u = S;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, x = m.tabs[g];
                    if ((!x.coverage || (b = e._lctf.coverageIndex(x.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (x.fmt == 1) {
                          var v = x.pairsets[b];
                          for (d = 0; d < v.length; d++)
                            v[d].gid2 == o && (y = v[d]);
                        } else if (x.fmt == 2) {
                          var N = e.U._getGlyphClass(s, x.classDef1), w = e.U._getGlyphClass(o, x.classDef2);
                          y = x.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var S = n.kern.glyph1.indexOf(s);
        if (S != -1) {
          var A = n.kern.rval[S].glyph2.indexOf(o);
          if (A != -1)
            return n.kern.rval[S].vals[A];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, x = 0; x < m; x++) {
                    for (; n[s + b + (1 + x)] == -1; )
                      b++;
                    p.chain[x] != n[s + b + (1 + x)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, x = 0; x < m + b; x++)
                      n[s + x + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), v = h.cDef[y + 2], N = h.scset[v], w = 0; w < N.length; w++) {
                var T = N[w], S = T.input;
                if (!(S.length > a)) {
                  for (g = !0, x = 0; x < S.length; x++) {
                    var A = e._lctf.getInterval(h.cDef, n[s + 1 + x]);
                    if (y == -1 && h.cDef[A + 2] != S[x]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var R = T.substLookupRecords;
                    for (f = 0; f < R.length; f += 2)
                      R[f], R[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var O = h.lookupRec;
              for (w = 0; w < O.length; w += 2) {
                y = O[w];
                var _ = i[O[w + 1]];
                e.U._applySubs(n, s + y, _, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, x = 0, y = 0, v = 0, N = 0, w = 0, T = 0, S = 0, A = 0, R = 0, O = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, O);
        var _ = O.val;
        if (p += O.size, _ == "o1" || _ == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (_ == "o3" || _ == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (_ == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (_ == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (_ == "o6" || _ == "o7")
          for (var L = l.length, E = _ == "o6", D = 0; D < L; D++) {
            var F = l.shift();
            E ? m += F : g += F, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (_ == "o8" || _ == "o24") {
          L = l.length;
          for (var H = 0; H + 6 <= L; )
            b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g), H += 6;
          _ == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (_ == "o11")
            break;
          if (_ == "o1234" || _ == "o1235" || _ == "o1236" || _ == "o1237")
            _ == "o1234" && (x = g, y = (b = m + l.shift()) + l.shift(), R = v = x + l.shift(), w = v, S = g, m = (T = (N = (A = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1235" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), A = y + l.shift(), R = v + l.shift(), N = A + l.shift(), w = R + l.shift(), T = N + l.shift(), S = w + l.shift(), m = T + l.shift(), g = S + l.shift(), l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1236" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), R = v = x + l.shift(), w = v, T = (N = (A = y + l.shift()) + l.shift()) + l.shift(), S = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g)), _ == "o1237" && (b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), A = y + l.shift(), R = v + l.shift(), N = A + l.shift(), w = R + l.shift(), T = N + l.shift(), S = w + l.shift(), Math.abs(T - m) > Math.abs(S - g) ? m = T + l.shift() : g = S + l.shift(), e.U.P.curveTo(a, b, x, y, v, A, R), e.U.P.curveTo(a, N, w, T, S, m, g));
          else if (_ == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var q = l.shift(), U = l.shift(), k = l.shift(), C = l.shift(), P = e.CFF.glyphBySE(o, k), X = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[P], s, o, i, a), s.x = q, s.y = U, e.U._drawCFF(o.CharStrings[X], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (_ == "o19" || _ == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (_ == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (_ == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (_ == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g);
          } else if (_ == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, x = g + l.shift(), m = y = b + l.shift(), g = (v = x + l.shift()) + l.shift(), e.U.P.curveTo(a, b, x, y, v, m, g);
          else if (_ == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              x = g, y = (b = m + l.shift()) + l.shift(), v = x + l.shift(), m = y + l.shift(), g = v, e.U.P.curveTo(a, b, x, y, v, m, g);
          else if (_ == "o10" || _ == "o29") {
            var Y = _ == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var W = l.pop(), ie = Y.Subrs[W + Y.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(ie, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (_ == "o30" || _ == "o31") {
            var J = l.length, se = (H = 0, _ == "o31");
            for (H += J - (L = -3 & J); H < L; )
              se ? (x = g, y = (b = m + l.shift()) + l.shift(), g = (v = x + l.shift()) + l.shift(), L - H == 5 ? (m = y + l.shift(), H++) : m = y, se = !1) : (b = m, x = g + l.shift(), y = b + l.shift(), v = x + l.shift(), m = y + l.shift(), L - H == 5 ? (g = v + l.shift(), H++) : g = v, se = !0), e.U.P.curveTo(a, b, x, y, v, m, g), H += 4;
          } else {
            if ((_ + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + _, n), _;
            l.push(_);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function R_() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(_, L) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = L += 1 << _[D - 1];
      var F = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var H = E[D]; H < E[D + 1]; ++H)
          F[H] = H - E[D] << 5 | D;
      return [E, F];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(_, L, E) {
      for (var D = _.length, F = 0, H = new t(L); F < D; ++F)
        ++H[_[F] - 1];
      var q, U = new t(L);
      for (F = 0; F < L; ++F)
        U[F] = U[F - 1] + H[F - 1] << 1;
      if (E) {
        q = new t(1 << L);
        var k = 15 - L;
        for (F = 0; F < D; ++F)
          if (_[F])
            for (var C = F << 4 | _[F], P = L - _[F], X = U[_[F] - 1]++ << P, Y = X | (1 << P) - 1; X <= Y; ++X)
              q[d[X] >>> k] = C;
      } else
        for (q = new t(D), F = 0; F < D; ++F)
          _[F] && (q[F] = d[U[_[F] - 1]++] >>> 15 - _[F]);
      return q;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var x = m(g, 9, 1), y = m(b, 5, 1), v = function(_) {
      for (var L = _[0], E = 1; E < _.length; ++E)
        _[E] > L && (L = _[E]);
      return L;
    }, N = function(_, L, E) {
      var D = L / 8 | 0;
      return (_[D] | _[D + 1] << 8) >> (7 & L) & E;
    }, w = function(_, L) {
      var E = L / 8 | 0;
      return (_[E] | _[E + 1] << 8 | _[E + 2] << 16) >> (7 & L);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], S = function(_, L, E) {
      var D = new Error(L || T[_]);
      if (D.code = _, Error.captureStackTrace && Error.captureStackTrace(D, S), !E)
        throw D;
      return D;
    }, A = function(_, L, E) {
      var D = _.length;
      if (!D || E && !E.l && D < 5)
        return L || new e(0);
      var F = !L || E, H = !E || E.i;
      E || (E = {}), L || (L = new e(3 * D));
      var q, U = function(De) {
        var Xe = L.length;
        if (De > Xe) {
          var We = new e(Math.max(2 * Xe, De));
          We.set(L), L = We;
        }
      }, k = E.f || 0, C = E.p || 0, P = E.b || 0, X = E.l, Y = E.d, W = E.m, ie = E.n, J = 8 * D;
      do {
        if (!X) {
          E.f = k = N(_, C, 1);
          var se = N(_, C + 1, 3);
          if (C += 3, !se) {
            var ue = _[(re = ((q = C) / 8 | 0) + (7 & q && 1) + 4) - 4] | _[re - 3] << 8, le = re + ue;
            if (le > D) {
              H && S(0);
              break;
            }
            F && U(P + ue), L.set(_.subarray(re, le), P), E.b = P += ue, E.p = C = 8 * le;
            continue;
          }
          if (se == 1)
            X = x, Y = y, W = 9, ie = 5;
          else if (se == 2) {
            var $ = N(_, C, 31) + 257, I = N(_, C + 10, 15) + 4, ne = $ + N(_, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(ne), Q = new e(19), ee = 0; ee < I; ++ee)
              Q[o[ee]] = N(_, C + 3 * ee, 7);
            C += 3 * I;
            var xe = v(Q), te = (1 << xe) - 1, de = m(Q, xe, 1);
            for (ee = 0; ee < ne; ) {
              var re, K = de[N(_, C, te)];
              if (C += 15 & K, (re = K >>> 4) < 16)
                Z[ee++] = re;
              else {
                var Ce = 0, fe = 0;
                for (re == 16 ? (fe = 3 + N(_, C, 3), C += 2, Ce = Z[ee - 1]) : re == 17 ? (fe = 3 + N(_, C, 7), C += 3) : re == 18 && (fe = 11 + N(_, C, 127), C += 7); fe--; )
                  Z[ee++] = Ce;
              }
            }
            var me = Z.subarray(0, $), ye = Z.subarray($);
            W = v(me), ie = v(ye), X = m(me, W, 1), Y = m(ye, ie, 1);
          } else
            S(1);
          if (C > J) {
            H && S(0);
            break;
          }
        }
        F && U(P + 131072);
        for (var ae = (1 << W) - 1, Fe = (1 << ie) - 1, he = C; ; he = C) {
          var pe = (Ce = X[w(_, C) & ae]) >>> 4;
          if ((C += 15 & Ce) > J) {
            H && S(0);
            break;
          }
          if (Ce || S(2), pe < 256)
            L[P++] = pe;
          else {
            if (pe == 256) {
              he = C, X = null;
              break;
            }
            var Ie = pe - 254;
            if (pe > 264) {
              var Ge = n[ee = pe - 257];
              Ie = N(_, C, (1 << Ge) - 1) + l[ee], C += Ge;
            }
            var Se = Y[w(_, C) & Fe], ot = Se >>> 4;
            if (Se || S(3), C += 15 & Se, ye = h[ot], ot > 3 && (Ge = s[ot], ye += w(_, C) & (1 << Ge) - 1, C += Ge), C > J) {
              H && S(0);
              break;
            }
            F && U(P + 131072);
            for (var be = P + Ie; P < be; P += 4)
              L[P] = L[P - ye], L[P + 1] = L[P + 1 - ye], L[P + 2] = L[P + 2 - ye], L[P + 3] = L[P + 3 - ye];
            P = be;
          }
        }
        E.l = X, E.p = he, E.b = P, X && (k = 1, E.m = W, E.d = Y, E.n = ie);
      } while (!k);
      return P == L.length ? L : function(De, Xe, We) {
        (Xe == null || Xe < 0) && (Xe = 0), (We == null || We > De.length) && (We = De.length);
        var lt = new (De instanceof t ? t : De instanceof r ? r : e)(We - Xe);
        return lt.set(De.subarray(Xe, We)), lt;
      }(L, 0, P);
    }, R = new e(0), O = typeof TextDecoder < "u" && new TextDecoder();
    try {
      O.decode(R, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(_) {
      var L = new DataView(_), E = 0;
      function D() {
        var $ = L.getUint16(E);
        return E += 2, $;
      }
      function F() {
        var $ = L.getUint32(E);
        return E += 4, $;
      }
      function H($) {
        ue.setUint16(le, $), le += 2;
      }
      function q($) {
        ue.setUint32(le, $), le += 4;
      }
      for (var U = { signature: F(), flavor: F(), length: F(), numTables: D(), reserved: D(), totalSfntSize: F(), majorVersion: D(), minorVersion: D(), metaOffset: F(), metaLength: F(), metaOrigLength: F(), privOffset: F(), privLength: F() }, k = 0; Math.pow(2, k) <= U.numTables; )
        k++;
      k--;
      for (var C = 16 * Math.pow(2, k), P = 16 * U.numTables - C, X = 12, Y = [], W = 0; W < U.numTables; W++)
        Y.push({ tag: F(), offset: F(), compLength: F(), origLength: F(), origChecksum: F() }), X += 16;
      var ie, J = new Uint8Array(12 + 16 * Y.length + Y.reduce(function($, I) {
        return $ + I.origLength + 4;
      }, 0)), se = J.buffer, ue = new DataView(se), le = 0;
      return q(U.flavor), H(U.numTables), H(C), H(k), H(P), Y.forEach(function($) {
        q($.tag), q($.origChecksum), q(X), q($.origLength), $.outOffset = X, (X += $.origLength) % 4 != 0 && (X += 4 - X % 4);
      }), Y.forEach(function($) {
        var I, ne = _.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          I = new Uint8Array(ne, 2), A(I, Z);
        } else
          Z = new Uint8Array(ne);
        J.set(Z, $.outOffset);
        var Q = 0;
        (X = $.outOffset + $.origLength) % 4 != 0 && (Q = 4 - X % 4), J.set(new Uint8Array(Q).buffer, $.outOffset + $.origLength), ie = X + Q;
      }), se.slice(0, ie);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function L_(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let S = 0;
        r[T].split(",").forEach((A) => {
          let [R, O] = A.split("+");
          R = parseInt(R, 36), O = O ? parseInt(O, 36) : 0, u.set(S += R, w[T]);
          for (let _ = O; _--; )
            u.set(++S, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, S = d, A = -1;
    for (let R = 0; R < N.length; R++) {
      const O = N.codePointAt(R);
      let _ = h(O) | 0, L = d;
      _ & i || (T & (n | o | a) ? _ & (s | o | a) ? (L = p, (S === d || S === p) && w[A]++) : _ & (n | l) && (S === f || S === m) && w[A]-- : T & (s | l) && (S === f || S === m) && w[A]--, S = w[R] = L, T = _, A = R, O > 65535 && R++);
    }
    return w;
  }
  function x(N, w) {
    const T = [];
    for (let A = 0; A < w.length; A++) {
      const R = w.codePointAt(A);
      R > 65535 && A++, T.push(c.U.codeToGlyph(N, R));
    }
    const S = N.GSUB;
    if (S) {
      const { lookupList: A, featureList: R } = S;
      let O;
      const _ = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, L = [];
      R.forEach((E) => {
        if (_.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (L[E.tab[D]])
              continue;
            L[E.tab[D]] = !0;
            const F = A[E.tab[D]], H = /^(isol|init|fina|medi)$/.test(E.tag);
            H && !O && (O = b(w));
            for (let q = 0; q < T.length; q++)
              (!O || !H || g[O[q]] === E.tag) && c.U._applySubs(T, q, F, A);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function v(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], S = N.hhea, A = N.head.unitsPerEm, R = y(T && T.sTypoAscender, S && S.ascender, A), O = {
      unitsPerEm: A,
      ascender: R,
      descender: y(T && T.sTypoDescender, S && S.descender, 0),
      capHeight: y(T && T.sCapHeight, R),
      xHeight: y(T && T.sxHeight, R),
      lineGap: y(T && T.sTypoLineGap, S && S.lineGap),
      supportsCodePoint(_) {
        return c.U.codeToGlyph(N, _) > 0;
      },
      forEachGlyph(_, L, E, D) {
        let F = 0;
        const H = 1 / O.unitsPerEm * L, q = x(N, _);
        let U = 0, k = -1;
        return q.forEach((C, P) => {
          if (C !== -1) {
            let X = w[C];
            if (!X) {
              const { cmds: Y, crds: W } = c.U.glyphToPath(N, C);
              let ie = "", J = 0;
              for (let I = 0, ne = Y.length; I < ne; I++) {
                const Z = t[Y[I]];
                ie += Y[I];
                for (let Q = 1; Q <= Z; Q++)
                  ie += (Q > 1 ? "," : "") + W[J++];
              }
              let se, ue, le, $;
              if (W.length) {
                se = ue = 1 / 0, le = $ = -1 / 0;
                for (let I = 0, ne = W.length; I < ne; I += 2) {
                  let Z = W[I], Q = W[I + 1];
                  Z < se && (se = Z), Q < ue && (ue = Q), Z > le && (le = Z), Q > $ && ($ = Q);
                }
              } else
                se = le = ue = $ = 0;
              X = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: se,
                yMin: ue,
                xMax: le,
                yMax: $,
                path: ie,
                pathCommandCount: Y.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            k !== -1 && (F += c.U.getPairAdjustment(N, k, C) * H), D.call(null, X, F, U), X.advanceWidth && (F += X.advanceWidth * H), E && (F += E * L), k = C;
          }
          U += _.codePointAt(U) > 65535 ? 2 : 1;
        }), F;
      }
    };
    return O;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), S = c._bin.readASCII(T, 0, 4);
    if (S === "wOFF")
      w = e(w);
    else if (S === "wOF2")
      throw new Error("woff2 fonts not supported");
    return v(c.parse(w)[0]);
  };
}
const F_ = /* @__PURE__ */ hs({
  name: "Typr Font Parser",
  dependencies: [E_, R_, L_],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
}), O_ = F_;
/*!
Custom bundle of @unicode-font-resolver/client v0.3.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function I_() {
  return function(c) {
    class e {
      constructor() {
        this.buckets = /* @__PURE__ */ new Map();
      }
      add(v) {
        const N = v >> 5;
        this.buckets.set(N, (this.buckets.get(N) || 0) | 1 << (31 & v));
      }
      has(v) {
        const N = this.buckets.get(v >> 5);
        return N !== void 0 && (N & 1 << (31 & v)) != 0;
      }
      serialize() {
        const v = [];
        return this.buckets.forEach((N, w) => {
          v.push(`${(+w).toString(36)}:${N.toString(36)}`);
        }), v.join(",");
      }
      deserialize(v) {
        this.buckets.clear(), v.split(",").forEach((N) => {
          const w = N.split(":");
          this.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
        });
      }
    }
    const t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      const v = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return `codepoint-index/plane${y >> 16}/${v}-${N}.json`;
    }
    function o(y, v) {
      const N = y & r;
      let w = v.codePointAt(N / 6 | 0);
      return w = (w || 48) - 48, (w & 1 << N % 6) != 0;
    }
    function i(y, v) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map((w) => w.split("-").map((T) => parseInt(T.trim(), 16)))).forEach(([w, T = w]) => {
        v(w, T);
      });
    }
    function a(y, v) {
      i(y, (N, w) => {
        for (let T = N; T <= w; T++)
          v(T);
      });
    }
    let l = {}, u = {};
    const h = /* @__PURE__ */ new WeakMap();
    function d(y) {
      let v = h.get(y);
      return v || (v = new e(), a(y.ranges, (N) => v.add(N)), h.set(y, v)), v;
    }
    const f = /* @__PURE__ */ new Map();
    function p(y) {
      let v = f.get(y);
      return v || (v = fetch(y).then((N) => N.json()), f.set(y, v)), v;
    }
    function m(y, v, N) {
      return y[v] ? v : y[N] ? N : function(w) {
        for (const T in w)
          return T;
      }(y);
    }
    function g(y, v) {
      let N = v;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (let w = 0; w < y.length; w++)
          Math.abs(y[w] - v) < Math.abs(N - v) && (N = y[w]);
      }
      return N;
    }
    let b;
    function x(y) {
      return b || (b = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", (v) => {
        b.add(v);
      })), b.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, v = {}) {
      const { lang: N = "en", category: w = "sans-serif", style: T = "normal", weight: S = 400 } = v, A = (v.dataUrl || "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v0.3.2/packages/data").replace(/\/$/g, ""), R = /* @__PURE__ */ new Map(), O = new Uint8Array(y.length), _ = {}, L = {}, E = new Array(y.length), D = /* @__PURE__ */ new Map();
      for (let F = 0; F < y.length; F++) {
        const H = y.codePointAt(F), q = s(H);
        E[F] = q, l[q] || D.has(q) || D.set(q, p(`${A}/${q}`).then((U) => {
          l[q] = U;
        })), H > 65535 && F++;
      }
      return Promise.all(D.values()).then(() => {
        D.clear();
        for (let F = 0; F < y.length; F++) {
          const H = y.codePointAt(F);
          let q = null;
          const U = l[E[F]];
          e:
            for (let k in U) {
              let C = L[k];
              if (C === void 0 && (C = L[k] = new RegExp(k).test(N)), C) {
                for (let P in U[k])
                  if (o(H, U[k][P])) {
                    q = P;
                    break e;
                  }
              }
            }
          q || (console.debug(`No font coverage for U+${H.toString(16)}`), q = "latin"), E[F] = q, u[q] || D.has(q) || D.set(q, p(`${A}/font-meta/${q}.json`).then((k) => {
            u[q] = k;
          })), H > 65535 && F++;
        }
        return Promise.all(D.values());
      }).then(() => {
        var F;
        let H = null;
        for (let q = 0; q < y.length; q++) {
          const U = y.codePointAt(q);
          if (H && (x(U) || d(H).has(U)))
            O[q] = O[q - 1];
          else {
            H = u[E[q]];
            let k = _[H.id];
            if (!k) {
              const { typeforms: P } = H, X = m(P, w, "sans-serif"), Y = m(P[X], T, "normal"), W = g((F = P[X]) === null || F === void 0 ? void 0 : F[Y], S);
              k = _[H.id] = `${A}/font-files/${H.id}/${X}.${Y}.${W}.woff`;
            }
            let C = R.get(k);
            C == null && (C = R.size, R.set(k, C)), O[q] = C;
          }
          U > 65535 && (q++, O[q] = O[q - 1]);
        }
        return { fontUrls: Array.from(R.keys()), chars: O };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function P_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, { lang: a, fonts: l = [], style: u = "normal", weight: h = "normal" } = {}) {
    const d = new Uint8Array(o.length), f = [];
    o.length || b();
    const p = /* @__PURE__ */ new Map(), m = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((y) => !y.lang || y.lang.test(a)).reverse(), l.length) {
      let w = 0;
      (function T(S = 0) {
        for (let A = S, R = o.length; A < R; A++) {
          const O = o.codePointAt(A);
          if (w === 1 && f[d[A - 1]].supportsCodePoint(O) || /\s/.test(o[A]))
            d[A] = d[A - 1], w === 2 && (m[m.length - 1][1] = A);
          else
            for (let _ = d[A], L = l.length; _ <= L; _++)
              if (_ === L) {
                const E = w === 2 ? m[m.length - 1] : m[m.length] = [A, A];
                E[1] = A, w = 2;
              } else {
                d[A] = _;
                const { src: E, unicodeRange: D } = l[_];
                if (!D || x(O, D)) {
                  const F = t[E];
                  if (!F) {
                    s(E, () => {
                      T(A);
                    });
                    return;
                  }
                  if (F.supportsCodePoint(O)) {
                    let H = p.get(F);
                    typeof H != "number" && (H = f.length, f.push(F), p.set(F, H)), d[A] = H, w = 1;
                    break;
                  }
                }
              }
          O > 65535 && A + 1 < R && (d[A + 1] = d[A], A++, w === 2 && (m[m.length - 1][1] = A));
        }
        g();
      })();
    } else
      m.push([0, o.length - 1]), g();
    function g() {
      if (m.length) {
        const y = m.map((v) => o.substring(v[0], v[1] + 1)).join(`
`);
        e.getFontsForString(y, { lang: a, style: u, weight: h }).then(({ fontUrls: v, chars: N }) => {
          const w = f.length;
          let T = 0;
          m.forEach((A) => {
            for (let R = 0, O = A[1] - A[0]; R <= O; R++)
              d[A[0] + R] = N[T++] + w;
            T++;
          });
          let S = 0;
          v.forEach((A, R) => {
            s(A, (O) => {
              f[R + w] = O, ++S === v.length && b();
            });
          });
        });
      } else
        b();
    }
    function b() {
      i({
        chars: d,
        fonts: f
      });
    }
    function x(y, v) {
      for (let N = 0; N < v.length; N++) {
        const [w, T = w] = v[N];
        if (w <= y && y <= T)
          return !0;
      }
      return !1;
    }
  };
}
const D_ = /* @__PURE__ */ hs({
  name: "FontResolver",
  dependencies: [
    P_,
    O_,
    I_
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function U_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: x, preResolvedFonts: y }, v) {
    const N = ({ chars: w, fonts: T }) => {
      let S, A;
      const R = [];
      for (let O = 0; O < w.length; O++)
        w[O] !== A ? (A = w[O], R.push(S = { start: O, end: O, fontObj: T[w[O]] })) : S.end = O;
      v(R);
    };
    y ? N(y) : c(
      p,
      N,
      { lang: m, fonts: g, style: b, weight: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g = "en",
    sdfGlyphSize: b = 64,
    fontSize: x = 400,
    fontWeight: y = 1,
    fontStyle: v = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: S,
    textAlign: A = "left",
    textIndent: R = 0,
    whiteSpace: O = "normal",
    overflowWrap: _ = "normal",
    anchorX: L = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    preResolvedFonts: F = null,
    includeCaretPositions: H = !1,
    chunkedBoundsSize: q = 8192,
    colorRanges: U = null
  }, k) {
    const C = h(), P = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), x = +x, N = +N, T = +T, w = w || "normal", R = +R, o({
      text: p,
      lang: g,
      style: v,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      preResolvedFonts: F
    }, (X) => {
      P.fontLoad = h() - C;
      const Y = isFinite(T);
      let W = null, ie = null, J = null, se = null, ue = null, le = null, $ = null, I = null, ne = 0, Z = 0, Q = O !== "nowrap";
      const ee = /* @__PURE__ */ new Map(), xe = h();
      let te = R, de = 0, re = new d();
      const K = [re];
      X.forEach((ae) => {
        const { fontObj: Fe } = ae, { ascender: he, descender: pe, unitsPerEm: Ie, lineGap: Ge, capHeight: Se, xHeight: ot } = Fe;
        let be = ee.get(Fe);
        if (!be) {
          const ve = x / Ie, Te = w === "normal" ? (he - pe + Ge) * ve : w * x, Dt = (Te - (he - pe) * ve) / 2, Ae = Math.min(Te, (he - pe) * ve), Le = (he + pe) / 2 * ve + Ae / 2;
          be = {
            index: ee.size,
            src: Fe.src,
            fontObj: Fe,
            fontSizeMult: ve,
            unitsPerEm: Ie,
            ascender: he * ve,
            descender: pe * ve,
            capHeight: Se * ve,
            xHeight: ot * ve,
            lineHeight: Te,
            baseline: -Dt - he * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (he + pe) / 2 * ve + Ae / 2,
            caretBottom: Le - Ae
          }, ee.set(Fe, be);
        }
        const { fontSizeMult: De } = be, Xe = p.slice(ae.start, ae.end + 1);
        let We, lt;
        Fe.forEachGlyph(Xe, x, N, (ve, Te, Dt) => {
          Te += de, Dt += ae.start, We = Te, lt = ve;
          const Ae = p.charAt(Dt), Le = ve.advanceWidth * De, nt = re.count;
          let Ve;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ae && new RegExp(n).test(Ae), ve.canBreakAfter = !!Ae && s.test(Ae), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || r.test(Ae)), !ve.isWhitespace && !ve.isEmpty && Z++, Q && Y && !ve.isWhitespace && Te + Le + te > T && nt) {
            if (re.glyphAt(nt - 1).glyphObj.canBreakAfter)
              Ve = new d(), te = -Te;
            else
              for (let ze = nt; ze--; )
                if (ze === 0 && _ === "break-word") {
                  Ve = new d(), te = -Te;
                  break;
                } else if (re.glyphAt(ze).glyphObj.canBreakAfter) {
                  Ve = re.splitAt(ze + 1);
                  const ht = Ve.glyphAt(0).x;
                  te -= ht;
                  for (let it = Ve.count; it--; )
                    Ve.glyphAt(it).x -= ht;
                  break;
                }
            Ve && (re.isSoftWrapped = !0, re = Ve, K.push(re), ne = T);
          }
          let we = re.glyphAt(re.count);
          we.glyphObj = ve, we.x = Te + te, we.width = Le, we.charIndex = Dt, we.fontData = be, Ae === `
` && (re = new d(), K.push(re), te = -(Te + Le + N * x) + R);
        }), de = We + lt.advanceWidth * De + N * x;
      });
      let Ce = 0;
      K.forEach((ae) => {
        let Fe = !0;
        for (let he = ae.count; he--; ) {
          const pe = ae.glyphAt(he);
          Fe && !pe.glyphObj.isWhitespace && (ae.width = pe.x + pe.width, ae.width > ne && (ne = ae.width), Fe = !1);
          let { lineHeight: Ie, capHeight: Ge, xHeight: Se, baseline: ot } = pe.fontData;
          Ie > ae.lineHeight && (ae.lineHeight = Ie);
          const be = ot - ae.baseline;
          be < 0 && (ae.baseline += be, ae.cap += be, ae.ex += be), ae.cap = Math.max(ae.cap, ae.baseline + Ge), ae.ex = Math.max(ae.ex, ae.baseline + Se);
        }
        ae.baseline -= Ce, ae.cap -= Ce, ae.ex -= Ce, Ce += ae.lineHeight;
      });
      let fe = 0, me = 0;
      if (L && (typeof L == "number" ? fe = -L : typeof L == "string" && (fe = -ne * (L === "left" ? 0 : L === "center" ? 0.5 : L === "right" ? 1 : l(L)))), E && (typeof E == "number" ? me = -E : typeof E == "string" && (me = E === "top" ? 0 : E === "top-baseline" ? -K[0].baseline : E === "top-cap" ? -K[0].cap : E === "top-ex" ? -K[0].ex : E === "middle" ? Ce / 2 : E === "bottom" ? Ce : E === "bottom-baseline" ? K[K.length - 1].baseline : l(E) * Ce)), !D) {
        const ae = e.getEmbeddingLevels(p, S);
        W = new Uint16Array(Z), ie = new Uint8Array(Z), J = new Float32Array(Z * 2), se = {}, $ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], I = [], H && (le = new Float32Array(p.length * 4)), U && (ue = new Uint8Array(Z * 3));
        let Fe = 0, he = -1, pe = -1, Ie, Ge;
        if (K.forEach((Se, ot) => {
          let { count: be, width: De } = Se;
          if (be > 0) {
            let Xe = 0;
            for (let Ae = be; Ae-- && Se.glyphAt(Ae).glyphObj.isWhitespace; )
              Xe++;
            let We = 0, lt = 0;
            if (A === "center")
              We = (ne - De) / 2;
            else if (A === "right")
              We = ne - De;
            else if (A === "justify" && Se.isSoftWrapped) {
              let Ae = 0;
              for (let Le = be - Xe; Le--; )
                Se.glyphAt(Le).glyphObj.isWhitespace && Ae++;
              lt = (ne - De) / Ae;
            }
            if (lt || We) {
              let Ae = 0;
              for (let Le = 0; Le < be; Le++) {
                let nt = Se.glyphAt(Le);
                const Ve = nt.glyphObj;
                nt.x += We + Ae, lt !== 0 && Ve.isWhitespace && Le < be - Xe && (Ae += lt, nt.width += lt);
              }
            }
            const ve = e.getReorderSegments(
              p,
              ae,
              Se.glyphAt(0).charIndex,
              Se.glyphAt(Se.count - 1).charIndex
            );
            for (let Ae = 0; Ae < ve.length; Ae++) {
              const [Le, nt] = ve[Ae];
              let Ve = 1 / 0, we = -1 / 0;
              for (let ze = 0; ze < be; ze++)
                if (Se.glyphAt(ze).charIndex >= Le) {
                  let ht = ze, it = ze;
                  for (; it < be; it++) {
                    let et = Se.glyphAt(it);
                    if (et.charIndex > nt)
                      break;
                    it < be - Xe && (Ve = Math.min(Ve, et.x), we = Math.max(we, et.x + et.width));
                  }
                  for (let et = ht; et < it; et++) {
                    const Gt = Se.glyphAt(et);
                    Gt.x = we - (Gt.x + Gt.width - Ve);
                  }
                  break;
                }
            }
            let Te;
            const Dt = (Ae) => Te = Ae;
            for (let Ae = 0; Ae < be; Ae++) {
              const Le = Se.glyphAt(Ae);
              Te = Le.glyphObj;
              const nt = Te.index, Ve = ae.levels[Le.charIndex] & 1;
              if (Ve) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, Dt);
              }
              if (H) {
                const { charIndex: we, fontData: ze } = Le, ht = Le.x + fe, it = Le.x + Le.width + fe;
                le[we * 4] = Ve ? it : ht, le[we * 4 + 1] = Ve ? ht : it, le[we * 4 + 2] = Se.baseline + ze.caretBottom + me, le[we * 4 + 3] = Se.baseline + ze.caretTop + me;
                const et = we - he;
                et > 1 && u(le, he, et), he = we;
              }
              if (U) {
                const { charIndex: we } = Le;
                for (; we > pe; )
                  pe++, U.hasOwnProperty(pe) && (Ge = U[pe]);
              }
              if (!Te.isWhitespace && !Te.isEmpty) {
                const we = Fe++, { fontSizeMult: ze, src: ht, index: it } = Le.fontData, et = se[ht] || (se[ht] = {});
                et[nt] || (et[nt] = {
                  path: Te.path,
                  pathBounds: [Te.xMin, Te.yMin, Te.xMax, Te.yMax]
                });
                const Gt = Le.x + fe, jn = Se.baseline + me;
                J[we * 2] = Gt, J[we * 2 + 1] = jn;
                const cn = Gt + Te.xMin * ze, ln = jn + Te.yMin * ze, Tn = Gt + Te.xMax * ze, On = jn + Te.yMax * ze;
                cn < $[0] && ($[0] = cn), ln < $[1] && ($[1] = ln), Tn > $[2] && ($[2] = Tn), On > $[3] && ($[3] = On), we % q === 0 && (Ie = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, I.push(Ie)), Ie.end++;
                const xt = Ie.rect;
                if (cn < xt[0] && (xt[0] = cn), ln < xt[1] && (xt[1] = ln), Tn > xt[2] && (xt[2] = Tn), On > xt[3] && (xt[3] = On), W[we] = nt, ie[we] = it, U) {
                  const un = we * 3;
                  ue[un] = Ge >> 16 & 255, ue[un + 1] = Ge >> 8 & 255, ue[un + 2] = Ge & 255;
                }
              }
            }
          }
        }), le) {
          const Se = p.length - he;
          Se > 1 && u(le, he, Se);
        }
      }
      const ye = [];
      ee.forEach(({ index: ae, src: Fe, unitsPerEm: he, ascender: pe, descender: Ie, lineHeight: Ge, capHeight: Se, xHeight: ot }) => {
        ye[ae] = { src: Fe, unitsPerEm: he, ascender: pe, descender: Ie, lineHeight: Ge, capHeight: Se, xHeight: ot };
      }), P.typesetting = h() - xe, k({
        glyphIds: W,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: ie,
        //index into fontData for each glyph
        glyphPositions: J,
        //x,y of each glyph's origin in layout
        glyphData: se,
        //dict holding data about each glyph appearing in the text
        fontData: ye,
        //data about each font used in the text
        caretPositions: le,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ue,
        //color for each glyph, if color ranges supplied
        chunkedBounds: I,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: x,
        //calculated em height
        topBaseline: me + K[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          fe,
          me - Ce,
          fe + ne,
          me
        ],
        visibleBounds: $,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: P
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, x, y, v] = g.blockBounds;
      m({
        width: y - b,
        height: v - x
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], x = p[m * 4 + 1], y = p[m * 4 + 2], v = p[m * 4 + 3], N = (x - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = v;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(x) {
      this.data[this.index * f.length + g] = x;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const z_ = /* @__PURE__ */ hs({
  name: "Typesetter",
  dependencies: [
    U_,
    D_,
    t1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), B_ = z_, k_ = /* @__PURE__ */ hs({
  name: "Typesetter",
  dependencies: [
    B_
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (const t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), G_ = new He();
let Ji;
function V_(c) {
  return Ji || (Ji = typeof document > "u" ? {} : document.createElement("a")), Ji.href = c, Ji.href;
}
const d1 = {
  font: "/assets/fonts/STFangsong.ttf",
  lang: "en",
  fontSize: 0.1,
  fontWeight: "normal",
  fontStyle: "normal",
  letterSpacing: 0,
  lineHeight: "normal",
  maxWidth: 1,
  direction: "auto",
  textAlign: "left",
  textIndent: 0,
  whiteSpace: "normal",
  overflowWrap: "normal",
  anchorX: 0,
  anchorY: 0,
  colorRanges: null,
  includeCaretPositions: !0,
  sdfGlyphSize: 64,
  gpuAccelerateSDF: !1
};
async function j_(c) {
  c = { ...d1, ...c };
  const e = [];
  if (c.font && e.push({ label: "user", src: V_(c.font) }), c.font = e, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || 64, c.colorRanges != null) {
    const h = {};
    for (const d in c.colorRanges)
      if (Object.hasOwn(c.colorRanges, d)) {
        let f = c.colorRanges[d];
        typeof f != "number" && (f = G_.set(f).getHex()), h[d] = f;
      }
    c.colorRanges = h;
  }
  Object.freeze(c);
  const t = await k_(c), { glyphIds: r, glyphFontIndices: n, fontData: s, glyphData: o, glyphPositions: i, fontSize: a } = t, l = new Tu();
  let u = 0;
  return r.forEach((h, d) => {
    const f = n[d], { src: p, unitsPerEm: m } = s[f], { path: g } = o[p][h], b = i[u++], x = i[u++], y = a / m, v = g.replace(/([A-Z])/mg, (N, w) => `$${w}`).split("$").filter((N) => N);
    for (const N of v) {
      const w = N[0];
      if (w === "Z")
        continue;
      const T = N.substring(1).split(",").map((S, A) => (A % 2 ? x : b) + Number.parseFloat(S) * y);
      w === "M" ? l.moveTo(...T) : w === "L" ? l.lineTo(...T) : w === "Q" ? l.quadraticCurveTo(...T) : w === "C" && l.bezierCurveTo(...T);
    }
  }), l.toShapes(!1);
}
const W_ = Object.fromEntries(Object.entries(ja).map((c) => [`props.${c[0]}`, c[1]]));
class H_ extends Mr {
  constructor(t, r) {
    super(t, r, {
      ...d1,
      color: new He(),
      strokeColor: new He(),
      outlineColor: new He()
    }, 0, 0);
    B(this, "isText3D", !0);
    this.type = "Text3D";
  }
  async rebuildShapes() {
    this.shapes = await j_(this.props), this.rebuildGeometry();
  }
}
Ye("Text3D", {
  members: W_,
  proto: "Shape",
  group: "Text.3D Text",
  icon: "text",
  create: ({ material: c, geometry: e } = {}) => new H_(e || new xm(), c)
});
class X_ extends Rx {
  constructor() {
    super();
    B(this, "isAudioListener2", !0);
    this.type = "AudioListener2";
  }
  toJSON(t) {
    const r = super.toJSON(t), n = { ...r.object };
    return delete n.children, t.listeners[n.uuid] = n, r;
  }
}
class $_ extends Lx {
  constructor(t) {
    super(t);
    B(this, "isPositionalAudio2", !0);
    B(this, "_src", "");
    this.type = "PositionalAudio2";
  }
  get src() {
    return this._src;
  }
  set src(t) {
    this._src !== t && (this._src = t, this.isPlaying && this.stop(), new Fx().load(t, (r) => {
      this.setBuffer(r);
    }));
  }
  play(t) {
    return this.isPlaying && this.stop(), super.play(t);
  }
  clone(t) {
    const r = po.get(this.listener);
    return new this.constructor(r).copy(this, t);
  }
  serialize(t) {
    t.autoplay = this.autoplay, t.loop = this.loop, t.src = this._src, t.listener = this.listener.uuid;
  }
  deserialize(t) {
    this.autoplay = t.autoplay || !1, this.loop = t.loop || !1, this.src = t.src;
  }
}
Ye("AudioListener2", {
  create: () => new X_(),
  proto: "AudioListener",
  members: {},
  group: "Audio.Audio Listener",
  icon: "ear"
});
Ye("PositionalAudio2", {
  create: ({ listener: c }) => new $_(c),
  proto: "PositionalAudio",
  members: {
    autoplay: "Boolean",
    loop: "Boolean",
    src: "Audio"
  },
  group: "Audio.Positional Audio",
  icon: "audio"
});
function Sp(c, e) {
  if (e === Ox)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), c;
  if (e === zl || e === wm) {
    let t = c.getIndex();
    if (t === null) {
      const o = [], i = c.getAttribute("position");
      if (i !== void 0) {
        for (let a = 0; a < i.count; a++)
          o.push(a);
        c.setIndex(o), t = c.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), c;
    }
    const r = t.count - 2, n = [];
    if (e === zl)
      for (let o = 1; o <= r; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < r; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = c.clone();
    return s.setIndex(n), s.clearGroups(), s;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), c;
}
class Gd extends vr {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new Z_(t);
    }), this.register(function(t) {
      return new iM(t);
    }), this.register(function(t) {
      return new aM(t);
    }), this.register(function(t) {
      return new cM(t);
    }), this.register(function(t) {
      return new eM(t);
    }), this.register(function(t) {
      return new tM(t);
    }), this.register(function(t) {
      return new nM(t);
    }), this.register(function(t) {
      return new sM(t);
    }), this.register(function(t) {
      return new K_(t);
    }), this.register(function(t) {
      return new rM(t);
    }), this.register(function(t) {
      return new Q_(t);
    }), this.register(function(t) {
      return new oM(t);
    }), this.register(function(t) {
      return new J_(t);
    }), this.register(function(t) {
      return new lM(t);
    }), this.register(function(t) {
      return new uM(t);
    });
  }
  load(e, t, r, n) {
    const s = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ho.extractUrlBase(e), this.manager.itemStart(e);
    const i = function(l) {
      n ? n(l) : console.error(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }, a = new Js(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        s.parse(l, o, function(u) {
          t(u), s.manager.itemEnd(e);
        }, i);
      } catch (u) {
        i(u);
      }
    }, r, i);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, r, n) {
    let s;
    const o = {}, i = {}, a = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (a.decode(new Uint8Array(e, 0, 4)) === f1) {
        try {
          o[Ze.KHR_BINARY_GLTF] = new hM(e);
        } catch (h) {
          n && n(h);
          return;
        }
        s = JSON.parse(o[Ze.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(a.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new SM(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      i[h.name] = h, o[h.name] = !0;
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
        switch (h) {
          case Ze.KHR_MATERIALS_UNLIT:
            o[h] = new Y_();
            break;
          case Ze.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new dM(s, this.dracoLoader);
            break;
          case Ze.KHR_TEXTURE_TRANSFORM:
            o[h] = new fM();
            break;
          case Ze.KHR_MESH_QUANTIZATION:
            o[h] = new pM();
            break;
          default:
            d.indexOf(h) >= 0 && i[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(i), l.parse(r, n);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function(n, s) {
      r.parse(e, t, n, s);
    });
  }
}
function q_() {
  let c = {};
  return {
    get: function(e) {
      return c[e];
    },
    add: function(e, t) {
      c[e] = t;
    },
    remove: function(e) {
      delete c[e];
    },
    removeAll: function() {
      c = {};
    }
  };
}
const Ze = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class J_ {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, r = "light:" + e;
    let n = t.cache.get(r);
    if (n)
      return n;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let l;
    const u = new He(16777215);
    a.color !== void 0 && u.setRGB(a.color[0], a.color[1], a.color[2], Rn);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        l = new pi(u), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        l = new Zo(u), l.distance = h;
        break;
      case "spot":
        l = new mi(u), l.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, l.angle = a.spot.outerConeAngle, l.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return l.position.set(0, 0, 0), l.decay = 2, Bs(l, a), a.intensity !== void 0 && (l.intensity = a.intensity), l.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(l), t.cache.add(r, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, r = this.parser, s = r.json.nodes[e], i = (s.extensions && s.extensions[this.name] || {}).light;
    return i === void 0 ? null : this._loadLight(i).then(function(a) {
      return r._getNodeRef(t.cache, i, a);
    });
  }
}
class Y_ {
  constructor() {
    this.name = Ze.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return An;
  }
  extendParams(e, t, r) {
    const n = [];
    e.color = new He(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Rn), e.opacity = o[3];
      }
      s.baseColorTexture !== void 0 && n.push(r.assignTexture(e, "map", s.baseColorTexture, vn));
    }
    return Promise.all(n);
  }
}
class K_ {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class Z_ {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const i = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Nt(i, i);
    }
    return Promise.all(s);
  }
}
class Q_ {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class eM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new He(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const i = o.sheenColorFactor;
      t.sheenColor.setRGB(i[0], i[1], i[2], Rn);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, vn)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s);
  }
}
class tM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s);
  }
}
class nM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const i = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new He().setRGB(i[0], i[1], i[2], Rn), Promise.all(s);
  }
}
class sM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name];
    return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
}
class rM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const i = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new He().setRGB(i[0], i[1], i[2], Rn), o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, vn)), Promise.all(s);
  }
}
class oM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Cs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s);
  }
}
class iM {
  constructor(e) {
    this.parser = e, this.name = Ze.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, r = t.json, n = r.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const s = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class aM {
  constructor(e) {
    this.parser = e, this.name = Ze.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class cM {
  constructor(e) {
    this.parser = e, this.name = Ze.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class lM {
  constructor(e) {
    this.name = Ze.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const n = r.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(i) {
        const a = n.byteOffset || 0, l = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(i, a, l);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class uM {
  constructor(e) {
    this.name = Ze.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const n = t.meshes[r.mesh];
    for (const l of n.primitives)
      if (l.mode !== Pn.TRIANGLES && l.mode !== Pn.TRIANGLE_STRIP && l.mode !== Pn.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const o = r.extensions[this.name].attributes, i = [], a = {};
    for (const l in o)
      i.push(this.parser.getDependency("accessor", o[l]).then((u) => (a[l] = u, a[l])));
    return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then((l) => {
      const u = l.pop(), h = u.isGroup ? u.children : [u], d = l[0].count, f = [];
      for (const p of h) {
        const m = new je(), g = new ge(), b = new dr(), x = new ge(1, 1, 1), y = new Ix(p.geometry, p.material, d);
        for (let v = 0; v < d; v++)
          a.TRANSLATION && g.fromBufferAttribute(a.TRANSLATION, v), a.ROTATION && b.fromBufferAttribute(a.ROTATION, v), a.SCALE && x.fromBufferAttribute(a.SCALE, v), y.setMatrixAt(v, m.compose(g, b, x));
        for (const v in a)
          v !== "TRANSLATION" && v !== "ROTATION" && v !== "SCALE" && p.geometry.setAttribute(v, a[v]);
        En.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), f.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
}
const f1 = "glTF", Po = 12, _p = { JSON: 1313821514, BIN: 5130562 };
class hM {
  constructor(e) {
    this.name = Ze.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Po), r = new TextDecoder();
    if (this.header = {
      magic: r.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== f1)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Po, s = new DataView(e, Po);
    let o = 0;
    for (; o < n; ) {
      const i = s.getUint32(o, !0);
      o += 4;
      const a = s.getUint32(o, !0);
      if (o += 4, a === _p.JSON) {
        const l = new Uint8Array(e, Po + o, i);
        this.content = r.decode(l);
      } else if (a === _p.BIN) {
        const l = Po + o;
        this.body = e.slice(l, l + i);
      }
      o += i;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class dM {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ze.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, i = {}, a = {}, l = {};
    for (const u in o) {
      const h = lu[u] || u.toLowerCase();
      i[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = lu[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = r.accessors[e.attributes[u]], f = co[d.componentType];
        l[h] = f.name, a[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(u, function(d) {
          for (const f in d.attributes) {
            const p = d.attributes[f], m = a[f];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, i, l);
      });
    });
  }
}
class fM {
  constructor() {
    this.name = Ze.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class pM {
  constructor() {
    this.name = Ze.KHR_MESH_QUANTIZATION;
  }
}
class p1 extends Bx {
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = r[s + o];
    return t;
  }
  interpolate_(e, t, r, n) {
    const s = this.resultBuffer, o = this.sampleValues, i = this.valueSize, a = i * 2, l = i * 3, u = n - t, h = (r - t) / u, d = h * h, f = d * h, p = e * l, m = p - l, g = -2 * f + 3 * d, b = f - d, x = 1 - g, y = b - d + h;
    for (let v = 0; v !== i; v++) {
      const N = o[m + v + i], w = o[m + v + a] * u, T = o[p + v + i], S = o[p + v] * u;
      s[v] = x * N + y * w + g * T + b * S;
    }
    return s;
  }
}
const mM = new dr();
class gM extends p1 {
  interpolate_(e, t, r, n) {
    const s = super.interpolate_(e, t, r, n);
    return mM.fromArray(s).normalize().toArray(s), s;
  }
}
const Pn = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, co = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Mp = {
  9728: js,
  9729: uo,
  9984: Am,
  9985: Cm,
  9986: Em,
  9987: yo
}, Ap = {
  33071: fo,
  33648: Rm,
  10497: Ys
}, ml = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, lu = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Fs = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, yM = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Mm,
  STEP: zx
}, gl = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function vM(c) {
  return c.DefaultMaterial === void 0 && (c.DefaultMaterial = new Vn({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Nm
  })), c.DefaultMaterial;
}
function lr(c, e, t) {
  for (const r in t.extensions)
    c[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]);
}
function Bs(c, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(c.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function xM(c, e, t) {
  let r = !1, n = !1, s = !1;
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (h.POSITION !== void 0 && (r = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (s = !0), r && n && s)
      break;
  }
  if (!r && !n && !s)
    return Promise.resolve(c);
  const o = [], i = [], a = [];
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (r) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : c.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : c.attributes.normal;
      i.push(d);
    }
    if (s) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : c.attributes.color;
      a.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(i),
    Promise.all(a)
  ]).then(function(l) {
    const u = l[0], h = l[1], d = l[2];
    return r && (c.morphAttributes.position = u), n && (c.morphAttributes.normal = h), s && (c.morphAttributes.color = d), c.morphTargetsRelative = !0, c;
  });
}
function bM(c, e) {
  if (c.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, r = e.weights.length; t < r; t++)
      c.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (c.morphTargetInfluences.length === t.length) {
      c.morphTargetDictionary = {};
      for (let r = 0, n = t.length; r < n; r++)
        c.morphTargetDictionary[t[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function NM(c) {
  let e;
  const t = c.extensions && c.extensions[Ze.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + yl(t.attributes) : e = c.indices + ":" + yl(c.attributes) + ":" + c.mode, c.targets !== void 0)
    for (let r = 0, n = c.targets.length; r < n; r++)
      e += ":" + yl(c.targets[r]);
  return e;
}
function yl(c) {
  let e = "";
  const t = Object.keys(c).sort();
  for (let r = 0, n = t.length; r < n; r++)
    e += t[r] + ":" + c[t[r]] + ";";
  return e;
}
function uu(c) {
  switch (c) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function wM(c) {
  return c.search(/\.jpe?g($|\?)/i) > 0 || c.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : c.search(/\.webp($|\?)/i) > 0 || c.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const TM = new je();
class SM {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new q_(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, n = !1, s = -1;
    typeof navigator < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || n && s < 98 ? this.textureLoader = new _u(this.options.manager) : this.textureLoader = new Px(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Js(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(o) {
      const i = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: r,
        userData: {}
      };
      return lr(s, i, n), Bs(i, n), Promise.all(r._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(i);
      })).then(function() {
        e(i);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n].joints;
      for (let i = 0, a = o.length; i < a; i++)
        e[o[i]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1)
      return r;
    const n = r.clone(), s = (o, i) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(i, a);
      for (const [l, u] of o.children.entries())
        s(u, i.children[l]);
    };
    return s(r, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const n = e(t[r]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const r = e + ":" + t;
    let n = this.cache.get(r);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(s, o) {
        return r.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ze.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(s, o) {
      r.load(ho.resolveURL(t.uri, n.path), s, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(r) {
      const n = t.byteLength || 0, s = t.byteOffset || 0;
      return r.slice(s, s + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, r = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = ml[n.type], i = co[n.componentType], a = n.normalized === !0, l = new i(n.count * o);
      return Promise.resolve(new no(l, o, a));
    }
    const s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(o) {
      const i = o[0], a = ml[n.type], l = co[n.componentType], u = l.BYTES_PER_ELEMENT, h = u * a, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? r.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, g;
      if (f && f !== h) {
        const b = Math.floor(d / f), x = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + b + ":" + n.count;
        let y = t.cache.get(x);
        y || (m = new l(i, b * f, n.count * f / u), y = new cm(m, f / u), t.cache.add(x, y)), g = new Vs(y, a, d % f / u, p);
      } else
        i === null ? m = new l(n.count * a) : m = new l(i, d, n.count * a), g = new no(m, a, p);
      if (n.sparse !== void 0) {
        const b = ml.SCALAR, x = co[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, v = n.sparse.values.byteOffset || 0, N = new x(o[1], y, n.sparse.count * b), w = new l(o[2], v, n.sparse.count * a);
        i !== null && (g = new no(g.array.slice(), g.itemSize, g.normalized));
        for (let T = 0, S = N.length; T < S; T++) {
          const A = N[T];
          if (g.setX(A, w[T * a]), a >= 2 && g.setY(A, w[T * a + 1]), a >= 3 && g.setZ(A, w[T * a + 2]), a >= 4 && g.setW(A, w[T * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, r = this.options, s = t.textures[e].source, o = t.images[s];
    let i = this.textureLoader;
    if (o.uri) {
      const a = r.manager.getHandler(o.uri);
      a !== null && (i = a);
    }
    return this.loadTextureImage(e, s, i);
  }
  loadTextureImage(e, t, r) {
    const n = this, s = this.json, o = s.textures[e], i = s.images[t], a = (i.uri || i.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const l = this.loadImageSource(t, r).then(function(u) {
      u.flipY = !1, u.name = o.name || i.name || "", u.name === "" && typeof i.uri == "string" && i.uri.startsWith("data:image/") === !1 && (u.name = i.uri);
      const d = (s.samplers || {})[o.sampler] || {};
      return u.magFilter = Mp[d.magFilter] || uo, u.minFilter = Mp[d.minFilter] || yo, u.wrapS = Ap[d.wrapS] || Ys, u.wrapT = Ap[d.wrapT] || Ys, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = l, l;
  }
  loadImageSource(e, t) {
    const r = this, n = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], i = self.URL || self.webkitURL;
    let a = o.uri || "", l = !1;
    if (o.bufferView !== void 0)
      a = r.getDependency("bufferView", o.bufferView).then(function(h) {
        l = !0;
        const d = new Blob([h], { type: o.mimeType });
        return a = i.createObjectURL(d), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(d, f) {
        let p = d;
        t.isImageBitmapLoader === !0 && (p = function(m) {
          const g = new Gn(m);
          g.needsUpdate = !0, d(g);
        }), t.load(ho.resolveURL(h, s.path), p, void 0, f);
      });
    }).then(function(h) {
      return l === !0 && i.revokeObjectURL(a), h.userData.mimeType = o.mimeType || wM(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, r, n) {
    const s = this;
    return this.getDependency("texture", r.index).then(function(o) {
      if (!o)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[Ze.KHR_TEXTURE_TRANSFORM]) {
        const i = r.extensions !== void 0 ? r.extensions[Ze.KHR_TEXTURE_TRANSFORM] : void 0;
        if (i) {
          const a = s.associations.get(o);
          o = s.extensions[Ze.KHR_TEXTURE_TRANSFORM].extendTexture(o, i), s.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const i = "PointsMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new gm(), Bn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, a.sizeAttenuation = !1, this.cache.add(i, a)), r = a;
    } else if (e.isLine) {
      const i = "LineBasicMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new wu(), Bn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, this.cache.add(i, a)), r = a;
    }
    if (n || s || o) {
      let i = "ClonedMaterial:" + r.uuid + ":";
      n && (i += "derivative-tangents:"), s && (i += "vertex-colors:"), o && (i += "flat-shading:");
      let a = this.cache.get(i);
      a || (a = r.clone(), s && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(i, a), this.associations.set(a, this.associations.get(r))), r = a;
    }
    e.material = r;
  }
  getMaterialType() {
    return Vn;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, r = this.json, n = this.extensions, s = r.materials[e];
    let o;
    const i = {}, a = s.extensions || {}, l = [];
    if (a[Ze.KHR_MATERIALS_UNLIT]) {
      const h = n[Ze.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), l.push(h.extendParams(i, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (i.color = new He(1, 1, 1), i.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        i.color.setRGB(d[0], d[1], d[2], Rn), i.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(i, "map", h.baseColorTexture, vn)), i.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, i.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(i, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(i, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, i);
      })));
    }
    s.doubleSided === !0 && (i.side = Su);
    const u = s.alphaMode || gl.OPAQUE;
    if (u === gl.BLEND ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === gl.MASK && (i.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "normalMap", s.normalTexture)), i.normalScale = new Nt(1, 1), s.normalTexture.scale !== void 0)) {
      const h = s.normalTexture.scale;
      i.normalScale.set(h, h);
    }
    if (s.occlusionTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (i.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== An) {
      const h = s.emissiveFactor;
      i.emissive = new He().setRGB(h[0], h[1], h[2], Rn);
    }
    return s.emissiveTexture !== void 0 && o !== An && l.push(t.assignTexture(i, "emissiveMap", s.emissiveTexture, vn)), Promise.all(l).then(function() {
      const h = new o(i);
      return s.name && (h.name = s.name), Bs(h, s), t.associations.set(h, { materials: e }), s.extensions && lr(n, h, s), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Qo.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, r = this.extensions, n = this.primitiveCache;
    function s(i) {
      return r[Ze.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i, t).then(function(a) {
        return Cp(a, i, t);
      });
    }
    const o = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i], u = NM(l), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        l.extensions && l.extensions[Ze.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = Cp(new Ss(), l, t), n[u] = { primitive: l, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, r = this.json, n = this.extensions, s = r.meshes[e], o = s.primitives, i = [];
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a].material === void 0 ? vM(this.cache) : this.getDependency("material", o[a].material);
      i.push(u);
    }
    return i.push(t.loadGeometries(o)), Promise.all(i).then(function(a) {
      const l = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let f = 0, p = u.length; f < p; f++) {
        const m = u[f], g = o[f];
        let b;
        const x = l[f];
        if (g.mode === Pn.TRIANGLES || g.mode === Pn.TRIANGLE_STRIP || g.mode === Pn.TRIANGLE_FAN || g.mode === void 0)
          b = s.isSkinnedMesh === !0 ? new Tm(m, x) : new Qt(m, x), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), g.mode === Pn.TRIANGLE_STRIP ? b.geometry = Sp(b.geometry, wm) : g.mode === Pn.TRIANGLE_FAN && (b.geometry = Sp(b.geometry, zl));
        else if (g.mode === Pn.LINES)
          b = new Dx(m, x);
        else if (g.mode === Pn.LINE_STRIP)
          b = new Sm(m, x);
        else if (g.mode === Pn.LINE_LOOP)
          b = new Ux(m, x);
        else if (g.mode === Pn.POINTS)
          b = new _m(m, x);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(b.geometry.morphAttributes).length > 0 && bM(b, s), b.name = t.createUniqueName(s.name || "mesh_" + e), Bs(b, s), g.extensions && lr(n, b, g), t.assignFinalMaterial(b), h.push(b);
      }
      for (let f = 0, p = h.length; f < p; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return s.extensions && lr(n, h[0], s), h[0];
      const d = new ro();
      s.extensions && lr(n, d, s), t.associations.set(d, { meshes: e });
      for (let f = 0, p = h.length; f < p; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e], n = r[r.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? t = new xr(Yt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : r.type === "orthographic" && (t = new qa(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Bs(t, r), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], r = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      r.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(n) {
      const s = n.pop(), o = n, i = [], a = [];
      for (let l = 0, u = o.length; l < u; l++) {
        const h = o[l];
        if (h) {
          i.push(h);
          const d = new je();
          s !== null && d.fromArray(s.array, l * 16), a.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
      }
      return new Mu(i, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, r = this, n = t.animations[e], s = n.name ? n.name : "animation_" + e, o = [], i = [], a = [], l = [], u = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const f = n.channels[h], p = n.samplers[f.sampler], m = f.target, g = m.node, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, x = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (o.push(this.getDependency("node", g)), i.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", x)), l.push(p), u.push(m));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(i),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u)
    ]).then(function(h) {
      const d = h[0], f = h[1], p = h[2], m = h[3], g = h[4], b = [];
      for (let x = 0, y = d.length; x < y; x++) {
        const v = d[x], N = f[x], w = p[x], T = m[x], S = g[x];
        if (v === void 0)
          continue;
        v.updateMatrix && v.updateMatrix();
        const A = r._createAnimationTracks(v, N, w, T, S);
        if (A)
          for (let R = 0; R < A.length; R++)
            b.push(A[R]);
      }
      return new Au(s, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json, r = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : r.getDependency("mesh", n.mesh).then(function(s) {
      const o = r._getNodeRef(r.meshCache, n.mesh, s);
      return n.weights !== void 0 && o.traverse(function(i) {
        if (i.isMesh)
          for (let a = 0, l = n.weights.length; a < l; a++)
            i.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, r = this, n = t.nodes[e], s = r._loadNodeShallow(e), o = [], i = n.children || [];
    for (let l = 0, u = i.length; l < u; l++)
      o.push(r.getDependency("node", i[l]));
    const a = n.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", n.skin);
    return Promise.all([
      s,
      Promise.all(o),
      a
    ]).then(function(l) {
      const u = l[0], h = l[1], d = l[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, TM);
      });
      for (let f = 0, p = h.length; f < p; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, r = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], o = s.name ? n.createUniqueName(s.name) : "", i = [], a = n._invokeOne(function(l) {
      return l.createNodeMesh && l.createNodeMesh(e);
    });
    return a && i.push(a), s.camera !== void 0 && i.push(n.getDependency("camera", s.camera).then(function(l) {
      return n._getNodeRef(n.cameraCache, s.camera, l);
    })), n._invokeAll(function(l) {
      return l.createNodeAttachment && l.createNodeAttachment(e);
    }).forEach(function(l) {
      i.push(l);
    }), this.nodeCache[e] = Promise.all(i).then(function(l) {
      let u;
      if (s.isBone === !0 ? u = new Bl() : l.length > 1 ? u = new ro() : l.length === 1 ? u = l[0] : u = new En(), u !== l[0])
        for (let h = 0, d = l.length; h < d; h++)
          u.add(l[h]);
      if (s.name && (u.userData.name = s.name, u.name = o), Bs(u, s), s.extensions && lr(r, u, s), s.matrix !== void 0) {
        const h = new je();
        h.fromArray(s.matrix), u.applyMatrix4(h);
      } else
        s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, r = this.json.scenes[e], n = this, s = new ro();
    r.name && (s.name = n.createUniqueName(r.name)), Bs(s, r), r.extensions && lr(t, s, r);
    const o = r.nodes || [], i = [];
    for (let a = 0, l = o.length; a < l; a++)
      i.push(n.getDependency("node", o[a]));
    return Promise.all(i).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        s.add(a[u]);
      const l = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof Bn || d instanceof Gn) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = l(s), s;
    });
  }
  _createAnimationTracks(e, t, r, n, s) {
    const o = [], i = e.name ? e.name : e.uuid, a = [];
    Fs[s.path] === Fs.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && a.push(d.name ? d.name : d.uuid);
    }) : a.push(i);
    let l;
    switch (Fs[s.path]) {
      case Fs.weights:
        l = Gl;
        break;
      case Fs.rotation:
        l = Vl;
        break;
      case Fs.position:
      case Fs.scale:
        l = kl;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            l = Gl;
            break;
          case 2:
          case 3:
          default:
            l = kl;
            break;
        }
        break;
    }
    const u = n.interpolation !== void 0 ? yM[n.interpolation] : Mm, h = this._getArrayFromAccessor(r);
    for (let d = 0, f = a.length; d < f; d++) {
      const p = new l(
        a[d] + "." + Fs[s.path],
        t.array,
        h,
        u
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const r = uu(t.constructor), n = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++)
        n[s] = t[s] * r;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(r) {
      const n = this instanceof Vl ? gM : p1;
      return new n(this.times, this.values, this.getValueSize() / 3, r);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function _M(c, e, t) {
  const r = e.attributes, n = new tr();
  if (r.POSITION !== void 0) {
    const i = t.json.accessors[r.POSITION], a = i.min, l = i.max;
    if (a !== void 0 && l !== void 0) {
      if (n.set(
        new ge(a[0], a[1], a[2]),
        new ge(l[0], l[1], l[2])
      ), i.normalized) {
        const u = uu(co[i.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const s = e.targets;
  if (s !== void 0) {
    const i = new ge(), a = new ge();
    for (let l = 0, u = s.length; l < u; l++) {
      const h = s[l];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, p = d.max;
        if (f !== void 0 && p !== void 0) {
          if (a.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), a.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), a.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
            const m = uu(co[d.componentType]);
            a.multiplyScalar(m);
          }
          i.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(i);
  }
  c.boundingBox = n;
  const o = new yi();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, c.boundingSphere = o;
}
function Cp(c, e, t) {
  const r = e.attributes, n = [];
  function s(o, i) {
    return t.getDependency("accessor", o).then(function(a) {
      c.setAttribute(i, a);
    });
  }
  for (const o in r) {
    const i = lu[o] || o.toLowerCase();
    i in c.attributes || n.push(s(r[o], i));
  }
  if (e.indices !== void 0 && !c.index) {
    const o = t.getDependency("accessor", e.indices).then(function(i) {
      c.setIndex(i);
    });
    n.push(o);
  }
  return Of.workingColorSpace !== Rn && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Of.workingColorSpace}" not supported.`), Bs(c, e), _M(c, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? xM(c, e.targets, t) : c;
  });
}
const vl = /* @__PURE__ */ new WeakMap();
class MM extends vr {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, r, n) {
    const s = new Js(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      this.parse(o, t, n);
    }, r, n);
  }
  parse(e, t, r) {
    this.decodeDracoFile(e, t, null, null, vn).catch(r);
  }
  decodeDracoFile(e, t, r, n, s = Rn) {
    const o = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: s
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const r = JSON.stringify(t);
    if (vl.has(e)) {
      const a = vl.get(e);
      if (a.key === r)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++, o = e.byteLength, i = this._getWorker(s, o).then((a) => (n = a, new Promise((l, u) => {
      n._callbacks[s] = { resolve: l, reject: u }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return i.catch(() => !0).then(() => {
      n && s && this._releaseTask(n, s);
    }), vl.set(e, {
      key: r,
      promise: i
    }), i;
  }
  _createGeometry(e) {
    const t = new Ss();
    e.index && t.setIndex(new no(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const n = e.attributes[r], s = n.name, o = n.array, i = n.itemSize, a = new no(o, i);
      s === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(s, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== vn)
      return;
    const r = new He();
    for (let n = 0, s = e.count; n < s; n++)
      r.fromBufferAttribute(e, n).convertSRGBToLinear(), e.setXYZ(n, r.r, r.g, r.b);
  }
  _loadLibrary(e, t) {
    const r = new Js(this.manager);
    return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((n, s) => {
      r.load(e, n, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((r) => {
      const n = r[0];
      e || (this.decoderConfig.wasmBinary = r[1]);
      const s = AM.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(s) {
          const o = s.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, s) {
          return n._taskLoad > s._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return r._taskCosts[e] = t, r._taskLoad += t, r;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function AM() {
  let c, e;
  onmessage = function(o) {
    const i = o.data;
    switch (i.type) {
      case "init":
        c = i.decoderConfig, e = new Promise(function(u) {
          c.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(c);
        });
        break;
      case "decode":
        const a = i.buffer, l = i.taskConfig;
        e.then((u) => {
          const h = u.draco, d = new h.Decoder();
          try {
            const f = t(h, d, new Int8Array(a), l), p = f.attributes.map((m) => m.array.buffer);
            f.index && p.push(f.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: f }, p);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: i.id, error: f.message });
          } finally {
            h.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, i, a, l) {
    const u = l.attributeIDs, h = l.attributeTypes;
    let d, f;
    const p = i.GetEncodedGeometryType(a);
    if (p === o.TRIANGULAR_MESH)
      d = new o.Mesh(), f = i.DecodeArrayToMesh(a, a.byteLength, d);
    else if (p === o.POINT_CLOUD)
      d = new o.PointCloud(), f = i.DecodeArrayToPointCloud(a, a.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const m = { index: null, attributes: [] };
    for (const g in u) {
      const b = self[h[g]];
      let x, y;
      if (l.useUniqueIDs)
        y = u[g], x = i.GetAttributeByUniqueId(d, y);
      else {
        if (y = i.GetAttributeId(d, o[u[g]]), y === -1)
          continue;
        x = i.GetAttribute(d, y);
      }
      const v = n(o, i, d, g, b, x);
      g === "color" && (v.vertexColorSpace = l.vertexColorSpace), m.attributes.push(v);
    }
    return p === o.TRIANGULAR_MESH && (m.index = r(o, i, d)), o.destroy(d), m;
  }
  function r(o, i, a) {
    const u = a.num_faces() * 3, h = u * 4, d = o._malloc(h);
    i.GetTrianglesUInt32Array(a, h, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function n(o, i, a, l, u, h) {
    const d = h.num_components(), p = a.num_points() * d, m = p * u.BYTES_PER_ELEMENT, g = s(o, u), b = o._malloc(m);
    i.GetAttributeDataArrayForAllPoints(a, h, g, m, b);
    const x = new u(o.HEAPF32.buffer, b, p).slice();
    return o._free(b), {
      name: l,
      array: x,
      itemSize: d
    };
  }
  function s(o, i) {
    switch (i) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Ep = function(c) {
  return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Ep(""));
} catch {
  Ep = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var zn = Uint8Array, Hs = Uint16Array, hu = Uint32Array, m1 = new zn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), g1 = new zn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), CM = new zn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), y1 = function(c, e) {
  for (var t = new Hs(31), r = 0; r < 31; ++r)
    t[r] = e += 1 << c[r - 1];
  for (var n = new hu(t[30]), r = 1; r < 30; ++r)
    for (var s = t[r]; s < t[r + 1]; ++s)
      n[s] = s - t[r] << 5 | r;
  return [t, n];
}, v1 = y1(m1, 2), x1 = v1[0], EM = v1[1];
x1[28] = 258, EM[258] = 28;
var RM = y1(g1, 0), LM = RM[0], du = new Hs(32768);
for (var ft = 0; ft < 32768; ++ft) {
  var Os = (ft & 43690) >>> 1 | (ft & 21845) << 1;
  Os = (Os & 52428) >>> 2 | (Os & 13107) << 2, Os = (Os & 61680) >>> 4 | (Os & 3855) << 4, du[ft] = ((Os & 65280) >>> 8 | (Os & 255) << 8) >>> 1;
}
var Jo = function(c, e, t) {
  for (var r = c.length, n = 0, s = new Hs(e); n < r; ++n)
    ++s[c[n] - 1];
  var o = new Hs(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + s[n - 1] << 1;
  var i;
  if (t) {
    i = new Hs(1 << e);
    var a = 15 - e;
    for (n = 0; n < r; ++n)
      if (c[n])
        for (var l = n << 4 | c[n], u = e - c[n], h = o[c[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          i[du[h] >>> a] = l;
  } else
    for (i = new Hs(r), n = 0; n < r; ++n)
      c[n] && (i[n] = du[o[c[n] - 1]++] >>> 15 - c[n]);
  return i;
}, Si = new zn(288);
for (var ft = 0; ft < 144; ++ft)
  Si[ft] = 8;
for (var ft = 144; ft < 256; ++ft)
  Si[ft] = 9;
for (var ft = 256; ft < 280; ++ft)
  Si[ft] = 7;
for (var ft = 280; ft < 288; ++ft)
  Si[ft] = 8;
var b1 = new zn(32);
for (var ft = 0; ft < 32; ++ft)
  b1[ft] = 5;
var FM = /* @__PURE__ */ Jo(Si, 9, 1), OM = /* @__PURE__ */ Jo(b1, 5, 1), xl = function(c) {
  for (var e = c[0], t = 1; t < c.length; ++t)
    c[t] > e && (e = c[t]);
  return e;
}, Xn = function(c, e, t) {
  var r = e / 8 | 0;
  return (c[r] | c[r + 1] << 8) >> (e & 7) & t;
}, bl = function(c, e) {
  var t = e / 8 | 0;
  return (c[t] | c[t + 1] << 8 | c[t + 2] << 16) >> (e & 7);
}, IM = function(c) {
  return (c / 8 | 0) + (c & 7 && 1);
}, PM = function(c, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > c.length) && (t = c.length);
  var r = new (c instanceof Hs ? Hs : c instanceof hu ? hu : zn)(t - e);
  return r.set(c.subarray(e, t)), r;
}, DM = function(c, e, t) {
  var r = c.length;
  if (!r || t && !t.l && r < 5)
    return e || new zn(0);
  var n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new zn(r * 3));
  var o = function(ie) {
    var J = e.length;
    if (ie > J) {
      var se = new zn(Math.max(J * 2, ie));
      se.set(e), e = se;
    }
  }, i = t.f || 0, a = t.p || 0, l = t.b || 0, u = t.l, h = t.d, d = t.m, f = t.n, p = r * 8;
  do {
    if (!u) {
      t.f = i = Xn(c, a, 1);
      var m = Xn(c, a + 1, 3);
      if (a += 3, m)
        if (m == 1)
          u = FM, h = OM, d = 9, f = 5;
        else if (m == 2) {
          var y = Xn(c, a, 31) + 257, v = Xn(c, a + 10, 15) + 4, N = y + Xn(c, a + 5, 31) + 1;
          a += 14;
          for (var w = new zn(N), T = new zn(19), S = 0; S < v; ++S)
            T[CM[S]] = Xn(c, a + S * 3, 7);
          a += v * 3;
          for (var A = xl(T), R = (1 << A) - 1, O = Jo(T, A, 1), S = 0; S < N; ) {
            var _ = O[Xn(c, a, R)];
            a += _ & 15;
            var g = _ >>> 4;
            if (g < 16)
              w[S++] = g;
            else {
              var L = 0, E = 0;
              for (g == 16 ? (E = 3 + Xn(c, a, 3), a += 2, L = w[S - 1]) : g == 17 ? (E = 3 + Xn(c, a, 7), a += 3) : g == 18 && (E = 11 + Xn(c, a, 127), a += 7); E--; )
                w[S++] = L;
            }
          }
          var D = w.subarray(0, y), F = w.subarray(y);
          d = xl(D), f = xl(F), u = Jo(D, d, 1), h = Jo(F, f, 1);
        } else
          throw "invalid block type";
      else {
        var g = IM(a) + 4, b = c[g - 4] | c[g - 3] << 8, x = g + b;
        if (x > r) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + b), e.set(c.subarray(g, x), l), t.b = l += b, t.p = a = x * 8;
        continue;
      }
      if (a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(l + 131072);
    for (var H = (1 << d) - 1, q = (1 << f) - 1, U = a; ; U = a) {
      var L = u[bl(c, a) & H], k = L >>> 4;
      if (a += L & 15, a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!L)
        throw "invalid length/literal";
      if (k < 256)
        e[l++] = k;
      else if (k == 256) {
        U = a, u = null;
        break;
      } else {
        var C = k - 254;
        if (k > 264) {
          var S = k - 257, P = m1[S];
          C = Xn(c, a, (1 << P) - 1) + x1[S], a += P;
        }
        var X = h[bl(c, a) & q], Y = X >>> 4;
        if (!X)
          throw "invalid distance";
        a += X & 15;
        var F = LM[Y];
        if (Y > 3) {
          var P = g1[Y];
          F += bl(c, a) & (1 << P) - 1, a += P;
        }
        if (a > p) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + 131072);
        for (var W = l + C; l < W; l += 4)
          e[l] = e[l - F], e[l + 1] = e[l + 1 - F], e[l + 2] = e[l + 2 - F], e[l + 3] = e[l + 3 - F];
        l = W;
      }
    }
    t.l = u, t.p = U, t.b = l, u && (i = 1, t.m = d, t.d = h, t.n = f);
  } while (!i);
  return l == e.length ? e : PM(e, 0, l);
}, UM = /* @__PURE__ */ new zn(0), zM = function(c) {
  if ((c[0] & 15) != 8 || c[0] >>> 4 > 7 || (c[0] << 8 | c[1]) % 31)
    throw "invalid zlib data";
  if (c[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function BM(c, e) {
  return DM((zM(c), c.subarray(2, -4)), e);
}
var kM = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), GM = 0;
try {
  kM.decode(UM, { stream: !0 }), GM = 1;
} catch {
}
function N1(c, e, t) {
  const r = t.length - c - 1;
  if (e >= t[r])
    return r - 1;
  if (e <= t[c])
    return c;
  let n = c, s = r, o = Math.floor((n + s) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? s = o : n = o, o = Math.floor((n + s) / 2);
  return o;
}
function VM(c, e, t, r) {
  const n = [], s = [], o = [];
  n[0] = 1;
  for (let i = 1; i <= t; ++i) {
    s[i] = e - r[c + 1 - i], o[i] = r[c + i] - e;
    let a = 0;
    for (let l = 0; l < i; ++l) {
      const u = o[l + 1], h = s[i - l], d = n[l] / (u + h);
      n[l] = a + u * d, a = h * d;
    }
    n[i] = a;
  }
  return n;
}
function jM(c, e, t, r) {
  const n = N1(c, r, e), s = VM(n, r, c, e), o = new pt(0, 0, 0, 0);
  for (let i = 0; i <= c; ++i) {
    const a = t[n - c + i], l = s[i], u = a.w * l;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * l;
  }
  return o;
}
function WM(c, e, t, r, n) {
  const s = [];
  for (let h = 0; h <= t; ++h)
    s[h] = 0;
  const o = [];
  for (let h = 0; h <= r; ++h)
    o[h] = s.slice(0);
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = s.slice(0);
  i[0][0] = 1;
  const a = s.slice(0), l = s.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[c + 1 - h], l[h] = n[c + h] - e;
    let d = 0;
    for (let f = 0; f < h; ++f) {
      const p = l[f + 1], m = a[h - f];
      i[h][f] = p + m;
      const g = i[f][h - 1] / i[h][f];
      i[f][h] = d + p * g, d = m * g;
    }
    i[h][h] = d;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = i[h][t];
  for (let h = 0; h <= t; ++h) {
    let d = 0, f = 1;
    const p = [];
    for (let m = 0; m <= t; ++m)
      p[m] = s.slice(0);
    p[0][0] = 1;
    for (let m = 1; m <= r; ++m) {
      let g = 0;
      const b = h - m, x = t - m;
      h >= m && (p[f][0] = p[d][0] / i[x + 1][b], g = p[f][0] * i[b][x]);
      const y = b >= -1 ? 1 : -b, v = h - 1 <= x ? m - 1 : t - h;
      for (let w = y; w <= v; ++w)
        p[f][w] = (p[d][w] - p[d][w - 1]) / i[x + 1][b + w], g += p[f][w] * i[b + w][x];
      h <= x && (p[f][m] = -p[d][m - 1] / i[x + 1][h], g += p[f][m] * i[h][x]), o[m][h] = g;
      const N = d;
      d = f, f = N;
    }
  }
  let u = t;
  for (let h = 1; h <= r; ++h) {
    for (let d = 0; d <= t; ++d)
      o[h][d] *= u;
    u *= t - h;
  }
  return o;
}
function HM(c, e, t, r, n) {
  const s = n < c ? n : c, o = [], i = N1(c, r, e), a = WM(i, r, c, s, e), l = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), d = h.w;
    h.x *= d, h.y *= d, h.z *= d, l[u] = h;
  }
  for (let u = 0; u <= s; ++u) {
    const h = l[i - c].clone().multiplyScalar(a[u][0]);
    for (let d = 1; d <= c; ++d)
      h.add(l[i - c + d].clone().multiplyScalar(a[u][d]));
    o[u] = h;
  }
  for (let u = s + 1; u <= n + 1; ++u)
    o[u] = new pt(0, 0, 0);
  return o;
}
function XM(c, e) {
  let t = 1;
  for (let n = 2; n <= c; ++n)
    t *= n;
  let r = 1;
  for (let n = 2; n <= e; ++n)
    r *= n;
  for (let n = 2; n <= c - e; ++n)
    r *= n;
  return t / r;
}
function $M(c) {
  const e = c.length, t = [], r = [];
  for (let s = 0; s < e; ++s) {
    const o = c[s];
    t[s] = new ge(o.x, o.y, o.z), r[s] = o.w;
  }
  const n = [];
  for (let s = 0; s < e; ++s) {
    const o = t[s].clone();
    for (let i = 1; i <= s; ++i)
      o.sub(n[s - i].clone().multiplyScalar(XM(s, i) * r[i]));
    n[s] = o.divideScalar(r[0]);
  }
  return n;
}
function qM(c, e, t, r, n) {
  const s = HM(c, e, t, r, n);
  return $M(s);
}
class JM extends kx {
  constructor(e, t, r, n, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = s || this.knots.length - 1;
    for (let o = 0; o < r.length; ++o) {
      const i = r[o];
      this.controlPoints[o] = new pt(i.x, i.y, i.z, i.w);
    }
  }
  getPoint(e, t = new ge()) {
    const r = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = jM(this.degree, this.knots, this.controlPoints, n);
    return s.w !== 1 && s.divideScalar(s.w), r.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new ge()) {
    const r = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = qM(this.degree, this.knots, this.controlPoints, n, 1);
    return r.copy(s[1]).normalize(), r;
  }
}
let qe, wt, mn;
class YM extends vr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, n) {
    const s = this, o = s.path === "" ? ho.extractUrlBase(e) : s.path, i = new Js(this.manager);
    i.setPath(s.path), i.setResponseType("arraybuffer"), i.setRequestHeader(s.requestHeader), i.setWithCredentials(s.withCredentials), i.load(e, function(a) {
      try {
        t(s.parse(a, o));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, r, n);
  }
  parse(e, t) {
    if (nA(e))
      qe = new tA().parse(e);
    else {
      const n = _1(e);
      if (!sA(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Lp(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Lp(n));
      qe = new eA().parse(n);
    }
    const r = new _u(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new KM(r, this.manager).parse(qe);
  }
}
class KM {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    wt = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), r = this.parseMaterials(t), n = this.parseDeformers(), s = new ZM().parse(n);
    return this.parseScene(n, s, r), mn;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in qe && qe.Connections.connections.forEach(function(r) {
      const n = r[0], s = r[1], o = r[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const i = { ID: s, relationship: o };
      e.get(n).parents.push(i), e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(s).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in qe.Objects) {
      const r = qe.Objects.Video;
      for (const n in r) {
        const s = r[n], o = parseInt(n);
        if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
          const i = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, a = typeof s.Content == "string" && s.Content !== "";
          if (i || a) {
            const l = this.parseImage(r[n]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const r in e) {
      const n = e[r];
      t[n] !== void 0 ? e[r] = t[n] : e[r] = e[r].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, r = e.RelativeFilename || e.Filename, n = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (n) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", r), s = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: s }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in qe.Objects) {
      const r = qe.Objects.Texture;
      for (const n in r) {
        const s = this.parseTexture(r[n], e);
        t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const r = this.loadTexture(e, t);
    r.ID = e.id, r.name = e.attrName;
    const n = e.WrapModeU, s = e.WrapModeV, o = n !== void 0 ? n.value : 0, i = s !== void 0 ? s.value : 0;
    if (r.wrapS = o === 0 ? Ys : fo, r.wrapT = i === 0 ? Ys : fo, "Scaling" in e) {
      const a = e.Scaling.value;
      r.repeat.x = a[0], r.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      r.offset.x = a[0], r.offset.y = a[1];
    }
    return r;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let r;
    const n = this.textureLoader.path, s = wt.get(e.id).children;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (r = t[s[0].ID], (r.indexOf("blob:") === 0 || r.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const i = e.FileName.slice(-3).toLowerCase();
    if (i === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Gn()) : (a.setPath(this.textureLoader.path), o = a.load(r));
    } else
      i === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Gn()) : o = this.textureLoader.load(r);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in qe.Objects) {
      const r = qe.Objects.Material;
      for (const n in r) {
        const s = this.parseMaterial(r[n], e);
        s !== null && t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const r = e.id, n = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !wt.has(r))
      return null;
    const o = this.parseParameters(e, t, r);
    let i;
    switch (s.toLowerCase()) {
      case "phong":
        i = new fa();
        break;
      case "lambert":
        i = new mm();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), i = new fa();
        break;
    }
    return i.setValues(o), i.name = n, i;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, r) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new He().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new He().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new He().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new He().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new He().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new He().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return wt.get(r).children.forEach(function(o) {
      const i = o.relationship;
      switch (i) {
        case "Bump":
          n.bumpMap = s.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = s.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = s.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = vn);
          break;
        case "DisplacementColor":
          n.displacementMap = s.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = s.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = vn);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = s.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = s.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = Lm, n.envMap.colorSpace = vn);
          break;
        case "SpecularColor":
          n.specularMap = s.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = vn);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = s.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", i);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in qe.Objects && t in qe.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = wt.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in qe.Objects) {
      const r = qe.Objects.Deformer;
      for (const n in r) {
        const s = r[n], o = wt.get(parseInt(n));
        if (s.attrType === "Skin") {
          const i = this.parseSkeleton(o, r);
          i.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), i.geometryID = o.parents[0].ID, e[n] = i;
        } else if (s.attrType === "BlendShape") {
          const i = {
            id: n
          };
          i.rawTargets = this.parseMorphTargets(o, r), i.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = i;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const r = [];
    return e.children.forEach(function(n) {
      const s = t[n.ID];
      if (s.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new je().fromArray(s.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), r.push(o);
    }), {
      rawBones: r,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const r = [];
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n], o = t[s.ID], i = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      i.geoID = wt.get(parseInt(s.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, r.push(i);
    }
    return r;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, r) {
    mn = new ro();
    const n = this.parseModels(e.skeletons, t, r), s = qe.Objects.Model, o = this;
    n.forEach(function(a) {
      const l = s[a.ID];
      o.setLookAtProperties(a, l), wt.get(a.ID).parents.forEach(function(h) {
        const d = n.get(h.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && mn.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), mn.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const l = T1(a.userData.transformData);
        a.applyMatrix4(l), a.updateWorldMatrix();
      }
    });
    const i = new QM().parse();
    mn.children.length === 1 && mn.children[0].isGroup && (mn.children[0].animations = i, mn = mn.children[0]), mn.animations = i;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, r) {
    const n = /* @__PURE__ */ new Map(), s = qe.Objects.Model;
    for (const o in s) {
      const i = parseInt(o), a = s[o], l = wt.get(i);
      let u = this.buildSkeleton(l, e, i, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(l);
            break;
          case "Light":
            u = this.createLight(l);
            break;
          case "Mesh":
            u = this.createMesh(l, t, r);
            break;
          case "NurbsCurve":
            u = this.createCurve(l, t);
            break;
          case "LimbNode":
          case "Root":
            u = new Bl();
            break;
          case "Null":
          default:
            u = new ro();
            break;
        }
        u.name = a.attrName ? Qo.sanitizeNodeName(a.attrName) : "", u.userData.originalName = a.attrName, u.ID = i;
      }
      this.getTransformData(u, a), n.set(i, u);
    }
    return n;
  }
  buildSkeleton(e, t, r, n) {
    let s = null;
    return e.parents.forEach(function(o) {
      for (const i in t) {
        const a = t[i];
        a.rawBones.forEach(function(l, u) {
          if (l.ID === o.ID) {
            const h = s;
            s = new Bl(), s.matrixWorld.copy(l.transformLink), s.name = n ? Qo.sanitizeNodeName(n) : "", s.userData.originalName = n, s.ID = r, a.bones[u] = s, h !== null && s.add(h);
          }
        });
      }
    }), s;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = qe.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new En();
    else {
      let n = 0;
      r.CameraProjectionType !== void 0 && r.CameraProjectionType.value === 1 && (n = 1);
      let s = 1;
      r.NearPlane !== void 0 && (s = r.NearPlane.value / 1e3);
      let o = 1e3;
      r.FarPlane !== void 0 && (o = r.FarPlane.value / 1e3);
      let i = window.innerWidth, a = window.innerHeight;
      r.AspectWidth !== void 0 && r.AspectHeight !== void 0 && (i = r.AspectWidth.value, a = r.AspectHeight.value);
      const l = i / a;
      let u = 45;
      r.FieldOfView !== void 0 && (u = r.FieldOfView.value);
      const h = r.FocalLength ? r.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new xr(u, l, s, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new qa(-i / 2, i / 2, a / 2, -a / 2, s, o);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new En();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = qe.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new En();
    else {
      let n;
      r.LightType === void 0 ? n = 0 : n = r.LightType.value;
      let s = 16777215;
      r.Color !== void 0 && (s = new He().fromArray(r.Color.value).convertSRGBToLinear());
      let o = r.Intensity === void 0 ? 1 : r.Intensity.value / 100;
      r.CastLightOnObject !== void 0 && r.CastLightOnObject.value === 0 && (o = 0);
      let i = 0;
      r.FarAttenuationEnd !== void 0 && (r.EnableFarAttenuation !== void 0 && r.EnableFarAttenuation.value === 0 ? i = 0 : i = r.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new Zo(s, o, i, a);
          break;
        case 1:
          t = new pi(s, o);
          break;
        case 2:
          let l = Math.PI / 3;
          r.InnerAngle !== void 0 && (l = Yt.degToRad(r.InnerAngle.value));
          let u = 0;
          r.OuterAngle !== void 0 && (u = Yt.degToRad(r.OuterAngle.value), u = Math.max(u, 1)), t = new mi(s, o, i, l, u, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), t = new Zo(s, o);
          break;
      }
      r.CastShadows !== void 0 && r.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, r) {
    let n, s = null, o = null;
    const i = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (s = t.get(a.ID)), r.has(a.ID) && i.push(r.get(a.ID));
    }), i.length > 1 ? o = i : i.length > 0 ? o = i[0] : (o = new fa({
      name: vr.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), i.push(o)), "color" in s.attributes && i.forEach(function(a) {
      a.vertexColors = !0;
    }), s.FBX_Deformer ? (n = new Tm(s, o), n.normalizeSkinWeights()) : n = new Qt(s, o), n;
  }
  createCurve(e, t) {
    const r = e.children.reduce(function(s, o) {
      return t.has(o.ID) && (s = t.get(o.ID)), s;
    }, null), n = new wu({
      name: vr.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Sm(r, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const r = {};
    "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? r.eulerOrder = S1(t.RotationOrder.value) : r.eulerOrder = "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && wt.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const s = qe.Objects.Model[n.ID];
        if ("Lcl_Translation" in s) {
          const o = s.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), mn.add(e.target)) : e.lookAt(new ge().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, r) {
    const n = this.parsePoseNodes();
    for (const s in e) {
      const o = e[s];
      wt.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const l = a.ID;
          wt.get(l).parents.forEach(function(h) {
            r.has(h.ID) && r.get(h.ID).bind(new Mu(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in qe.Objects) {
      const t = qe.Objects.Pose;
      for (const r in t)
        if (t[r].attrType === "BindPose" && t[r].NbPoseNodes > 0) {
          const n = t[r].PoseNode;
          Array.isArray(n) ? n.forEach(function(s) {
            e[s.Node] = new je().fromArray(s.Matrix.a);
          }) : e[n.Node] = new je().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in qe && "AmbientColor" in qe.GlobalSettings) {
      const e = qe.GlobalSettings.AmbientColor.value, t = e[0], r = e[1], n = e[2];
      if (t !== 0 || r !== 0 || n !== 0) {
        const s = new He(t, r, n).convertSRGBToLinear();
        mn.add(new Nu(s, 1));
      }
    }
  }
}
class ZM {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in qe.Objects) {
      const r = qe.Objects.Geometry;
      for (const n in r) {
        const s = wt.get(parseInt(n)), o = this.parseGeometry(s, r[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, r) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, r);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, r) {
    const n = r.skeletons, s = [], o = e.parents.map(function(h) {
      return qe.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const i = e.children.reduce(function(h, d) {
      return n[d.ID] !== void 0 && (h = n[d.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      r.morphTargets[h.ID] !== void 0 && s.push(r.morphTargets[h.ID]);
    });
    const a = o[0], l = {};
    "RotationOrder" in a && (l.eulerOrder = S1(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
    const u = T1(l);
    return this.genGeometry(t, i, s, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, r, n) {
    const s = new Ss();
    e.attrName && (s.name = e.attrName);
    const o = this.parseGeoNode(e, t), i = this.genBuffers(o), a = new yn(i.vertex, 3);
    if (a.applyMatrix4(n), s.setAttribute("position", a), i.colors.length > 0 && s.setAttribute("color", new yn(i.colors, 3)), t && (s.setAttribute("skinIndex", new Gx(i.weightsIndices, 4)), s.setAttribute("skinWeight", new yn(i.vertexWeights, 4)), s.FBX_Deformer = t), i.normal.length > 0) {
      const l = new bs().getNormalMatrix(n), u = new yn(i.normal, 3);
      u.applyNormalMatrix(l), s.setAttribute("normal", u);
    }
    if (i.uvs.forEach(function(l, u) {
      const h = u === 0 ? "uv" : `uv${u}`;
      s.setAttribute(h, new yn(i.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let l = i.materialIndex[0], u = 0;
      if (i.materialIndex.forEach(function(h, d) {
        h !== l && (s.addGroup(u, d - u, l), l = h, u = d);
      }), s.groups.length > 0) {
        const h = s.groups[s.groups.length - 1], d = h.start + h.count;
        d !== i.materialIndex.length && s.addGroup(d, i.materialIndex.length - d, l);
      }
      s.groups.length === 0 && s.addGroup(0, i.materialIndex.length, i.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, r, n), s;
  }
  parseGeoNode(e, t) {
    const r = {};
    if (r.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], r.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      r.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && r.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return r.weightTable = {}, t !== null && (r.skeleton = t, t.rawBones.forEach(function(n, s) {
      n.indices.forEach(function(o, i) {
        r.weightTable[o] === void 0 && (r.weightTable[o] = []), r.weightTable[o].push({
          id: s,
          weight: n.weights[i]
        });
      });
    })), r;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let r = 0, n = 0, s = !1, o = [], i = [], a = [], l = [], u = [], h = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, p) {
      let m, g = !1;
      f < 0 && (f = f ^ -1, g = !0);
      let b = [], x = [];
      if (o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = Yi(p, r, f, e.color);
        a.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          x.push(y.weight), b.push(y.id);
        }), x.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const y = [0, 0, 0, 0], v = [0, 0, 0, 0];
          x.forEach(function(N, w) {
            let T = N, S = b[w];
            v.forEach(function(A, R, O) {
              if (T > A) {
                O[R] = T, T = A;
                const _ = y[R];
                y[R] = S, S = _;
              }
            });
          }), b = y, x = v;
        }
        for (; x.length < 4; )
          x.push(0), b.push(0);
        for (let y = 0; y < 4; ++y)
          u.push(x[y]), h.push(b[y]);
      }
      if (e.normal) {
        const y = Yi(p, r, f, e.normal);
        i.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = Yi(p, r, f, e.material)[0], m < 0 && (d.negativeMaterialIndices = !0, m = 0)), e.uv && e.uv.forEach(function(y, v) {
        const N = Yi(p, r, f, y);
        l[v] === void 0 && (l[v] = []), l[v].push(N[0]), l[v].push(N[1]);
      }), n++, g && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, o, m, i, a, l, u, h, n), r++, n = 0, o = [], i = [], a = [], l = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, r, n, s, o, i, a, l, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[r[h * 3]]), e.vertex.push(t.vertexPositions[r[h * 3 + 1]]), e.vertex.push(t.vertexPositions[r[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[(h - 1) * 4]), e.weightsIndices.push(l[(h - 1) * 4 + 1]), e.weightsIndices.push(l[(h - 1) * 4 + 2]), e.weightsIndices.push(l[(h - 1) * 4 + 3]), e.weightsIndices.push(l[h * 4]), e.weightsIndices.push(l[h * 4 + 1]), e.weightsIndices.push(l[h * 4 + 2]), e.weightsIndices.push(l[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(i[f][0]), e.uvs[f].push(i[f][1]), e.uvs[f].push(i[f][(h - 1) * 2]), e.uvs[f].push(i[f][(h - 1) * 2 + 1]), e.uvs[f].push(i[f][h * 2]), e.uvs[f].push(i[f][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, r, n) {
    if (r.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    r.forEach(function(o) {
      o.rawTargets.forEach(function(i) {
        const a = qe.Objects.Geometry[i.geoID];
        a !== void 0 && s.genMorphGeometry(e, t, a, n, i.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, r, n, s) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], i = r.Vertices !== void 0 ? r.Vertices.a : [], a = r.Indexes !== void 0 ? r.Indexes.a : [], l = e.attributes.position.count * 3, u = new Float32Array(l);
    for (let p = 0; p < a.length; p++) {
      const m = a[p] * 3;
      u[m] = i[p * 3], u[m + 1] = i[p * 3 + 1], u[m + 2] = i[p * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, d = this.genBuffers(h), f = new yn(d.vertex, 3);
    f.name = s || r.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Normals.a;
    let s = [];
    return r === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.UV.a;
    let s = [];
    return r === "IndexToDirect" && (s = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Colors.a;
    let s = [];
    r === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let o = 0, i = new He(); o < n.length; o += 4)
      i.fromArray(n, o).convertSRGBToLinear().toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: r
      };
    const n = e.Materials.a, s = [];
    for (let o = 0; o < n.length; ++o)
      s.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Ss();
    const r = t - 1, n = e.KnotVector.a, s = [], o = e.Points.a;
    for (let h = 0, d = o.length; h < d; h += 4)
      s.push(new pt().fromArray(o, h));
    let i, a;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      i = r, a = n.length - 1 - i;
      for (let h = 0; h < r; ++h)
        s.push(s[h]);
    }
    const u = new JM(r, n, s, i, a).getPoints(s.length * 12);
    return new Ss().setFromPoints(u);
  }
}
class QM {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const r in t) {
        const n = t[r], s = this.addClip(n);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (qe.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = qe.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const r in e) {
      const n = e[r];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(s.id, s);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = qe.Objects.AnimationCurve;
    for (const r in t) {
      const n = {
        id: t[r].id,
        times: t[r].KeyTime.a.map(rA),
        values: t[r].KeyValueFloat.a
      }, s = wt.get(n.id);
      if (s !== void 0) {
        const o = s.parents[0].ID, i = s.parents[0].relationship;
        i.match(/X/) ? e.get(o).curves.x = n : i.match(/Y/) ? e.get(o).curves.y = n : i.match(/Z/) ? e.get(o).curves.z = n : i.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = qe.Objects.AnimationLayer, r = /* @__PURE__ */ new Map();
    for (const n in t) {
      const s = [], o = wt.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, l) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (s[l] === void 0) {
              const h = wt.get(a.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const d = qe.Objects.Model[h.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const f = {
                  modelName: d.attrName ? Qo.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                mn.traverse(function(p) {
                  p.ID === d.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new je()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), s[l] = f;
              }
            }
            s[l] && (s[l][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const h = wt.get(a.ID).parents.filter(function(b) {
                return b.relationship !== void 0;
              })[0].ID, d = wt.get(h).parents[0].ID, f = wt.get(d).parents[0].ID, p = wt.get(f).parents[0].ID, m = qe.Objects.Model[p], g = {
                modelName: m.attrName ? Qo.sanitizeNodeName(m.attrName) : "",
                morphName: qe.Objects.Deformer[h].attrName
              };
              s[l] = g;
            }
            s[l][u.attr] = u;
          }
        }
      }), r.set(parseInt(n), s));
    }
    return r;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = qe.Objects.AnimationStack, r = {};
    for (const n in t) {
      const s = wt.get(parseInt(n)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(s[0].ID);
      r[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return r;
  }
  addClip(e) {
    let t = [];
    const r = this;
    return e.layer.forEach(function(n) {
      t = t.concat(r.generateTracks(n));
    }), new Au(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let r = new ge(), n = new dr(), s = new ge();
    if (e.transform && e.transform.decompose(r, n, s), r = r.toArray(), n = new ws().setFromQuaternion(n, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, r, n) {
    const s = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(s, t, r);
    return new kl(e + "." + n, s, o);
  }
  generateRotationTrack(e, t, r, n, s, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Yt.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Yt.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Yt.degToRad));
    const i = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(i, t, r);
    n !== void 0 && (n = n.map(Yt.degToRad), n.push(o), n = new ws().fromArray(n), n = new dr().setFromEuler(n)), s !== void 0 && (s = s.map(Yt.degToRad), s.push(o), s = new ws().fromArray(s), s = new dr().setFromEuler(s).invert());
    const l = new dr(), u = new ws(), h = [];
    for (let d = 0; d < a.length; d += 3)
      u.set(a[d], a[d + 1], a[d + 2], o), l.setFromEuler(u), n !== void 0 && l.premultiply(n), s !== void 0 && l.multiply(s), l.toArray(h, d / 3 * 4);
    return new Vl(e + ".quaternion", i, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, r = t.values.map(function(s) {
      return s / 100;
    }), n = mn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Gl(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, r);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(r, n) {
      return r - n;
    }), t.length > 1) {
      let r = 1, n = t[0];
      for (let s = 1; s < t.length; s++) {
        const o = t[s];
        o !== n && (t[r] = o, n = o, r++);
      }
      t = t.slice(0, r);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, r) {
    const n = r, s = [];
    let o = -1, i = -1, a = -1;
    return e.forEach(function(l) {
      if (t.x && (o = t.x.times.indexOf(l)), t.y && (i = t.y.times.indexOf(l)), t.z && (a = t.z.times.indexOf(l)), o !== -1) {
        const u = t.x.values[o];
        s.push(u), n[0] = u;
      } else
        s.push(n[0]);
      if (i !== -1) {
        const u = t.y.values[i];
        s.push(u), n[1] = u;
      } else
        s.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        s.push(u), n[2] = u;
      } else
        s.push(n[2]);
    }), s;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const r = e.values[t - 1], n = e.values[t] - r, s = Math.abs(n);
      if (s >= 180) {
        const o = s / 180, i = n / o;
        let a = r + i;
        const l = e.times[t - 1], h = (e.times[t] - l) / o;
        let d = l + h;
        const f = [], p = [];
        for (; d < e.times[t]; )
          f.push(d), d += h, p.push(a), a += i;
        e.times = Fp(e.times, t, f), e.values = Fp(e.values, t, p);
      }
    }
  }
}
class eA {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new w1(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, r = e.split(/[\r\n]+/);
    return r.forEach(function(n, s) {
      const o = n.match(/^[\s\t]*;/), i = n.match(/^[\s\t]*$/);
      if (o || i)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : l ? t.parseNodeProperty(n, l, r[++s]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const r = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: r }, o = this.parseNodeAttr(n), i = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(r, s) : r in i ? (r === "PoseNode" ? i.PoseNode.push(s) : i[r].id !== void 0 && (i[r] = {}, i[r][i[r].id] = i[r]), o.id !== "" && (i[r][o.id] = s)) : typeof o.id == "number" ? (i[r] = {}, i[r][o.id] = s) : r !== "Properties70" && (r === "PoseNode" ? i[r] = [s] : i[r] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let r = "", n = "";
    return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: r, type: n };
  }
  parseNodeProperty(e, t, r) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, s);
      return;
    }
    if (n === "C") {
      const a = s.split(",").slice(1), l = parseInt(a[0]), u = parseInt(a[1]);
      let h = s.split(",").slice(3);
      h = h.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", s = [l, u], iA(s, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = s), n in o && Array.isArray(o[n]) ? o[n].push(s) : n !== "a" ? o[n] = s : o.a = s, this.setCurrentProp(o, n), n === "a" && s.slice(-1) !== "," && (o.a = wl(s));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = wl(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, r) {
    const n = r.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = n[0], o = n[1], i = n[2], a = n[3];
    let l = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        l = parseFloat(l);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        l = wl(l);
        break;
    }
    this.getPrevNode()[s] = {
      type: o,
      type2: i,
      flag: a,
      value: l
    }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class tA {
  parse(e) {
    const t = new Rp(e);
    t.skip(23);
    const r = t.getUint32();
    if (r < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
    const n = new w1();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, r);
      s !== null && n.add(s.name, s);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const r = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), i = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let d = 0; d < s; d++)
      a.push(this.parseProperty(e));
    const l = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (r.singleProperty = s === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(i, r, d);
    }
    return r.propertyList = a, typeof l == "number" && (r.id = l), u !== "" && (r.attrName = u), h !== "" && (r.attrType = h), i !== "" && (r.name = i), r;
  }
  parseSubNode(e, t, r) {
    if (r.singleProperty === !0) {
      const n = r.propertyList[0];
      Array.isArray(n) ? (t[r.name] = r, r.a = n) : t[r.name] = n;
    } else if (e === "Connections" && r.name === "C") {
      const n = [];
      r.propertyList.forEach(function(s, o) {
        o !== 0 && n.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (r.name === "Properties70")
      Object.keys(r).forEach(function(s) {
        t[s] = r[s];
      });
    else if (e === "Properties70" && r.name === "P") {
      let n = r.propertyList[0], s = r.propertyList[1];
      const o = r.propertyList[2], i = r.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? a = [
        r.propertyList[4],
        r.propertyList[5],
        r.propertyList[6]
      ] : a = r.propertyList[4], t[n] = {
        type: s,
        type2: o,
        flag: i,
        value: a
      };
    } else
      t[r.name] === void 0 ? typeof r.id == "number" ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : r.name === "PoseNode" ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : t[r.name][r.id] === void 0 && (t[r.name][r.id] = r);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let r;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return r = e.getUint32(), e.getArrayBuffer(r);
      case "S":
        return r = e.getUint32(), e.getString(r);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), s = e.getUint32(), o = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const i = BM(new Uint8Array(e.getArrayBuffer(o))), a = new Rp(i.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Rp {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let r = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = r.indexOf(0);
    return n >= 0 && (r = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(r);
  }
}
class w1 {
  add(e, t) {
    this[e] = t;
  }
}
function nA(c) {
  const e = "Kaydara FBX Binary  \0";
  return c.byteLength >= e.length && e === _1(c, 0, e.length);
}
function sA(c) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function r(n) {
    const s = c[n - 1];
    return c = c.slice(t + n), t++, s;
  }
  for (let n = 0; n < e.length; ++n)
    if (r(1) === e[n])
      return !1;
  return !0;
}
function Lp(c) {
  const e = /FBXVersion: (\d+)/, t = c.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function rA(c) {
  return c / 46186158e3;
}
const oA = [];
function Yi(c, e, t, r) {
  let n;
  switch (r.mappingType) {
    case "ByPolygonVertex":
      n = c;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = r.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
  }
  r.referenceType === "IndexToDirect" && (n = r.indices[n]);
  const s = n * r.dataSize, o = s + r.dataSize;
  return aA(oA, r.buffer, s, o);
}
const Nl = new ws(), Ir = new ge();
function T1(c) {
  const e = new je(), t = new je(), r = new je(), n = new je(), s = new je(), o = new je(), i = new je(), a = new je(), l = new je(), u = new je(), h = new je(), d = new je(), f = c.inheritType ? c.inheritType : 0;
  if (c.translation && e.setPosition(Ir.fromArray(c.translation)), c.preRotation) {
    const R = c.preRotation.map(Yt.degToRad);
    R.push(c.eulerOrder || ws.DEFAULT_ORDER), t.makeRotationFromEuler(Nl.fromArray(R));
  }
  if (c.rotation) {
    const R = c.rotation.map(Yt.degToRad);
    R.push(c.eulerOrder || ws.DEFAULT_ORDER), r.makeRotationFromEuler(Nl.fromArray(R));
  }
  if (c.postRotation) {
    const R = c.postRotation.map(Yt.degToRad);
    R.push(c.eulerOrder || ws.DEFAULT_ORDER), n.makeRotationFromEuler(Nl.fromArray(R)), n.invert();
  }
  c.scale && s.scale(Ir.fromArray(c.scale)), c.scalingOffset && i.setPosition(Ir.fromArray(c.scalingOffset)), c.scalingPivot && o.setPosition(Ir.fromArray(c.scalingPivot)), c.rotationOffset && a.setPosition(Ir.fromArray(c.rotationOffset)), c.rotationPivot && l.setPosition(Ir.fromArray(c.rotationPivot)), c.parentMatrixWorld && (h.copy(c.parentMatrix), u.copy(c.parentMatrixWorld));
  const p = t.clone().multiply(r).multiply(n), m = new je();
  m.extractRotation(u);
  const g = new je();
  g.copyPosition(u);
  const b = g.clone().invert().multiply(u), x = m.clone().invert().multiply(b), y = s, v = new je();
  if (f === 0)
    v.copy(m).multiply(p).multiply(x).multiply(y);
  else if (f === 1)
    v.copy(m).multiply(x).multiply(p).multiply(y);
  else {
    const O = new je().scale(new ge().setFromMatrixScale(h)).clone().invert(), _ = x.clone().multiply(O);
    v.copy(m).multiply(p).multiply(_).multiply(y);
  }
  const N = l.clone().invert(), w = o.clone().invert();
  let T = e.clone().multiply(a).multiply(l).multiply(t).multiply(r).multiply(n).multiply(N).multiply(i).multiply(o).multiply(s).multiply(w);
  const S = new je().copyPosition(T), A = u.clone().multiply(S);
  return d.copyPosition(A), T = d.clone().multiply(v), T.premultiply(u.invert()), T;
}
function S1(c) {
  c = c || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return c === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[c];
}
function wl(c) {
  return c.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function _1(c, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = c.byteLength), new TextDecoder().decode(new Uint8Array(c, e, t));
}
function iA(c, e) {
  for (let t = 0, r = c.length, n = e.length; t < n; t++, r++)
    c[r] = e[t];
}
function aA(c, e, t, r) {
  for (let n = t, s = 0; n < r; n++, s++)
    c[s] = e[n];
  return c;
}
function Fp(c, e, t) {
  return c.slice(0, e).concat(t).concat(c.slice(e));
}
const M1 = new MM();
M1.setDecoderPath("/draco/");
class Vd extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Ja(0.1), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    B(this, "isModel3D", !0);
    B(this, "_model", "");
    B(this, "_modelRoot", null);
    B(this, "_modeMatrix");
    B(this, "_object");
    B(this, "_isLoading", !1);
    B(this, "_castShadowModel", !1);
    B(this, "_receiveShadowModel", !1);
    B(this, "_objectOrgSize", new ge());
    this.type = "Model3D", this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this.onBeforeRender = () => {
      (this._castShadowModel !== this.castShadow || this._receiveShadowModel !== this.receiveShadow) && this.updateModelShadow();
    }, this.geometry.boundingBox || this.geometry.computeBoundingBox();
  }
  get model() {
    return this._model;
  }
  set model(t) {
    this._model !== t && (this._object && this._object.removeFromParent(), this._model && (this._modeMatrix = void 0), this._model = t, this.loadModel());
  }
  async loadModel() {
    if (this._object && (this._object.removeFromParent(), this._object = void 0), !this._model)
      return;
    this._isLoading = !0;
    let t;
    if (/.glb$/i.test(this._model))
      t = new Gd(), t.setDRACOLoader(M1);
    else if (/.fbx$/i.test(this._model))
      t = new YM();
    else
      throw ke.panic(`Model[${this._model}] is not supported!`);
    const r = await t.loadAsync(this._model);
    r instanceof ro ? this._object = r : this._object = r.scene, this._modelRoot = r, this._object.__isHidden = !0, this._isLoading = !1, this.material.visible = !1, this.add(this._object), this.objectAutoSize(), this.updateModelShadow();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.resizeObject();
  }
  resizeObject() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0);
    const r = this.geometry.boundingBox.getSize(new ge()).divide(this._objectOrgSize), n = Math.min(r.x, r.y, r.z);
    this._object.scale.set(n, n, n);
  }
  objectAutoSize() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    if (this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0), this._modeMatrix)
      return this._object.applyMatrix4(this._modeMatrix);
    const t = this.geometry.boundingBox.getSize(new ge()).multiply(this.scale), r = this.getWorldPosition(new ge()), n = new tr().setFromObject(this._object, !0), s = n.getCenter(new ge()), o = n.getSize(this._objectOrgSize), i = t.divide(o), a = Math.min(i.x, i.y, i.z);
    this._object.position.copy(r.sub(s).multiply(i)), this._object.scale.set(a, a, a);
  }
  updateModelShadow() {
    this._object && (this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this._object.traverse((t) => {
      t.castShadow = this._castShadowModel, t.receiveShadow = this._receiveShadowModel;
    }));
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), r.geometry = s(t.geometries, this.geometry), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        o !== this._object && r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    super.serialize(t), t.model = this._model, t.objectOrgSize = this._objectOrgSize.toArray(), this._object && (t.modeMatrix = this._object.matrix.toArray());
  }
  deserialize(t) {
    super.deserialize(t), t.objectOrgSize && this._objectOrgSize.fromArray(t.objectOrgSize), t.modeMatrix && (this._modeMatrix = new je().fromArray(t.modeMatrix), this._object && this._object.applyMatrix4(this._modeMatrix)), this.model = t.model;
  }
}
Ye("Model3D", {
  create: ({ material: c, geometry: e } = {}) => new Vd(e, c),
  members: {
    model: "String"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class cA extends Vd {
  constructor(e, t, r = 0, n = 0) {
    super(e || new Xa(1, 1, 1), t, r, n), this.type = "StaticMesh";
  }
  rebuildBody() {
    if (!this._object)
      return;
    const e = this.world;
    if (this.physicalBody && (this.world && this.world.removeMesh(this), Xs.destroyBody(this.physicalBody)), this._bodyType !== Sc.Ghost) {
      const t = Xs.createShape(this._object);
      this.physicalBody = Xs.createBody(this, this._mass, t), this.physicalBody.setUserIndex(this.id), e && e.addMesh(this, this.physicalBody);
    } else
      this.physicalBody = null;
  }
}
Ye("StaticMesh", {
  create: ({ material: c, geometry: e } = {}) => new cA(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    model: "String"
  },
  proto: "Entity",
  group: "Objects.Static Mesh",
  icon: "mesh"
});
class lA extends Vd {
  constructor(t, r, n = 0, s = 0) {
    super(t || new vm(), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    B(this, "isCharacter", !0);
    B(this, "actions", {});
    B(this, "_mixer");
    B(this, "_clips", []);
    B(this, "_objectOrgSize", new ge());
    this.type = "Character";
  }
  async loadModel() {
    if (await super.loadModel(), !this._object || !this._modelRoot)
      return;
    const t = this._object.getObjectByProperty("isMesh", !0);
    t && (t.onBeforeRender = () => {
      this._mixer && this._mixer.update(nn.delta);
    }), this._mixer = new Vx(this._object), this._mixer.addEventListener("finished", ({ action: r }) => {
      const n = Object.entries(this.actions).find((s) => s[1].action === r);
      n && (ke.notice(`action ${n[0]} finished!`), n[1].isPending = !1, n[1].resolve && (n[1].resolve(!0), n[1].resolve = void 0));
    }), this._clips = this._modelRoot.animations || [];
    for (const r of this._clips)
      this.actions[r.name] = { isPending: !1, action: this._mixer.clipAction(r), resolve: void 0 };
  }
  async act(t, r) {
    const n = this.actions[t];
    if (n) {
      if (n.isPending)
        return !0;
    } else
      return !1;
    n.isPending = !0;
    const s = n.action;
    return s.clampWhenFinished = !0, s.reset().setLoop(r ? jx : Wx, r ? 1 / 0 : 1).setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(1).play(), new Promise((o) => {
      n.resolve = o;
    });
  }
  stop(t) {
    const r = t ? [t] : Object.keys(this.actions);
    for (const n of r) {
      const s = this.actions[n];
      if (s) {
        if (!s.isPending)
          continue;
      } else
        continue;
      s.isPending = !1, s.resolve && (s.resolve(!1), s.resolve = void 0), s.action.stop();
    }
  }
}
Ye("Character", {
  create: ({ material: c, geometry: e } = {}) => new lA(e, c),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Model3D",
  group: "Entities.Character",
  icon: "human"
});
const Ut = new ge(), uA = new ge();
class hA extends _m {
  constructor(t, r) {
    super(t || new Ss(), r);
    B(this, "isParticles", !0);
    B(this, "mass", 0);
    /** Resistance Coefficient */
    B(this, "airResCoe", 25e-4);
    B(this, "growSpeed", 1);
    B(this, "spaceSize", new ge(1, 1, 1));
    B(this, "bornSpaceSize", new ge(1, 1, 1));
    B(this, "bornPoint", new ge(0, 0, 0));
    B(this, "_count", 100);
    B(this, "_countFired", 0);
    B(this, "_positions", null);
    B(this, "_velocities", null);
    B(this, "_bornTime", 0);
    this.type = "Particles", this.rebuildBuffer(), this.onBeforeRender = () => {
      this.update();
    };
  }
  get count() {
    return this._count;
  }
  set count(t) {
    t <= 0 && (t = 100), this._count !== t && (this._count = t, this.rebuildBuffer());
  }
  rebuildBuffer() {
    this._countFired = 0, this.geometry.setDrawRange(0, 0);
    const t = new Float32Array(this._count * 3), r = new Float32Array(this._count * 3), n = new yn(t, 3), s = new yn(r, 3);
    n.setUsage(xu), this.geometry.setAttribute("position", n), this._positions = n, this._velocities = s;
  }
  update() {
    for (let t = 0; t < this._countFired; t++) {
      const r = this._positions.getX(t), n = this._positions.getY(t), s = this._positions.getZ(t);
      if (this.isOutofSpace(r, n, s))
        this._positions.setXYZ(t, ...this.randBornPoint()), this._velocities.setXYZ(t, 0, 0, 0);
      else {
        const [o, i] = nn.calcObjectPosition(
          Ut.set(r, n, s),
          uA.set(this._velocities.getX(t), this._velocities.getY(t), this._velocities.getZ(t)),
          this.mass,
          this.airResCoe
        );
        this._positions.setXYZ(t, ...o.toArray()), this._velocities.setXYZ(t, ...i.toArray());
      }
    }
    this.grow(), this._positions.needsUpdate = !0;
  }
  grow() {
    if (this._countFired >= this._count)
      return;
    const t = this._bornTime === 0 ? 1 : (nn.now - this._bornTime) / 1e3;
    this._bornTime || (this._bornTime = nn.now);
    const r = Math.floor(t * this.growSpeed), n = Math.min(r, this._count) - this._countFired;
    if (n <= 0)
      return;
    const s = this._countFired;
    this._countFired += n;
    for (let o = s; o < this._countFired; o++)
      this._positions.setXYZ(o, ...this.randBornPoint()), this._velocities.setXYZ(o, 0, 0, 0);
    this.geometry.setDrawRange(0, this._countFired);
  }
  isOutofSpace(t, r, n) {
    return t > this.spaceSize.x || t < -this.spaceSize.x || r > this.spaceSize.y || r < -this.spaceSize.y || n > this.spaceSize.z || n < -this.spaceSize.z;
  }
  randBornPoint() {
    return Ut.copy(this.bornPoint), Ut.x += this.bornSpaceSize.x * (Math.random() - 0.5) * 2, Ut.y += this.bornSpaceSize.y * (Math.random() - 0.5) * 2, Ut.z += this.bornSpaceSize.z * (Math.random() - 0.5) * 2, Ut.x > this.spaceSize.x ? Ut.x = this.spaceSize.x - 1e-5 : Ut.x < -this.spaceSize.x && (Ut.x = -this.spaceSize.x + 1e-5), Ut.y > this.spaceSize.y ? Ut.y = this.spaceSize.y - 1e-5 : Ut.y < -this.spaceSize.y && (Ut.y = -this.spaceSize.y + 1e-5), Ut.z > this.spaceSize.z ? Ut.z = this.spaceSize.z - 1e-5 : Ut.z < -this.spaceSize.z && (Ut.z = -this.spaceSize.z + 1e-5), Ut.toArray();
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    t.mass = this.mass, t.spaceSize = this.spaceSize.toArray(), t.bornSpaceSize = this.bornSpaceSize.toArray(), t.bornPoint = this.bornPoint.toArray(), t.count = this.count, t.growSpeed = this.growSpeed, t.airResCoe = this.airResCoe;
  }
  deserialize(t) {
    t.mass !== void 0 && (this.mass = t.mass), t.spaceSize && this.spaceSize.fromArray(t.spaceSize), t.bornSpaceSize && this.bornSpaceSize.fromArray(t.bornSpaceSize), t.bornPoint && this.bornPoint.fromArray(t.bornPoint), t.count > 0 && (this.count = t.count), t.growSpeed > 0 && (this.growSpeed = t.growSpeed), t.airResCoe !== void 0 && (this.airResCoe = t.airResCoe);
  }
}
Ye("Particles", {
  members: {
    mass: "Number",
    airResCoe: "Number",
    count: "Number",
    spaceSize: "Vector3",
    bornPoint: "Vector3",
    bornSpaceSize: "Vector3",
    growSpeed: "Number"
  },
  proto: "Points",
  group: "Particles.Particles",
  icon: "box",
  create: () => new hA()
});
class Mc extends Qt {
  constructor(e, t = {}) {
    super(e), this.isRefractor = !0, this.type = "Refractor", this.camera = new xr();
    const r = this, n = t.color !== void 0 ? new He(t.color) : new He(8355711), s = t.textureWidth || 512, o = t.textureHeight || 512, i = t.clipBias || 0, a = t.shader || Mc.RefractorShader, l = t.multisample !== void 0 ? t.multisample : 4, u = this.camera;
    u.matrixAutoUpdate = !1, u.userData.refractor = !0;
    const h = new jl(), d = new je(), f = new Cu(s, o, { samples: l, type: Fm });
    this.material = new ls({
      uniforms: nr.clone(a.uniforms),
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      transparent: !0
      // ensures, refractors are drawn from farthest to closest
    }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = d;
    const p = function() {
      const y = new ge(), v = new ge(), N = new je(), w = new ge(), T = new ge();
      return function(A) {
        return y.setFromMatrixPosition(r.matrixWorld), v.setFromMatrixPosition(A.matrixWorld), w.subVectors(y, v), N.extractRotation(r.matrixWorld), T.set(0, 0, 1), T.applyMatrix4(N), w.dot(T) < 0;
      };
    }(), m = function() {
      const y = new ge(), v = new ge(), N = new dr(), w = new ge();
      return function() {
        r.matrixWorld.decompose(v, N, w), y.set(0, 0, 1).applyQuaternion(N).normalize(), y.negate(), h.setFromNormalAndCoplanarPoint(y, v);
      };
    }(), g = function() {
      const y = new jl(), v = new pt(), N = new pt();
      return function(T) {
        u.matrixWorld.copy(T.matrixWorld), u.matrixWorldInverse.copy(u.matrixWorld).invert(), u.projectionMatrix.copy(T.projectionMatrix), u.far = T.far, y.copy(h), y.applyMatrix4(u.matrixWorldInverse), v.set(y.normal.x, y.normal.y, y.normal.z, y.constant);
        const S = u.projectionMatrix;
        N.x = (Math.sign(v.x) + S.elements[8]) / S.elements[0], N.y = (Math.sign(v.y) + S.elements[9]) / S.elements[5], N.z = -1, N.w = (1 + S.elements[10]) / S.elements[14], v.multiplyScalar(2 / v.dot(N)), S.elements[2] = v.x, S.elements[6] = v.y, S.elements[10] = v.z + 1 - i, S.elements[14] = v.w;
      };
    }();
    function b(y) {
      d.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), d.multiply(y.projectionMatrix), d.multiply(y.matrixWorldInverse), d.multiply(r.matrixWorld);
    }
    function x(y, v, N) {
      r.visible = !1;
      const w = y.getRenderTarget(), T = y.xr.enabled, S = y.shadowMap.autoUpdate;
      y.xr.enabled = !1, y.shadowMap.autoUpdate = !1, y.setRenderTarget(f), y.autoClear === !1 && y.clear(), y.render(v, u), y.xr.enabled = T, y.shadowMap.autoUpdate = S, y.setRenderTarget(w);
      const A = N.viewport;
      A !== void 0 && y.state.viewport(A), r.visible = !0;
    }
    this.onBeforeRender = function(y, v, N) {
      N.userData.refractor !== !0 && p(N) && (m(), b(N), g(N), x(y, v, N));
    }, this.getRenderTarget = function() {
      return f;
    }, this.dispose = function() {
      f.dispose(), r.material.dispose();
    };
  }
}
Mc.RefractorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Ki = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
class A1 extends Qt {
  constructor(t, r) {
    super(t || new Tr(1, 1), r || new ls({
      name: Ki.name,
      uniforms: nr.clone(Ki.uniforms),
      fragmentShader: Ki.fragmentShader,
      vertexShader: Ki.vertexShader
    }));
    B(this, "isReflector", !0);
    B(this, "props", {
      color: new He(8355711),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      multisample: 4
    });
    B(this, "renderTarget");
    B(this, "camera", new xr());
    this.type = "Reflector";
    const n = new jl(), s = new ge(), o = new ge(), i = new ge(), a = new je(), l = new ge(0, 0, -1), u = new pt(), h = new ge(), d = new ge(), f = new pt(), p = new je(), m = this.camera;
    this.renderTarget = new Cu(this.props.textureWidth, this.props.textureHeight, { samples: this.props.multisample, type: Fm }), r ? this.props.color = this.material.uniforms.color.value : this.material.uniforms.color.value = this.props.color, this.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.material.uniforms.textureMatrix.value = p, this.onBeforeRender = (g, b, x) => {
      if (o.setFromMatrixPosition(this.matrixWorld), i.setFromMatrixPosition(x.matrixWorld), a.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(a), h.subVectors(o, i), h.dot(s) > 0)
        return;
      h.reflect(s).negate(), h.add(o), a.extractRotation(x.matrixWorld), l.set(0, 0, -1), l.applyMatrix4(a), l.add(i), d.subVectors(o, l), d.reflect(s).negate(), d.add(o), m.position.copy(h), m.up.set(0, 1, 0), m.up.applyMatrix4(a), m.up.reflect(s), m.lookAt(d), m.far = x instanceof xr ? x.far : 1e3, m.updateMatrixWorld(), m.projectionMatrix.copy(x.projectionMatrix), p.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), p.multiply(m.projectionMatrix), p.multiply(m.matrixWorldInverse), p.multiply(this.matrixWorld), n.setFromNormalAndCoplanarPoint(s, o), n.applyMatrix4(m.matrixWorldInverse), u.set(n.normal.x, n.normal.y, n.normal.z, n.constant);
      const y = m.projectionMatrix;
      f.x = (Math.sign(u.x) + y.elements[8]) / y.elements[0], f.y = (Math.sign(u.y) + y.elements[9]) / y.elements[5], f.z = -1, f.w = (1 + y.elements[10]) / y.elements[14], u.multiplyScalar(2 / u.dot(f)), y.elements[2] = u.x, y.elements[6] = u.y, y.elements[10] = u.z + 1 - this.props.clipBias, y.elements[14] = u.w, this.visible = !1;
      const v = g.getRenderTarget(), N = g.xr.enabled, w = g.shadowMap.autoUpdate;
      g.xr.enabled = !1, g.shadowMap.autoUpdate = !1, g.setRenderTarget(this.renderTarget), g.state.buffers.depth.setMask(!0), g.autoClear === !1 && g.clear(), g.render(b, m), g.xr.enabled = N, g.shadowMap.autoUpdate = w, g.setRenderTarget(v);
      const T = x.viewport;
      T !== void 0 && g.state.viewport(T), this.visible = !0;
    };
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t);
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  dispose() {
    this.renderTarget.dispose(), this.material.dispose();
  }
  clone(t) {
    const r = super.clone(t), n = Qs(this.props);
    return er(r.props, n), r;
  }
  serialize(t) {
    t.props = Qs(this.props);
  }
  deserialize(t) {
    t.props && er(this.props, t.props);
  }
}
Ye("Reflector", {
  members: {
    castShadow: "Boolean",
    receiveShadow: "Boolean",
    color: "Color",
    textureWidth: "Number",
    textureHeight: "Number",
    clipBias: "Number"
  },
  proto: "Object3D",
  group: "Objects.Reflector",
  icon: "plane",
  create: ({ geometry: c, material: e } = {}) => new A1(c, e)
});
const Na = 0.15, Zi = Na * 0.5, to = class to extends Nn {
  constructor(t, r) {
    super(t || new Tr(10, 10), r || new ls({
      uniforms: nr.merge([
        so.fog,
        to.WaterShader.uniforms
      ]),
      vertexShader: to.WaterShader.vertexShader,
      fragmentShader: to.WaterShader.fragmentShader,
      transparent: !0,
      fog: !0
    }), 0, 0);
    B(this, "isWaterPlane", !0);
    B(this, "props", {
      color: new He(),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      flowDirection: new Nt(1, 0),
      flowSpeed: 0.03,
      reflectivity: 0.02,
      scale: 1
    });
    B(this, "textureMatrix", new je());
    B(this, "reflector");
    B(this, "refractor");
    B(this, "refractorClipBias");
    this.type = "WaterPlane", t || (this.rotation.x = -Math.PI / 2);
    const n = new A1(t);
    n.textureWidth = this.props.textureWidth, n.textureHeight = this.props.textureHeight, n.clipBias = this.props.clipBias;
    const s = new Mc(t, {
      textureWidth: this.props.textureWidth,
      textureHeight: this.props.textureHeight,
      clipBias: 0
    });
    if (this.refractorClipBias = s.camera.projectionMatrix.elements[10], n.matrixAutoUpdate = !1, s.matrixAutoUpdate = !1, this.reflector = n, this.refractor = s, r)
      this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.props.flowDirection = this.material.uniforms.flowDirection.value, this.props.color = this.material.uniforms.color.value, this.props.reflectivity = this.material.uniforms.reflectivity.value, this.textureMatrix = this.material.uniforms.textureMatrix.value, this.props.scale = this.material.uniforms.config.value.w;
    else {
      this.material.uniforms.flowDirection = {
        type: "v2",
        value: this.props.flowDirection
      };
      const o = new Gn(), i = new Gn();
      o.wrapS = o.wrapT = Ys, i.wrapS = i.wrapT = Ys, this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = o, this.material.uniforms.tNormalMap1.value = i, this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = Zi, this.material.uniforms.config.value.z = Zi, this.material.uniforms.config.value.w = this.props.scale;
    }
    this.onBeforeRender = function(o, i, a) {
      this.updateTextureMatrix(a), this.updateFlow(), this.visible = !1, n.matrixWorld.copy(this.matrixWorld), s.matrixWorld.copy(this.matrixWorld), n.onBeforeRender(o, i, a, null, null, null), s.onBeforeRender(o, i, a, null, null, null), this.visible = !0;
    };
  }
  get normalMap0() {
    return this.material.uniforms.tNormalMap0.value;
  }
  set normalMap0(t) {
    const r = this.material.uniforms.tNormalMap0.value;
    r !== t && (this.material.uniforms.tNormalMap0.value = t, r.dispose());
  }
  get normalMap1() {
    return this.material.uniforms.tNormalMap1.value;
  }
  set normalMap1(t) {
    const r = this.material.uniforms.tNormalMap1.value;
    r !== t && (this.material.uniforms.tNormalMap1.value = t, r.dispose());
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t, this.reflector.clipBias = t);
  }
  get flowDirection() {
    return this.props.flowDirection;
  }
  set flowDirection(t) {
    this.props.flowDirection !== t && (this.props.flowDirection = t, this.material.uniforms.flowDirection.value = t);
  }
  get flowSpeed() {
    return this.props.flowSpeed;
  }
  set flowSpeed(t) {
    this.props.flowSpeed !== t && (this.props.flowSpeed = t);
  }
  get reflectivity() {
    return this.props.reflectivity;
  }
  set reflectivity(t) {
    this.props.reflectivity !== t && (this.props.reflectivity = t, this.material.uniforms.reflectivity.value = this.props.reflectivity);
  }
  get waterScale() {
    return this.props.scale;
  }
  set waterScale(t) {
    this.props.scale !== t && (this.props.scale = t, this.material.uniforms.config.value.w = this.props.scale);
  }
  appleProps() {
    this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.flowDirection.value = this.props.flowDirection, this.material.uniforms.config.value.w = this.props.scale, this.reflector.textureWidth = this.props.textureWidth, this.reflector.textureHeight = this.props.textureHeight, this.reflector.clipBias = this.props.clipBias, this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight);
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Bt], s = Qs(n), o = r.props[Bt];
    return er(o, s), o.appleProps(), r;
  }
  serialize(t) {
    super.serialize(t), t.props = Qs(this.props);
  }
  deserialize(t) {
    super.deserialize(t), t.props && (er(this.props, t.props), this.appleProps());
  }
  dispose() {
    this.reflector.dispose(), this.refractor.dispose();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.reflector.geometry = this.geometry, this.refractor.geometry = this.geometry;
  }
  updateTextureMatrix(t) {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(t.projectionMatrix), this.textureMatrix.multiply(t.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld);
  }
  updateFlow() {
    const t = this.material.uniforms.config;
    t.value.x += this.props.flowSpeed * nn.delta, t.value.y = t.value.x + Zi, t.value.x >= Na ? (t.value.x = 0, t.value.y = Zi) : t.value.y >= Na && (t.value.y = t.value.y - Na);
  }
};
B(to, "WaterShader", {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new pt()
    }
  },
  vertexShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_vertex>
      #include <logdepthbuf_pars_vertex>
  
      uniform mat4 textureMatrix;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        vUv = uv;
        vCoord = textureMatrix * vec4( position, 1.0 );
  
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vToEye = cameraPosition - worldPosition.xyz;
  
        vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
        gl_Position = projectionMatrix * mvPosition;
  
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
  
      }`
  ),
  fragmentShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_fragment>
      #include <logdepthbuf_pars_fragment>
  
      uniform sampler2D tReflectionMap;
      uniform sampler2D tRefractionMap;
      uniform sampler2D tNormalMap0;
      uniform sampler2D tNormalMap1;
  
      #ifdef USE_FLOWMAP
        uniform sampler2D tFlowMap;
      #else
        uniform vec2 flowDirection;
      #endif
  
      uniform vec3 color;
      uniform float reflectivity;
      uniform vec4 config;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        #include <logdepthbuf_fragment>
  
        float flowMapOffset0 = config.x;
        float flowMapOffset1 = config.y;
        float halfCycle = config.z;
        float scale = config.w;
  
        vec3 toEye = normalize( vToEye );
  
        // determine flow direction
        vec2 flow;
        #ifdef USE_FLOWMAP
          flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
        #else
          flow = flowDirection;
        #endif
        flow.x *= - 1.0;
  
        // sample normal maps (distort uvs with flowdata)
        vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
        vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );
  
        // linear interpolate to get the final normal color
        float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
        vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );
  
        // calculate normal vector
        vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
  
        // calculate the fresnel term to blend reflection and refraction maps
        float theta = max( dot( toEye, normal ), 0.0 );
        float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );
  
        // calculate final uv coords
        vec3 coord = vCoord.xyz / vCoord.w;
        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;
  
        vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
        vec4 refractColor = texture2D( tRefractionMap, uv );
  
        // multiply water color with the mix of both textures
        gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );
  
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
  
      }`
  )
});
let Op = to;
const Tl = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new ge() },
    up: { value: new ge(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
}, dA = new En();
class fA extends Qt {
  constructor(t, r) {
    super(t || new Xa(1, 1, 1), r || new ls({
      name: "SkyShader",
      fragmentShader: Tl.fragmentShader,
      vertexShader: Tl.vertexShader,
      uniforms: nr.clone(Tl.uniforms),
      side: bu,
      depthWrite: !1
    }));
    B(this, "isSkyBox", !0);
    B(this, "_renderTarget");
    B(this, "_pmremGenerator");
    B(this, "_sceneTmp", new $a());
    B(this, "_sceneRoot");
    B(this, "_sun");
    B(this, "_sunPosition");
    this.type = "SkyBox", t || this.scale.multiplyScalar(1e3), r || (this.material.uniforms.turbidity.value = 10, this.material.uniforms.rayleigh.value = 2, this.material.uniforms.mieCoefficient.value = 5e-3, this.material.uniforms.mieDirectionalG.value = 0.8, this.material.uniforms.sunPosition.value.copy(this.calSunPosition(2, 180))), this._sunPosition = this.material.uniforms.sunPosition.value, this.onBeforeRender = async (n, s, o) => {
      this._sceneRoot = s, this._sun && typeof this._sun == "string" && (this._sun = s.getObjectByProperty("uuid", this._sun)), this._renderTarget || (this._renderTarget = 1, this._pmremGenerator = new Hx(n), this.updateRenderTarget()), this._sun && !this._sun.position.equals(this._sunPosition) && this.updateSunPotision();
    };
  }
  get turbidity() {
    return this.material.uniforms.turbidity.value;
  }
  set turbidity(t) {
    this.material.uniforms.turbidity.value = t;
  }
  get rayleigh() {
    return this.material.uniforms.rayleigh.value;
  }
  set rayleigh(t) {
    this.material.uniforms.rayleigh.value = t;
  }
  get mieCoefficient() {
    return this.material.uniforms.mieCoefficient.value;
  }
  set mieCoefficient(t) {
    this.material.uniforms.mieCoefficient.value = t;
  }
  get mieDirectionalG() {
    return this.material.uniforms.mieDirectionalG.value;
  }
  set mieDirectionalG(t) {
    this.material.uniforms.mieDirectionalG.value = t;
  }
  get sunPosition() {
    return this.material.uniforms.sunPosition.value;
  }
  set sunPosition(t) {
    this.material.uniforms.sunPosition.value.copy(t);
  }
  get sun() {
    return dA;
  }
  set sun(t) {
    t instanceof pi && (this._sun = t, this.updateSunPotision());
  }
  calSunPosition(t, r) {
    const n = Yt.degToRad(90 - t), s = Yt.degToRad(r), o = new ge();
    return o.setFromSphericalCoords(1, n, s), o;
  }
  updateSunPotision() {
    typeof this._sun == "object" && (this.material.uniforms.sunPosition.value.copy(this._sun.position), this.updateRenderTarget());
  }
  updateRenderTarget() {
    if (this._renderTarget !== void 0 && typeof this._renderTarget == "object" && this._renderTarget.dispose(), !this._pmremGenerator)
      return;
    const t = this.parent, r = t ? t.children.indexOf(this) : -1;
    t && t.children.splice(r, 1), this._sceneTmp.children.push(this), this._renderTarget = this._pmremGenerator.fromScene(this._sceneTmp), t && (r !== -1 ? t.children.splice(r, 0, this) : t.children.push(this)), this._sceneRoot && (this._sceneRoot.background = this._renderTarget.texture, this._sceneRoot.environment = this._renderTarget.texture);
  }
  serialize(t) {
    t.scale = this.scale.toArray(), t.turbidity = this.turbidity, t.rayleigh = this.rayleigh, t.mieCoefficient = this.mieCoefficient, t.mieDirectionalG = this.mieDirectionalG, t.sunPosition = this.sunPosition.toArray(), this._sun && (t.sun = this._sun.uuid || this._sun);
  }
  deserialize(t) {
    this.scale.fromArray(t.scale), this.turbidity = t.turbidity, this.rayleigh = t.rayleigh, this.mieCoefficient = t.mieCoefficient, this.mieDirectionalG = t.mieDirectionalG, this.sunPosition.fromArray(t.sunPosition), t.sun && (this._sun = t.sun), this.updateRenderTarget();
  }
}
Ye(
  "SkyBox",
  {
    members: {
      scale: "Vector3",
      turbidity: "Number",
      rayleigh: "Number",
      mieCoefficient: "Number",
      mieDirectionalG: "Number",
      sun: "Object3D"
    },
    proto: "Object3D",
    group: "Objects.Sky Box",
    icon: "box",
    create: ({ geometry: c, material: e } = {}) => new fA(c, e)
  }
);
class tn extends Oe {
  constructor(t, r, n) {
    super("void");
    B(this, "isObjectNode", !0);
    B(this, "typesExtended", { in: {}, out: {} });
    B(this, "isObject3DNode");
    B(this, "eventDispatcher", null);
    B(this, "_object", null);
    B(this, "_objectRaw", null);
    this._inst = t, this.objectType = r, n && (this.object = n), this.updateType = "none", this.isObject3DNode = li(r, "Object3D"), this.initTypes();
  }
  get object() {
    return this._object;
  }
  set object(t) {
    if (typeof t != "object" || !ZT(t, this.objectType))
      throw ke.panic(`type is not compitable, expected type is ${this.objectType}!`);
    this._objectRaw = t, this._object = new Proxy(t, {
      get(r, n, s) {
        if (n === Bt)
          return r;
        if (typeof n != "string")
          return Reflect.get(r, n, s);
        const o = n.split(".");
        if (o.length > 1) {
          let i = Reflect.get(r, o[0], s);
          for (let a = 1; a < o.length; a++)
            i = i[o[a]];
          return i;
        }
        return Reflect.get(r, n, s);
      },
      set: (r, n, s, o) => {
        if (typeof n != "string")
          return Reflect.set(r, n, s, o);
        if (Reflect.get(r, n, o) === s)
          return !0;
        let a = !0;
        const l = n.split(".");
        if (l.length > 1) {
          let u = Reflect.get(r, l[0], o);
          const h = l.pop();
          for (let d = 1; d < l.length; d++)
            u = u[l[d]];
          if (u[h] === s)
            return !0;
          u[h] = s;
        } else
          a = Reflect.set(r, n, s, r);
        if (this.eventDispatcher) {
          const u = !!this.typesExtended.in[n];
          this.eventDispatcher.dispatchEvent({ type: u ? "nodeEventInputChanged" : "nodeEventOutputChanged", source: null, node: this, fields: [n] });
        }
        return a;
      }
    }), (t instanceof En || t instanceof M.Material) && (this.objectType = t.type, this.initTypes()), Object.defineProperty(this, "_object", {
      writable: !1
    });
  }
  getObjectsExtended() {
    return { in: this.object, out: this.object };
  }
  fill(t, r) {
    this._object && typeof this._object == "string" && (this.object = r[this._object] || t.getObjectByProperty("uuid", this._object));
  }
  dispose() {
    this._object && this._object instanceof Gn && this._object.dispose();
  }
  toJSON(t) {
    const r = super.toJSON(t);
    if (this._object instanceof Gn) {
      const n = this._object.toJSON(t);
      t.textures[this._object.uuid] = n;
    }
    return r;
  }
  serialize(t) {
    if (!this._object)
      throw ke.panic("object has not been set before serialize!");
    super.serialize(t), t._inst = this._inst, t.object = this._object.uuid, t.objectType = this.objectType;
  }
  deserialize(t) {
    if (!li(t.objectType, this.objectType))
      throw ke.panic(`type is not compitable, expected type is ${this.objectType}!`);
    super.deserialize(t), this._object = t.object, this.initTypes();
  }
  createDefault(t) {
    if (this.isObject3DNode)
      this.object = t, this.objectType = t.type, this.initTypes();
    else {
      const r = M[this.objectType];
      if (!r)
        throw ke.panic(`class[${this.objectType}] not found in THREE!`);
      this.object = new r();
    }
  }
  initTypes() {
    const t = za(this.objectType);
    if (!t)
      throw ke.panic(`class[${this.objectType}] not found!`);
    Ts(this.typesExtended.in), Object.assign(this.typesExtended.in, t.in), Ts(this.typesExtended.out), Object.assign(this.typesExtended.out, t.out);
  }
}
rr(
  "ObjectNode",
  tn,
  {
    // @ts-expect-error
    object: "Object3D | Texture"
  },
  "",
  {
    object3DRef: { clsName: "ObjectNode", func: () => new tn("object3DRef", "Object3D"), group: "Objects.Object", icon: "box" },
    texture: { clsName: "ObjectNode", func: () => new tn("texture", "Texture"), group: "Inputs.Primitives.Texture", icon: "photo" }
    // cubeTexture: { clsName: 'CubeTexture', func: () => new ObjectNode('cubeTexture', 'CubeTexture'), group: 'Inputs.Primitives.Cube Texture', icon: 'photo' },
  }
);
const C1 = {
  Boolean: {
    fromJson: (c) => new Boolean(c),
    toJson: (c) => c
  },
  Number: {
    fromJson: (c) => c ?? 0,
    toJson: (c) => c
  },
  String: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Url: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Script: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Color: {
    fromJson: (c) => new He().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector2: {
    fromJson: (c) => new Nt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector3: {
    fromJson: (c) => new ge().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector4: {
    fromJson: (c) => new pt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Euler: {
    fromJson: (c) => new ws().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  // uniformNode for gpu
  bool: {
    label: "bool UniformNode",
    fromJson: function(c) {
      const e = new Qe(!1, "bool");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  float: {
    label: "float UniformNode",
    fromJson: function(c) {
      const e = new Qe(0, "float");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  color: {
    label: "color UniformNode",
    fromJson: function(c) {
      const e = new Qe(new He(), "color");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec2: {
    label: "vec2 UniformNode",
    fromJson: function(c) {
      const e = new Qe(new Nt());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec3: {
    label: "vec3 UniformNode",
    fromJson: function(c) {
      const e = new Qe(new ge());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec4: {
    label: "vec4 UniformNode",
    fromJson: function(c) {
      const e = new Qe(new ge());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  int: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(0, "int");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new bs());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new je());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  code: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  uint: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(0, "uint");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  void: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  property: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  sampler: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  cubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  ivec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new Nt(), "ivec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new Nt(), "uvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new Nt(), "bvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new ge(), "ivec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new ge(), "uvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new ge(), "bvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new pt(), "ivec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new pt(), "uvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new pt(), "bvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new bs(), "imat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new bs(), "umat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new bs(), "bmat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new je(), "imat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new je(), "umat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new Qe(new je(), "bmat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix3: {
    label: void 0,
    fromJson: (c) => new bs(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix4: {
    label: void 0,
    fromJson: (c) => new je(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Audio: {
    label: void 0,
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Image: {
    label: void 0,
    fromJson: function(c) {
      const e = document.createElement("img");
      return c != null && c.src && (e.src = c.src), e;
    },
    toJson: function(c) {
      return { src: c.src };
    }
  },
  Texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  CubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Material: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Object3D: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  }
};
function Qi(c, e) {
  return C1[c].fromJson(e);
}
function Ip(c, e) {
  return C1[c].toJson(e);
}
const pA = globalThis.AsyncFunction || (async (c) => c).constructor;
class ui extends tn {
  constructor(t, r, n = !0) {
    super(t, "Object3D", r);
    B(this, "isScriptNode", !0);
    B(this, "inputs");
    B(this, "outputs");
    B(this, "enabled", !1);
    B(this, "_parametersProps", ["params", "out", "THREE", "TSL", "world", "window", "document"]);
    B(this, "_parameters", [null, null, M, Xv, nn, null, null]);
    B(this, "_code", "");
    // eslint-disable-next-line @typescript-eslint/ban-types
    B(this, "_main");
    this.editable = n, this.inputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this.outputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventOutputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this._parameters[0] = this.inputs, this._parameters[1] = this.outputs, this._main = this.compile();
  }
  get code() {
    return this._code;
  }
  set code(t) {
    this._code = t;
    try {
      this._main = this.compile();
    } catch (r) {
      console.warn(r);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this._code && this.object && await this._main.call(this._objectRaw, ...this._parameters);
  }
  getObjectsExtended() {
    return { in: this.inputs, out: this.outputs };
  }
  initTypes() {
  }
  addInput(t, r) {
    if (this.typesExtended.in[t])
      return;
    this.typesExtended.in[t] = { types: [r], direct: "in", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = Qi(r);
    return this.inputs[t] = n, n;
  }
  removeInput(t) {
    return this.typesExtended.in[t] ? (delete this.typesExtended.in[t], delete this.inputs[t], !0) : !1;
  }
  addOutput(t, r) {
    if (this.typesExtended.out[t])
      return;
    this.typesExtended.out[t] = { types: [r], direct: "out", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = Qi(r);
    return this.outputs[t] = n, n;
  }
  removeOutput(t) {
    return this.typesExtended.out[t] ? (delete this.typesExtended.out[t], delete this.outputs[t], !0) : !1;
  }
  serialize(t) {
    var r;
    super.serialize(t), t.object = (r = this.object) == null ? void 0 : r.uuid, t.types = { ...this.typesExtended }, t.enabled = this.enabled, t.inputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.in))
      t.inputs[n] = Ip(s.types[0], this.inputs[n]);
    t.outputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.out))
      t.outputs[n] = Ip(s.types[0], this.outputs[n]);
    t.code = this._code;
  }
  deserialize(t) {
    var r, n;
    super.deserialize(t), (r = t.types) != null && r.in && (Ts(this.typesExtended.in), Object.assign(this.typesExtended.in, t.types.in));
    for (const [s, o] of Object.entries(this.typesExtended.in)) {
      const i = t.inputs ? t.inputs[s] : void 0;
      this.inputs[s] = Qi(o.types[0], i);
    }
    (n = t.types) != null && n.out && (Ts(this.typesExtended.out), Object.assign(this.typesExtended.out, t.types.out));
    for (const [s, o] of Object.entries(this.typesExtended.out)) {
      const i = t.outputs ? t.outputs[s] : void 0;
      this.outputs[s] = Qi(o.types[0], i);
    }
    t.code !== void 0 && (this.code = t.code), this.enabled = t.enabled;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new pA(this._parametersProps, this._code);
  }
}
rr(
  "ScriptNode",
  ui,
  {
    enabled: "Boolean",
    code: "Script"
  },
  "ObjectNode"
);
class Dn extends ui {
  constructor() {
    super(...arguments);
    B(this, "isScriptBlockNode", !0);
    B(this, "_prev");
    B(this, "_next");
  }
  get prev() {
    return this._prev;
  }
  set prev(t) {
    this._prev = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this.object && (this._code ? await this._main.call(this._objectRaw, ...this._parameters) : !0) !== !1 && this._next && await this._next.exec(t);
  }
  fill(t, r) {
    super.fill(t, r), this.prev && typeof this.prev == "string" && (this.prev = r[this.prev]), this.next && typeof this.next == "string" && (this.next = r[this.next]);
  }
  serialize(t) {
    var r, n;
    super.serialize(t), t.prev = (r = this.prev) == null ? void 0 : r.uuid, t.next = (n = this.next) == null ? void 0 : n.uuid;
  }
  deserialize(t) {
    super.deserialize(t), this.prev = t.prev, this.next = t.next;
  }
}
rr("ScriptBlockNode", Dn, {}, "ScriptNode", {
  scriptBlock: { clsName: "UpdateNode", func: () => new Dn("scriptBlock"), group: "Scripts.Script Block", icon: "brand-javascript" }
});
class Pr extends Dn {
  constructor(t, r, n, s) {
    super(t, n);
    B(this, "isEventListenerNode", !0);
    B(this, "_event", "onBorn");
    B(this, "_eventSource");
    B(this, "_listener");
    r && (this._event = r), this._eventSource = s || this.object;
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t, this._eventSource || (this._eventSource = t), this.resetEventlisten(this._event);
  }
  get event() {
    return this._event;
  }
  set event(t) {
    this.resetEventlisten(t), this._event = t;
  }
  serialize(t) {
    super.serialize(t), t.event = this.event;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event;
  }
  resetEventlisten(t) {
    this.object === null || typeof this.object != "object" || (this._listener && this._eventSource.removeEventListener(this.event, this._listener), this._listener = (r) => {
      this.exec(r);
    }, this._eventSource.addEventListener(t, this._listener));
  }
  dispose() {
    super.dispose(), this._listener && typeof this.object == "object" && this._eventSource.removeEventListener(this.event, this._listener);
  }
}
rr("EventListenerNode", Pr, {
  event: "String"
}, "ScriptBlockNode", {
  eventOnBorn: { clsName: "EventListenerNode", func: () => new Pr("eventOnBorn", "onBorn"), group: "Scripts.On Born", icon: "loader" },
  eventOnDead: { clsName: "EventListenerNode", func: () => new Pr("eventOnDead", "onDead"), group: "Scripts.On Dead", icon: "bell-off" },
  eventOnCollisionEnter: { clsName: "EventListenerNode", func: () => new Pr("eventOnCollisionEnter", "onCollisionEnter"), group: "Scripts.On Collision Enter", icon: "arrows-shuffle" },
  eventOnCollisionLeave: { clsName: "EventListenerNode", func: () => new Pr("eventOnCollisionLeave", "onCollisionLeave"), group: "Scripts.On Collision Leave", icon: "arrow-bounce" },
  eventCustom: { clsName: "EventListenerNode", func: () => new Pr("eventCustom", "onCustomEvent"), group: "Scripts.On Custom Event", icon: "calendar-event" }
});
class Pp extends ui {
  constructor(t, r) {
    super(t, r);
    B(this, "isUpdateNode", !0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdate(t, r, n, s) {
    if (this.enabled && this._code && this.object)
      try {
        this._main.call(this._objectRaw, ...this._parameters, n, s);
      } catch (o) {
        console.error(o);
      }
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new Function(...this._parametersProps, "delta", "now", this._code);
  }
}
rr("UpdateNode", Pp, {}, "ScriptNode", {
  update: { clsName: "UpdateNode", func: () => new Pp("update"), group: "Scripts.On Update", icon: "refresh" }
});
class Dp extends Dn {
  constructor(t, r) {
    super(t, r);
    B(this, "isKeyboardNode", !0);
    B(this, "event", "keydown");
    B(this, "key", "");
    B(this, "_listenerKeyDown");
    B(this, "_listenerKeyUp");
    B(this, "_listenerBorn");
    B(this, "_listenerDead");
    B(this, "_isActived", !1);
    this._listenerKeyDown = (s) => {
      this.exec(s);
    }, this._listenerKeyUp = (s) => {
      this.exec(s);
    }, this._listenerBorn = () => {
      this._isActived = !0;
    }, this._listenerDead = () => {
      this._isActived = !1;
    };
    const n = ["_listenerKeyDown", "_listenerKeyUp"];
    window.addEventListener("keydown", this._listenerKeyDown), window.addEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), n.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const s of n)
      Object.defineProperty(this, s, {
        writable: !1
      });
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t;
    const r = [];
    this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), r.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const n of r)
      Object.defineProperty(this, n, {
        writable: !1
      });
  }
  async exec(t) {
    if (this._isActived && !(t.type !== this.event || t.key !== this.key))
      return super.exec(t);
  }
  serialize(t) {
    super.serialize(t), t.event = this.event, t.key = this.key;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event, this.key = t.key;
  }
  dispose() {
    super.dispose(), window.removeEventListener("keydown", this._listenerKeyDown), window.removeEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.removeEventListener("onBorn", this._listenerBorn), this.object.removeEventListener("onDead", this._listenerDead));
  }
}
rr("KeyboardNode", Dp, {
  event: '"keydown"|"keyup"',
  key: '"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"'
}, "ScriptBlockNode", {
  keyboardEvent: { clsName: "KeyboardNode", func: () => new Dp("keyboardEvent"), group: "Scripts.On Keyboard", icon: "keyboard" }
});
const mA = {
  lineBasicMaterial: { clsName: "LineBasicMaterial", func: () => new M.LineBasicMaterial(), group: "Material.Line Basic Material", icon: "brand-medium" },
  // lineBasicNodeMaterial: { clsName: 'LineBasicNodeMaterial', func: () => new Nodes.LineBasicNodeMaterial(), group: 'Material.Line Basic Material Node', icon: 'brand-medium' },
  meshBasicMaterial: { clsName: "MeshBasicMaterial", func: () => new M.MeshBasicMaterial(), group: "Material.Mesh Basic Material", icon: "brand-medium" },
  // meshBasicNodeMaterial: { clsName: 'MeshBasicNodeMaterial', func: () => new Nodes.MeshBasicNodeMaterial(), group: 'Material.Mesh Basic Material Node', icon: 'brand-medium' },
  meshPhysicalMaterial: { clsName: "MeshPhysicalMaterial", func: () => new M.MeshPhysicalMaterial({}), group: "Material.Mesh Physical Material", icon: "brand-medium" },
  // meshPhysicalNodeMaterial: { clsName: 'MeshPhysicalNodeMaterial', func: () => new Nodes.MeshPhysicalNodeMaterial({}), group: 'Material.Mesh Physical Material Node', icon: 'brand-medium' },
  meshStandardMaterial: { clsName: "MeshStandardMaterial", func: () => new M.MeshStandardMaterial(), group: "Material.Mesh Standard Material", icon: "brand-medium" },
  // meshStandardNodeMaterial: { clsName: 'MeshStandardNodeMaterial', func: () => new Nodes.MeshStandardNodeMaterial(), group: 'Material.Mesh Standard Material Node', icon: 'brand-medium' },
  pointsMaterial: { clsName: "PointsMaterial", func: () => new M.PointsMaterial(), group: "Material.Points Material", icon: "brand-medium" },
  // pointsNodeMaterial: { clsName: 'PointsNodeMaterial', func: () => new Nodes.PointsNodeMaterial(), group: 'Material.Points Material Node', icon: 'brand-medium' },
  spriteMaterial: { clsName: "SpriteMaterial", func: () => new M.SpriteMaterial(), group: "Material.Sprite Material", icon: "brand-medium" },
  // spriteNodeMaterial: { clsName: 'SpriteNodeMaterial', func: () => new Nodes.SpriteNodeMaterial(), group: 'Material.Sprite Material Node', icon: 'brand-medium' },
  pongMaterial: { clsName: "MeshPhongMaterial", func: () => new M.MeshPhongMaterial(), group: "Material.Phong Material", icon: "brand-medium" },
  toonMaterial: { clsName: "MeshToonMaterial", func: () => new M.MeshToonMaterial({ color: 16777215, refractionRatio: 0.98 }), group: "Material.Toon Material", icon: "brand-medium" },
  normalMaterial: { clsName: "MeshNormalMaterial", func: () => new M.MeshNormalMaterial(), group: "Material.Normal Material", icon: "brand-medium" },
  matcapMaterial: { clsName: "MeshMatcapMaterial", func: () => new M.MeshMatcapMaterial(), group: "Material.Matcap Material", icon: "brand-medium" },
  lambertMaterial: { clsName: "MeshLambertMaterial", func: () => new M.MeshLambertMaterial(), group: "Material.Lambert Material", icon: "brand-medium" },
  depthMaterial: { clsName: "MeshDepthMaterial", func: () => new M.MeshDepthMaterial(), group: "Material.Depth Material", icon: "brand-medium" }
};
for (const [c, e] of Object.entries(mA))
  Ud(c, e);
function Sl(c, e) {
  return c instanceof tn ? c : new Proxy(c, {
    get(t, r, n) {
      if (r === Bt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      if (Reflect.has(t, `${r}Node`)) {
        const o = Reflect.get(t, `${r}Node`, n);
        if (o !== null)
          return o;
      }
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      let o = r;
      Reflect.has(t, `${r}Node`) && n && n.isNode && (o = `${r}Node`);
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else {
        if (Reflect.get(t, o, s) === n)
          return !0;
        i = Reflect.set(t, o, n, s);
      }
      return i && e.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: c, fields: [r] }), i;
    }
  });
}
class E1 extends Dn {
  constructor(t, r, n, s) {
    super(t, s, !1);
    B(this, "isEffectNode", !0);
    Ts(this.typesExtended.in), Ts(this.inputs);
    for (const [o, i] of Object.entries(r.in || {}))
      this.addInput(o, i);
    Ts(this.typesExtended.out), Ts(this.outputs);
    for (const [o, i] of Object.entries(r.out || {}))
      this.addOutput(o, i);
    n && (this.code = n);
  }
  serialize(t) {
    super.serialize(t), delete t.code, delete t.types;
  }
}
rr("EffectNode", E1, {}, "ScriptBlockNode");
function R1(c, e, t, r) {
  return Ud(c, {
    clsName: "EffectNode",
    func: () => new E1(c, t, r),
    group: `Effects.${e}`,
    icon: "polygon"
  });
}
R1(
  "FallingPoints",
  "Falling Points",
  {
    in: {
      speed: "Number",
      size: "Number",
      maxCount: "Number"
    }
  },
  `const worldPosition = this.getWorldPosition(new THREE.Vector3());
const initialPosition = world.combineBuffer(this, 'position', params.maxCount || 1000);
const geometry = new THREE.BufferGeometry();

this.traverse(function (child) {
  if (child.isMesh) {
    child.material.visible = false;
  }
} );

geometry.setAttribute( 'position', initialPosition.clone() );
geometry.attributes.position.setUsage( THREE.DynamicDrawUsage );

const size = params.size || 0.02;
const mesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size, color: 0xffffff } ) );
const positions = geometry.attributes.position;
const count = positions.count;
const speed = params.speed || 5;
const minY = -worldPosition.y;
let resolve;
const promise = new Promise((rslv) => resolve = rslv);

mesh.onBeforeRender = () => {
  const delta = world.delta;
  let verticesDown = 0;

  for ( let i = 0; i < count; i ++ ) {
    const px = positions.getX( i );
    const py = positions.getY( i );
    const pz = positions.getZ( i );

    if ( py > minY ) {
      positions.setXYZ(
        i,
        px + 1.5 * ( 0.50 - Math.random() ) * speed * delta,
        py + 3.0 * ( 0.25 - Math.random() ) * speed * delta,
        pz + 1.5 * ( 0.50 - Math.random() ) * speed * delta
      );
    } else {
      verticesDown += 1;
    }
  }

  // all vertices down
  if ( verticesDown >= count ) {
    resolve();
  }
  positions.needsUpdate = true;
};
this.add(mesh);
await promise;
this.removeFromParent();
`
);
class L1 extends En {
  constructor(t, r, n) {
    super();
    B(this, "isEffect", !0);
    B(this, "props");
    this.geometry = t, this.material = r, this.type = "Effect", this.visible = !1, this.props = zd({ ...n }, (s, o) => {
      this.onPropsChanged([s], [o]);
    }), this.addEventListener("added", async () => {
      await this.onAttached(), this.geometry && this.material && (this.visible = !0);
    }), this.addEventListener("removed", async () => {
      await this.onDetached(), this.visible = !1;
    });
  }
  async onAttached() {
    await this.build();
  }
  onPropsChanged(t, r) {
  }
  onDetached() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  async build() {
  }
  dispose() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  clone(t) {
    const r = super.clone(t), n = Qs(this.props), s = r.props[Bt];
    return er(s, n), r;
  }
  serialize(t) {
    t.props = Qs(this.props);
  }
  deserialize(t) {
    if (t.props) {
      const r = this.props[Bt];
      er(r, t.props), this.build();
    }
  }
}
Ye(
  "Effect",
  {
    members: {},
    proto: "Object3D",
    group: "",
    icon: "",
    create: () => new L1()
  }
);
const fu = {};
function gA(c, e) {
  if (fu[c])
    throw ke.panic(`Class[${c}] aready exists`);
  return fu[c] = e, Ye(c, e);
}
function yA(c, e) {
  const t = fu[c];
  if (!t)
    throw ke.panic(`Class[${c}] not found!`);
  return t.create(e);
}
nn.createEffect = yA;
class vA extends L1 {
  constructor() {
    super(void 0, void 0, { maxCount: 1e3, texture: "", lerpPosition: 0 });
    B(this, "isEffectBurning", !0);
    this.type = "EffectBurning";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPropsChanged(t, r) {
    const n = this.parent;
    if (!n || !(n instanceof Qt))
      return;
    t.includes("maxCount") && (this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.build());
    let s = !1;
    if (t.includes("lerpPosition"))
      if (this.material) {
        const o = Ft("targetPosition", "vec3"), i = Rt(this.props.lerpPosition), a = rn(bn, o, i);
        this.material.positionNode = a, this.material.uniformsNeedUpdate = !0;
      } else
        s = !0;
    t.includes("texture") && (s = !0), s && (this.material && (this.material.dispose(), this.material = void 0), this.build());
  }
  async buildMaterial() {
    if (!this.props.texture)
      return;
    const t = Ft("targetPosition", "vec3"), r = Ft("particleSize", "float"), n = Rt(this.props.lerpPosition), s = rn(bn, t, n), o = await new _u().loadAsync(this.props.texture);
    o.colorSpace = vn;
    const i = Ft("particleSpeed", "float"), a = Ft("particleIntensity", "float"), l = Xh(1), u = E0(
      tt(6, 6),
      // count
      U0,
      // uv
      l.mul(i)
      // current frame
    ), d = Zt(o, u).mul(a), f = new Pd({
      depthWrite: !1,
      transparent: !0,
      sizeAttenuation: !0,
      blending: Xx
    });
    f.colorNode = d, f.sizeNode = r, f.positionNode = s, this.material && this.material.dispose(), this.material = f;
  }
  buildGeometry() {
    const t = this.parent;
    if (!t || !(t instanceof Qt))
      return;
    const r = new Ss(), n = [], s = [], o = [], i = nn.combineBuffer(t, "position", this.props.maxCount || 1e3), a = i.count;
    for (let l = 0; l < a; l++)
      n.push(20 + Math.random() * 50), s.push(Math.random() * 0.04), o.push(30 + Math.random() * 230);
    r.setAttribute("position", i), r.setAttribute("targetPosition", i), r.setAttribute("particleSpeed", new yn(n, 1)), r.setAttribute("particleIntensity", new yn(s, 1)), r.setAttribute("particleSize", new yn(o, 1)), this.geometry && this.geometry.dispose(), this.geometry = r;
  }
  async build() {
    this.geometry || this.buildGeometry(), this.material || await this.buildMaterial(), this.geometry && this.material && (this.isPoints = !0, this.visible = !0);
  }
  toJSON(t) {
    const r = this.isPoints;
    delete this.isPoints;
    const n = super.toJSON(t);
    return this.isPoints = r, n;
  }
}
gA(
  "EffectBurning",
  {
    members: {
      "props.maxCount": "Number",
      "props.texture": "Url",
      "props.lerpPosition": "Number"
    },
    proto: "Effect",
    group: "Effects.Burning Effect",
    icon: "fireworks",
    create: () => new vA()
  }
);
R1(
  "Burning",
  "Burning Body",
  {
    in: {
      texture: "Url",
      lerpPosition: "Number",
      time: "Number",
      maxCount: "Number"
    }
  },
  `const effect = world.createEffect('EffectBurning');
effect.props.maxCount = params.maxCount || 1000;
effect.props.lerpPosition = params.lerpPosition;
effect.props.texture = params.texture;
this.add(effect);

// waits
if (params.time) {
  await world.wait(params.time);
  effect.removeFromParent();
}
`
);
class xA extends Oe {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const dt = xA, wa = new kh();
wa.camera = new xr();
const Up = {
  LineBasicNodeMaterial: is.basic,
  MeshBasicNodeMaterial: is.basic,
  PointsNodeMaterial: is.points,
  MeshStandardNodeMaterial: is.standard,
  MeshPhysicalNodeMaterial: is.physical,
  MeshPhongNodeMaterial: is.phong
}, bA = {
  [Be.ATAN2]: "atan"
}, NA = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function fs(c) {
  return `#include <${c}>`;
}
function Do(c) {
  return `${c}Shader`;
}
class zp extends g0 {
  constructor(e, t, r, n = null) {
    super(e, t, new kv(), null, n), this.shader = r, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow();
  }
  getMethod(e) {
    return bA[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), Up[t] !== void 0) {
      const r = Up[t], n = this.shader;
      n.vertexShader = r.vertexShader, n.fragmentShader = r.fragmentShader, n.uniforms = nr.merge([r.uniforms, so.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new dt({
      node: us,
      nodeType: "vec3",
      source: fs("clipping_planes_fragment"),
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: fs("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new dt({
      node: e.opacityNode,
      nodeType: "float",
      source: fs("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new dt({
      node: e.normalNode,
      nodeType: "vec3",
      source: fs("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new dt({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: fs("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.metalnessNode,
      nodeType: "float",
      source: fs("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.roughnessNode,
      nodeType: "float",
      source: fs("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new dt({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new dt({
      node: e.positionNode,
      nodeType: "vec3",
      source: fs("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new dt({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  getTexture(e, t, r) {
    return e.isTextureCube ? `textureCube( ${t}, ${r} )` : `texture2D( ${t}, ${r} )`;
  }
  getTextureBias(e, t, r, n) {
    return this.material.extensions !== void 0 && (this.material.extensions.shaderTextureLOD = !0), `textureLod( ${t}, ${r}, ${n} )`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let r = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let s = null;
      n.type === "texture" ? s = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? s = `samplerCube ${n.name}; ` : s = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? s = "uniform " + NA[o] + " " + s : s = "uniform " + s, r += s;
    }
    return r;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const r = this.attributes;
      for (const n of r)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const r = this.varyings;
    if (e === "vertex")
      for (const n of r)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of r)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, r, n = this) {
    const s = Do(e);
    let o = n[s];
    const i = o.indexOf(t);
    if (i !== -1) {
      const a = o.substring(0, i + t.length), l = o.substring(i + t.length);
      o = `${a}
${r}
${l}`;
    }
    n[s] = o;
  }
  replaceCode(e, t, r, n = this) {
    const s = Do(e);
    n[s] = n[s].replaceAll(t, r);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of $r) {
      const r = this.getUniforms(t), n = this.getAttributes(t), s = this.getVaryings(t), o = this.getVars(t), i = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${r}

// attributes
${n}

// varyings
${s}

// vars
${o}

// codes
${i}

// </node_builder>

${this.shader[Do(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const r of t) {
      const n = fs(r), s = bm[r], o = Do(e);
      this.shader[o] = this.shader[o].replaceAll(n, s);
    }
  }
  _sortSlotsToFlow() {
    for (const e of $r) {
      const t = this.shader[Do(e)], r = this.slots[e].sort((n, s) => t.indexOf(n.source) > t.indexOf(s.source) ? 1 : -1);
      for (const n of r)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of $r) {
      for (const t of this.slots[e]) {
        const r = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, s = t.source, o = r.code + `
	` + t.target.replace("%RESULT%", r.result);
        n === "append" ? this.addCode(e, s, o) : n === "replace" ? this.replaceCode(e, s, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of $r)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    wa.object = this.object, wa.renderer = this.renderer;
    for (const e of this.updateNodes)
      wa.updateNode(e);
  }
}
const pu = /* @__PURE__ */ new WeakMap(), Xr = new kh();
Bn.prototype.onBuild = function(c, e, t) {
  if (Array.isArray(c.material))
    for (const r of c.material)
      r.isNodeMaterial === !0 && pu.set(r, new zp(c, t, e, r).build());
  else
    c.material.isNodeMaterial === !0 && pu.set(c.material, new zp(c, t, e).build());
};
Bn.prototype.onBeforeRender = function(c, e, t, r, n) {
  const s = pu.get(this);
  if (s !== void 0) {
    Xr.material = this, Xr.camera = t, Xr.object = n, Xr.renderer = c;
    const o = s.updateNodes;
    if (o.length > 0) {
      c.state.useProgram(null);
      for (const i of o)
        Xr.updateNode(i);
    }
  }
};
class wA {
  constructor(e, t, r) {
    this.variables = [], this.currentTextureIndex = 0;
    let n = Pf;
    const s = new $a(), o = new $x();
    o.position.z = 1;
    const i = {
      passThruTexture: { value: null }
    }, a = h(f(), i), l = new Qt(new Tr(2, 2), a);
    s.add(l), this.setDataType = function(p) {
      return n = p, this;
    }, this.addVariable = function(p, m, g) {
      const b = this.createShaderMaterial(m), x = {
        name: p,
        initialValueTexture: g,
        material: b,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: js,
        magFilter: js
      };
      return this.variables.push(x), x;
    }, this.setVariableDependencies = function(p, m) {
      p.dependencies = m;
    }, this.init = function() {
      if (r.capabilities.isWebGL2 === !1 && r.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (r.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let p = 0; p < this.variables.length; p++) {
        const m = this.variables[p];
        m.renderTargets[0] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), m.renderTargets[1] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), this.renderTexture(m.initialValueTexture, m.renderTargets[0]), this.renderTexture(m.initialValueTexture, m.renderTargets[1]);
        const g = m.material, b = g.uniforms;
        if (m.dependencies !== null)
          for (let x = 0; x < m.dependencies.length; x++) {
            const y = m.dependencies[x];
            if (y.name !== m.name) {
              let v = !1;
              for (let N = 0; N < this.variables.length; N++)
                if (y.name === this.variables[N].name) {
                  v = !0;
                  break;
                }
              if (!v)
                return "Variable dependency not found. Variable=" + m.name + ", dependency=" + y.name;
            }
            b[y.name] = { value: null }, g.fragmentShader = `
uniform sampler2D ` + y.name + `;
` + g.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const p = this.currentTextureIndex, m = this.currentTextureIndex === 0 ? 1 : 0;
      for (let g = 0, b = this.variables.length; g < b; g++) {
        const x = this.variables[g];
        if (x.dependencies !== null) {
          const y = x.material.uniforms;
          for (let v = 0, N = x.dependencies.length; v < N; v++) {
            const w = x.dependencies[v];
            y[w.name].value = w.renderTargets[p].texture;
          }
        }
        this.doRenderTarget(x.material, x.renderTargets[m]);
      }
      this.currentTextureIndex = m;
    }, this.getCurrentRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.geometry.dispose(), l.material.dispose();
      const p = this.variables;
      for (let m = 0; m < p.length; m++) {
        const g = p[m];
        g.initialValueTexture && g.initialValueTexture.dispose();
        const b = g.renderTargets;
        for (let x = 0; x < b.length; x++)
          b[x].dispose();
      }
    };
    function u(p) {
      p.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function h(p, m) {
      m = m || {};
      const g = new ls({
        name: "GPUComputationShader",
        uniforms: m,
        vertexShader: d(),
        fragmentShader: p
      });
      return u(g), g;
    }
    this.createShaderMaterial = h, this.createRenderTarget = function(p, m, g, b, x, y) {
      return p = p || e, m = m || t, g = g || fo, b = b || fo, x = x || js, y = y || js, new Cu(p, m, {
        wrapS: g,
        wrapT: b,
        minFilter: x,
        magFilter: y,
        format: If,
        type: n,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const p = new Float32Array(e * t * 4), m = new pa(p, e, t, If, Pf);
      return m.needsUpdate = !0, m;
    }, this.renderTexture = function(p, m) {
      i.passThruTexture.value = p, this.doRenderTarget(a, m), i.passThruTexture.value = null;
    }, this.doRenderTarget = function(p, m) {
      const g = r.getRenderTarget(), b = r.xr.enabled, x = r.shadowMap.autoUpdate;
      r.xr.enabled = !1, r.shadowMap.autoUpdate = !1, l.material = p, r.setRenderTarget(m), r.render(s, o), l.material = a, r.xr.enabled = b, r.shadowMap.autoUpdate = x, r.setRenderTarget(g);
    };
    function d() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function f() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const bt = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function F1(c) {
  const e = await fetch(c);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function TA(c) {
  if (!c)
    throw new Error("No basePath supplied");
  return await F1(`${c}/profilesList.json`);
}
async function SA(c, e, t = null, r = !0) {
  if (!c)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await TA(e);
  let s;
  if (c.profiles.some((a) => {
    const l = n[a];
    return l && (s = {
      profileId: a,
      profilePath: `${e}/${l.path}`,
      deprecated: !!l.deprecated
    }), !!s;
  }), !s) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    s = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await F1(s.profilePath);
  let i;
  if (r) {
    let a;
    if (c.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[c.handedness], !a)
      throw new Error(
        `No matching handedness, ${c.handedness}, in profile ${s.profileId}`
      );
    a.assetPath && (i = s.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: i };
}
const _A = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: bt.ComponentState.DEFAULT
};
function MA(c = 0, e = 0) {
  let t = c, r = e;
  if (Math.sqrt(c * c + e * e) > 1) {
    const o = Math.atan2(e, c);
    t = Math.cos(o), r = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: r * 0.5 + 0.5
  };
}
class AA {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === bt.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(_A);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: r,
    state: n
  }) {
    const { normalizedXAxis: s, normalizedYAxis: o } = MA(e, t);
    switch (this.componentProperty) {
      case bt.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? s : 0.5;
        break;
      case bt.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case bt.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? r : 0;
        break;
      case bt.ComponentProperty.STATE:
        this.valueNodeProperty === bt.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class CA {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((r) => {
      const n = new AA(t.visualResponses[r]);
      this.visualResponses[r] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: bt.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = bt.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = bt.ComponentState.PRESSED : (t.touched || this.values.button > bt.ButtonTouchThreshold) && (this.values.state = bt.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === bt.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > bt.AxisTouchThreshold && (this.values.state = bt.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === bt.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > bt.AxisTouchThreshold && (this.values.state = bt.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class EA {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, r) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = r, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const s = this.layoutDescription.components[n];
      this.components[n] = new CA(n, s);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const RA = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", LA = "generic-trigger";
class FA extends En {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((r) => {
        const { valueNode: n, minNode: s, maxNode: o, value: i, valueNodeProperty: a } = r;
        n && (a === bt.VisualResponseProperty.VISIBILITY ? n.visible = i : a === bt.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          s.quaternion,
          o.quaternion,
          i
        ), n.position.lerpVectors(
          s.position,
          o.position,
          i
        )));
      });
    }));
  }
}
function OA(c, e) {
  Object.values(c.components).forEach((t) => {
    const { type: r, touchPointNodeName: n, visualResponses: s } = t;
    if (r === bt.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new Ja(1e-3), i = new An({ color: 255 }), a = new Qt(o, i);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(s).forEach((o) => {
      const { valueNodeName: i, minNodeName: a, maxNodeName: l, valueNodeProperty: u } = o;
      if (u === bt.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(l), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${l} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(i), o.valueNode || console.warn(`Could not find ${i} in the model`);
    });
  });
}
function Bp(c, e) {
  OA(c.motionController, e), c.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = c.envMap, t.material.needsUpdate = !0);
  }), c.add(e);
}
class IA {
  constructor(e = null) {
    this.gltfLoader = e, this.path = RA, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new Gd());
  }
  createControllerModel(e) {
    const t = new FA();
    let r = null;
    return e.addEventListener("connected", (n) => {
      const s = n.data;
      s.targetRayMode !== "tracked-pointer" || !s.gamepad || SA(s, this.path, LA).then(({ profile: o, assetPath: i }) => {
        t.motionController = new EA(
          s,
          o,
          i
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          r = a.scene.clone(), Bp(t, r);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (l) => {
              this._assetCache[t.motionController.assetUrl] = l, r = l.scene.clone(), Bp(t, r);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(r), r = null;
    }), t;
  }
}
const PA = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class DA {
  constructor(e, t, r, n, s = null) {
    this.controller = t, this.handModel = e, this.bones = [], s === null && (s = new Gd(), s.setPath(r || PA)), s.load(`${n}.glb`, (o) => {
      const i = o.scene.children[0];
      this.handModel.add(i);
      const a = i.getObjectByProperty("type", "SkinnedMesh");
      a.frustumCulled = !1, a.castShadow = !0, a.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((u) => {
        const h = i.getObjectByName(u);
        h !== void 0 ? h.jointName = u : console.warn(`Couldn't find ${u} in ${n} hand mesh`), this.bones.push(h);
      });
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const r = this.bones[t];
      if (r) {
        const n = e[r.jointName];
        if (n.visible) {
          const s = n.position;
          r.position.copy(s), r.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const UA = 0.01, zA = "index-finger-tip";
class kp extends En {
  constructor(e, t = null) {
    super(), this.controller = e, this.motionController = null, this.envMap = null, this.loader = t, this.mesh = null, e.addEventListener("connected", (r) => {
      const n = r.data;
      n.hand && !this.motionController && (this.xrInputSource = n, this.motionController = new DA(this, e, this.path, n.handedness, this.loader));
    }), e.addEventListener("disconnected", () => {
      this.clear(), this.motionController = null;
    });
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && this.motionController.updateMesh();
  }
  getPointerPosition() {
    const e = this.controller.joints[zA];
    return e ? e.position : null;
  }
  intersectBoxObject(e) {
    const t = this.getPointerPosition();
    if (t) {
      const r = new yi(t, UA), n = new tr().setFromObject(e);
      return r.intersectsBox(n);
    } else
      return !1;
  }
  checkButton(e) {
    this.intersectBoxObject(e) ? e.onPress() : e.onClear(), e.isPressed() && e.whilePressed();
  }
}
class BA extends Yv {
  constructor() {
    super(), this.name;
    const e = new qa(-5, 5, 5, -5);
    e.near = 1e-4, e.far = 1e3, e.position.set(0, 0, 4), this.add(e);
    const t = new Qt(new Ja(0.5), new An({ color: 8947967, wireframe: !0 }));
    t.onBeforeRender = () => {
      t.rotation.y -= 4e-3;
    }, this.add(t);
    const r = new h1();
    r.text = "Loading...", r.color = 8947865, r.anchorX = "center", r.fontSize = 0.16, r.position.set(0, -0.6, 0), this.add(r);
  }
}
const Jt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], kA = Math.PI / 180;
function jd() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Jt[c & 255] + Jt[c >> 8 & 255] + Jt[c >> 16 & 255] + Jt[c >> 24 & 255] + "-" + Jt[e & 255] + Jt[e >> 8 & 255] + "-" + Jt[e >> 16 & 15 | 64] + Jt[e >> 24 & 255] + "-" + Jt[t & 63 | 128] + Jt[t >> 8 & 255] + "-" + Jt[t >> 16 & 255] + Jt[t >> 24 & 255] + Jt[r & 255] + Jt[r >> 8 & 255] + Jt[r >> 16 & 255] + Jt[r >> 24 & 255]).toLowerCase();
}
function Un(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function Uo(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return c / 4294967295;
    case Uint16Array:
      return c / 65535;
    case Uint8Array:
      return c / 255;
    case Int32Array:
      return Math.max(c / 2147483647, -1);
    case Int16Array:
      return Math.max(c / 32767, -1);
    case Int8Array:
      return Math.max(c / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function fn(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return Math.round(c * 4294967295);
    case Uint16Array:
      return Math.round(c * 65535);
    case Uint8Array:
      return Math.round(c * 255);
    case Int32Array:
      return Math.round(c * 2147483647);
    case Int16Array:
      return Math.round(c * 32767);
    case Int8Array:
      return Math.round(c * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class _i {
  constructor(e = 0, t = 0, r = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = n;
  }
  static slerpFlat(e, t, r, n, s, o, i) {
    let a = r[n + 0], l = r[n + 1], u = r[n + 2], h = r[n + 3];
    const d = s[o + 0], f = s[o + 1], p = s[o + 2], m = s[o + 3];
    if (i === 0) {
      e[t + 0] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (i === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
      return;
    }
    if (h !== m || a !== d || l !== f || u !== p) {
      let g = 1 - i;
      const b = a * d + l * f + u * p + h * m, x = b >= 0 ? 1 : -1, y = 1 - b * b;
      if (y > Number.EPSILON) {
        const N = Math.sqrt(y), w = Math.atan2(N, b * x);
        g = Math.sin(g * w) / N, i = Math.sin(i * w) / N;
      }
      const v = i * x;
      if (a = a * g + d * v, l = l * g + f * v, u = u * g + p * v, h = h * g + m * v, g === 1 - i) {
        const N = 1 / Math.sqrt(a * a + l * l + u * u + h * h);
        a *= N, l *= N, u *= N, h *= N;
      }
    }
    e[t] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, r, n, s, o) {
    const i = r[n], a = r[n + 1], l = r[n + 2], u = r[n + 3], h = s[o], d = s[o + 1], f = s[o + 2], p = s[o + 3];
    return e[t] = i * p + u * h + a * f - l * d, e[t + 1] = a * p + u * d + l * h - i * f, e[t + 2] = l * p + u * f + i * d - a * h, e[t + 3] = u * p - i * h - a * d - l * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._order, i = Math.cos, a = Math.sin, l = i(r / 2), u = i(n / 2), h = i(s / 2), d = a(r / 2), f = a(n / 2), p = a(s / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "YZX":
        this._x = d * u * h + l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "XZY":
        this._x = d * u * h - l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], n = t[4], s = t[8], o = t[1], i = t[5], a = t[9], l = t[2], u = t[6], h = t[10], d = r + i + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - a) * f, this._y = (s - l) * f, this._z = (o - n) * f;
    } else if (r > i && r > h) {
      const f = 2 * Math.sqrt(1 + r - i - h);
      this._w = (u - a) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (s + l) / f;
    } else if (i > h) {
      const f = 2 * Math.sqrt(1 + i - r - h);
      this._w = (s - l) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (a + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - r - i);
      this._w = (o - n) / f, this._x = (s + l) / f, this._y = (a + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Un(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const n = Math.min(1, t / r);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._w, i = t._x, a = t._y, l = t._z, u = t._w;
    return this._x = r * u + o * i + n * l - s * a, this._y = n * u + o * a + s * i - r * l, this._z = s * u + o * l + r * a - n * i, this._w = o * u - r * i - n * a - s * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, n = this._y, s = this._z, o = this._w;
    let i = o * e._w + r * e._x + n * e._y + s * e._z;
    if (i < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, i = -i) : this.copy(e), i >= 1)
      return this._w = o, this._x = r, this._y = n, this._z = s, this;
    const a = 1 - i * i;
    if (a <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * r + t * this._x, this._y = f * n + t * this._y, this._z = f * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(a), u = Math.atan2(l, i), h = Math.sin((1 - t) * u) / l, d = Math.sin(t * u) / l;
    return this._w = o * h + this._w * d, this._x = r * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class G {
  constructor(e = 0, t = 0, r = 0) {
    G.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Gp.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Gp.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * n, this.y = s[1] * t + s[4] * r + s[7] * n, this.z = s[2] * t + s[5] * r + s[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * r + s[11] * n + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * n + s[12]) * o, this.y = (s[1] * t + s[5] * r + s[9] * n + s[13]) * o, this.z = (s[2] * t + s[6] * r + s[10] * n + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, n = this.z, s = e.x, o = e.y, i = e.z, a = e.w, l = a * t + o * n - i * r, u = a * r + i * t - s * n, h = a * n + s * r - o * t, d = -s * t - o * r - i * n;
    return this.x = l * a + d * -s + u * -i - h * -o, this.y = u * a + d * -o + h * -s - l * -i, this.z = h * a + d * -i + l * -o - u * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * n, this.y = s[1] * t + s[5] * r + s[9] * n, this.z = s[2] * t + s[6] * r + s[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, n = e.y, s = e.z, o = t.x, i = t.y, a = t.z;
    return this.x = n * a - s * i, this.y = s * o - r * a, this.z = r * i - n * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return _l.copy(this).projectOnVector(e), this.sub(_l);
  }
  reflect(e) {
    return this.sub(_l.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Un(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _l = /* @__PURE__ */ new G(), Gp = /* @__PURE__ */ new _i();
class Ee {
  constructor(e = 0, t = 0) {
    Ee.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Un(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * r - o * n + e.x, this.y = s * n + o * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Mi {
  constructor(e = new G(1 / 0, 1 / 0, 1 / 0), t = new G(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(ms.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(ms.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ms.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0)
      e.boundingBox === null && e.computeBoundingBox(), Dr.copy(e.boundingBox), Dr.applyMatrix4(e.matrixWorld), this.union(Dr);
    else {
      const n = e.geometry;
      if (n !== void 0)
        if (t && n.attributes !== void 0 && n.attributes.position !== void 0) {
          const s = n.attributes.position;
          for (let o = 0, i = s.count; o < i; o++)
            ms.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ms);
        } else
          n.boundingBox === null && n.computeBoundingBox(), Dr.copy(n.boundingBox), Dr.applyMatrix4(e.matrixWorld), this.union(Dr);
    }
    const r = e.children;
    for (let n = 0, s = r.length; n < s; n++)
      this.expandByObject(r[n], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ms), ms.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(zo), ea.subVectors(this.max, zo), Ur.subVectors(e.a, zo), zr.subVectors(e.b, zo), Br.subVectors(e.c, zo), Is.subVectors(zr, Ur), Ps.subVectors(Br, zr), ur.subVectors(Ur, Br);
    let t = [
      0,
      -Is.z,
      Is.y,
      0,
      -Ps.z,
      Ps.y,
      0,
      -ur.z,
      ur.y,
      Is.z,
      0,
      -Is.x,
      Ps.z,
      0,
      -Ps.x,
      ur.z,
      0,
      -ur.x,
      -Is.y,
      Is.x,
      0,
      -Ps.y,
      Ps.x,
      0,
      -ur.y,
      ur.x,
      0
    ];
    return !Ml(t, Ur, zr, Br, ea) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Ml(t, Ur, zr, Br, ea)) ? !1 : (ta.crossVectors(Is, Ps), t = [ta.x, ta.y, ta.z], Ml(t, Ur, zr, Br, ea));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ms).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ms).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (ps[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ps[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ps[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ps[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ps[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ps[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ps[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ps[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ps), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ps = [
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G(),
  /* @__PURE__ */ new G()
], ms = /* @__PURE__ */ new G(), Dr = /* @__PURE__ */ new Mi(), Ur = /* @__PURE__ */ new G(), zr = /* @__PURE__ */ new G(), Br = /* @__PURE__ */ new G(), Is = /* @__PURE__ */ new G(), Ps = /* @__PURE__ */ new G(), ur = /* @__PURE__ */ new G(), zo = /* @__PURE__ */ new G(), ea = /* @__PURE__ */ new G(), ta = /* @__PURE__ */ new G(), hr = /* @__PURE__ */ new G();
function Ml(c, e, t, r, n) {
  for (let s = 0, o = c.length - 3; s <= o; s += 3) {
    hr.fromArray(c, s);
    const i = n.x * Math.abs(hr.x) + n.y * Math.abs(hr.y) + n.z * Math.abs(hr.z), a = e.dot(hr), l = t.dot(hr), u = r.dot(hr);
    if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > i)
      return !1;
  }
  return !0;
}
class O1 {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const n = r.slice(0);
      for (let s = 0, o = n.length; s < o; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const GA = 1015, Vp = 35044, na = 2e3, jp = 2001, Mt = /* @__PURE__ */ new G(), sa = /* @__PURE__ */ new Ee();
class lo {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = Vp, this.updateRange = { offset: 0, count: -1 }, this.gpuType = GA, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        sa.fromBufferAttribute(this, t), sa.applyMatrix3(e), this.setXY(t, sa.x, sa.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Mt.fromBufferAttribute(this, t), Mt.applyMatrix3(e), this.setXYZ(t, Mt.x, Mt.y, Mt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Mt.fromBufferAttribute(this, t), Mt.applyMatrix4(e), this.setXYZ(t, Mt.x, Mt.y, Mt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Mt.fromBufferAttribute(this, t), Mt.applyNormalMatrix(e), this.setXYZ(t, Mt.x, Mt.y, Mt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Mt.fromBufferAttribute(this, t), Mt.transformDirection(e), this.setXYZ(t, Mt.x, Mt.y, Mt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = Uo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = fn(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Uo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Uo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Uo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Uo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, n) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, r, n, s) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array), s = fn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Vp && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class VA extends lo {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class jA extends lo {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class $e extends lo {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
const WA = /* @__PURE__ */ new Mi(), Bo = /* @__PURE__ */ new G(), Al = /* @__PURE__ */ new G();
class HA {
  constructor(e = new G(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : WA.setFromPoints(e).getCenter(r);
    let n = 0;
    for (let s = 0, o = e.length; s < o; s++)
      n = Math.max(n, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Bo.subVectors(e, this.center);
    const t = Bo.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), n = (r - this.radius) * 0.5;
      this.center.addScaledVector(Bo, n / r), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Al.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Bo.copy(e.center).add(Al)), this.expandByPoint(Bo.copy(e.center).sub(Al))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Kn {
  constructor(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    Kn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g);
  }
  set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    const b = this.elements;
    return b[0] = e, b[4] = t, b[8] = r, b[12] = n, b[1] = s, b[5] = o, b[9] = i, b[13] = a, b[2] = l, b[6] = u, b[10] = h, b[14] = d, b[3] = f, b[7] = p, b[11] = m, b[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Kn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, n = 1 / kr.setFromMatrixColumn(e, 0).length(), s = 1 / kr.setFromMatrixColumn(e, 1).length(), o = 1 / kr.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z, o = Math.cos(r), i = Math.sin(r), a = Math.cos(n), l = Math.sin(n), u = Math.cos(s), h = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = -a * h, t[8] = l, t[1] = f + p * l, t[5] = d - m * l, t[9] = -i * a, t[2] = m - d * l, t[6] = p + f * l, t[10] = o * a;
    } else if (e.order === "YXZ") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d + m * i, t[4] = p * i - f, t[8] = o * l, t[1] = o * h, t[5] = o * u, t[9] = -i, t[2] = f * i - p, t[6] = m + d * i, t[10] = o * a;
    } else if (e.order === "ZXY") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d - m * i, t[4] = -o * h, t[8] = p + f * i, t[1] = f + p * i, t[5] = o * u, t[9] = m - d * i, t[2] = -o * l, t[6] = i, t[10] = o * a;
    } else if (e.order === "ZYX") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = p * l - f, t[8] = d * l + m, t[1] = a * h, t[5] = m * l + d, t[9] = f * l - p, t[2] = -l, t[6] = i * a, t[10] = o * a;
    } else if (e.order === "YZX") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = m - d * h, t[8] = p * h + f, t[1] = h, t[5] = o * u, t[9] = -i * u, t[2] = -l * u, t[6] = f * h + p, t[10] = d - m * h;
    } else if (e.order === "XZY") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = -h, t[8] = l * u, t[1] = d * h + m, t[5] = o * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = i * u, t[10] = m * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(XA, e, $A);
  }
  lookAt(e, t, r) {
    const n = this.elements;
    return _n.subVectors(e, t), _n.lengthSq() === 0 && (_n.z = 1), _n.normalize(), Ds.crossVectors(r, _n), Ds.lengthSq() === 0 && (Math.abs(r.z) === 1 ? _n.x += 1e-4 : _n.z += 1e-4, _n.normalize(), Ds.crossVectors(r, _n)), Ds.normalize(), ra.crossVectors(_n, Ds), n[0] = Ds.x, n[4] = ra.x, n[8] = _n.x, n[1] = Ds.y, n[5] = ra.y, n[9] = _n.y, n[2] = Ds.z, n[6] = ra.z, n[10] = _n.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[4], a = r[8], l = r[12], u = r[1], h = r[5], d = r[9], f = r[13], p = r[2], m = r[6], g = r[10], b = r[14], x = r[3], y = r[7], v = r[11], N = r[15], w = n[0], T = n[4], S = n[8], A = n[12], R = n[1], O = n[5], _ = n[9], L = n[13], E = n[2], D = n[6], F = n[10], H = n[14], q = n[3], U = n[7], k = n[11], C = n[15];
    return s[0] = o * w + i * R + a * E + l * q, s[4] = o * T + i * O + a * D + l * U, s[8] = o * S + i * _ + a * F + l * k, s[12] = o * A + i * L + a * H + l * C, s[1] = u * w + h * R + d * E + f * q, s[5] = u * T + h * O + d * D + f * U, s[9] = u * S + h * _ + d * F + f * k, s[13] = u * A + h * L + d * H + f * C, s[2] = p * w + m * R + g * E + b * q, s[6] = p * T + m * O + g * D + b * U, s[10] = p * S + m * _ + g * F + b * k, s[14] = p * A + m * L + g * H + b * C, s[3] = x * w + y * R + v * E + N * q, s[7] = x * T + y * O + v * D + N * U, s[11] = x * S + y * _ + v * F + N * k, s[15] = x * A + y * L + v * H + N * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], n = e[8], s = e[12], o = e[1], i = e[5], a = e[9], l = e[13], u = e[2], h = e[6], d = e[10], f = e[14], p = e[3], m = e[7], g = e[11], b = e[15];
    return p * (+s * a * h - n * l * h - s * i * d + r * l * d + n * i * f - r * a * f) + m * (+t * a * f - t * l * d + s * o * d - n * o * f + n * l * u - s * a * u) + g * (+t * l * h - t * i * f - s * o * h + r * o * f + s * i * u - r * l * u) + b * (-n * i * u - t * a * h + t * i * d + n * o * h - r * o * d + r * a * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = e[9], d = e[10], f = e[11], p = e[12], m = e[13], g = e[14], b = e[15], x = h * g * l - m * d * l + m * a * f - i * g * f - h * a * b + i * d * b, y = p * d * l - u * g * l - p * a * f + o * g * f + u * a * b - o * d * b, v = u * m * l - p * h * l + p * i * f - o * m * f - u * i * b + o * h * b, N = p * h * a - u * m * a - p * i * d + o * m * d + u * i * g - o * h * g, w = t * x + r * y + n * v + s * N;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / w;
    return e[0] = x * T, e[1] = (m * d * s - h * g * s - m * n * f + r * g * f + h * n * b - r * d * b) * T, e[2] = (i * g * s - m * a * s + m * n * l - r * g * l - i * n * b + r * a * b) * T, e[3] = (h * a * s - i * d * s - h * n * l + r * d * l + i * n * f - r * a * f) * T, e[4] = y * T, e[5] = (u * g * s - p * d * s + p * n * f - t * g * f - u * n * b + t * d * b) * T, e[6] = (p * a * s - o * g * s - p * n * l + t * g * l + o * n * b - t * a * b) * T, e[7] = (o * d * s - u * a * s + u * n * l - t * d * l - o * n * f + t * a * f) * T, e[8] = v * T, e[9] = (p * h * s - u * m * s - p * r * f + t * m * f + u * r * b - t * h * b) * T, e[10] = (o * m * s - p * i * s + p * r * l - t * m * l - o * r * b + t * i * b) * T, e[11] = (u * i * s - o * h * s - u * r * l + t * h * l + o * r * f - t * i * f) * T, e[12] = N * T, e[13] = (u * m * n - p * h * n + p * r * d - t * m * d - u * r * g + t * h * g) * T, e[14] = (p * i * n - o * m * n - p * r * a + t * m * a + o * r * g - t * i * g) * T, e[15] = (o * h * n - u * i * n + u * r * a - t * h * a - o * r * d + t * i * d) * T, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= s, t[1] *= r, t[5] *= n, t[9] *= s, t[2] *= r, t[6] *= n, t[10] *= s, t[3] *= r, t[7] *= n, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = 1 - r, o = e.x, i = e.y, a = e.z, l = s * o, u = s * i;
    return this.set(
      l * o + r,
      l * i - n * a,
      l * a + n * i,
      0,
      l * i + n * a,
      u * i + r,
      u * a - n * o,
      0,
      l * a - n * i,
      u * a + n * o,
      s * a * a + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, n, s, o) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const n = this.elements, s = t._x, o = t._y, i = t._z, a = t._w, l = s + s, u = o + o, h = i + i, d = s * l, f = s * u, p = s * h, m = o * u, g = o * h, b = i * h, x = a * l, y = a * u, v = a * h, N = r.x, w = r.y, T = r.z;
    return n[0] = (1 - (m + b)) * N, n[1] = (f + v) * N, n[2] = (p - y) * N, n[3] = 0, n[4] = (f - v) * w, n[5] = (1 - (d + b)) * w, n[6] = (g + x) * w, n[7] = 0, n[8] = (p + y) * T, n[9] = (g - x) * T, n[10] = (1 - (d + m)) * T, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, r) {
    const n = this.elements;
    let s = kr.set(n[0], n[1], n[2]).length();
    const o = kr.set(n[4], n[5], n[6]).length(), i = kr.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], $n.copy(this);
    const l = 1 / s, u = 1 / o, h = 1 / i;
    return $n.elements[0] *= l, $n.elements[1] *= l, $n.elements[2] *= l, $n.elements[4] *= u, $n.elements[5] *= u, $n.elements[6] *= u, $n.elements[8] *= h, $n.elements[9] *= h, $n.elements[10] *= h, t.setFromRotationMatrix($n), r.x = s, r.y = o, r.z = i, this;
  }
  makePerspective(e, t, r, n, s, o, i = na) {
    const a = this.elements, l = 2 * s / (t - e), u = 2 * s / (r - n), h = (t + e) / (t - e), d = (r + n) / (r - n);
    let f, p;
    if (i === na)
      f = -(o + s) / (o - s), p = -2 * o * s / (o - s);
    else if (i === jp)
      f = -o / (o - s), p = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + i);
    return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = u, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, r, n, s, o, i = na) {
    const a = this.elements, l = 1 / (t - e), u = 1 / (r - n), h = 1 / (o - s), d = (t + e) * l, f = (r + n) * u;
    let p, m;
    if (i === na)
      p = (o + s) * h, m = -2 * h;
    else if (i === jp)
      p = s * h, m = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + i);
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = m, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const kr = /* @__PURE__ */ new G(), $n = /* @__PURE__ */ new Kn(), XA = /* @__PURE__ */ new G(0, 0, 0), $A = /* @__PURE__ */ new G(1, 1, 1), Ds = /* @__PURE__ */ new G(), ra = /* @__PURE__ */ new G(), _n = /* @__PURE__ */ new G(), Wp = /* @__PURE__ */ new Kn(), Hp = /* @__PURE__ */ new _i();
class Ac {
  constructor(e = 0, t = 0, r = 0, n = Ac.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, n = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const n = e.elements, s = n[0], o = n[4], i = n[8], a = n[1], l = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Un(i, -1, 1)), Math.abs(i) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Un(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(i, f), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Un(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Un(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(a, s)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(Un(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(i, f));
        break;
      case "XZY":
        this._z = Math.asin(-Un(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(i, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return Wp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Wp, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Hp.setFromEuler(this), this.setFromQuaternion(Hp, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ac.DEFAULT_ORDER = "XYZ";
class qA {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class Ai {
  constructor(e, t, r, n, s, o, i, a, l) {
    Ai.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l);
  }
  set(e, t, r, n, s, o, i, a, l) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = i, u[3] = t, u[4] = s, u[5] = a, u[6] = r, u[7] = o, u[8] = l, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[3], a = r[6], l = r[1], u = r[4], h = r[7], d = r[2], f = r[5], p = r[8], m = n[0], g = n[3], b = n[6], x = n[1], y = n[4], v = n[7], N = n[2], w = n[5], T = n[8];
    return s[0] = o * m + i * x + a * N, s[3] = o * g + i * y + a * w, s[6] = o * b + i * v + a * T, s[1] = l * m + u * x + h * N, s[4] = l * g + u * y + h * w, s[7] = l * b + u * v + h * T, s[2] = d * m + f * x + p * N, s[5] = d * g + f * y + p * w, s[8] = d * b + f * v + p * T, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8];
    return t * o * u - t * i * l - r * s * u + r * i * a + n * s * l - n * o * a;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = u * o - i * l, d = i * a - u * s, f = l * s - o * a, p = t * h + r * d + n * f;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return e[0] = h * m, e[1] = (n * l - u * r) * m, e[2] = (i * r - n * o) * m, e[3] = d * m, e[4] = (u * t - n * a) * m, e[5] = (n * s - i * t) * m, e[6] = f * m, e[7] = (r * a - l * t) * m, e[8] = (o * t - r * s) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, n, s, o, i) {
    const a = Math.cos(s), l = Math.sin(s);
    return this.set(
      r * a,
      r * l,
      -r * (a * o + l * i) + o + e,
      -n * l,
      n * a,
      -n * (-l * o + a * i) + i + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Cl.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Cl.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Cl.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Cl = /* @__PURE__ */ new Ai();
let JA = 0;
const Xp = /* @__PURE__ */ new G(), Gr = /* @__PURE__ */ new _i(), gs = /* @__PURE__ */ new Kn(), oa = /* @__PURE__ */ new G(), ko = /* @__PURE__ */ new G(), YA = /* @__PURE__ */ new G(), KA = /* @__PURE__ */ new _i(), $p = /* @__PURE__ */ new G(1, 0, 0), qp = /* @__PURE__ */ new G(0, 1, 0), Jp = /* @__PURE__ */ new G(0, 0, 1), ZA = { type: "added" }, QA = { type: "removed" };
class $s extends O1 {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: JA++ }), this.uuid = jd(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = $s.DEFAULT_UP.clone();
    const e = new G(), t = new Ac(), r = new _i(), n = new G(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Kn()
      },
      normalMatrix: {
        value: new Ai()
      }
    }), this.matrix = new Kn(), this.matrixWorld = new Kn(), this.matrixAutoUpdate = $s.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = $s.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new qA(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Gr.setFromAxisAngle(e, t), this.quaternion.multiply(Gr), this;
  }
  rotateOnWorldAxis(e, t) {
    return Gr.setFromAxisAngle(e, t), this.quaternion.premultiply(Gr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis($p, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(qp, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Jp, e);
  }
  translateOnAxis(e, t) {
    return Xp.copy(e).applyQuaternion(this.quaternion), this.position.add(Xp.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis($p, e);
  }
  translateY(e) {
    return this.translateOnAxis(qp, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Jp, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(gs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? oa.copy(e) : oa.set(e, t, r);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), ko.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? gs.lookAt(ko, oa, this.up) : gs.lookAt(oa, ko, this.up), this.quaternion.setFromRotationMatrix(gs), n && (gs.extractRotation(n.matrixWorld), Gr.setFromRotationMatrix(gs), this.quaternion.premultiply(Gr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(ZA)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(QA)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), gs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), gs.multiply(e.parent.matrixWorld)), e.applyMatrix4(gs), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, n = this.children.length; r < n; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const o = this.children[n].getObjectsByProperty(e, t);
      o.length > 0 && (r = r.concat(o));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ko, e, YA), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ko, KA, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let s = 0, o = n.length; s < o; s++) {
        const i = n[s];
        i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function s(i, a) {
      return i[a.uuid] === void 0 && (i[a.uuid] = a.toJSON(e)), a.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const i = this.geometry.parameters;
      if (i !== void 0 && i.shapes !== void 0) {
        const a = i.shapes;
        if (Array.isArray(a))
          for (let l = 0, u = a.length; l < u; l++) {
            const h = a[l];
            s(e.shapes, h);
          }
        else
          s(e.shapes, a);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const i = [];
        for (let a = 0, l = this.material.length; a < l; a++)
          i.push(s(e.materials, this.material[a]));
        n.material = i;
      } else
        n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let i = 0; i < this.children.length; i++)
        n.children.push(this.children[i].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const a = this.animations[i];
        n.animations.push(s(e.animations, a));
      }
    }
    if (t) {
      const i = o(e.geometries), a = o(e.materials), l = o(e.textures), u = o(e.images), h = o(e.shapes), d = o(e.skeletons), f = o(e.animations), p = o(e.nodes);
      i.length > 0 && (r.geometries = i), a.length > 0 && (r.materials = a), l.length > 0 && (r.textures = l), u.length > 0 && (r.images = u), h.length > 0 && (r.shapes = h), d.length > 0 && (r.skeletons = d), f.length > 0 && (r.animations = f), p.length > 0 && (r.nodes = p);
    }
    return r.object = n, r;
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
}
$s.DEFAULT_UP = /* @__PURE__ */ new G(0, 1, 0);
$s.DEFAULT_MATRIX_AUTO_UPDATE = !0;
$s.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
function eC(c) {
  if (c.length === 0)
    return 1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] < e && (e = c[t]);
  return e;
}
function tC(c) {
  if (c.length === 0)
    return -1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] > e && (e = c[t]);
  return e;
}
function I1(c) {
  for (let e = c.length - 1; e >= 0; --e)
    if (c[e] >= 65535)
      return !0;
  return !1;
}
const nC = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function sC(c, e) {
  return new nC[c](e);
}
function P1(c) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", c);
}
function rC() {
  const c = P1("canvas");
  return c.style.display = "block", c;
}
const Yp = {};
function oC(c) {
  c in Yp || (Yp[c] = !0, console.warn(c));
}
const iC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayMax: tC,
  arrayMin: eC,
  arrayNeedsUint32: I1,
  createCanvasElement: rC,
  createElementNS: P1,
  getTypedArray: sC,
  warnOnce: oC
}, Symbol.toStringTag, { value: "Module" }));
let aC = 0;
const In = /* @__PURE__ */ new Kn(), El = /* @__PURE__ */ new $s(), Vr = /* @__PURE__ */ new G(), Mn = /* @__PURE__ */ new Mi(), Go = /* @__PURE__ */ new Mi(), zt = /* @__PURE__ */ new G();
class qt extends O1 {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: aC++ }), this.uuid = jd(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (I1(e) ? jA : VA)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Ai().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return In.makeRotationFromQuaternion(e), this.applyMatrix4(In), this;
  }
  rotateX(e) {
    return In.makeRotationX(e), this.applyMatrix4(In), this;
  }
  rotateY(e) {
    return In.makeRotationY(e), this.applyMatrix4(In), this;
  }
  rotateZ(e) {
    return In.makeRotationZ(e), this.applyMatrix4(In), this;
  }
  translate(e, t, r) {
    return In.makeTranslation(e, t, r), this.applyMatrix4(In), this;
  }
  scale(e, t, r) {
    return In.makeScale(e, t, r), this.applyMatrix4(In), this;
  }
  lookAt(e) {
    return El.lookAt(e), El.updateMatrix(), this.applyMatrix4(El.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Vr).negate(), this.translate(Vr.x, Vr.y, Vr.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, n = e.length; r < n; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new $e(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Mi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new G(-1 / 0, -1 / 0, -1 / 0),
        new G(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, n = t.length; r < n; r++) {
          const s = t[r];
          Mn.setFromBufferAttribute(s), this.morphTargetsRelative ? (zt.addVectors(this.boundingBox.min, Mn.min), this.boundingBox.expandByPoint(zt), zt.addVectors(this.boundingBox.max, Mn.max), this.boundingBox.expandByPoint(zt)) : (this.boundingBox.expandByPoint(Mn.min), this.boundingBox.expandByPoint(Mn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new HA());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new G(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (Mn.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s];
          Go.setFromBufferAttribute(i), this.morphTargetsRelative ? (zt.addVectors(Mn.min, Go.min), Mn.expandByPoint(zt), zt.addVectors(Mn.max, Go.max), Mn.expandByPoint(zt)) : (Mn.expandByPoint(Go.min), Mn.expandByPoint(Go.max));
        }
      Mn.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        zt.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(zt));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s], a = this.morphTargetsRelative;
          for (let l = 0, u = i.count; l < u; l++)
            zt.fromBufferAttribute(i, l), a && (Vr.fromBufferAttribute(e, l), zt.add(Vr)), n = Math.max(n, r.distanceToSquared(zt));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, n = t.position.array, s = t.normal.array, o = t.uv.array, i = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new lo(new Float32Array(4 * i), 4));
    const a = this.getAttribute("tangent").array, l = [], u = [];
    for (let R = 0; R < i; R++)
      l[R] = new G(), u[R] = new G();
    const h = new G(), d = new G(), f = new G(), p = new Ee(), m = new Ee(), g = new Ee(), b = new G(), x = new G();
    function y(R, O, _) {
      h.fromArray(n, R * 3), d.fromArray(n, O * 3), f.fromArray(n, _ * 3), p.fromArray(o, R * 2), m.fromArray(o, O * 2), g.fromArray(o, _ * 2), d.sub(h), f.sub(h), m.sub(p), g.sub(p);
      const L = 1 / (m.x * g.y - g.x * m.y);
      isFinite(L) && (b.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(L), x.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(L), l[R].add(b), l[O].add(b), l[_].add(b), u[R].add(x), u[O].add(x), u[_].add(x));
    }
    let v = this.groups;
    v.length === 0 && (v = [{
      start: 0,
      count: r.length
    }]);
    for (let R = 0, O = v.length; R < O; ++R) {
      const _ = v[R], L = _.start, E = _.count;
      for (let D = L, F = L + E; D < F; D += 3)
        y(
          r[D + 0],
          r[D + 1],
          r[D + 2]
        );
    }
    const N = new G(), w = new G(), T = new G(), S = new G();
    function A(R) {
      T.fromArray(s, R * 3), S.copy(T);
      const O = l[R];
      N.copy(O), N.sub(T.multiplyScalar(T.dot(O))).normalize(), w.crossVectors(S, O);
      const L = w.dot(u[R]) < 0 ? -1 : 1;
      a[R * 4] = N.x, a[R * 4 + 1] = N.y, a[R * 4 + 2] = N.z, a[R * 4 + 3] = L;
    }
    for (let R = 0, O = v.length; R < O; ++R) {
      const _ = v[R], L = _.start, E = _.count;
      for (let D = L, F = L + E; D < F; D += 3)
        A(r[D + 0]), A(r[D + 1]), A(r[D + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new lo(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let d = 0, f = r.count; d < f; d++)
          r.setXYZ(d, 0, 0, 0);
      const n = new G(), s = new G(), o = new G(), i = new G(), a = new G(), l = new G(), u = new G(), h = new G();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0), m = e.getX(d + 1), g = e.getX(d + 2);
          n.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), i.fromBufferAttribute(r, p), a.fromBufferAttribute(r, m), l.fromBufferAttribute(r, g), i.add(u), a.add(u), l.add(u), r.setXYZ(p, i.x, i.y, i.z), r.setXYZ(m, a.x, a.y, a.z), r.setXYZ(g, l.x, l.y, l.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), r.setXYZ(d + 0, u.x, u.y, u.z), r.setXYZ(d + 1, u.x, u.y, u.z), r.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      zt.fromBufferAttribute(e, t), zt.normalize(), e.setXYZ(t, zt.x, zt.y, zt.z);
  }
  toNonIndexed() {
    function e(i, a) {
      const l = i.array, u = i.itemSize, h = i.normalized, d = new l.constructor(a.length * u);
      let f = 0, p = 0;
      for (let m = 0, g = a.length; m < g; m++) {
        i.isInterleavedBufferAttribute ? f = a[m] * i.data.stride + i.offset : f = a[m] * u;
        for (let b = 0; b < u; b++)
          d[p++] = l[f++];
      }
      return new lo(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new qt(), r = this.index.array, n = this.attributes;
    for (const i in n) {
      const a = n[i], l = e(a, r);
      t.setAttribute(i, l);
    }
    const s = this.morphAttributes;
    for (const i in s) {
      const a = [], l = s[i];
      for (let u = 0, h = l.length; u < h; u++) {
        const d = l[u], f = e(d, r);
        a.push(f);
      }
      t.morphAttributes[i] = a;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let i = 0, a = o.length; i < a; i++) {
      const l = o[i];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const a = this.parameters;
      for (const l in a)
        a[l] !== void 0 && (e[l] = a[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const a in r) {
      const l = r[a];
      e.data.attributes[a] = l.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const a in this.morphAttributes) {
      const l = this.morphAttributes[a], u = [];
      for (let h = 0, d = l.length; h < d; h++) {
        const f = l[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[a] = u, s = !0);
    }
    s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const i = this.boundingSphere;
    return i !== null && (e.data.boundingSphere = {
      center: i.center.toArray(),
      radius: i.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const n = e.attributes;
    for (const l in n) {
      const u = n[l];
      this.setAttribute(l, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const u = [], h = s[l];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const i = e.boundingBox;
    i !== null && (this.boundingBox = i.clone());
    const a = e.boundingSphere;
    return a !== null && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Wd extends qt {
  constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: n,
      heightSegments: s,
      depthSegments: o
    };
    const i = this;
    n = Math.floor(n), s = Math.floor(s), o = Math.floor(o);
    const a = [], l = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, r, t, e, o, s, 0), p("z", "y", "x", 1, -1, r, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, r, t, n, o, 2), p("x", "z", "y", 1, -1, e, r, -t, n, o, 3), p("x", "y", "z", 1, -1, e, t, r, n, s, 4), p("x", "y", "z", -1, -1, e, t, -r, n, s, 5), this.setIndex(a), this.setAttribute("position", new $e(l, 3)), this.setAttribute("normal", new $e(u, 3)), this.setAttribute("uv", new $e(h, 2));
    function p(m, g, b, x, y, v, N, w, T, S, A) {
      const R = v / T, O = N / S, _ = v / 2, L = N / 2, E = w / 2, D = T + 1, F = S + 1;
      let H = 0, q = 0;
      const U = new G();
      for (let k = 0; k < F; k++) {
        const C = k * O - L;
        for (let P = 0; P < D; P++) {
          const X = P * R - _;
          U[m] = X * x, U[g] = C * y, U[b] = E, l.push(U.x, U.y, U.z), U[m] = 0, U[g] = 0, U[b] = w > 0 ? 1 : -1, u.push(U.x, U.y, U.z), h.push(P / T), h.push(1 - k / S), H += 1;
        }
      }
      for (let k = 0; k < S; k++)
        for (let C = 0; C < T; C++) {
          const P = d + C + D * k, X = d + C + D * (k + 1), Y = d + (C + 1) + D * (k + 1), W = d + (C + 1) + D * k;
          a.push(P, X, W), a.push(X, Y, W), q += 6;
        }
      i.addGroup(f, q, A), f += q, d += H;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wd(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class ds {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, n = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      r = this.getPoint(o / e), s += r.distanceTo(n), t.push(s), n = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let n = 0;
    const s = r.length;
    let o;
    t ? o = t : o = e * r[s - 1];
    let i = 0, a = s - 1, l;
    for (; i <= a; )
      if (n = Math.floor(i + (a - i) / 2), l = r[n] - o, l < 0)
        i = n + 1;
      else if (l > 0)
        a = n - 1;
      else {
        a = n;
        break;
      }
    if (n = a, r[n] === o)
      return n / (s - 1);
    const u = r[n], d = r[n + 1] - u, f = (o - u) / d;
    return (n + f) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const o = this.getPoint(n), i = this.getPoint(s), a = t || (o.isVector2 ? new Ee() : new G());
    return a.copy(i).sub(o).normalize(), a;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new G(), n = [], s = [], o = [], i = new G(), a = new Kn();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      n[f] = this.getTangentAt(p, new G());
    }
    s[0] = new G(), o[0] = new G();
    let l = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= l && (l = u, r.set(1, 0, 0)), h <= l && (l = h, r.set(0, 1, 0)), d <= l && r.set(0, 0, 1), i.crossVectors(n[0], r).normalize(), s[0].crossVectors(n[0], i), o[0].crossVectors(n[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), i.crossVectors(n[f - 1], n[f]), i.length() > Number.EPSILON) {
        i.normalize();
        const p = Math.acos(Un(n[f - 1].dot(n[f]), -1, 1));
        s[f].applyMatrix4(a.makeRotationAxis(i, p));
      }
      o[f].crossVectors(n[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(Un(s[0].dot(s[e]), -1, 1));
      f /= e, n[0].dot(i.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        s[p].applyMatrix4(a.makeRotationAxis(n[p], f * p)), o[p].crossVectors(n[p], s[p]);
    }
    return {
      tangents: n,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Hd extends ds {
  constructor(e = 0, t = 0, r = 1, n = 1, s = 0, o = Math.PI * 2, i = !1, a = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = i, this.aRotation = a;
  }
  getPoint(e, t) {
    const r = t || new Ee(), n = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += n;
    for (; s > n; )
      s -= n;
    s < Number.EPSILON && (o ? s = 0 : s = n), this.aClockwise === !0 && !o && (s === n ? s = -n : s = s - n);
    const i = this.aStartAngle + e * s;
    let a = this.aX + this.xRadius * Math.cos(i), l = this.aY + this.yRadius * Math.sin(i);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = a - this.aX, f = l - this.aY;
      a = d * u - f * h + this.aX, l = d * h + f * u + this.aY;
    }
    return r.set(a, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class cC extends Hd {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, r, n, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Xd() {
  let c = 0, e = 0, t = 0, r = 0;
  function n(s, o, i, a) {
    c = s, e = i, t = -3 * s + 3 * o - 2 * i - a, r = 2 * s - 2 * o + i + a;
  }
  return {
    initCatmullRom: function(s, o, i, a, l) {
      n(o, i, l * (i - s), l * (a - o));
    },
    initNonuniformCatmullRom: function(s, o, i, a, l, u, h) {
      let d = (o - s) / l - (i - s) / (l + u) + (i - o) / u, f = (i - o) / u - (a - o) / (u + h) + (a - i) / h;
      d *= u, f *= u, n(o, i, d, f);
    },
    calc: function(s) {
      const o = s * s, i = o * s;
      return c + e * s + t * o + r * i;
    }
  };
}
const ia = /* @__PURE__ */ new G(), Rl = /* @__PURE__ */ new Xd(), Ll = /* @__PURE__ */ new Xd(), Fl = /* @__PURE__ */ new Xd();
class lC extends ds {
  constructor(e = [], t = !1, r = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
  }
  getPoint(e, t = new G()) {
    const r = t, n = this.points, s = n.length, o = (s - (this.closed ? 0 : 1)) * e;
    let i = Math.floor(o), a = o - i;
    this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / s) + 1) * s : a === 0 && i === s - 1 && (i = s - 2, a = 1);
    let l, u;
    this.closed || i > 0 ? l = n[(i - 1) % s] : (ia.subVectors(n[0], n[1]).add(n[0]), l = ia);
    const h = n[i % s], d = n[(i + 1) % s];
    if (this.closed || i + 2 < s ? u = n[(i + 2) % s] : (ia.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), u = ia), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(l.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), g = Math.pow(d.distanceToSquared(u), f);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Rl.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, p, m, g), Ll.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, p, m, g), Fl.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, p, m, g);
    } else
      this.curveType === "catmullrom" && (Rl.initCatmullRom(l.x, h.x, d.x, u.x, this.tension), Ll.initCatmullRom(l.y, h.y, d.y, u.y, this.tension), Fl.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
    return r.set(
      Rl.calc(a),
      Ll.calc(a),
      Fl.calc(a)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new G().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Kp(c, e, t, r, n) {
  const s = (r - e) * 0.5, o = (n - t) * 0.5, i = c * c, a = c * i;
  return (2 * t - 2 * r + s + o) * a + (-3 * t + 3 * r - 2 * s - o) * i + s * c + t;
}
function uC(c, e) {
  const t = 1 - c;
  return t * t * e;
}
function hC(c, e) {
  return 2 * (1 - c) * c * e;
}
function dC(c, e) {
  return c * c * e;
}
function Yo(c, e, t, r) {
  return uC(c, e) + hC(c, t) + dC(c, r);
}
function fC(c, e) {
  const t = 1 - c;
  return t * t * t * e;
}
function pC(c, e) {
  const t = 1 - c;
  return 3 * t * t * c * e;
}
function mC(c, e) {
  return 3 * (1 - c) * c * c * e;
}
function gC(c, e) {
  return c * c * c * e;
}
function Ko(c, e, t, r, n) {
  return fC(c, e) + pC(c, t) + mC(c, r) + gC(c, n);
}
class D1 extends ds {
  constructor(e = new Ee(), t = new Ee(), r = new Ee(), n = new Ee()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class yC extends ds {
  constructor(e = new G(), t = new G(), r = new G(), n = new G()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new G()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y),
      Ko(e, n.z, s.z, o.z, i.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class U1 extends ds {
  constructor(e = new Ee(), t = new Ee()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ee()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ee()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class vC extends ds {
  constructor(e = new G(), t = new G()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new G()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new G()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class z1 extends ds {
  constructor(e = new Ee(), t = new Ee(), r = new Ee()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class B1 extends ds {
  constructor(e = new G(), t = new G(), r = new G()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new G()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y),
      Yo(e, n.z, s.z, o.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class k1 extends ds {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.points, s = (n.length - 1) * e, o = Math.floor(s), i = s - o, a = n[o === 0 ? o : o - 1], l = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return r.set(
      Kp(i, a.x, l.x, u.x, h.x),
      Kp(i, a.y, l.y, u.y, h.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new Ee().fromArray(n));
    }
    return this;
  }
}
const Wa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: cC,
  CatmullRomCurve3: lC,
  CubicBezierCurve: D1,
  CubicBezierCurve3: yC,
  EllipseCurve: Hd,
  LineCurve: U1,
  LineCurve3: vC,
  QuadraticBezierCurve: z1,
  QuadraticBezierCurve3: B1,
  SplineCurve: k1
}, Symbol.toStringTag, { value: "Module" }));
class xC extends ds {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Wa[r](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= r) {
        const o = n[s] - r, i = this.curves[s], a = i.getLength(), l = a === 0 ? 0 : 1 - o / a;
        return i.getPointAt(l, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let n = 0, s = this.curves; n < s.length; n++) {
      const o = s[n], i = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, a = o.getPoints(i);
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        r && r.equals(u) || (t.push(u), r = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(new Wa[n.type]().fromJSON(n));
    }
    return this;
  }
}
class mu extends xC {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ee(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new U1(this.currentPoint.clone(), new Ee(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, n) {
    const s = new z1(
      this.currentPoint.clone(),
      new Ee(e, t),
      new Ee(r, n)
    );
    return this.curves.push(s), this.currentPoint.set(r, n), this;
  }
  bezierCurveTo(e, t, r, n, s, o) {
    const i = new D1(
      this.currentPoint.clone(),
      new Ee(e, t),
      new Ee(r, n),
      new Ee(s, o)
    );
    return this.curves.push(i), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new k1(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, n, s, o) {
    const i = this.currentPoint.x, a = this.currentPoint.y;
    return this.absarc(
      e + i,
      t + a,
      r,
      n,
      s,
      o
    ), this;
  }
  absarc(e, t, r, n, s, o) {
    return this.absellipse(e, t, r, r, n, s, o), this;
  }
  ellipse(e, t, r, n, s, o, i, a) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, t + u, r, n, s, o, i, a), this;
  }
  absellipse(e, t, r, n, s, o, i, a) {
    const l = new Hd(e, t, r, n, s, o, i, a);
    if (this.curves.length > 0) {
      const h = l.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Cc extends qt {
  constructor(e = [new Ee(0, -0.5), new Ee(0.5, 0), new Ee(0, 0.5)], t = 12, r = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: n
    }, t = Math.floor(t), n = Un(n, 0, Math.PI * 2);
    const s = [], o = [], i = [], a = [], l = [], u = 1 / t, h = new G(), d = new Ee(), f = new G(), p = new G(), m = new G();
    let g = 0, b = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          g = e[x + 1].x - e[x].x, b = e[x + 1].y - e[x].y, f.x = b * 1, f.y = -g, f.z = b * 0, m.copy(f), f.normalize(), a.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          a.push(m.x, m.y, m.z);
          break;
        default:
          g = e[x + 1].x - e[x].x, b = e[x + 1].y - e[x].y, f.x = b * 1, f.y = -g, f.z = b * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), a.push(f.x, f.y, f.z), m.copy(p);
      }
    for (let x = 0; x <= t; x++) {
      const y = r + x * u * n, v = Math.sin(y), N = Math.cos(y);
      for (let w = 0; w <= e.length - 1; w++) {
        h.x = e[w].x * v, h.y = e[w].y, h.z = e[w].x * N, o.push(h.x, h.y, h.z), d.x = x / t, d.y = w / (e.length - 1), i.push(d.x, d.y);
        const T = a[3 * w + 0] * v, S = a[3 * w + 1], A = a[3 * w + 0] * N;
        l.push(T, S, A);
      }
    }
    for (let x = 0; x < t; x++)
      for (let y = 0; y < e.length - 1; y++) {
        const v = y + x * e.length, N = v, w = v + e.length, T = v + e.length + 1, S = v + 1;
        s.push(N, w, S), s.push(T, S, w);
      }
    this.setIndex(s), this.setAttribute("position", new $e(o, 3)), this.setAttribute("uv", new $e(i, 2)), this.setAttribute("normal", new $e(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cc(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class $d extends Cc {
  constructor(e = 1, t = 1, r = 4, n = 8) {
    const s = new mu();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new $d(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class qd extends qt {
  constructor(e = 1, t = 32, r = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: n
    }, t = Math.max(3, t);
    const s = [], o = [], i = [], a = [], l = new G(), u = new Ee();
    o.push(0, 0, 0), i.push(0, 0, 1), a.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = r + h / t * n;
      l.x = e * Math.cos(f), l.y = e * Math.sin(f), o.push(l.x, l.y, l.z), i.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, a.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      s.push(h, h + 1, 0);
    this.setIndex(s), this.setAttribute("position", new $e(o, 3)), this.setAttribute("normal", new $e(i, 3)), this.setAttribute("uv", new $e(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new qd(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ec extends qt {
  constructor(e = 1, t = 1, r = 1, n = 32, s = 1, o = !1, i = 0, a = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: n,
      heightSegments: s,
      openEnded: o,
      thetaStart: i,
      thetaLength: a
    };
    const l = this;
    n = Math.floor(n), s = Math.floor(s);
    const u = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], g = r / 2;
    let b = 0;
    x(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new $e(h, 3)), this.setAttribute("normal", new $e(d, 3)), this.setAttribute("uv", new $e(f, 2));
    function x() {
      const v = new G(), N = new G();
      let w = 0;
      const T = (t - e) / r;
      for (let S = 0; S <= s; S++) {
        const A = [], R = S / s, O = R * (t - e) + e;
        for (let _ = 0; _ <= n; _++) {
          const L = _ / n, E = L * a + i, D = Math.sin(E), F = Math.cos(E);
          N.x = O * D, N.y = -R * r + g, N.z = O * F, h.push(N.x, N.y, N.z), v.set(D, T, F).normalize(), d.push(v.x, v.y, v.z), f.push(L, 1 - R), A.push(p++);
        }
        m.push(A);
      }
      for (let S = 0; S < n; S++)
        for (let A = 0; A < s; A++) {
          const R = m[A][S], O = m[A + 1][S], _ = m[A + 1][S + 1], L = m[A][S + 1];
          u.push(R, O, L), u.push(O, _, L), w += 6;
        }
      l.addGroup(b, w, 0), b += w;
    }
    function y(v) {
      const N = p, w = new Ee(), T = new G();
      let S = 0;
      const A = v === !0 ? e : t, R = v === !0 ? 1 : -1;
      for (let _ = 1; _ <= n; _++)
        h.push(0, g * R, 0), d.push(0, R, 0), f.push(0.5, 0.5), p++;
      const O = p;
      for (let _ = 0; _ <= n; _++) {
        const E = _ / n * a + i, D = Math.cos(E), F = Math.sin(E);
        T.x = A * F, T.y = g * R, T.z = A * D, h.push(T.x, T.y, T.z), d.push(0, R, 0), w.x = D * 0.5 + 0.5, w.y = F * 0.5 * R + 0.5, f.push(w.x, w.y), p++;
      }
      for (let _ = 0; _ < n; _++) {
        const L = N + _, E = O + _;
        v === !0 ? u.push(E, E + 1, L) : u.push(E + 1, E, L), S += 3;
      }
      l.addGroup(b, S, v === !0 ? 1 : 2), b += S;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ec(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Jd extends Ec {
  constructor(e = 1, t = 1, r = 32, n = 1, s = !1, o = 0, i = Math.PI * 2) {
    super(0, e, t, r, n, s, o, i), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: n,
      openEnded: s,
      thetaStart: o,
      thetaLength: i
    };
  }
  static fromJSON(e) {
    return new Jd(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Ar extends qt {
  constructor(e = [], t = [], r = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: n
    };
    const s = [], o = [];
    i(n), l(r), u(), this.setAttribute("position", new $e(s, 3)), this.setAttribute("normal", new $e(s.slice(), 3)), this.setAttribute("uv", new $e(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function i(x) {
      const y = new G(), v = new G(), N = new G();
      for (let w = 0; w < t.length; w += 3)
        f(t[w + 0], y), f(t[w + 1], v), f(t[w + 2], N), a(y, v, N, x);
    }
    function a(x, y, v, N) {
      const w = N + 1, T = [];
      for (let S = 0; S <= w; S++) {
        T[S] = [];
        const A = x.clone().lerp(v, S / w), R = y.clone().lerp(v, S / w), O = w - S;
        for (let _ = 0; _ <= O; _++)
          _ === 0 && S === w ? T[S][_] = A : T[S][_] = A.clone().lerp(R, _ / O);
      }
      for (let S = 0; S < w; S++)
        for (let A = 0; A < 2 * (w - S) - 1; A++) {
          const R = Math.floor(A / 2);
          A % 2 === 0 ? (d(T[S][R + 1]), d(T[S + 1][R]), d(T[S][R])) : (d(T[S][R + 1]), d(T[S + 1][R + 1]), d(T[S + 1][R]));
        }
    }
    function l(x) {
      const y = new G();
      for (let v = 0; v < s.length; v += 3)
        y.x = s[v + 0], y.y = s[v + 1], y.z = s[v + 2], y.normalize().multiplyScalar(x), s[v + 0] = y.x, s[v + 1] = y.y, s[v + 2] = y.z;
    }
    function u() {
      const x = new G();
      for (let y = 0; y < s.length; y += 3) {
        x.x = s[y + 0], x.y = s[y + 1], x.z = s[y + 2];
        const v = g(x) / 2 / Math.PI + 0.5, N = b(x) / Math.PI + 0.5;
        o.push(v, 1 - N);
      }
      p(), h();
    }
    function h() {
      for (let x = 0; x < o.length; x += 6) {
        const y = o[x + 0], v = o[x + 2], N = o[x + 4], w = Math.max(y, v, N), T = Math.min(y, v, N);
        w > 0.9 && T < 0.1 && (y < 0.2 && (o[x + 0] += 1), v < 0.2 && (o[x + 2] += 1), N < 0.2 && (o[x + 4] += 1));
      }
    }
    function d(x) {
      s.push(x.x, x.y, x.z);
    }
    function f(x, y) {
      const v = x * 3;
      y.x = e[v + 0], y.y = e[v + 1], y.z = e[v + 2];
    }
    function p() {
      const x = new G(), y = new G(), v = new G(), N = new G(), w = new Ee(), T = new Ee(), S = new Ee();
      for (let A = 0, R = 0; A < s.length; A += 9, R += 6) {
        x.set(s[A + 0], s[A + 1], s[A + 2]), y.set(s[A + 3], s[A + 4], s[A + 5]), v.set(s[A + 6], s[A + 7], s[A + 8]), w.set(o[R + 0], o[R + 1]), T.set(o[R + 2], o[R + 3]), S.set(o[R + 4], o[R + 5]), N.copy(x).add(y).add(v).divideScalar(3);
        const O = g(N);
        m(w, R + 0, x, O), m(T, R + 2, y, O), m(S, R + 4, v, O);
      }
    }
    function m(x, y, v, N) {
      N < 0 && x.x === 1 && (o[y] = x.x - 1), v.x === 0 && v.z === 0 && (o[y] = N / 2 / Math.PI + 0.5);
    }
    function g(x) {
      return Math.atan2(x.z, -x.x);
    }
    function b(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ar(e.vertices, e.indices, e.radius, e.details);
  }
}
class Yd extends Ar {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = 1 / r, s = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      // (±1/φ, ±φ, 0)
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      0,
      // (±φ, 0, ±1/φ)
      -r,
      0,
      -n,
      r,
      0,
      -n,
      -r,
      0,
      n,
      r,
      0,
      n
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Yd(e.radius, e.detail);
  }
}
const qn = /* @__PURE__ */ new G(), ys = /* @__PURE__ */ new G(), Ol = /* @__PURE__ */ new G(), vs = /* @__PURE__ */ new G(), jr = /* @__PURE__ */ new G(), Wr = /* @__PURE__ */ new G(), Zp = /* @__PURE__ */ new G(), Il = /* @__PURE__ */ new G(), Pl = /* @__PURE__ */ new G(), Dl = /* @__PURE__ */ new G();
let aa = !1;
class ks {
  constructor(e = new G(), t = new G(), r = new G()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, n) {
    n.subVectors(r, t), qn.subVectors(e, t), n.cross(qn);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, n, s) {
    qn.subVectors(n, t), ys.subVectors(r, t), Ol.subVectors(e, t);
    const o = qn.dot(qn), i = qn.dot(ys), a = qn.dot(Ol), l = ys.dot(ys), u = ys.dot(Ol), h = o * l - i * i;
    if (h === 0)
      return s.set(-2, -1, -1);
    const d = 1 / h, f = (l * a - i * u) * d, p = (o * u - i * a) * d;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, r, n) {
    return this.getBarycoord(e, t, r, n, vs), vs.x >= 0 && vs.y >= 0 && vs.x + vs.y <= 1;
  }
  static getUV(e, t, r, n, s, o, i, a) {
    return aa === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), aa = !0), this.getInterpolation(e, t, r, n, s, o, i, a);
  }
  static getInterpolation(e, t, r, n, s, o, i, a) {
    return this.getBarycoord(e, t, r, n, vs), a.setScalar(0), a.addScaledVector(s, vs.x), a.addScaledVector(o, vs.y), a.addScaledVector(i, vs.z), a;
  }
  static isFrontFacing(e, t, r, n) {
    return qn.subVectors(r, t), ys.subVectors(e, t), qn.cross(ys).dot(n) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, r, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return qn.subVectors(this.c, this.b), ys.subVectors(this.a, this.b), qn.cross(ys).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ks.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ks.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, n, s) {
    return aa === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), aa = !0), ks.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  getInterpolation(e, t, r, n, s) {
    return ks.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  containsPoint(e) {
    return ks.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ks.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, n = this.b, s = this.c;
    let o, i;
    jr.subVectors(n, r), Wr.subVectors(s, r), Il.subVectors(e, r);
    const a = jr.dot(Il), l = Wr.dot(Il);
    if (a <= 0 && l <= 0)
      return t.copy(r);
    Pl.subVectors(e, n);
    const u = jr.dot(Pl), h = Wr.dot(Pl);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = a * h - u * l;
    if (d <= 0 && a >= 0 && u <= 0)
      return o = a / (a - u), t.copy(r).addScaledVector(jr, o);
    Dl.subVectors(e, s);
    const f = jr.dot(Dl), p = Wr.dot(Dl);
    if (p >= 0 && f <= p)
      return t.copy(s);
    const m = f * l - a * p;
    if (m <= 0 && l >= 0 && p <= 0)
      return i = l / (l - p), t.copy(r).addScaledVector(Wr, i);
    const g = u * p - f * h;
    if (g <= 0 && h - u >= 0 && f - p >= 0)
      return Zp.subVectors(s, n), i = (h - u) / (h - u + (f - p)), t.copy(n).addScaledVector(Zp, i);
    const b = 1 / (g + m + d);
    return o = m * b, i = d * b, t.copy(r).addScaledVector(jr, o).addScaledVector(Wr, i);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ca = /* @__PURE__ */ new G(), la = /* @__PURE__ */ new G(), Ul = /* @__PURE__ */ new G(), ua = /* @__PURE__ */ new ks();
class bC extends qt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), s = Math.cos(kA * t), o = e.getIndex(), i = e.getAttribute("position"), a = o ? o.count : i.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
      for (let p = 0; p < a; p += 3) {
        o ? (l[0] = o.getX(p), l[1] = o.getX(p + 1), l[2] = o.getX(p + 2)) : (l[0] = p, l[1] = p + 1, l[2] = p + 2);
        const { a: m, b: g, c: b } = ua;
        if (m.fromBufferAttribute(i, l[0]), g.fromBufferAttribute(i, l[1]), b.fromBufferAttribute(i, l[2]), ua.getNormal(Ul), h[0] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, h[1] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, h[2] = `${Math.round(b.x * n)},${Math.round(b.y * n)},${Math.round(b.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let x = 0; x < 3; x++) {
            const y = (x + 1) % 3, v = h[x], N = h[y], w = ua[u[x]], T = ua[u[y]], S = `${v}_${N}`, A = `${N}_${v}`;
            A in d && d[A] ? (Ul.dot(d[A].normal) <= s && (f.push(w.x, w.y, w.z), f.push(T.x, T.y, T.z)), d[A] = null) : S in d || (d[S] = {
              index0: l[x],
              index1: l[y],
              normal: Ul.clone()
            });
          }
      }
      for (const p in d)
        if (d[p]) {
          const { index0: m, index1: g } = d[p];
          ca.fromBufferAttribute(i, m), la.fromBufferAttribute(i, g), f.push(ca.x, ca.y, ca.z), f.push(la.x, la.y, la.z);
        }
      this.setAttribute("position", new $e(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class G1 extends mu {
  constructor(e) {
    super(e), this.uuid = jd(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(new mu().fromJSON(n));
    }
    return this;
  }
}
const NC = {
  triangulate: function(c, e, t = 2) {
    const r = e && e.length, n = r ? e[0] * t : c.length;
    let s = V1(c, 0, n, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let i, a, l, u, h, d, f;
    if (r && (s = MC(c, e, s, t)), c.length > 80 * t) {
      i = l = c[0], a = u = c[1];
      for (let p = t; p < n; p += t)
        h = c[p], d = c[p + 1], h < i && (i = h), d < a && (a = d), h > l && (l = h), d > u && (u = d);
      f = Math.max(l - i, u - a), f = f !== 0 ? 32767 / f : 0;
    }
    return hi(s, o, t, i, a, f, 0), o;
  }
};
function V1(c, e, t, r, n) {
  let s, o;
  if (n === UC(c, e, t, r) > 0)
    for (s = e; s < t; s += r)
      o = Qp(s, c[s], c[s + 1], o);
  else
    for (s = t - r; s >= e; s -= r)
      o = Qp(s, c[s], c[s + 1], o);
  return o && Rc(o, o.next) && (fi(o), o = o.next), o;
}
function wr(c, e) {
  if (!c)
    return c;
  e || (e = c);
  let t = c, r;
  do
    if (r = !1, !t.steiner && (Rc(t, t.next) || vt(t.prev, t, t.next) === 0)) {
      if (fi(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function hi(c, e, t, r, n, s, o) {
  if (!c)
    return;
  !o && s && LC(c, r, n, s);
  let i = c, a, l;
  for (; c.prev !== c.next; ) {
    if (a = c.prev, l = c.next, s ? TC(c, r, n, s) : wC(c)) {
      e.push(a.i / t | 0), e.push(c.i / t | 0), e.push(l.i / t | 0), fi(c), c = l.next, i = l.next;
      continue;
    }
    if (c = l, c === i) {
      o ? o === 1 ? (c = SC(wr(c), e, t), hi(c, e, t, r, n, s, 2)) : o === 2 && _C(c, e, t, r, n, s) : hi(wr(c), e, t, r, n, s, 1);
      break;
    }
  }
}
function wC(c) {
  const e = c.prev, t = c, r = c.next;
  if (vt(e, t, r) >= 0)
    return !1;
  const n = e.x, s = t.x, o = r.x, i = e.y, a = t.y, l = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, h = i < a ? i < l ? i : l : a < l ? a : l, d = n > s ? n > o ? n : o : s > o ? s : o, f = i > a ? i > l ? i : l : a > l ? a : l;
  let p = r.next;
  for (; p !== e; ) {
    if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && eo(n, i, s, a, o, l, p.x, p.y) && vt(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function TC(c, e, t, r) {
  const n = c.prev, s = c, o = c.next;
  if (vt(n, s, o) >= 0)
    return !1;
  const i = n.x, a = s.x, l = o.x, u = n.y, h = s.y, d = o.y, f = i < a ? i < l ? i : l : a < l ? a : l, p = u < h ? u < d ? u : d : h < d ? h : d, m = i > a ? i > l ? i : l : a > l ? a : l, g = u > h ? u > d ? u : d : h > d ? h : d, b = gu(f, p, e, t, r), x = gu(m, g, e, t, r);
  let y = c.prevZ, v = c.nextZ;
  for (; y && y.z >= b && v && v.z <= x; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && eo(i, u, a, h, l, d, y.x, y.y) && vt(y.prev, y, y.next) >= 0 || (y = y.prevZ, v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && eo(i, u, a, h, l, d, v.x, v.y) && vt(v.prev, v, v.next) >= 0))
      return !1;
    v = v.nextZ;
  }
  for (; y && y.z >= b; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && eo(i, u, a, h, l, d, y.x, y.y) && vt(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; v && v.z <= x; ) {
    if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && eo(i, u, a, h, l, d, v.x, v.y) && vt(v.prev, v, v.next) >= 0)
      return !1;
    v = v.nextZ;
  }
  return !0;
}
function SC(c, e, t) {
  let r = c;
  do {
    const n = r.prev, s = r.next.next;
    !Rc(n, s) && j1(n, r, r.next, s) && di(n, s) && di(s, n) && (e.push(n.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), fi(r), fi(r.next), r = c = s), r = r.next;
  } while (r !== c);
  return wr(r);
}
function _C(c, e, t, r, n, s) {
  let o = c;
  do {
    let i = o.next.next;
    for (; i !== o.prev; ) {
      if (o.i !== i.i && IC(o, i)) {
        let a = W1(o, i);
        o = wr(o, o.next), a = wr(a, a.next), hi(o, e, t, r, n, s, 0), hi(a, e, t, r, n, s, 0);
        return;
      }
      i = i.next;
    }
    o = o.next;
  } while (o !== c);
}
function MC(c, e, t, r) {
  const n = [];
  let s, o, i, a, l;
  for (s = 0, o = e.length; s < o; s++)
    i = e[s] * r, a = s < o - 1 ? e[s + 1] * r : c.length, l = V1(c, i, a, r, !1), l === l.next && (l.steiner = !0), n.push(OC(l));
  for (n.sort(AC), s = 0; s < n.length; s++)
    t = CC(n[s], t);
  return t;
}
function AC(c, e) {
  return c.x - e.x;
}
function CC(c, e) {
  const t = EC(c, e);
  if (!t)
    return e;
  const r = W1(t, c);
  return wr(r, r.next), wr(t, t.next);
}
function EC(c, e) {
  let t = e, r = -1 / 0, n;
  const s = c.x, o = c.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= s && d > r && (r = d, n = t.x < t.next.x ? t : t.next, d === s))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n)
    return null;
  const i = n, a = n.x, l = n.y;
  let u = 1 / 0, h;
  t = n;
  do
    s >= t.x && t.x >= a && s !== t.x && eo(o < l ? s : r, o, a, l, o < l ? r : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), di(t, c) && (h < u || h === u && (t.x > n.x || t.x === n.x && RC(n, t))) && (n = t, u = h)), t = t.next;
  while (t !== i);
  return n;
}
function RC(c, e) {
  return vt(c.prev, c, e.prev) < 0 && vt(e.next, c, c.next) < 0;
}
function LC(c, e, t, r) {
  let n = c;
  do
    n.z === 0 && (n.z = gu(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== c);
  n.prevZ.nextZ = null, n.prevZ = null, FC(n);
}
function FC(c) {
  let e, t, r, n, s, o, i, a, l = 1;
  do {
    for (t = c, c = null, s = null, o = 0; t; ) {
      for (o++, r = t, i = 0, e = 0; e < l && (i++, r = r.nextZ, !!r); e++)
        ;
      for (a = l; i > 0 || a > 0 && r; )
        i !== 0 && (a === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, i--) : (n = r, r = r.nextZ, a--), s ? s.nextZ = n : c = n, n.prevZ = s, s = n;
      t = r;
    }
    s.nextZ = null, l *= 2;
  } while (o > 1);
  return c;
}
function gu(c, e, t, r, n) {
  return c = (c - t) * n | 0, e = (e - r) * n | 0, c = (c | c << 8) & 16711935, c = (c | c << 4) & 252645135, c = (c | c << 2) & 858993459, c = (c | c << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, c | e << 1;
}
function OC(c) {
  let e = c, t = c;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== c);
  return t;
}
function eo(c, e, t, r, n, s, o, i) {
  return (n - o) * (e - i) >= (c - o) * (s - i) && (c - o) * (r - i) >= (t - o) * (e - i) && (t - o) * (s - i) >= (n - o) * (r - i);
}
function IC(c, e) {
  return c.next.i !== e.i && c.prev.i !== e.i && !PC(c, e) && // dones't intersect other edges
  (di(c, e) && di(e, c) && DC(c, e) && // locally visible
  (vt(c.prev, c, e.prev) || vt(c, e.prev, e)) || // does not create opposite-facing sectors
  Rc(c, e) && vt(c.prev, c, c.next) > 0 && vt(e.prev, e, e.next) > 0);
}
function vt(c, e, t) {
  return (e.y - c.y) * (t.x - e.x) - (e.x - c.x) * (t.y - e.y);
}
function Rc(c, e) {
  return c.x === e.x && c.y === e.y;
}
function j1(c, e, t, r) {
  const n = da(vt(c, e, t)), s = da(vt(c, e, r)), o = da(vt(t, r, c)), i = da(vt(t, r, e));
  return !!(n !== s && o !== i || n === 0 && ha(c, t, e) || s === 0 && ha(c, r, e) || o === 0 && ha(t, c, r) || i === 0 && ha(t, e, r));
}
function ha(c, e, t) {
  return e.x <= Math.max(c.x, t.x) && e.x >= Math.min(c.x, t.x) && e.y <= Math.max(c.y, t.y) && e.y >= Math.min(c.y, t.y);
}
function da(c) {
  return c > 0 ? 1 : c < 0 ? -1 : 0;
}
function PC(c, e) {
  let t = c;
  do {
    if (t.i !== c.i && t.next.i !== c.i && t.i !== e.i && t.next.i !== e.i && j1(t, t.next, c, e))
      return !0;
    t = t.next;
  } while (t !== c);
  return !1;
}
function di(c, e) {
  return vt(c.prev, c, c.next) < 0 ? vt(c, e, c.next) >= 0 && vt(c, c.prev, e) >= 0 : vt(c, e, c.prev) < 0 || vt(c, c.next, e) < 0;
}
function DC(c, e) {
  let t = c, r = !1;
  const n = (c.x + e.x) / 2, s = (c.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== c);
  return r;
}
function W1(c, e) {
  const t = new yu(c.i, c.x, c.y), r = new yu(e.i, e.x, e.y), n = c.next, s = e.prev;
  return c.next = e, e.prev = c, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function Qp(c, e, t, r) {
  const n = new yu(c, e, t);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function fi(c) {
  c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
}
function yu(c, e, t) {
  this.i = c, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function UC(c, e, t, r) {
  let n = 0;
  for (let s = e, o = t - r; s < t; s += r)
    n += (c[o] - c[s]) * (c[s + 1] + c[o + 1]), o = s;
  return n;
}
class qs {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let n = t - 1, s = 0; s < t; n = s++)
      r += e[n].x * e[s].y - e[s].x * e[n].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return qs.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], n = [], s = [];
    em(e), tm(r, e);
    let o = e.length;
    t.forEach(em);
    for (let a = 0; a < t.length; a++)
      n.push(o), o += t[a].length, tm(r, t[a]);
    const i = NC.triangulate(r, n);
    for (let a = 0; a < i.length; a += 3)
      s.push(i.slice(a, a + 3));
    return s;
  }
}
function em(c) {
  const e = c.length;
  e > 2 && c[e - 1].equals(c[0]) && c.pop();
}
function tm(c, e) {
  for (let t = 0; t < e.length; t++)
    c.push(e[t].x), c.push(e[t].y);
}
class Kd extends qt {
  constructor(e = new G1([new Ee(0.5, 0.5), new Ee(-0.5, 0.5), new Ee(-0.5, -0.5), new Ee(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, n = [], s = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i];
      o(l);
    }
    this.setAttribute("position", new $e(n, 3)), this.setAttribute("uv", new $e(s, 2)), this.computeVertexNormals();
    function o(i) {
      const a = [], l = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, p = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const b = t.extrudePath, x = t.UVGenerator !== void 0 ? t.UVGenerator : zC;
      let y, v = !1, N, w, T, S;
      b && (y = b.getSpacedPoints(u), v = !0, d = !1, N = b.computeFrenetFrames(u, !1), w = new G(), T = new G(), S = new G()), d || (g = 0, f = 0, p = 0, m = 0);
      const A = i.extractPoints(l);
      let R = A.shape;
      const O = A.holes;
      if (!qs.isClockWise(R)) {
        R = R.reverse();
        for (let I = 0, ne = O.length; I < ne; I++) {
          const Z = O[I];
          qs.isClockWise(Z) && (O[I] = Z.reverse());
        }
      }
      const L = qs.triangulateShape(R, O), E = R;
      for (let I = 0, ne = O.length; I < ne; I++) {
        const Z = O[I];
        R = R.concat(Z);
      }
      function D(I, ne, Z) {
        return ne || console.error("THREE.ExtrudeGeometry: vec does not exist"), I.clone().addScaledVector(ne, Z);
      }
      const F = R.length, H = L.length;
      function q(I, ne, Z) {
        let Q, ee, xe;
        const te = I.x - ne.x, de = I.y - ne.y, re = Z.x - I.x, K = Z.y - I.y, Ce = te * te + de * de, fe = te * K - de * re;
        if (Math.abs(fe) > Number.EPSILON) {
          const me = Math.sqrt(Ce), ye = Math.sqrt(re * re + K * K), ae = ne.x - de / me, Fe = ne.y + te / me, he = Z.x - K / ye, pe = Z.y + re / ye, Ie = ((he - ae) * K - (pe - Fe) * re) / (te * K - de * re);
          Q = ae + te * Ie - I.x, ee = Fe + de * Ie - I.y;
          const Ge = Q * Q + ee * ee;
          if (Ge <= 2)
            return new Ee(Q, ee);
          xe = Math.sqrt(Ge / 2);
        } else {
          let me = !1;
          te > Number.EPSILON ? re > Number.EPSILON && (me = !0) : te < -Number.EPSILON ? re < -Number.EPSILON && (me = !0) : Math.sign(de) === Math.sign(K) && (me = !0), me ? (Q = -de, ee = te, xe = Math.sqrt(Ce)) : (Q = te, ee = de, xe = Math.sqrt(Ce / 2));
        }
        return new Ee(Q / xe, ee / xe);
      }
      const U = [];
      for (let I = 0, ne = E.length, Z = ne - 1, Q = I + 1; I < ne; I++, Z++, Q++)
        Z === ne && (Z = 0), Q === ne && (Q = 0), U[I] = q(E[I], E[Z], E[Q]);
      const k = [];
      let C, P = U.concat();
      for (let I = 0, ne = O.length; I < ne; I++) {
        const Z = O[I];
        C = [];
        for (let Q = 0, ee = Z.length, xe = ee - 1, te = Q + 1; Q < ee; Q++, xe++, te++)
          xe === ee && (xe = 0), te === ee && (te = 0), C[Q] = q(Z[Q], Z[xe], Z[te]);
        k.push(C), P = P.concat(C);
      }
      for (let I = 0; I < g; I++) {
        const ne = I / g, Z = f * Math.cos(ne * Math.PI / 2), Q = p * Math.sin(ne * Math.PI / 2) + m;
        for (let ee = 0, xe = E.length; ee < xe; ee++) {
          const te = D(E[ee], U[ee], Q);
          J(te.x, te.y, -Z);
        }
        for (let ee = 0, xe = O.length; ee < xe; ee++) {
          const te = O[ee];
          C = k[ee];
          for (let de = 0, re = te.length; de < re; de++) {
            const K = D(te[de], C[de], Q);
            J(K.x, K.y, -Z);
          }
        }
      }
      const X = p + m;
      for (let I = 0; I < F; I++) {
        const ne = d ? D(R[I], P[I], X) : R[I];
        v ? (T.copy(N.normals[0]).multiplyScalar(ne.x), w.copy(N.binormals[0]).multiplyScalar(ne.y), S.copy(y[0]).add(T).add(w), J(S.x, S.y, S.z)) : J(ne.x, ne.y, 0);
      }
      for (let I = 1; I <= u; I++)
        for (let ne = 0; ne < F; ne++) {
          const Z = d ? D(R[ne], P[ne], X) : R[ne];
          v ? (T.copy(N.normals[I]).multiplyScalar(Z.x), w.copy(N.binormals[I]).multiplyScalar(Z.y), S.copy(y[I]).add(T).add(w), J(S.x, S.y, S.z)) : J(Z.x, Z.y, h / u * I);
        }
      for (let I = g - 1; I >= 0; I--) {
        const ne = I / g, Z = f * Math.cos(ne * Math.PI / 2), Q = p * Math.sin(ne * Math.PI / 2) + m;
        for (let ee = 0, xe = E.length; ee < xe; ee++) {
          const te = D(E[ee], U[ee], Q);
          J(te.x, te.y, h + Z);
        }
        for (let ee = 0, xe = O.length; ee < xe; ee++) {
          const te = O[ee];
          C = k[ee];
          for (let de = 0, re = te.length; de < re; de++) {
            const K = D(te[de], C[de], Q);
            v ? J(K.x, K.y + y[u - 1].y, y[u - 1].x + Z) : J(K.x, K.y, h + Z);
          }
        }
      }
      Y(), W();
      function Y() {
        const I = n.length / 3;
        if (d) {
          let ne = 0, Z = F * ne;
          for (let Q = 0; Q < H; Q++) {
            const ee = L[Q];
            se(ee[2] + Z, ee[1] + Z, ee[0] + Z);
          }
          ne = u + g * 2, Z = F * ne;
          for (let Q = 0; Q < H; Q++) {
            const ee = L[Q];
            se(ee[0] + Z, ee[1] + Z, ee[2] + Z);
          }
        } else {
          for (let ne = 0; ne < H; ne++) {
            const Z = L[ne];
            se(Z[2], Z[1], Z[0]);
          }
          for (let ne = 0; ne < H; ne++) {
            const Z = L[ne];
            se(Z[0] + F * u, Z[1] + F * u, Z[2] + F * u);
          }
        }
        r.addGroup(I, n.length / 3 - I, 0);
      }
      function W() {
        const I = n.length / 3;
        let ne = 0;
        ie(E, ne), ne += E.length;
        for (let Z = 0, Q = O.length; Z < Q; Z++) {
          const ee = O[Z];
          ie(ee, ne), ne += ee.length;
        }
        r.addGroup(I, n.length / 3 - I, 1);
      }
      function ie(I, ne) {
        let Z = I.length;
        for (; --Z >= 0; ) {
          const Q = Z;
          let ee = Z - 1;
          ee < 0 && (ee = I.length - 1);
          for (let xe = 0, te = u + g * 2; xe < te; xe++) {
            const de = F * xe, re = F * (xe + 1), K = ne + Q + de, Ce = ne + ee + de, fe = ne + ee + re, me = ne + Q + re;
            ue(K, Ce, fe, me);
          }
        }
      }
      function J(I, ne, Z) {
        a.push(I), a.push(ne), a.push(Z);
      }
      function se(I, ne, Z) {
        le(I), le(ne), le(Z);
        const Q = n.length / 3, ee = x.generateTopUV(r, n, Q - 3, Q - 2, Q - 1);
        $(ee[0]), $(ee[1]), $(ee[2]);
      }
      function ue(I, ne, Z, Q) {
        le(I), le(ne), le(Q), le(ne), le(Z), le(Q);
        const ee = n.length / 3, xe = x.generateSideWallUV(r, n, ee - 6, ee - 3, ee - 2, ee - 1);
        $(xe[0]), $(xe[1]), $(xe[3]), $(xe[1]), $(xe[2]), $(xe[3]);
      }
      function le(I) {
        n.push(a[I * 3 + 0]), n.push(a[I * 3 + 1]), n.push(a[I * 3 + 2]);
      }
      function $(I) {
        s.push(I.x), s.push(I.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return BC(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const i = t[e.shapes[s]];
      r.push(i);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Wa[n.type]().fromJSON(n)), new Kd(r, e.options);
  }
}
const zC = {
  generateTopUV: function(c, e, t, r, n) {
    const s = e[t * 3], o = e[t * 3 + 1], i = e[r * 3], a = e[r * 3 + 1], l = e[n * 3], u = e[n * 3 + 1];
    return [
      new Ee(s, o),
      new Ee(i, a),
      new Ee(l, u)
    ];
  },
  generateSideWallUV: function(c, e, t, r, n, s) {
    const o = e[t * 3], i = e[t * 3 + 1], a = e[t * 3 + 2], l = e[r * 3], u = e[r * 3 + 1], h = e[r * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], p = e[n * 3 + 2], m = e[s * 3], g = e[s * 3 + 1], b = e[s * 3 + 2];
    return Math.abs(i - u) < Math.abs(o - l) ? [
      new Ee(o, 1 - a),
      new Ee(l, 1 - h),
      new Ee(d, 1 - p),
      new Ee(m, 1 - b)
    ] : [
      new Ee(i, 1 - a),
      new Ee(u, 1 - h),
      new Ee(f, 1 - p),
      new Ee(g, 1 - b)
    ];
  }
};
function BC(c, e, t) {
  if (t.shapes = [], Array.isArray(c))
    for (let r = 0, n = c.length; r < n; r++) {
      const s = c[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(c.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Zd extends Ar {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Zd(e.radius, e.detail);
  }
}
class Qd extends Ar {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Qd(e.radius, e.detail);
  }
}
class ef extends qt {
  constructor(e = 1, t = 1, r = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: n
    };
    const s = e / 2, o = t / 2, i = Math.floor(r), a = Math.floor(n), l = i + 1, u = a + 1, h = e / i, d = t / a, f = [], p = [], m = [], g = [];
    for (let b = 0; b < u; b++) {
      const x = b * d - o;
      for (let y = 0; y < l; y++) {
        const v = y * h - s;
        p.push(v, -x, 0), m.push(0, 0, 1), g.push(y / i), g.push(1 - b / a);
      }
    }
    for (let b = 0; b < a; b++)
      for (let x = 0; x < i; x++) {
        const y = x + l * b, v = x + l * (b + 1), N = x + 1 + l * (b + 1), w = x + 1 + l * b;
        f.push(y, v, w), f.push(v, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new $e(p, 3)), this.setAttribute("normal", new $e(m, 3)), this.setAttribute("uv", new $e(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ef(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class tf extends qt {
  constructor(e = 0.5, t = 1, r = 32, n = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: n,
      thetaStart: s,
      thetaLength: o
    }, r = Math.max(3, r), n = Math.max(1, n);
    const i = [], a = [], l = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new G(), p = new Ee();
    for (let m = 0; m <= n; m++) {
      for (let g = 0; g <= r; g++) {
        const b = s + g / r * o;
        f.x = h * Math.cos(b), f.y = h * Math.sin(b), a.push(f.x, f.y, f.z), l.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, u.push(p.x, p.y);
      }
      h += d;
    }
    for (let m = 0; m < n; m++) {
      const g = m * (r + 1);
      for (let b = 0; b < r; b++) {
        const x = b + g, y = x, v = x + r + 1, N = x + r + 2, w = x + 1;
        i.push(y, v, w), i.push(v, N, w);
      }
    }
    this.setIndex(i), this.setAttribute("position", new $e(a, 3)), this.setAttribute("normal", new $e(l, 3)), this.setAttribute("uv", new $e(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new tf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class nf extends qt {
  constructor(e = new G1([new Ee(0, 0.5), new Ee(-0.5, -0.5), new Ee(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], n = [], s = [], o = [];
    let i = 0, a = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(i, a, u), i += a, a = 0;
    this.setIndex(r), this.setAttribute("position", new $e(n, 3)), this.setAttribute("normal", new $e(s, 3)), this.setAttribute("uv", new $e(o, 2));
    function l(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      qs.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, b = p.length; g < b; g++) {
        const x = p[g];
        qs.isClockWise(x) === !0 && (p[g] = x.reverse());
      }
      const m = qs.triangulateShape(f, p);
      for (let g = 0, b = p.length; g < b; g++) {
        const x = p[g];
        f = f.concat(x);
      }
      for (let g = 0, b = f.length; g < b; g++) {
        const x = f[g];
        n.push(x.x, x.y, 0), s.push(0, 0, 1), o.push(x.x, x.y);
      }
      for (let g = 0, b = m.length; g < b; g++) {
        const x = m[g], y = x[0] + h, v = x[1] + h, N = x[2] + h;
        r.push(y, v, N), a += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return kC(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let n = 0, s = e.shapes.length; n < s; n++) {
      const o = t[e.shapes[n]];
      r.push(o);
    }
    return new nf(r, e.curveSegments);
  }
}
function kC(c, e) {
  if (e.shapes = [], Array.isArray(c))
    for (let t = 0, r = c.length; t < r; t++) {
      const n = c[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(c.uuid);
  return e;
}
class sf extends qt {
  constructor(e = 1, t = 32, r = 16, n = 0, s = Math.PI * 2, o = 0, i = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: n,
      phiLength: s,
      thetaStart: o,
      thetaLength: i
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const a = Math.min(o + i, Math.PI);
    let l = 0;
    const u = [], h = new G(), d = new G(), f = [], p = [], m = [], g = [];
    for (let b = 0; b <= r; b++) {
      const x = [], y = b / r;
      let v = 0;
      b === 0 && o === 0 ? v = 0.5 / t : b === r && a === Math.PI && (v = -0.5 / t);
      for (let N = 0; N <= t; N++) {
        const w = N / t;
        h.x = -e * Math.cos(n + w * s) * Math.sin(o + y * i), h.y = e * Math.cos(o + y * i), h.z = e * Math.sin(n + w * s) * Math.sin(o + y * i), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), g.push(w + v, 1 - y), x.push(l++);
      }
      u.push(x);
    }
    for (let b = 0; b < r; b++)
      for (let x = 0; x < t; x++) {
        const y = u[b][x + 1], v = u[b][x], N = u[b + 1][x], w = u[b + 1][x + 1];
        (b !== 0 || o > 0) && f.push(y, v, w), (b !== r - 1 || a < Math.PI) && f.push(v, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new $e(p, 3)), this.setAttribute("normal", new $e(m, 3)), this.setAttribute("uv", new $e(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class rf extends Ar {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new rf(e.radius, e.detail);
  }
}
class of extends qt {
  constructor(e = 1, t = 0.4, r = 12, n = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: n,
      arc: s
    }, r = Math.floor(r), n = Math.floor(n);
    const o = [], i = [], a = [], l = [], u = new G(), h = new G(), d = new G();
    for (let f = 0; f <= r; f++)
      for (let p = 0; p <= n; p++) {
        const m = p / n * s, g = f / r * Math.PI * 2;
        h.x = (e + t * Math.cos(g)) * Math.cos(m), h.y = (e + t * Math.cos(g)) * Math.sin(m), h.z = t * Math.sin(g), i.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), d.subVectors(h, u).normalize(), a.push(d.x, d.y, d.z), l.push(p / n), l.push(f / r);
      }
    for (let f = 1; f <= r; f++)
      for (let p = 1; p <= n; p++) {
        const m = (n + 1) * f + p - 1, g = (n + 1) * (f - 1) + p - 1, b = (n + 1) * (f - 1) + p, x = (n + 1) * f + p;
        o.push(m, g, x), o.push(g, b, x);
      }
    this.setIndex(o), this.setAttribute("position", new $e(i, 3)), this.setAttribute("normal", new $e(a, 3)), this.setAttribute("uv", new $e(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new of(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class af extends qt {
  constructor(e = 1, t = 0.4, r = 64, n = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: n,
      p: s,
      q: o
    }, r = Math.floor(r), n = Math.floor(n);
    const i = [], a = [], l = [], u = [], h = new G(), d = new G(), f = new G(), p = new G(), m = new G(), g = new G(), b = new G();
    for (let y = 0; y <= r; ++y) {
      const v = y / r * s * Math.PI * 2;
      x(v, s, o, e, f), x(v + 0.01, s, o, e, p), g.subVectors(p, f), b.addVectors(p, f), m.crossVectors(g, b), b.crossVectors(m, g), m.normalize(), b.normalize();
      for (let N = 0; N <= n; ++N) {
        const w = N / n * Math.PI * 2, T = -t * Math.cos(w), S = t * Math.sin(w);
        h.x = f.x + (T * b.x + S * m.x), h.y = f.y + (T * b.y + S * m.y), h.z = f.z + (T * b.z + S * m.z), a.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), l.push(d.x, d.y, d.z), u.push(y / r), u.push(N / n);
      }
    }
    for (let y = 1; y <= r; y++)
      for (let v = 1; v <= n; v++) {
        const N = (n + 1) * (y - 1) + (v - 1), w = (n + 1) * y + (v - 1), T = (n + 1) * y + v, S = (n + 1) * (y - 1) + v;
        i.push(N, w, S), i.push(w, T, S);
      }
    this.setIndex(i), this.setAttribute("position", new $e(a, 3)), this.setAttribute("normal", new $e(l, 3)), this.setAttribute("uv", new $e(u, 2));
    function x(y, v, N, w, T) {
      const S = Math.cos(y), A = Math.sin(y), R = N / v * y, O = Math.cos(R);
      T.x = w * (2 + O) * 0.5 * S, T.y = w * (2 + O) * A * 0.5, T.z = w * Math.sin(R) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new af(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class cf extends qt {
  constructor(e = new B1(new G(-1, -1, 0), new G(-1, 1, 0), new G(1, 1, 0)), t = 64, r = 1, n = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: n,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const i = new G(), a = new G(), l = new Ee();
    let u = new G();
    const h = [], d = [], f = [], p = [];
    m(), this.setIndex(p), this.setAttribute("position", new $e(h, 3)), this.setAttribute("normal", new $e(d, 3)), this.setAttribute("uv", new $e(f, 2));
    function m() {
      for (let y = 0; y < t; y++)
        g(y);
      g(s === !1 ? t : 0), x(), b();
    }
    function g(y) {
      u = e.getPointAt(y / t, u);
      const v = o.normals[y], N = o.binormals[y];
      for (let w = 0; w <= n; w++) {
        const T = w / n * Math.PI * 2, S = Math.sin(T), A = -Math.cos(T);
        a.x = A * v.x + S * N.x, a.y = A * v.y + S * N.y, a.z = A * v.z + S * N.z, a.normalize(), d.push(a.x, a.y, a.z), i.x = u.x + r * a.x, i.y = u.y + r * a.y, i.z = u.z + r * a.z, h.push(i.x, i.y, i.z);
      }
    }
    function b() {
      for (let y = 1; y <= t; y++)
        for (let v = 1; v <= n; v++) {
          const N = (n + 1) * (y - 1) + (v - 1), w = (n + 1) * y + (v - 1), T = (n + 1) * y + v, S = (n + 1) * (y - 1) + v;
          p.push(N, w, S), p.push(w, T, S);
        }
    }
    function x() {
      for (let y = 0; y <= t; y++)
        for (let v = 0; v <= n; v++)
          l.x = y / t, l.y = v / n, f.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new cf(
      new Wa[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class GC extends qt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), n = new G(), s = new G();
      if (e.index !== null) {
        const o = e.attributes.position, i = e.index;
        let a = e.groups;
        a.length === 0 && (a = [{ start: 0, count: i.count, materialIndex: 0 }]);
        for (let l = 0, u = a.length; l < u; ++l) {
          const h = a[l], d = h.start, f = h.count;
          for (let p = d, m = d + f; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const b = i.getX(p + g), x = i.getX(p + (g + 1) % 3);
              n.fromBufferAttribute(o, b), s.fromBufferAttribute(o, x), nm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let i = 0, a = o.count / 3; i < a; i++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * i + l, h = 3 * i + (l + 1) % 3;
            n.fromBufferAttribute(o, u), s.fromBufferAttribute(o, h), nm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new $e(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function nm(c, e, t) {
  const r = `${c.x},${c.y},${c.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${c.x},${c.y},${c.z}`;
  return t.has(r) === !0 || t.has(n) === !0 ? !1 : (t.add(r), t.add(n), !0);
}
const sm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BoxGeometry: Wd,
  CapsuleGeometry: $d,
  CircleGeometry: qd,
  ConeGeometry: Jd,
  CylinderGeometry: Ec,
  DodecahedronGeometry: Yd,
  EdgesGeometry: bC,
  ExtrudeGeometry: Kd,
  IcosahedronGeometry: Zd,
  LatheGeometry: Cc,
  OctahedronGeometry: Qd,
  PlaneGeometry: ef,
  PolyhedronGeometry: Ar,
  RingGeometry: tf,
  ShapeGeometry: nf,
  SphereGeometry: sf,
  TetrahedronGeometry: rf,
  TorusGeometry: of,
  TorusKnotGeometry: af,
  TubeGeometry: cf,
  WireframeGeometry: GC
}, Symbol.toStringTag, { value: "Module" }));
class Ha extends vu {
  constructor(t) {
    super();
    B(this, "nodes", []);
    B(this, "isLocked", !1);
    this.object = t, t.graph || (t.graph = this), this.addEventListener("nodeEventOutputChanged", ({ node: r, fields: n }) => {
      for (const s of n)
        this.applyNodePins(r._parentGraphNode, s, "out");
    });
  }
  newGraphNode(t, r) {
    const n = new Proxy({ x: 0, y: 0 }, {
      set: (o, i, a, l) => {
        if (a === Reflect.get(o, i))
          return !0;
        const u = Reflect.set(o, i, a, l);
        return u && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s] }), u;
      }
    }), s = {
      name: r,
      scoped: Sl(t, this),
      anchor: n,
      bounds: {},
      outs: {}
    };
    return t._parentGraphNode = s, s;
  }
  add(t) {
    if (this.nodes.indexOf(t) !== -1)
      throw ke.panic(`Graph Node[${t.scoped.uuid}] aready exists`);
    t.scoped instanceof tn && (t.scoped.eventDispatcher = this), this.nodes.push(t), this.dispatchEvent({ type: "graphAdded", soure: this, nodes: [t] });
  }
  remove(t) {
    const r = this.nodes.indexOf(t);
    if (r === -1)
      return !1;
    this.nodes.splice(r, 1), t.scoped instanceof tn && (t.scoped.eventDispatcher = null);
    for (const n of Object.keys(t.bounds))
      this.disconnect({ node: t, field: n }, !0);
    for (const n of Object.values(t.outs))
      for (const s of [...n])
        this.disconnect({ node: s.node, field: s.field }, !0);
    t.scoped.dispose && t.scoped.dispose(), this.dispatchEvent({ type: "graphRemoved", soure: this, nodes: [t] });
  }
  get(t) {
    return this.nodes.find((r) => r.scoped.uuid === t);
  }
  update(t, r, n, s) {
    for (const o of this.nodes)
      o.scoped.onUpdate && o.scoped.onUpdate(t, r, n, s);
  }
  connect(t, r, n) {
    if (!t.field && t.node.scoped instanceof Dn || !t.field && r.node.scoped instanceof Dn) {
      if (t.node.scoped instanceof Dn != r.node.scoped instanceof Dn) {
        if (n)
          return 0;
        throw ke.panic("not supported");
      }
      if (!(t.node.scoped instanceof Dn) || !(r.node.scoped instanceof Dn)) {
        if (n)
          return 0;
        throw ke.panic("not supported");
      }
      if (t.node.scoped.next === r.node.scoped) {
        if (n)
          return 3;
      } else if (t.node.scoped.next || r.node.scoped.prev) {
        if (n)
          return 0;
        throw ke.panic("not supported");
      }
      return n || (t.node.scoped.next = r.node.scoped, r.node.scoped.prev = t.node.scoped, this.dispatchEvent({ type: "graphModified", soure: this, nodes: [t.node, r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node })), 3;
    }
    if (!r.field) {
      if (n)
        return 0;
      throw ke.panic("not supported");
    }
    const s = r.node.bounds[r.field];
    if (s) {
      if (s.node === t.node && s.field === t.field)
        return s.type;
      if (n)
        return 0;
      throw ke.panic(`field[${r.field}] has been bound`);
    }
    const o = t.node.scoped instanceof tn ? t.node.scoped.objectType : ep(t.node.name), i = ep(r.node.name), { out: a } = t.node.scoped.typesExtended || za(o), { in: l } = r.node.scoped.typesExtended || za(i), u = t.field ? a[t.field] : { types: [o] }, h = r.field ? l[r.field] : { types: [i] };
    if (t.field) {
      if (!KT(u.types, h.types)) {
        if (n)
          return 0;
        throw ke.panic("type mismatched");
      }
    } else if (!QT(o, h.types)) {
      if (n)
        return 0;
      throw ke.panic("type mismatched");
    }
    const f = u.types.findIndex((g) => Tc(g)) !== -1 ? 1 : 2;
    if (n)
      return f;
    r.node.bounds[r.field] = { node: t.node, type: f, field: t.field };
    const p = t.field || "$";
    return (t.node.outs[p] || (t.node.outs[p] = [])).push({ node: r.node, type: f, field: r.field }), this.applyNodeBounds(r.node), this.dispatchEvent({ type: "graphModified", soure: this, nodes: [r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node }), f;
  }
  disconnect(t, r) {
    if (!t.field && t.node.scoped instanceof Dn) {
      if (!t.node.scoped.prev)
        throw ke.panic("state error");
      t.node.scoped.prev.next = void 0, t.node.scoped.prev = void 0;
      return;
    }
    if (!t.field)
      throw ke.panic("not allowed");
    const n = t.node.bounds[t.field];
    if (n === void 0)
      return;
    const s = n.node, o = n.field || "$", i = s.outs[o];
    if (!i)
      throw ke.panic(`bound list not found for node[field=${t.field}]`);
    const a = t.node.scoped, l = i.findIndex((f) => f.node === t.node && f.field === t.field);
    if (l === -1)
      return;
    delete t.node.bounds[t.field], i.splice(l, 1);
    const u = a instanceof tn ? a.getObjectsExtended().in : a, h = u[t.field];
    if (h instanceof Bn)
      u[t.field] = new An();
    else {
      const f = `${t.field}Node`;
      Object.hasOwn(u, f) ? u[f] = null : h && (h.isNode || h.isMaterial) && (u[t.field] = null), u instanceof Bn && (u.needsUpdate = !0, u instanceof ls && (u.uniformsNeedUpdate = !0));
    }
    r || (this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s, t.node] }), this.dispatchEvent({ type: "graphDisconnected", soure: this, from: s, to: t.node }));
  }
  clear() {
    for (const t of this.nodes)
      t.scoped.dispose && t.scoped.dispose();
    this.nodes.length = 0;
  }
  clone(t, r) {
    const n = r.get(this.object);
    if (!n)
      throw ke.panic(`object[${this.object.uuid}] is not found in list being transfered`);
    const s = {};
    for (const i of this.nodes) {
      const a = i.scoped;
      let l;
      const u = {};
      if (a instanceof tn) {
        l = ru(i.name), a.serialize(u), l.deserialize(u), a.object instanceof Gn && (s[a.object.uuid] = a.object);
        const h = a.object[Bt], d = r.get(h);
        d && (s[h.uuid] = d);
      } else
        a.clone ? l = a.clone(!0) : l = ru(i.name, a);
      s[l.uuid] = l, s[a.uuid] = l;
    }
    const o = new Ha(n);
    for (const i of Object.values(this.nodes)) {
      let a = s[i.scoped.uuid];
      a instanceof tn ? (a.fill(t, s), a.eventDispatcher = o) : a[Bt] || (a = Sl(Me(a), o));
      const l = new Proxy({ ...i.anchor }, {
        set: (h, d, f, p) => {
          if (f === Reflect.get(h, d))
            return !0;
          const m = Reflect.set(h, d, f, p);
          return m && o.dispatchEvent({ type: "graphModified", soure: o, nodes: [u] }), m;
        }
      }), u = {
        name: i.name,
        scoped: a,
        anchor: l,
        bounds: {},
        outs: {}
      };
      a._parentGraphNode = u;
      for (const [h, d] of Object.entries(i.bounds)) {
        const { node: f, type: p, field: m } = d, g = s[f.scoped.uuid];
        if (!g)
          throw ke.panic(`node[${f.scoped.uuid}] not found`);
        u.bounds[h] = { type: p, node: g, field: m };
      }
      for (const [h, d] of Object.entries(i.outs || {})) {
        const f = u.outs[h] || (u.outs[h] = []);
        for (const p of d) {
          const { node: m, type: g, field: b } = p, x = s[m.scoped.uuid];
          if (!x)
            throw ke.panic(`node[${m.scoped.uuid}] not found`);
          f.push({ node: x, type: g, field: b });
        }
      }
      o.nodes.push(u);
    }
    for (const i of o.nodes) {
      for (const a of Object.values(i.bounds)) {
        const l = o.nodes.find((u) => u.scoped.uuid === a.node.uuid);
        l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
      }
      for (const a of Object.values(i.outs))
        for (const l of a) {
          const u = o.nodes.find((h) => h.scoped.uuid === l.node.uuid);
          u || console.error(`node[${l.node.uuid}] not found!`), l.node = u;
        }
    }
    for (const i of o.nodes)
      o.applyNodeBounds(i);
    return o;
  }
  serialize(t) {
    const r = {
      isGraph: !0,
      nodes: []
    };
    for (const n of this.nodes) {
      t.nodes[n.scoped.uuid] || (t.nodes[n.scoped.uuid] = n.scoped.toJSON(t));
      const s = {};
      Object.entries(n.outs).forEach(([i, a]) => {
        s[i] = a.map((l) => ({ n: l.node.scoped.uuid, f: l.field, t: l.type }));
      });
      const o = {
        name: n.name,
        node: n.scoped.uuid,
        anchor: { ...n.anchor },
        bounds: Object.fromEntries(Object.entries(n.bounds).map((i) => [i[0], { t: i[1].type, n: i[1].node.scoped.uuid, f: i[1].field }])),
        outs: s
      };
      r.nodes.push(o);
    }
    return r;
  }
  deserialize(t, r, n) {
    if (!t || !t.isGraph)
      return;
    if (!Array.isArray(t.nodes))
      throw ke.panic("not node info found");
    this.clear();
    const s = { ...r, ...n };
    for (const o of t.nodes) {
      let i = r[o.node];
      if (!i)
        throw ke.panic(`node[${o.node}] not found`);
      i instanceof tn ? (i.fill(this.object, s), i.eventDispatcher = this) : i = Sl(Me(i), this);
      const a = new Proxy(o.anchor, {
        set: (u, h, d, f) => {
          if (d === Reflect.get(u, h))
            return !0;
          const p = Reflect.set(u, h, d, f);
          return p && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [l] }), p;
        }
      }), l = {
        name: o.name,
        scoped: i,
        anchor: a,
        bounds: {},
        outs: {}
      };
      i._parentGraphNode = l;
      for (const [u, h] of Object.entries(o.bounds)) {
        const { n: d, t: f, f: p } = h, m = r[d];
        if (!m)
          throw ke.panic(`node[${d}] not found`);
        l.bounds[u] = { type: f, node: m, field: p };
      }
      for (const [u, h] of Object.entries(o.outs || {})) {
        const d = l.outs[u] || (l.outs[u] = []);
        for (const f of h) {
          const { n: p, t: m, f: g } = f, b = r[p];
          if (!b)
            throw ke.panic(`node[${p}] not found`);
          d.push({ node: b, type: m, field: g });
        }
      }
      this.nodes.push(l);
    }
    for (const o of this.nodes) {
      for (const i of Object.values(o.bounds)) {
        const a = this.nodes.find((l) => l.scoped.uuid === i.node.uuid);
        a || console.error(`node[${i.node.uuid}] not found!`), i.node = a;
      }
      for (const i of Object.values(o.outs))
        for (const a of i) {
          const l = this.nodes.find((u) => u.scoped.uuid === a.node.uuid);
          l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
        }
    }
    for (const o of this.nodes)
      this.applyNodeBounds(o);
  }
  applyNodeBounds(t, r) {
    for (const [n, s] of Object.entries(t.bounds)) {
      if (r && !r.includes(n))
        continue;
      const { node: o, type: i, field: a } = s, l = o.outs[a || "$"];
      if (!l)
        throw ke.panic(`bound list not found for node[field=${n}]`);
      if (!l.find((m) => m.node === t && m.field === n))
        throw ke.panic(`bound slot not found for node[field=${n}]`);
      const h = o.scoped instanceof tn ? o.scoped.getObjectsExtended().out : o.scoped;
      let d = a ? h[a] : h;
      const f = t.scoped instanceof tn ? t.scoped.getObjectsExtended().in : t.scoped, p = f[n];
      if (typeof d == "object" && (d = d[Bt] || d), d !== p) {
        if (i === 1) {
          typeof p == "object" && p.dispose && p.dispose(), f[n] = d;
          continue;
        }
        typeof d == "object" ? !p || p === null ? f[n] = d : typeof p.copy == "function" ? p.copy(d) : typeof d.clone == "function" ? f[n] = d.clone() : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d) : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d);
      }
    }
    t.scoped instanceof Bn && (t.scoped.needsUpdate = !0, t.scoped instanceof ls && (t.scoped.uniformsNeedUpdate = !0));
  }
  applyNodePins(t, r, n) {
    if (n === "in")
      t.scoped instanceof Bn ? (t.scoped.needsUpdate = !0, t.scoped instanceof ls && (t.scoped.uniformsNeedUpdate = !0)) : t.scoped instanceof tn && t.scoped.object instanceof Gn && (t.scoped.object.needsUpdate = !0);
    else {
      const s = t.outs[r];
      if (!s)
        return;
      for (const o of s)
        o.type === 1 ? this.applyNodePins(o.node, o.field, "in") : this.applyNodeBounds(o.node, [o.field]);
    }
  }
  addType(t, r, n, s) {
    return r ? /^[a-z][a-z0-9_]*$/i.test(r) ? t.scoped instanceof ui ? (s === "in" ? t.scoped.addInput : t.scoped.addOutput).call(t.scoped, r, n) ? !0 : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: `Failed to create field[${r}] as type[${n}]!` }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "It is not a ScriptNode!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Illegal name!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Empty name!" }), !1);
  }
  removeType(t, r, n) {
    if (!(t.scoped instanceof ui) || !(n === "in" ? t.scoped.removeInput : t.scoped.removeOutput).call(t.scoped, r))
      return !1;
    if (n === "in")
      this.disconnect({ node: t, field: r, io: n });
    else {
      const o = t.outs[r];
      if (o)
        for (const i of [...o])
          this.disconnect({ node: i.node, field: i.field });
    }
    return !0;
  }
}
const { getTypedArray: rm } = iC, { createNodeFromType: VC } = Xv;
class jC extends vr {
  constructor(t) {
    super(t);
    B(this, "_textures");
    B(this, "_listeners", {});
    B(this, "_nodes");
    B(this, "_nodesJSON");
  }
  load(t, r, n, s) {
    const o = this, i = this.path === "" ? ho.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new Js(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(l) {
      let u = null;
      try {
        u = JSON.parse(l);
      } catch (d) {
        s !== void 0 && s(d), console.error("THREE:ObjectLoader: Can't parse " + t + ".", d.message);
        return;
      }
      const h = u.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + t)), console.error("THREE.ObjectLoader: Can't load " + t);
        return;
      }
      o.parse(u, r);
    }, n, s);
  }
  async loadAsync(t, r) {
    const n = this, s = this.path === "" ? ho.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new Js(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const i = await o.loadAsync(t, r), a = JSON.parse(i), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + t);
    return await n.parseAsync(a);
  }
  parse(t, r) {
    this._nodesJSON = t.nodes;
    const n = this.parseAnimations(t.animations), s = this.parseShapes(t.shapes), o = this.parseGeometries(t.geometries, s), i = this.parseImages(t.images, function() {
      r !== void 0 && r(u);
    }), a = this.parseTextures(t.textures, i), l = this.parseMaterials(t.materials, a);
    if (t.listeners)
      for (const d of t.listeners) {
        const f = this.parseObject(d, o, l, a, n);
        this._listeners[f.uuid] = f;
      }
    const u = this.parseObject(t.object, o, l, a, n), h = this.parseSkeletons(t.skeletons, u);
    if (this.bindSkeletons(u, h), r !== void 0) {
      let d = !1;
      for (const f in i)
        if (i[f].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && r(u);
    }
    this._nodesJSON = null, u.traverse((d) => {
      d.userData.graph && new Ha(d).deserialize(d.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const d of Object.values(this._nodes || {}))
      d.fill && d.fill(u, this._nodes || {}, this._textures || {});
    return u;
  }
  async parseAsync(t) {
    this._nodesJSON = t.nodes;
    const r = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes), s = this.parseGeometries(t.geometries, n), o = await this.parseImagesAsync(t.images), i = this.parseTextures(t.textures, o), a = this.parseMaterials(t.materials, i);
    if (t.listeners)
      for (const h of t.listeners) {
        const d = this.parseObject(h, s, a, i, r);
        this._listeners[d.uuid] = d;
      }
    const l = this.parseObject(t.object, s, a, i, r), u = this.parseSkeletons(t.skeletons, l);
    this.bindSkeletons(l, u), this._nodesJSON = null, l.traverse((h) => {
      h.userData.graph && new Ha(h).deserialize(h.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const h of Object.values(this._nodes || {}))
      h.fill && h.fill(l, this._nodes || {}, this._textures || {});
    return l;
  }
  parseShapes(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0, s = t.length; n < s; n++) {
        const o = new vo().fromJSON(t[n]);
        r[o.uuid] = o;
      }
    return r;
  }
  parseSkeletons(t, r) {
    const n = {}, s = {};
    if (r.traverse(function(o) {
      o.isBone && (s[o.uuid] = o);
    }), t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = new Mu();
        a.fromJSON(t[o], s), n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(t, r) {
    const n = {};
    if (t !== void 0) {
      const s = new qx();
      for (let o = 0, i = t.length; o < i; o++) {
        let a;
        const l = t[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = s.parse(l);
            break;
          default:
            l.type in sm ? a = sm[l.type].fromJSON(l, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(t, r) {
    const n = {};
    if (this._textures = r, t !== void 0) {
      const s = this.parseNodes(this._nodesJSON, r);
      this._nodes = s;
      const o = new Da();
      o.setTextures(r), o.setNodes(s);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = s[l.uuid];
        u ? n[l.uuid] = u : n[l.uuid] = o.parse(l);
      }
    } else
      this._nodesJSON && (this._nodes = this.parseNodes(this._nodesJSON, r));
    return n;
  }
  parseAnimations(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0; n < t.length; n++) {
        const s = t[n], o = Au.parse(s);
        r[o.uuid] = o;
      }
    return r;
  }
  parseImages(t, r) {
    const n = this, s = {};
    let o;
    function i(l) {
      return n.manager.itemStart(l), o.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
        return i(h);
      } else
        return l.data ? {
          data: rm(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      const l = new Jx(r);
      o = new Df(l), o.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = t.length; u < h; u++) {
        const d = t[u], f = d.url;
        if (Array.isArray(f)) {
          const p = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const b = f[m], x = a(b);
            x !== null && (x instanceof HTMLImageElement ? p.push(x) : p.push(new pa(x.data, x.width, x.height)));
          }
          s[d.uuid] = new Gi(p);
        } else {
          const p = a(d.url);
          s[d.uuid] = new Gi(p);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(t) {
    const r = this, n = {};
    let s;
    async function o(i) {
      if (typeof i == "string" && i) {
        const a = i, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : r.resourcePath + a;
        return await s.loadAsync(l);
      } else
        return i.data ? {
          data: rm(i.type, i.data),
          width: i.width,
          height: i.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      s = new Df(this.manager), s.setCrossOrigin(this.crossOrigin);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, f = u.length; d < f; d++) {
            const p = u[d], m = await o(p);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new pa(m.data, m.width, m.height)));
          }
          n[l.uuid] = new Gi(h);
        } else {
          const h = await o(l.url);
          n[l.uuid] = new Gi(h);
        }
      }
    }
    return n;
  }
  parseTextures(t, r) {
    function n(o, i) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), i[o]);
    }
    const s = {};
    if (t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = t[o];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), r[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = r[a.image], u = l.data;
        let h;
        Array.isArray(u) ? (h = new Yx(), u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new pa() : h = new Gn(), u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = n(a.mapping, WC)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = n(a.wrap[0], om), h.wrapT = n(a.wrap[1], om)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, im)), a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, im)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), s[a.uuid] = h;
      }
    return s;
  }
  parseObject(t, r, n, s, o) {
    var m;
    function i(g) {
      return r[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", g), r[g];
    }
    function a(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const b = [];
          for (let x = 0, y = g.length; x < y; x++) {
            const v = g[x];
            n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), b.push(n[v]);
          }
          return b;
        }
        return n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), n[g];
      }
    }
    function l(g) {
      return s[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", g), s[g];
    }
    if (this._listeners[t.uuid]) {
      const g = this._listeners[t.uuid];
      if (t.children !== void 0) {
        const b = t.children;
        for (let x = 0; x < b.length; x++)
          g.add(this.parseObject(b[x], r, n, s, o));
      }
      return g;
    }
    const u = t.geometry ? i(t.geometry) : void 0, h = t.material ? a(t.material) : void 0;
    (u || h) && (t = { ...t, geometry: u, material: h });
    const d = ((m = t.userData) == null ? void 0 : m.extend) || t.type;
    if (d === "PositionalAudio2" && t.listener) {
      const g = this._listeners[t.listener];
      t = { ...t, listener: g };
    }
    const f = uS(d, t);
    switch (qv(d)) {
      case "Scene":
        t.background !== void 0 && (Number.isInteger(t.background) ? f.background = new He(t.background) : f.background = l(t.background)), t.environment !== void 0 && (f.environment = l(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? f.fog = new Kx(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (f.fog = new Zx(t.fog.color, t.fog.density)), t.fog.name !== "" && (f.fog.name = t.fog.name)), t.backgroundBlurriness !== void 0 && (f.backgroundBlurriness = t.backgroundBlurriness), t.backgroundIntensity !== void 0 && (f.backgroundIntensity = t.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        t.focus !== void 0 && (f.focus = t.focus), t.zoom !== void 0 && (f.zoom = t.zoom), t.filmGauge !== void 0 && (f.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (f.filmOffset = t.filmOffset), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        t.zoom !== void 0 && (f.zoom = t.zoom), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "SkinnedMesh":
        t.bindMode !== void 0 && (f.bindMode = t.bindMode), t.bindMatrix !== void 0 && f.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (f.skeleton = t.skeleton);
        break;
    }
    if (f.uuid = t.uuid, t.name !== void 0 && (f.name = t.name), t.matrix !== void 0 ? (f.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (f.matrixAutoUpdate = t.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (t.position !== void 0 && f.position.fromArray(t.position), t.rotation !== void 0 && f.rotation.fromArray(t.rotation), t.quaternion !== void 0 && f.quaternion.fromArray(t.quaternion), t.scale !== void 0 && f.scale.fromArray(t.scale)), t.up !== void 0 && f.up.fromArray(t.up), t.castShadow !== void 0 && (f.castShadow = t.castShadow), t.receiveShadow !== void 0 && (f.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (f.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (f.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (f.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && f.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (f.shadow.camera = this.parseObject(t.shadow.camera, r, n, s, o))), t.visible !== void 0 && (f.visible = t.visible), t.frustumCulled !== void 0 && (f.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (f.renderOrder = t.renderOrder), t.userData !== void 0 && (f.userData = t.userData), t.layers !== void 0 && (f.layers.mask = t.layers), t.children !== void 0) {
      const g = t.children;
      for (let b = 0; b < g.length; b++)
        f.add(this.parseObject(g[b], r, n, s, o));
    }
    if (t.animations !== void 0) {
      const g = t.animations;
      for (let b = 0; b < g.length; b++) {
        const x = g[b];
        f.animations.push(o[x]);
      }
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (f.autoUpdate = t.autoUpdate);
      const g = t.levels;
      for (let b = 0; b < g.length; b++) {
        const x = g[b], y = f.getObjectByProperty("uuid", x.object);
        y !== void 0 && f.addLevel(y, x.distance, x.hysteresis);
      }
    }
    return f.deserialize && f.deserialize(t), f;
  }
  bindSkeletons(t, r) {
    Object.keys(r).length !== 0 && t.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const s = r[n.skeleton];
        s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix);
      }
    });
  }
  parseNodes(t, r) {
    if (t !== void 0) {
      const n = {}, s = new Da();
      for (const i of t) {
        const { uuid: a, type: l, _inst: u } = i;
        if (/Material$/.test(l)) {
          const f = s.parse(i);
          f.uuid = a, n[a] = f;
          continue;
        }
        const d = u ? ru(u) : VC(l);
        n[a] = d, n[a].uuid = a;
      }
      const o = { nodes: n, textures: r };
      for (const i of t) {
        i.meta = o;
        const a = n[i.uuid];
        a.isMaterial || (a.deserialize(i), delete i.meta);
      }
      return n;
    }
    return {};
  }
}
const WC = {
  UVMapping: Qx,
  CubeReflectionMapping: eb,
  CubeRefractionMapping: tb,
  EquirectangularReflectionMapping: Lm,
  EquirectangularRefractionMapping: nb,
  CubeUVReflectionMapping: sb
}, om = {
  RepeatWrapping: Ys,
  ClampToEdgeWrapping: fo,
  MirroredRepeatWrapping: Rm
}, im = {
  NearestFilter: js,
  NearestMipmapNearestFilter: Am,
  NearestMipmapLinearFilter: Em,
  LinearFilter: uo,
  LinearMipmapNearestFilter: Cm,
  LinearMipmapLinearFilter: yo
}, am = {
  resolution: "auto",
  toneMapping: hm,
  toneMappingExposure: 1,
  shadowMap: {
    enabled: !0,
    type: rb
  },
  vrEnable: !1
};
class YC extends M.EventDispatcher {
  constructor(t) {
    super();
    B(this, "renderer");
    B(this, "clock");
    B(this, "size", { width: 2048, height: 2048 });
    B(this, "uuid", M.MathUtils.generateUUID());
    B(this, "defaultScene", new BA());
    B(this, "currentScene");
    B(this, "currentCamera");
    B(this, "defaultCamera");
    // vr
    B(this, "vrSession");
    /** left, right */
    B(this, "hands", []);
    B(this, "handsConllisionMap", /* @__PURE__ */ new Set());
    B(this, "working", !1);
    // for app
    B(this, "settings", { ...am });
    B(this, "scenes", []);
    B(this, "spawns");
    this.context = t, Object.assign(nn, {
      navigateTo: this.navigateTo.bind(this),
      setCamera: this.setCamera.bind(this),
      spawn: this.createObjectFromSpawn.bind(this)
    }), this.renderer = new M.WebGLRenderer({
      canvas: this.context,
      antialias: !0
    }), this.renderer.outputColorSpace = M.SRGBColorSpace, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.autoUpdate = !0, this.renderer.shadowMap.type = M.PCFSoftShadowMap, this.renderer.autoClear = !1, this.renderer.toneMapping = M.ACESFilmicToneMapping, this.renderer.setClearColor(16777215), nn.gpuComputeRender = new wA(pS, mS, this.renderer), this.clock = new M.Clock(), this.currentScene = this.defaultScene, this.defaultCamera = new M.PerspectiveCamera(50, 1, 1e-3, 1e3), this.defaultCamera.name = "Perspective", this.defaultCamera.position.set(4, 3, 8), this.defaultCamera.lookAt(0, 0, 0);
    const r = this.currentScene.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.currentCamera = r, this.resize(this.size.width, this.size.height, 1);
  }
  resize(t, r, n) {
    if (!this.context)
      return;
    const s = Math.max(n, 1), o = t / r;
    this.size.width = t * s, this.size.height = r * s, this.renderer.setSize(this.size.width, this.size.height, !1), this.currentCamera && (this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = o, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / o, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix()));
  }
  navigateTo(t) {
    const r = this.scenes.find((s) => s.uuid === t || s.name === t);
    if (!r) {
      console.error(`Scene[${t}] not found`);
      return;
    }
    if (this.currentScene === r)
      return;
    this.currentScene && this.currentScene.deactive(), this.currentScene = r, this.currentScene.active();
    const n = r.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.setCamera(n), this.settings.vrEnable && (this.currentScene.getObjectByName("vr-controller0") || this.setupVr(r), this.vrSession || this.startVR());
  }
  createObjectFromSpawn(t) {
    if (!this.spawns)
      return;
    const r = this.spawns.children.find((n) => n.name === t);
    if (r)
      return cb(r, !0, this.spawns);
  }
  setCamera(t) {
    if (this.currentCamera !== t && (this.currentCamera = t, this.currentCamera)) {
      const r = this.size.width / this.size.height;
      this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = r, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / r, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix());
    }
  }
  async load(t) {
    const r = new jC(), s = await (await fetch(t)).json(), o = await r.parseAsync(s), { project: i } = s;
    i.world && (Ts(this.settings), Object.assign(this.settings, { ...am, ...i.world })), this.settings.resolution || (this.settings.resolution = "auto"), this.settings.vrEnable && (this.renderer.xr.enabled = !0), this.scenes.length = 0;
    for (const l of o.children)
      l.name === "[Spawns]" ? this.spawns = l : this.scenes.push(l);
    const a = this.scenes.find((l) => l.name === "index") || this.scenes[0] || this.defaultScene;
    this.navigateTo(a.uuid);
  }
  setupVr(t) {
    const r = this.renderer.xr.getController(0);
    r.name = "vr-controller0", t.add(r);
    const n = this.renderer.xr.getController(1);
    t.add(n);
    const s = new IA(), o = this.renderer.xr.getControllerGrip(0);
    o.add(s.createControllerModel(o)), t.add(o);
    const i = this.renderer.xr.getHand(0);
    this.hands[0] || (this.hands[0] = new kp(i), this.hands[0].name = "left"), i.add(this.hands[0]), t.add(i);
    const a = this.renderer.xr.getControllerGrip(1);
    a.add(s.createControllerModel(a)), t.add(a);
    const l = this.renderer.xr.getHand(1);
    this.hands[1] || (this.hands[1] = new kp(l), this.hands[1].name = "right"), l.add(this.hands[1]), t.add(l);
  }
  async startVR() {
    if (!navigator.xr || !await navigator.xr.isSessionSupported("immersive-vr"))
      return ke.error("Your browser is not currently supported VR!"), !1;
    if (this.vrSession)
      return ke.warn("VR has already been started!"), !1;
    let r;
    const n = new Promise((i) => r = i), s = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
    this.vrSession = await navigator.xr.requestSession("immersive-vr", s), await this.renderer.xr.setSession(this.vrSession);
    const o = () => {
      this.vrSession && (this.vrSession.removeEventListener("end", o), this.vrSession = null, this.currentCamera = this.defaultCamera, ke.debug("VR has been exited successfully!")), r(!0);
    };
    return this.vrSession.addEventListener("end", o), this.currentCamera = this.defaultCamera, n;
  }
  stopVR() {
    this.vrSession && this.vrSession.end();
  }
  updateVR() {
    this.renderer.xr.updateCamera(this.currentCamera);
    for (const t of this.hands)
      if (t)
        for (const r of this.currentScene.children) {
          if (r.bodyType === Sc.Ghost)
            continue;
          const n = `${t.name}:${r.uuid}`;
          t.intersectBoxObject(r) ? (this.handsConllisionMap.add(n), r.dispatchEvent({ type: "onCollisionEnter", target: t })) : this.handsConllisionMap.has(n) && (this.handsConllisionMap.delete(n), r.dispatchEvent({ type: "onCollisionLeave", target: t }));
        }
  }
  render(t, r) {
    nn.delta = t, nn.now = r, this.currentScene.update(this.renderer, this.currentCamera, t, r), Xr.update(), this.renderer.xr.enabled && this.updateVR(), this.renderer.render(this.currentScene, this.currentCamera);
  }
  async run() {
    if (this.working)
      throw ke.panic("already working");
    this.working = !0, this.clock.start();
    const t = (r, n) => {
      if (!this.working) {
        this.renderer.setAnimationLoop(null);
        return;
      }
      const s = this.clock.getDelta(), o = this.clock.oldTime;
      this.render(s, o);
    };
    this.renderer.setAnimationLoop(t);
  }
  dispose() {
    this.clock.stop(), this.renderer.dispose();
  }
}
const KC = "[Spawns]", ZC = "__isHidden";
export {
  X_ as AudioListener2,
  NS as BezierLine,
  Va as BezierLineMaterial,
  wS as Box,
  ZC as BuiltinObjectKeyHidden,
  KC as BuiltinSceneSpawns,
  TS as Capsule,
  lA as Character,
  SS as Cone,
  _S as Cylinder,
  E1 as EffectNode,
  Vd as Model3D,
  hA as Particles,
  Yv as PhysicalScene,
  RS as Plane,
  $_ as PositionalAudio2,
  A1 as Reflector,
  PS as ShapeArc,
  IS as ShapeCircle,
  OS as ShapeRounded,
  FS as ShapeSquare,
  LS as ShapeTriangle,
  fA as SkyBox,
  MS as Sphere,
  cA as StaticMesh,
  H_ as Text3D,
  h1 as TextMesh,
  AS as Torus,
  CS as TorusKnot,
  YC as U3JsRuntime,
  Op as WaterPlane,
  R1 as addEffectNode,
  cb as clone,
  ib as cloneTracingBegin,
  ab as cloneTracingEnd,
  Sl as nodeProxy,
  po as objectsTransferred,
  ja as textMembers
};
