var cb = Object.defineProperty;
var lb = (c, e, t) => e in c ? cb(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var G = (c, e, t) => (lb(c, typeof e != "symbol" ? e + "" : e, t), t);
import * as M from "three";
import { Color as je, Vector2 as Tt, Vector3 as ye, Vector4 as mt, Matrix3 as Ts, Matrix4 as Ge, EventDispatcher as Ka, MathUtils as Qt, LinearSRGBColorSpace as Rn, SRGBColorSpace as vn, StaticDrawUsage as ub, InterleavedBuffer as Om, InterleavedBufferAttribute as js, DynamicDrawUsage as Tu, InstancedInterleavedBuffer as Oa, DepthTexture as Fm, NearestFilter as Ws, LessCompare as hb, WebGPUCoordinateSystem as db, ShaderMaterial as fs, NoColorSpace as Im, Material as kn, WebGLCubeRenderTarget as fb, BoxGeometry as Za, BackSide as Su, NoBlending as pb, Mesh as Jt, Scene as Qa, LinearMipmapLinearFilter as To, LinearFilter as po, CubeCamera as mb, RenderTarget as gb, sRGBEncoding as yb, LinearEncoding as vb, Float16BufferAttribute as xb, REVISION as bb, TangentSpaceNormalMap as Yf, ObjectSpaceNormalMap as Nb, NoToneMapping as Kf, LinearToneMapping as wb, ReinhardToneMapping as Tb, CineonToneMapping as Sb, ACESFilmicToneMapping as Pm, FramebufferTexture as Dm, UnsignedIntType as _b, DepthFormat as Mb, PointLight as ni, DirectionalLight as bi, SpotLight as Ni, AmbientLight as _u, HemisphereLight as Um, Loader as Sr, FileLoader as Ys, PointsMaterial as Mu, LineBasicMaterial as Au, LineDashedMaterial as zm, MeshNormalMaterial as Ab, MeshBasicMaterial as Cn, MeshLambertMaterial as Bm, MeshPhongMaterial as wa, MeshStandardMaterial as jn, MeshPhysicalMaterial as Es, SpriteMaterial as Cb, MaterialLoader as wi, ObjectLoader as Eb, Object3D as xn, BufferAttribute as ao, BufferGeometry as Kn, Box3 as nr, InstancedBufferGeometry as km, Float32BufferAttribute as yn, WireframeGeometry as Rb, Sphere as Ti, UniformsLib as co, ShaderLib as ls, UniformsUtils as sr, Line3 as Lb, CubicBezierCurve3 as Ob, PerspectiveCamera as _r, OrthographicCamera as ec, CapsuleGeometry as Gm, ConeGeometry as Fb, CylinderGeometry as Ib, SphereGeometry as tc, TorusGeometry as Pb, TorusKnotGeometry as Db, ExtrudeGeometry as Vm, PlaneGeometry as Er, ShapePath as Cu, Shape as So, Path as Ub, MeshDepthMaterial as zb, RGBADepthPacking as Bb, MeshDistanceMaterial as kb, ShaderChunk as jm, DoubleSide as Eu, InstancedBufferAttribute as Wm, FrontSide as Hm, Texture as Vn, AudioListener as Gb, PositionalAudio as Vb, AudioLoader as jb, TrianglesDrawMode as Wb, TriangleFanDrawMode as Vl, TriangleStripDrawMode as Xm, LoaderUtils as mo, Quaternion as pr, InstancedMesh as Hb, TextureLoader as Ru, ImageBitmapLoader as Xb, RepeatWrapping as Ks, PropertyBinding as si, SkinnedMesh as $m, LineSegments as $b, Line as qm, LineLoop as qb, Points as Jm, Group as lo, Skeleton as Lu, AnimationClip as Ou, Bone as jl, InterpolateLinear as Ym, ColorManagement as Zf, NearestMipmapNearestFilter as Km, LinearMipmapNearestFilter as Zm, NearestMipmapLinearFilter as Qm, ClampToEdgeWrapping as go, MirroredRepeatWrapping as eg, InterpolateDiscrete as Jb, VectorKeyframeTrack as Wl, NumberKeyframeTrack as Hl, QuaternionKeyframeTrack as Xl, Interpolant as Yb, Curve as Kb, EquirectangularReflectionMapping as tg, Uint16BufferAttribute as Zb, Euler as Ss, AnimationMixer as Qb, LoopRepeat as eN, LoopOnce as tN, Plane as $l, WebGLRenderTarget as Fu, HalfFloatType as ng, PMREMGenerator as nN, AdditiveBlending as sN, Camera as rN, RGBAFormat as Qf, DataTexture as Ta, FloatType as ep, BufferGeometryLoader as oN, LoadingManager as iN, ImageLoader as tp, Source as $i, CubeTexture as aN, Fog as cN, FogExp2 as lN, UVMapping as uN, CubeReflectionMapping as hN, CubeRefractionMapping as dN, EquirectangularRefractionMapping as fN, CubeUVReflectionMapping as pN, PCFSoftShadowMap as mN } from "three";
import { EventDispatcher as KE } from "three";
import { computeBoundsTree as gN, disposeBoundsTree as yN, acceleratedRaycast as vN } from "three-mesh-bvh";
const ql = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, ht = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, xN = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
}, Qr = ["fragment", "vertex"], Jl = ["setup", "analyze", "generate"], sg = [...Qr, "compute"], nc = ["x", "y", "z", "w"];
function sc(c) {
  let e = "{";
  c.isNode === !0 && (e += `uuid:"${c.uuid}"`);
  for (const { property: t, index: r, childNode: n } of ri(c)) {
    let s = sc(n);
    s.includes(",") || (s = s.slice(s.indexOf('"'), s.indexOf("}"))), e += `,${t}${r !== void 0 ? "/" + r : ""}:${s}`;
  }
  return e += "}", e;
}
function* ri(c, e = !1) {
  for (const t in c) {
    if (t.startsWith("_") === !0)
      continue;
    const r = c[t];
    if (Array.isArray(r) === !0)
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
    else if (r && r.isNode === !0)
      yield { property: t, childNode: r };
    else if (typeof r == "object")
      for (const n in r) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
  }
}
function Hs(c) {
  if (c == null)
    return null;
  const e = typeof c;
  return c.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : c.isVector2 === !0 ? "vec2" : c.isVector3 === !0 ? "vec3" : c.isVector4 === !0 ? "vec4" : c.isMatrix3 === !0 ? "mat3" : c.isMatrix4 === !0 ? "mat4" : c.isColor === !0 ? "color" : c instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function Iu(c, ...e) {
  const t = c ? c.slice(-4) : void 0;
  return e.length === 1 && (t === "vec2" ? e = [e[0], e[0]] : t === "vec3" ? e = [e[0], e[0], e[0]] : t === "vec4" && (e = [e[0], e[0], e[0], e[0]])), c === "color" ? new je(...e) : t === "vec2" ? new Tt(...e) : t === "vec3" ? new ye(...e) : t === "vec4" ? new mt(...e) : t === "mat3" ? new Ts(...e) : t === "mat4" ? new Ge(...e) : c === "bool" ? e[0] || !1 : c === "float" || c === "int" || c === "uint" ? e[0] || 0 : c === "string" ? e[0] || "" : c === "ArrayBuffer" ? Du(e[0]) : null;
}
function Pu(c) {
  let e = "";
  const t = new Uint8Array(c);
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Du(c) {
  return Uint8Array.from(atob(c), (e) => e.charCodeAt(0)).buffer;
}
const bN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: Pu,
  base64ToArrayBuffer: Du,
  getCacheKey: sc,
  getNodeChildren: ri,
  getValueFromType: Iu,
  getValueType: Hs
}, Symbol.toStringTag, { value: "Module" })), Yl = /* @__PURE__ */ new Map();
let NN = 0, wN = class extends Ka {
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = ht.NONE, this.updateBeforeType = ht.NONE, this.uuid = Qt.generateUUID(), this.isNode = !0, Object.defineProperty(this, "id", { value: NN++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    for (const { childNode: e } of ri(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const t of this.getChildren())
      t.traverse(e);
  }
  getCacheKey() {
    return sc(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    for (const r of this.getChildren())
      t["_node" + r.id] = r;
    return null;
  }
  construct(e) {
    return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."), this.setup(e);
  }
  analyze(e) {
    const t = e.getDataFromNode(this);
    if (t.dependenciesCount = t.dependenciesCount === void 0 ? 1 : t.dependenciesCount + 1, t.dependenciesCount === 1) {
      const r = e.getNodeProperties(this);
      for (const n of Object.values(r))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    if (r && r.isNode === !0)
      return r.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const r = this.getShared(e);
    if (this !== r)
      return r.build(e, t);
    e.addNode(this), e.addChain(this);
    let n = null;
    const s = e.getBuildStage();
    if (s === "setup") {
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0 || e.context.tempRead === !1) {
        const i = e.stack.nodes.length;
        o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length !== i && (o.outputNode = e.stack);
        for (const a of Object.values(o))
          a && a.isNode === !0 && a.build(e);
      }
    } else if (s === "analyze")
      this.analyze(e);
    else if (s === "generate")
      if (this.generate.length === 1) {
        const i = this.getNodeType(e), a = e.getDataFromNode(this);
        n = a.snippet, n === void 0 && (n = this.generate(e) || "", a.snippet = n), n = e.format(n, i, t);
      } else
        n = this.generate(e, t) || "";
    return e.removeChain(this), n;
  }
  getSerializeChildren() {
    return ri(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(), r = {};
    for (const { property: n, index: s, childNode: o } of t)
      s !== void 0 ? (r[n] === void 0 && (r[n] = Number.isInteger(s) ? [] : {}), r[n][s] = o.toJSON(e.meta).uuid) : r[n] = o.toJSON(e.meta).uuid;
    Object.keys(r).length > 0 && (e.inputNodes = r);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const r in e.inputNodes)
        if (Array.isArray(e.inputNodes[r])) {
          const n = [];
          for (const s of e.inputNodes[r])
            n.push(t[s]);
          this[r] = n;
        } else if (typeof e.inputNodes[r] == "object") {
          const n = {};
          for (const s in e.inputNodes[r]) {
            const o = e.inputNodes[r][s];
            n[s] = t[o];
          }
          this[r] = n;
        } else {
          const n = e.inputNodes[r];
          this[r] = t[n];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: r } = this, n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let s = e.nodes[t];
    s === void 0 && (s = {
      uuid: t,
      type: r,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, n !== !0 && (e.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
    if (n) {
      const i = o(e.textures), a = o(e.images), l = o(e.nodes);
      i.length > 0 && (s.textures = i), a.length > 0 && (s.images = a), l.length > 0 && (s.nodes = l);
    }
    return s;
  }
};
const Oe = wN;
function re(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node class ${c} is not a class`);
  if (Yl.has(c))
    throw new Error(`Redefinition of node class ${c}`);
  Yl.set(c, e), e.type = c;
}
function Kl(c) {
  const e = Yl.get(c);
  if (e !== void 0)
    return new e();
}
class rg extends Oe {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node.build(e), r = this.indexNode.build(e, "uint");
    return `${t}[ ${r} ]`;
  }
}
const rc = rg;
re("ArrayElementNode", rg);
class og extends Oe {
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let r = null;
    for (const n of this.convertTo.split("|"))
      (r === null || e.getTypeLength(t) === e.getTypeLength(n)) && (r = n);
    return r;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const r = this.node, n = this.getNodeType(e), s = r.build(e, n);
    return e.format(s, n, t);
  }
}
const oc = og;
re("ConvertNode", og);
class ig extends Oe {
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).dependenciesCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, t)), s = e.getDataFromNode(this);
      if (e.context.tempRead !== !1 && s.propertyName !== void 0)
        return e.format(s.propertyName, n, t);
      if (e.context.tempWrite !== !1 && n !== "void" && t !== "void" && this.hasDependencies(e)) {
        const o = super.build(e, n), i = e.getVarFromNode(this, null, n), a = e.getPropertyName(i);
        return e.addLineFlowCode(`${a} = ${o}`), s.snippet = o, s.propertyName = a, e.format(s.propertyName, n, t);
      }
    }
    return super.build(e, t);
  }
}
const St = ig;
re("TempNode", ig);
class ag extends St {
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, r) => t + e.getTypeLength(r.getNodeType(e)), 0));
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.nodes, s = e.getPrimitiveType(r), o = [];
    for (const a of n) {
      let l = a.build(e);
      const u = e.getPrimitiveType(a.getNodeType(e));
      u !== s && (l = e.format(l, u, s)), o.push(l);
    }
    const i = `${e.getType(r)}( ${o.join(", ")} )`;
    return e.format(i, r, t);
  }
}
const cg = ag;
re("JoinNode", ag);
const TN = nc.join("");
class lg extends Oe {
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(nc.indexOf(t) + 1, e);
    return e;
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length);
  }
  generate(e, t) {
    const r = this.node, n = e.getTypeLength(r.getNodeType(e));
    let s = null;
    if (n > 1) {
      let o = null;
      this.getVectorLength() >= n && (o = e.getTypeFromLength(this.getVectorLength()));
      const a = r.build(e, o);
      this.components.length === n && this.components === TN.slice(0, this.components.length) ? s = e.format(a, o, t) : s = e.format(`${a}.${this.components}`, this.getNodeType(e), t);
    } else
      s = r.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
const Fa = lg;
re("SplitNode", lg);
class ug extends St {
  constructor(e, t, r) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = r;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: r, targetNode: n } = this, s = this.getNodeType(e), o = e.getTypeFromLength(r.length), i = n.build(e, o), a = t.build(e, s), l = e.getTypeLength(s), u = [];
    for (let h = 0; h < l; h++) {
      const d = nc[h];
      d === r[0] ? (u.push(i), h += r.length - 1) : u.push(a + "." + d);
    }
    return `${e.getType(s)}( ${u.join(", ")} )`;
  }
}
const hg = ug;
re("SetNode", ug);
class dg extends Oe {
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Hs(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Hs(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = Pu(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? Iu(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Uu = dg;
re("InputNode", dg);
class fg extends Uu {
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.getConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const r = this.getNodeType(e);
    return e.format(this.generateConst(e), r, t);
  }
}
const On = fg;
re("ConstNode", fg);
let yo = null;
const eo = /* @__PURE__ */ new Map();
function V(c, e) {
  if (eo.has(c))
    throw new Error(`Redefinition of node element ${c}`);
  if (typeof e != "function")
    throw new Error(`Node element ${c} is not a function`);
  eo.set(c, e);
}
const np = (c) => c.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), pg = {
  setup(c, e) {
    const t = e.shift();
    return c(Si(t), ...e);
  },
  get(c, e, t) {
    if (typeof e == "string" && c[e] === void 0) {
      if (c.isStackNode !== !0 && e === "assign")
        return (...r) => yo.assign(t, ...r);
      if (eo.has(e)) {
        const r = eo.get(e);
        return c.isStackNode ? (...n) => t.add(r(...n)) : (...n) => r(t, ...n);
      } else {
        if (e === "self")
          return c;
        if (e.endsWith("Assign") && eo.has(e.slice(0, e.length - 6))) {
          const r = eo.get(e.slice(0, e.length - 6));
          return c.isStackNode ? (...n) => t.assign(n[0], r(...n)) : (...n) => t.assign(r(t, ...n));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = np(e), Me(new Fa(t, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = np(e.slice(3).toLowerCase()), e = e.split("").sort().join(""), (r) => Me(new hg(c, e, r));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), Me(new Fa(c, e));
          if (/^\d+$/.test(e) === !0)
            return Me(new rc(t, new On(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(c, e, t);
  },
  set(c, e, t, r) {
    return typeof e == "string" && c[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (r[e].assign(t), !0) : Reflect.set(c, e, t, r);
  }
}, nl = /* @__PURE__ */ new WeakMap(), sp = /* @__PURE__ */ new WeakMap(), SN = function(c, e = null) {
  const t = Hs(c);
  if (t === "node") {
    let r = nl.get(c);
    return r === void 0 && (r = new Proxy(c, pg), nl.set(c, r), nl.set(r, r)), r;
  } else {
    if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string")
      return Me(Zl(c, e));
    if (t === "shader")
      return Ve(c);
  }
  return c;
}, _N = function(c, e = null) {
  for (const t in c)
    c[t] = Me(c[t], e);
  return c;
}, MN = function(c, e = null) {
  const t = c.length;
  for (let r = 0; r < t; r++)
    c[r] = Me(c[r], e);
  return c;
}, AN = function(c, e = null, t = null, r = null) {
  const n = (s) => Me(r !== null ? Object.assign(s, r) : s);
  return e === null ? (...s) => n(new c(...vr(s))) : t !== null ? (t = Me(t), (...s) => n(new c(e, ...vr(s), t))) : (...s) => n(new c(e, ...vr(s)));
}, CN = function(c, ...e) {
  return Me(new c(...vr(e)));
};
class EN extends Oe {
  constructor(e, t) {
    super(), this.shaderNode = e, this.inputNodes = t;
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  call(e) {
    const { shaderNode: t, inputNodes: r } = this;
    if (t.layout) {
      let o = sp.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), sp.set(e.constructor, o));
      let i = o.get(t);
      return i === void 0 && (i = Me(e.buildFunctionNode(t)), o.set(t, i)), Me(i.call(r));
    }
    const n = t.jsFunc, s = r !== null ? n(r, e.stack, e) : n(e.stack, e);
    return Me(s);
  }
  setup(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    return r === null ? this.call(e).build(e, t) : super.generate(e, t);
  }
}
class RN extends Oe {
  constructor(e) {
    super(), this.jsFunc = e, this.layout = null;
  }
  get isArrayInput() {
    return /^\(\s+?\[/.test(this.jsFunc.toString());
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return Si(e), Me(new EN(this, e));
  }
  setup() {
    return this.call();
  }
}
const LN = [!1, !0], ON = [0, 1, 2, 3], FN = [-1, -2], mg = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], zu = /* @__PURE__ */ new Map();
for (const c of LN)
  zu.set(c, new On(c));
const Bu = /* @__PURE__ */ new Map();
for (const c of ON)
  Bu.set(c, new On(c, "uint"));
const ku = new Map([...Bu].map((c) => new On(c.value, "int")));
for (const c of FN)
  ku.set(c, new On(c, "int"));
const ic = new Map([...ku].map((c) => new On(c.value)));
for (const c of mg)
  ic.set(c, new On(c));
for (const c of mg)
  ic.set(-c, new On(-c));
const ac = { bool: zu, uint: Bu, ints: ku, float: ic }, rp = new Map([...zu, ...ic]), Zl = (c, e) => rp.has(c) ? rp.get(c) : c.isNode === !0 ? c : new On(c, e), IN = (c) => {
  try {
    return c.getNodeType();
  } catch {
    return;
  }
}, gt = function(c, e = null) {
  return (...t) => {
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(c) && t.every((n) => typeof n != "object")) && (t = [Iu(c, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return Me(e.get(t[0]));
    if (t.length === 1) {
      const n = Zl(t[0], c);
      return IN(n) === c ? Me(n) : Me(new oc(n, c));
    }
    const r = t.map((n) => Zl(n));
    return Me(new cg(r, c));
  };
}, gg = (c) => c != null ? c.nodeType || c.convertTo || (typeof c == "string" ? c : null) : null;
function yr(c) {
  return new Proxy(new RN(c), pg);
}
const Me = (c, e = null) => (
  /* new */
  SN(c, e)
), Si = (c, e = null) => new _N(c, e), vr = (c, e = null) => new MN(c, e), J = (...c) => new AN(...c), ue = (...c) => new CN(...c), PN = (c) => (console.warn("TSL: shader() is deprecated. Use tslFn() instead."), new yr(c)), Ve = (c) => {
  const e = new yr(c), t = (...r) => {
    let n;
    return Si(r), r[0] && r[0].isNode ? n = [...r] : n = r[0], e.call(n);
  };
  return t.shaderNode = e, t.setLayout = (r) => (e.setLayout(r), t), t;
};
re("ShaderNode", yr);
const oi = (c) => yo = c, Gu = () => yo, dr = (...c) => yo.if(...c);
function yg(c) {
  return yo && yo.add(c), c;
}
V("append", yg);
const vg = new gt("color"), Se = new gt("float", ac.float), Ia = new gt("int", ac.int), xg = new gt("uint", ac.uint), bg = new gt("bool", ac.bool), rt = new gt("vec2"), Ng = new gt("ivec2"), wg = new gt("uvec2"), Tg = new gt("bvec2"), Ce = new gt("vec3"), Sg = new gt("ivec3"), _g = new gt("uvec3"), Mg = new gt("bvec3"), st = new gt("vec4"), Ag = new gt("ivec4"), Cg = new gt("uvec4"), Eg = new gt("bvec4"), Ms = new gt("mat3"), Rg = new gt("imat3"), Lg = new gt("umat3"), Og = new gt("bmat3"), Vu = new gt("mat4"), Fg = new gt("imat4"), Ig = new gt("umat4"), Pg = new gt("bmat4"), Dg = (c = "") => Me(new On(c, "string")), Ug = (c) => Me(new On(c, "ArrayBuffer"));
V("color", vg);
V("float", Se);
V("int", Ia);
V("uint", xg);
V("bool", bg);
V("vec2", rt);
V("ivec2", Ng);
V("uvec2", wg);
V("bvec2", Tg);
V("vec3", Ce);
V("ivec3", Sg);
V("uvec3", _g);
V("bvec3", Mg);
V("vec4", st);
V("ivec4", Ag);
V("uvec4", Cg);
V("bvec4", Eg);
V("mat3", Ms);
V("imat3", Rg);
V("umat3", Lg);
V("bmat3", Og);
V("mat4", Vu);
V("imat4", Fg);
V("umat4", Ig);
V("bmat4", Pg);
V("string", Dg);
V("arrayBuffer", Ug);
const zg = J(rc), Bg = (c, e) => Me(new oc(Me(c), e)), DN = (c, e) => Me(new Fa(Me(c), e));
V("element", zg);
V("convert", Bg);
class ju extends Oe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: t, name: r } = this, n = e.getVarFromNode(this, r, e.getVectorType(this.getNodeType(e))), s = e.getPropertyName(n), o = t.build(e, n.type);
    return e.addLineFlowCode(`${s} = ${o}`), s;
  }
}
const kg = ju, vo = J(ju);
V("temp", vo);
V("toVar", (...c) => vo(...c).append());
re("VarNode", ju);
class Wu extends Uu {
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.getUniformHash(e);
    let s = e.getNodeFromHash(n);
    s === void 0 && (e.setHashNode(this, n), s = this);
    const o = s.getInputType(e), i = e.getUniformFromNode(s, o, e.shaderStage, e.context.label), a = e.getPropertyName(i);
    return e.context.label !== void 0 && delete e.context.label, e.format(a, r, t);
  }
}
const nt = Wu, Ft = (c, e) => {
  const t = gg(e || c), r = c && c.isNode === !0 ? c.node && c.node.value || c.value : c;
  return Me(new Wu(r, t));
};
re("UniformNode", Wu);
class Gg extends nt {
  constructor(e = []) {
    super(), this.isArrayUniformNode = !0, this.nodes = e;
  }
  getNodeType(e) {
    return this.nodes[0].getNodeType(e);
  }
}
const Vg = Gg;
re("ArrayUniformNode", Gg);
class Hu extends St {
  constructor(e, t) {
    super(), this.targetNode = e, this.sourceNode = t;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, t) {
    return t !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  generate(e, t) {
    const r = this.targetNode, n = this.sourceNode, s = r.getNodeType(e), o = r.build(e), i = n.build(e, s), a = `${o} = ${i}`;
    if (t === "void") {
      e.addLineFlowCode(a);
      return;
    } else
      return n.getNodeType(e) === "void" ? (e.addLineFlowCode(a), o) : e.format(a, s, t);
  }
}
const UN = Hu, jg = J(Hu);
re("AssignNode", Hu);
V("assign", jg);
class Xu extends Oe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: r } = this, n = this.getNodeType(e), s = e.getVaryingFromNode(this, n);
    s.needsInterpolation || (s.needsInterpolation = e.shaderStage === "fragment"), t !== null && (s.name = t);
    const o = e.getPropertyName(s, ql.VERTEX);
    return e.flowNodeFromShaderStage(ql.VERTEX, r, n, o), e.getPropertyName(s);
  }
}
const Wg = Xu, ct = J(Xu);
V("varying", ct);
re("VaryingNode", Xu);
class $u extends Oe {
  constructor(e, t = null) {
    super(t), this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (t === null) {
      const r = this.getAttributeName(e);
      if (e.hasGeometryAttribute(r)) {
        const n = e.geometry.getAttribute(r);
        t = e.getTypeFromAttribute(n);
      } else
        t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), r = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t), o = e.getTypeFromAttribute(s), i = e.getAttribute(t, o);
      return e.shaderStage === "vertex" ? e.format(i.name, o, r) : ct(this).build(e, r);
    } else
      return console.warn(`AttributeNode: Attribute "${t}" not found.`), e.getConst(r);
  }
}
const qu = $u, Mt = (c, e) => Me(new $u(c, e));
re("AttributeNode", $u);
class Ju extends Oe {
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const Hg = Ju, Yu = J(Ju);
V("bypass", Yu);
re("BypassNode", Ju);
let zN = 0;
class BN {
  constructor() {
    this.id = zN++, this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
}
const cc = BN;
class Ku extends Oe {
  constructor(e, t = new cc()) {
    super(), this.isCacheNode = !0, this.node = e, this.cache = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const r = e.getCache();
    e.setCache(this.cache);
    const n = this.node.build(e, ...t);
    return e.setCache(r), n;
  }
}
const Xg = Ku, Pa = J(Ku);
V("cache", Pa);
re("CacheNode", Ku);
class Zu extends Oe {
  constructor(e, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.context = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const r = this.node.build(e);
    return e.setContext(t), r;
  }
  generate(e, t) {
    const r = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const n = this.node.build(e, t);
    return e.setContext(r), n;
  }
}
const Qu = Zu, Zn = J(Zu), eh = (c, e) => Zn(c, { label: e });
V("context", Zn);
V("label", eh);
re("ContextNode", Zu);
class es extends Oe {
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), r = this.scope;
    let n;
    if (r === es.VERTEX)
      n = e.getVertexIndex();
    else if (r === es.INSTANCE)
      n = e.getInstanceIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + r);
    let s;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? s = n : s = ct(this).build(e, t), s;
  }
}
es.VERTEX = "vertex";
es.INSTANCE = "instance";
const kN = es, GN = ue(es, es.VERTEX), $g = ue(es, es.INSTANCE);
re("IndexNode", es);
class VN {
  start() {
  }
  finish() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
}
const th = VN;
class jN {
  constructor(e, t, r = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = r;
  }
}
const Da = jN;
class WN {
  constructor(e, t, r, n = void 0) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = r.getSelf(), this.needsUpdate = n;
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
}
const nh = WN;
class HN {
  constructor(e, t) {
    this.isNodeVar = !0, this.name = e, this.type = t;
  }
}
const lc = HN;
class XN extends lc {
  constructor(e, t) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
const sh = XN;
class $N {
  constructor(e, t, r = "") {
    this.name = e, this.type = t, this.code = r, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
const rh = $N;
class qN {
  constructor() {
    this.keywords = [], this.nodes = [], this.keywordsCallback = {};
  }
  getNode(e) {
    let t = this.nodes[e];
    return t === void 0 && this.keywordsCallback[e] !== void 0 && (t = this.keywordsCallback[e](e), this.nodes[e] = t), t;
  }
  addKeyword(e, t) {
    return this.keywords.push(e), this.keywordsCallback[e] = t, this;
  }
  parse(e) {
    const t = this.keywords, r = new RegExp(`\\b${t.join("\\b|\\b")}\\b`, "g"), n = e.match(r), s = [];
    if (n !== null)
      for (const o of n) {
        const i = this.getNode(o);
        i !== void 0 && s.indexOf(i) === -1 && s.push(i);
      }
    return s;
  }
  include(e, t) {
    const r = this.parse(t);
    for (const n of r)
      n.build(e);
  }
}
const oh = qN;
class zt extends Oe {
  constructor(e, t = null) {
    super(e), this.name = t, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    return e.getPropertyName(e.getVarFromNode(this, this.name));
  }
}
const ih = zt, An = (c, e) => Me(new zt(c, e)), qt = ue(zt, "vec4", "DiffuseColor"), uo = ue(zt, "float", "Roughness"), qg = ue(zt, "float", "Metalness"), Ua = ue(zt, "float", "Clearcoat"), ii = ue(zt, "float", "ClearcoatRoughness"), mr = ue(zt, "vec3", "Sheen"), uc = ue(zt, "float", "SheenRoughness"), hc = ue(zt, "float", "Iridescence"), ah = ue(zt, "float", "IridescenceIOR"), ch = ue(zt, "float", "IridescenceThickness"), us = ue(zt, "color", "SpecularColor"), za = ue(zt, "float", "Shininess"), Jg = ue(zt, "vec4", "Output"), xr = ue(zt, "float", "dashSize"), ai = ue(zt, "float", "gapSize"), JN = ue(zt, "float", "pointWidth");
re("PropertyNode", zt);
class lh extends ih {
  constructor(e, t = null) {
    super(e, t), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const Ql = lh, YN = (c, e) => Me(new lh(c, e));
re("ParameterNode", lh);
class uh extends qu {
  constructor(e = 0) {
    super(null, "vec2"), this.isUVNode = !0, this.index = e;
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const Yg = uh, yt = (...c) => Me(new uh(...c));
re("UVNode", uh);
class Kg extends Oe {
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const r = this.textureNode.build(e, "property"), n = this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${r}, ${n} )`, this.getNodeType(e), t);
  }
}
const Zg = J(Kg);
V("textureSize", Zg);
re("TextureSizeNode", Kg);
class Nt extends St {
  constructor(e, t, r, ...n) {
    if (super(), this.op = e, n.length > 0) {
      let s = r;
      for (let o = 0; o < n.length; o++)
        s = new Nt(e, s, n[o]);
      r = s;
    }
    this.aNode = t, this.bNode = r;
  }
  getNodeType(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = n.getNodeType(e), i = s.getNodeType(e);
    if (o === "void" || i === "void")
      return "void";
    if (r === "%")
      return o;
    if (r === "&" || r === "|" || r === "^" || r === ">>" || r === "<<")
      return e.getIntegerType(o);
    if (r === "==" || r === "&&" || r === "||" || r === "^^")
      return "bool";
    if (r === "<" || r === ">" || r === "<=" || r === ">=") {
      const a = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(o), e.getTypeLength(i));
      return a > 1 ? `bvec${a}` : "bool";
    } else
      return o === "float" && e.isMatrix(i) ? i : e.isMatrix(o) && e.isVector(i) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(i) ? e.getVectorFromMatrix(i) : e.getTypeLength(i) > e.getTypeLength(o) ? i : o;
  }
  generate(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = this.getNodeType(e, t);
    let i = null, a = null;
    o !== "void" ? (i = n.getNodeType(e), a = s.getNodeType(e), r === "<" || r === ">" || r === "<=" || r === ">=" || r === "==" ? e.isVector(i) ? a = i : i = a = "float" : r === ">>" || r === "<<" ? (i = o, a = e.changeComponentType(a, "uint")) : e.isMatrix(i) && e.isVector(a) ? a = e.getVectorFromMatrix(i) : e.isVector(i) && e.isMatrix(a) ? i = e.getVectorFromMatrix(a) : i = a = o) : i = a = o;
    const l = n.build(e, i), u = s.build(e, a), h = e.getTypeLength(t);
    if (t !== "void")
      return r === "<" && h > 1 ? e.format(`${e.getMethod("lessThan")}( ${l}, ${u} )`, o, t) : r === "<=" && h > 1 ? e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${u} )`, o, t) : r === ">" && h > 1 ? e.format(`${e.getMethod("greaterThan")}( ${l}, ${u} )`, o, t) : r === ">=" && h > 1 ? e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${u} )`, o, t) : e.format(`( ${l} ${this.op} ${u} )`, o, t);
    if (i !== "void")
      return e.format(`${l} ${this.op} ${u}`, o, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Qg = Nt, ts = J(Nt, "+"), Ba = J(Nt, "-"), en = J(Nt, "*"), xo = J(Nt, "/"), ey = J(Nt, "%"), ty = J(Nt, "=="), KN = J(Nt, "!="), ny = J(Nt, "<"), sy = J(Nt, ">"), ry = J(Nt, "<="), oy = J(Nt, ">="), iy = J(Nt, "&&"), ay = J(Nt, "||"), cy = J(Nt, "^^"), ly = J(Nt, "&"), uy = J(Nt, "|"), hy = J(Nt, "^"), dy = J(Nt, "<<"), fy = J(Nt, ">>");
V("add", ts);
V("sub", Ba);
V("mul", en);
V("div", xo);
V("remainder", ey);
V("equal", ty);
V("notEqual", KN);
V("lessThan", ny);
V("greaterThan", sy);
V("lessThanEqual", ry);
V("greaterThanEqual", oy);
V("and", iy);
V("or", ay);
V("xor", cy);
V("bitAnd", ly);
V("bitOr", uy);
V("bitXor", hy);
V("shiftLeft", dy);
V("shiftRight", fy);
re("OperatorNode", Nt);
class B extends St {
  constructor(e, t, r = null, n = null) {
    super(), this.method = e, this.aNode = t, this.bNode = r, this.cNode = n;
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e), r = this.bNode ? this.bNode.getNodeType(e) : null, n = this.cNode ? this.cNode.getNodeType(e) : null, s = e.isMatrix(t) ? 0 : e.getTypeLength(t), o = e.isMatrix(r) ? 0 : e.getTypeLength(r), i = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return s > o && s > i ? t : o > i ? r : i > s ? n : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === B.LENGTH || t === B.DISTANCE || t === B.DOT ? "float" : t === B.CROSS ? "vec3" : this.getInputType(e);
  }
  generate(e, t) {
    const r = this.method, n = this.getNodeType(e), s = this.getInputType(e), o = this.aNode, i = this.bNode, a = this.cNode, l = e.renderer.isWebGLRenderer === !0;
    if (r === B.TRANSFORM_DIRECTION) {
      let u = o, h = i;
      e.isMatrix(u.getNodeType(e)) ? h = st(Ce(h), 0) : u = st(Ce(u), 0);
      const d = en(u, h).xyz;
      return Ln(d).build(e, t);
    } else {
      if (r === B.NEGATE)
        return e.format("( - " + o.build(e, s) + " )", n, t);
      if (r === B.ONE_MINUS)
        return Ba(1, o).build(e, t);
      if (r === B.RECIPROCAL)
        return xo(1, o).build(e, t);
      if (r === B.DIFFERENCE)
        return fh(Ba(o, i)).build(e, t);
      {
        const u = [];
        return r === B.CROSS ? u.push(
          o.build(e, n),
          i.build(e, n)
        ) : r === B.STEP ? u.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : s),
          i.build(e, s)
        ) : l && (r === B.MIN || r === B.MAX) || r === B.MOD ? u.push(
          o.build(e, s),
          i.build(e, e.getTypeLength(i.getNodeType(e)) === 1 ? "float" : s)
        ) : r === B.REFRACT ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, "float")
        ) : r === B.MIX ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : s)
        ) : (u.push(o.build(e, s)), i !== null && u.push(i.build(e, s)), a !== null && u.push(a.build(e, s))), e.format(`${e.getMethod(r)}( ${u.join(", ")} )`, n, t);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
B.RADIANS = "radians";
B.DEGREES = "degrees";
B.EXP = "exp";
B.EXP2 = "exp2";
B.LOG = "log";
B.LOG2 = "log2";
B.SQRT = "sqrt";
B.INVERSE_SQRT = "inversesqrt";
B.FLOOR = "floor";
B.CEIL = "ceil";
B.NORMALIZE = "normalize";
B.FRACT = "fract";
B.SIN = "sin";
B.COS = "cos";
B.TAN = "tan";
B.ASIN = "asin";
B.ACOS = "acos";
B.ATAN = "atan";
B.ABS = "abs";
B.SIGN = "sign";
B.LENGTH = "length";
B.NEGATE = "negate";
B.ONE_MINUS = "oneMinus";
B.DFDX = "dFdx";
B.DFDY = "dFdy";
B.ROUND = "round";
B.RECIPROCAL = "reciprocal";
B.TRUNC = "trunc";
B.FWIDTH = "fwidth";
B.ATAN2 = "atan2";
B.MIN = "min";
B.MAX = "max";
B.MOD = "mod";
B.STEP = "step";
B.REFLECT = "reflect";
B.DISTANCE = "distance";
B.DIFFERENCE = "difference";
B.DOT = "dot";
B.CROSS = "cross";
B.POW = "pow";
B.TRANSFORM_DIRECTION = "transformDirection";
B.MIX = "mix";
B.CLAMP = "clamp";
B.REFRACT = "refract";
B.SMOOTHSTEP = "smoothstep";
B.FACEFORWARD = "faceforward";
const ke = B, hh = Se(1e-6), ZN = Se(1e6), py = J(B, B.RADIANS), my = J(B, B.DEGREES), gy = J(B, B.EXP), yy = J(B, B.EXP2), vy = J(B, B.LOG), xy = J(B, B.LOG2), by = J(B, B.SQRT), Ny = J(B, B.INVERSE_SQRT), dc = J(B, B.FLOOR), dh = J(B, B.CEIL), Ln = J(B, B.NORMALIZE), fc = J(B, B.FRACT), wy = J(B, B.SIN), Ty = J(B, B.COS), Sy = J(B, B.TAN), _y = J(B, B.ASIN), My = J(B, B.ACOS), Ay = J(B, B.ATAN), fh = J(B, B.ABS), Cy = J(B, B.SIGN), Ey = J(B, B.LENGTH), Ry = J(B, B.NEGATE), Ly = J(B, B.ONE_MINUS), Oy = J(B, B.DFDX), Fy = J(B, B.DFDY), Iy = J(B, B.ROUND), Py = J(B, B.RECIPROCAL), Dy = J(B, B.TRUNC), Uy = J(B, B.FWIDTH), zy = J(B, B.ATAN2), By = J(B, B.MIN), ky = J(B, B.MAX), Gy = J(B, B.MOD), Vy = J(B, B.STEP), jy = J(B, B.REFLECT), Wy = J(B, B.DISTANCE), Hy = J(B, B.DIFFERENCE), ph = J(B, B.DOT), Xy = J(B, B.CROSS), mh = J(B, B.POW), $y = J(B, B.POW, 2), qy = J(B, B.POW, 3), Jy = J(B, B.POW, 4), Yy = J(B, B.TRANSFORM_DIRECTION), bn = J(B, B.MIX), gh = (c, e = 0, t = 1) => Me(new B(B.CLAMP, Me(c), Me(e), Me(t))), Ky = (c) => gh(c), Zy = J(B, B.REFRACT), As = J(B, B.SMOOTHSTEP), Qy = J(B, B.FACEFORWARD), QN = (c, e, t) => bn(e, t, c), ew = (c, e, t) => As(e, t, c);
V("radians", py);
V("degrees", my);
V("exp", gy);
V("exp2", yy);
V("log", vy);
V("log2", xy);
V("sqrt", by);
V("inverseSqrt", Ny);
V("floor", dc);
V("ceil", dh);
V("normalize", Ln);
V("fract", fc);
V("sin", wy);
V("cos", Ty);
V("tan", Sy);
V("asin", _y);
V("acos", My);
V("atan", Ay);
V("abs", fh);
V("sign", Cy);
V("length", Ey);
V("negate", Ry);
V("oneMinus", Ly);
V("dFdx", Oy);
V("dFdy", Fy);
V("round", Iy);
V("reciprocal", Py);
V("trunc", Dy);
V("fwidth", Uy);
V("atan2", zy);
V("min", By);
V("max", ky);
V("mod", Gy);
V("step", Vy);
V("reflect", jy);
V("distance", Wy);
V("dot", ph);
V("cross", Xy);
V("pow", mh);
V("pow2", $y);
V("pow3", qy);
V("pow4", Jy);
V("transformDirection", Yy);
V("mix", QN);
V("clamp", gh);
V("refract", Zy);
V("smoothstep", ew);
V("faceForward", Qy);
V("difference", Hy);
V("saturate", Ky);
re("MathNode", B);
const tw = Ve((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.mul(0.9478672986).add(0.0521327014).pow(2.4), n = t.mul(0.0773993808), s = t.lessThanEqual(0.04045), o = bn(r, n, s);
  return st(o, e.a);
}), nw = Ve((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.pow(0.41666).mul(1.055).sub(0.055), n = t.mul(12.92), s = t.lessThanEqual(31308e-7), o = bn(r, n, s);
  return st(o, e.a);
}), op = (c) => {
  let e = null;
  return c === Rn ? e = "Linear" : c === vn && (e = "sRGB"), e;
}, e0 = (c, e) => op(c) + "To" + op(e);
class an extends St {
  constructor(e, t) {
    super("vec4"), this.method = e, this.node = t;
  }
  setup() {
    const { method: e, node: t } = this;
    return e === an.LINEAR_TO_LINEAR ? t : sw[e]({ value: t });
  }
}
an.LINEAR_TO_LINEAR = "LinearToLinear";
an.LINEAR_TO_sRGB = "LinearTosRGB";
an.sRGB_TO_LINEAR = "sRGBToLinear";
const sw = {
  [an.LINEAR_TO_sRGB]: nw,
  [an.sRGB_TO_LINEAR]: tw
}, $o = an, t0 = (c, e) => Me(new an(e0(Rn, e), Me(c))), pc = (c, e) => Me(new an(e0(e, Rn), Me(c))), n0 = J(an, an.LINEAR_TO_sRGB), s0 = J(an, an.sRGB_TO_LINEAR);
V("linearTosRGB", n0);
V("sRGBToLinear", s0);
V("linearToColorSpace", t0);
V("colorSpaceToLinear", pc);
re("ColorSpaceNode", an);
class yh extends Oe {
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.snippet;
    if (r === "void")
      e.addLineFlowCode(n);
    else
      return e.format(`( ${n} )`, r, t);
  }
}
const r0 = yh, _i = J(yh);
re("ExpressionNode", yh);
class vh extends nt {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = r, this.compareNode = n, this.updateMatrix = !1, this.updateType = ht.NONE, this.setUpdateMatrix(t === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return yt(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    const t = this.value;
    return Ft(t.matrix).mul(Ce(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? ht.FRAME : ht.NONE, this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let r = this.uvNode;
    (r === null || e.context.forceUVContext === !0) && e.context.getUVNode && (r = e.context.getUVNode(this)), r || (r = this.getDefaultUV()), this.updateMatrix === !0 && (r = this.getTransformedUV(r));
    let n = this.levelNode;
    n === null && e.context.getSamplerLevelNode && (n = e.context.getSamplerLevelNode(this)), t.uvNode = r, t.levelNode = n ? e.context.getMIPLevelAlgorithmNode(this, n) : null;
  }
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.compareNode, o = this.value;
    if (!o || o.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const i = super.generate(e, "property");
    if (t === "sampler")
      return i + "_sampler";
    if (e.isReference(t))
      return i;
    {
      const a = e.getDataFromNode(this);
      let l = a.propertyName;
      if (l === void 0) {
        const d = r.build(e, "vec2"), f = e.getVarFromNode(this);
        l = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(o, i, d, m);
        } else if (s !== null) {
          const m = s.build(e, "float");
          p = e.getTextureCompare(o, i, d, m);
        } else
          p = e.getTexture(o, i, d);
        e.addLineFlowCode(`${l} = ${p}`), e.context.tempWrite !== !1 && (a.snippet = p, a.propertyName = l);
      }
      let u = l;
      const h = this.getNodeType(e);
      return e.needsColorSpaceToLinear(this.value) && (u = pc(_i(u, h), this.value.colorSpace).setup(e).build(e, h)), e.format(u, h, t);
    }
  }
  uv(e) {
    const t = this.clone();
    return t.uvNode = e, Me(t);
  }
  level(e) {
    const t = this.clone();
    return t.levelNode = e, Zn(t, {
      getMIPLevelAlgorithmNode: (r, n) => n
    });
  }
  size(e) {
    return Zg(this, e);
  }
  compare(e) {
    const t = this.clone();
    return t.compareNode = Me(e), Me(t);
  }
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value];
  }
  update() {
    const e = this.value;
    e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
}
const Mi = vh, En = J(vh), rw = (c) => (c.isNode === !0 ? c : En(c)).convert("sampler");
V("texture", En);
re("TextureNode", vh);
class xh extends Oe {
  constructor(e, t, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = r, this.reference = null, this.node = null, this.updateType = ht.OBJECT, this.setNodeType(t);
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setNodeType(e) {
    let t = null;
    e === "texture" ? t = En(null) : t = Ft(e), this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  update() {
    this.node.value = this.reference[this.property];
  }
  setup() {
    return this.node;
  }
}
const mc = xh, Cs = (c, e, t) => Me(new xh(c, e, t));
re("ReferenceNode", xh);
class bh extends mc {
  constructor(e, t, r = null) {
    super(e, t, r), this.material = r, this.updateType = ht.RENDER;
  }
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
  setup(e) {
    const t = this.material !== null ? this.material : e.material;
    return this.node.value = t[this.property], super.setup(e);
  }
}
const o0 = bh, i0 = (c, e, t) => Me(new bh(c, e, t));
re("MaterialReferenceNode", bh);
class Be extends Oe {
  constructor(e = Be.VIEW_MATRIX, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = ht.OBJECT, this._uniformNode = new nt(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === Be.WORLD_MATRIX || e === Be.VIEW_MATRIX)
      return "mat4";
    if (e === Be.NORMAL_MATRIX)
      return "mat3";
    if (e === Be.POSITION || e === Be.VIEW_POSITION || e === Be.DIRECTION || e === Be.SCALE)
      return "vec3";
  }
  update(e) {
    const t = this.object3d, r = this._uniformNode, n = this.scope;
    if (n === Be.VIEW_MATRIX)
      r.value = t.modelViewMatrix;
    else if (n === Be.NORMAL_MATRIX)
      r.value = t.normalMatrix;
    else if (n === Be.WORLD_MATRIX)
      r.value = t.matrixWorld;
    else if (n === Be.POSITION)
      r.value = r.value || new ye(), r.value.setFromMatrixPosition(t.matrixWorld);
    else if (n === Be.SCALE)
      r.value = r.value || new ye(), r.value.setFromMatrixScale(t.matrixWorld);
    else if (n === Be.DIRECTION)
      r.value = r.value || new ye(), t.getWorldDirection(r.value);
    else if (n === Be.VIEW_POSITION) {
      const s = e.camera;
      r.value = r.value || new ye(), r.value.setFromMatrixPosition(t.matrixWorld), r.value.applyMatrix4(s.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return t === Be.WORLD_MATRIX || t === Be.VIEW_MATRIX ? this._uniformNode.nodeType = "mat4" : t === Be.NORMAL_MATRIX ? this._uniformNode.nodeType = "mat3" : (t === Be.POSITION || t === Be.VIEW_POSITION || t === Be.DIRECTION || t === Be.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Be.VIEW_MATRIX = "viewMatrix";
Be.NORMAL_MATRIX = "normalMatrix";
Be.WORLD_MATRIX = "worldMatrix";
Be.POSITION = "position";
Be.SCALE = "scale";
Be.VIEW_POSITION = "viewPosition";
Be.DIRECTION = "direction";
const gn = Be, ow = J(Be, Be.DIRECTION), iw = J(Be, Be.VIEW_MATRIX), aw = J(Be, Be.NORMAL_MATRIX), cw = J(Be, Be.WORLD_MATRIX), ka = J(Be, Be.POSITION), lw = J(Be, Be.SCALE), Nh = J(Be, Be.VIEW_POSITION);
re("Object3DNode", Be);
class it extends gn {
  constructor(e = it.POSITION) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? "mat4" : t === it.NEAR || t === it.FAR ? "float" : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera, r = this._uniformNode, n = this.scope;
    n === it.VIEW_MATRIX ? r.value = t.matrixWorldInverse : n === it.PROJECTION_MATRIX ? r.value = t.projectionMatrix : n === it.NEAR ? r.value = t.near : n === it.FAR ? r.value = t.far : (this.object3d = t, super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? this._uniformNode.nodeType = "mat4" : (t === it.NEAR || t === it.FAR) && (this._uniformNode.nodeType = "float"), super.generate(e);
  }
}
it.PROJECTION_MATRIX = "projectionMatrix";
it.NEAR = "near";
it.FAR = "far";
const wh = it, hs = eh(ue(it, it.PROJECTION_MATRIX), "projectionMatrix"), Sa = ue(it, it.NEAR), _a = ue(it, it.FAR), Rs = ue(it, it.VIEW_MATRIX), uw = ue(it, it.NORMAL_MATRIX), hw = ue(it, it.WORLD_MATRIX), dw = ue(it, it.POSITION);
re("CameraNode", it);
class jt extends gn {
  constructor(e = jt.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
const fw = jt, pw = ue(jt, jt.DIRECTION), Zs = ue(jt, jt.VIEW_MATRIX).temp("ModelViewMatrix"), Th = ue(jt, jt.NORMAL_MATRIX), ci = ue(jt, jt.WORLD_MATRIX), mw = ue(jt, jt.POSITION), gw = ue(jt, jt.SCALE), yw = ue(jt, jt.VIEW_POSITION);
re("ModelNode", jt);
class Rt extends Oe {
  constructor(e = Rt.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Rt.GEOMETRY)
      r = Mt("normal", "vec3");
    else if (t === Rt.LOCAL)
      r = ct(li);
    else if (t === Rt.VIEW) {
      const n = Th.mul(Mr);
      r = Ln(ct(n));
    } else if (t === Rt.WORLD) {
      const n = ps.transformDirection(Rs);
      r = Ln(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Rt.GEOMETRY = "geometry";
Rt.LOCAL = "local";
Rt.VIEW = "view";
Rt.WORLD = "world";
const qo = Rt, li = ue(Rt, Rt.GEOMETRY), Mr = ue(Rt, Rt.LOCAL).temp("Normal"), ps = ue(Rt, Rt.VIEW), gc = ue(Rt, Rt.WORLD), Ct = An("vec3", "TransformedNormalView"), a0 = Ct.transformDirection(Rs).normalize(), gr = An("vec3", "TransformedClearcoatNormalView");
re("NormalNode", Rt);
const ip = /* @__PURE__ */ new Map();
class ce extends Oe {
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, t) {
    let r = ip.get(e);
    return r === void 0 && (r = i0(e, t), ip.set(e, r)), r;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const t = e.context.material, r = this.scope;
    let n = null;
    if (r === ce.COLOR) {
      const s = this.getColor(r);
      t.map && t.map.isTexture === !0 ? n = s.mul(this.getTexture("map")) : n = s;
    } else if (r === ce.OPACITY) {
      const s = this.getFloat(r);
      t.alphaMap && t.alphaMap.isTexture === !0 ? n = s.mul(this.getTexture("alpha")) : n = s;
    } else if (r === ce.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? n = this.getTexture(r).r : n = Se(1);
    else if (r === ce.ROUGHNESS) {
      const s = this.getFloat(r);
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).g) : n = s;
    } else if (r === ce.METALNESS) {
      const s = this.getFloat(r);
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).b) : n = s;
    } else if (r === ce.EMISSIVE) {
      const s = this.getColor(r);
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? n = s.mul(this.getTexture(r)) : n = s;
    } else if (r === ce.NORMAL)
      t.normalMap ? n = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2")) : t.bumpMap ? n = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")) : n = ps;
    else if (r === ce.CLEARCOAT) {
      const s = this.getFloat(r);
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? n = s.mul(this.getTexture(r).r) : n = s;
    } else if (r === ce.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat(r);
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).r) : n = s;
    } else if (r === ce.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap ? n = this.getTexture(r).normalMap(this.getCache(r + "Scale", "vec2")) : n = ps;
    else if (r === ce.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenColor").rgb) : n = s;
    } else if (r === ce.SHEEN_ROUGHNESS) {
      const s = this.getFloat(r);
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).a) : n = s, n = n.clamp(0.07, 1);
    } else if (r === ce.IRIDESCENCE_THICKNESS) {
      const s = Cs(1, "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = Cs(0, "float", t.iridescenceThicknessRange);
        n = s.sub(o).mul(this.getTexture(r).g).add(o);
      } else
        n = s;
    } else {
      const s = this.getNodeType(e);
      n = this.getCache(r, s);
    }
    return n;
  }
}
ce.ALPHA_TEST = "alphaTest";
ce.COLOR = "color";
ce.OPACITY = "opacity";
ce.SHININESS = "shininess";
ce.SPECULAR_COLOR = "specular";
ce.SPECULAR_STRENGTH = "specularStrength";
ce.REFLECTIVITY = "reflectivity";
ce.ROUGHNESS = "roughness";
ce.METALNESS = "metalness";
ce.NORMAL = "normal";
ce.CLEARCOAT = "clearcoat";
ce.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
ce.CLEARCOAT_NORMAL = "clearcoatNormal";
ce.EMISSIVE = "emissive";
ce.ROTATION = "rotation";
ce.SHEEN = "sheen";
ce.SHEEN_ROUGHNESS = "sheenRoughness";
ce.IRIDESCENCE = "iridescence";
ce.IRIDESCENCE_IOR = "iridescenceIOR";
ce.IRIDESCENCE_THICKNESS = "iridescenceThickness";
ce.LINE_SCALE = "scale";
ce.LINE_DASH_SIZE = "dashSize";
ce.LINE_GAP_SIZE = "gapSize";
ce.LINE_WIDTH = "linewidth";
ce.LINE_DASH_OFFSET = "dashOffset";
ce.POINT_WIDTH = "pointWidth";
const ws = ce, c0 = ue(ce, ce.ALPHA_TEST), bo = ue(ce, ce.COLOR), l0 = ue(ce, ce.SHININESS), u0 = ue(ce, ce.EMISSIVE), Sh = ue(ce, ce.OPACITY), h0 = ue(ce, ce.SPECULAR_COLOR), d0 = ue(ce, ce.SPECULAR_STRENGTH), vw = ue(ce, ce.REFLECTIVITY), f0 = ue(ce, ce.ROUGHNESS), p0 = ue(ce, ce.METALNESS), m0 = ue(ce, ce.NORMAL), g0 = ue(ce, ce.CLEARCOAT), y0 = ue(ce, ce.CLEARCOAT_ROUGHNESS), v0 = ue(ce, ce.CLEARCOAT_NORMAL), x0 = ue(ce, ce.ROTATION), b0 = ue(ce, ce.SHEEN), N0 = ue(ce, ce.SHEEN_ROUGHNESS), w0 = ue(ce, ce.IRIDESCENCE), T0 = ue(ce, ce.IRIDESCENCE_IOR), S0 = ue(ce, ce.IRIDESCENCE_THICKNESS), Ga = ue(ce, ce.LINE_SCALE), _h = ue(ce, ce.LINE_DASH_SIZE), Mh = ue(ce, ce.LINE_GAP_SIZE), Yr = ue(ce, ce.LINE_WIDTH), eu = ue(ce, ce.LINE_DASH_OFFSET), _0 = ue(ce, ce.POINT_WIDTH);
re("MaterialNode", ce);
class lt extends Oe {
  constructor(e = lt.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === lt.GEOMETRY)
      r = Mt("position", "vec3");
    else if (t === lt.LOCAL)
      r = ct(tn);
    else if (t === lt.WORLD) {
      const n = ci.mul(rn);
      r = ct(n);
    } else if (t === lt.VIEW) {
      const n = Zs.mul(rn);
      r = ct(n);
    } else if (t === lt.VIEW_DIRECTION) {
      const n = ns.negate();
      r = Ln(ct(n));
    } else if (t === lt.WORLD_DIRECTION) {
      const n = rn.transformDirection(ci);
      r = Ln(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
lt.GEOMETRY = "geometry";
lt.LOCAL = "local";
lt.WORLD = "world";
lt.WORLD_DIRECTION = "worldDirection";
lt.VIEW = "view";
lt.VIEW_DIRECTION = "viewDirection";
const Bs = lt, tn = ue(lt, lt.GEOMETRY), rn = ue(lt, lt.LOCAL).temp("Position"), Ah = ue(lt, lt.WORLD), Ch = ue(lt, lt.WORLD_DIRECTION), ns = ue(lt, lt.VIEW), Pt = ue(lt, lt.VIEW_DIRECTION);
re("PositionNode", lt);
class Eh extends St {
  constructor(e = rn) {
    super("vec4"), this.positionNode = e;
  }
  setup() {
    return hs.mul(Zs).mul(this.positionNode);
  }
}
const M0 = Eh, A0 = J(Eh);
re("ModelViewProjectionNode", Eh);
class Rh extends Uu {
  constructor(e, t = null, r = 0, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = r, this.bufferOffset = n, this.usage = ub, this.instanced = !1, this.attribute = null, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null)
      return;
    const t = this.getNodeType(e), r = this.value, n = e.getTypeLength(t), s = this.bufferStride || n, o = this.bufferOffset, i = r.isInterleavedBuffer === !0 ? r : new Om(r, s), a = new js(i, n, o);
    i.setUsage(this.usage), this.attribute = a, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const t = this.getNodeType(e), r = e.getBufferAttributeFromNode(this, t), n = e.getPropertyName(r);
    let s = null;
    return e.shaderStage === "vertex" ? s = n : s = ct(this).build(e, t), s;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const xw = Rh, Ai = (c, e, t, r) => Me(new Rh(c, e, t, r)), C0 = (c, e, t, r) => Ai(c, e, t, r).setUsage(Tu), E0 = (c, e, t, r) => Ai(c, e, t, r).setInstanced(!0), R0 = (c, e, t, r) => C0(c, e, t, r).setInstanced(!0);
V("toAttribute", (c) => Ai(c.value));
re("BufferAttributeNode", Rh);
class Lh extends Oe {
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null;
  }
  setup() {
    let e = this.instanceMatrixNode;
    if (e === null) {
      const i = this.instanceMesh.instanceMatrix, a = new Oa(i.array, 16, 1), l = i.usage === Tu ? R0 : E0, u = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        l(a, "vec4", 16, 0),
        l(a, "vec4", 16, 4),
        l(a, "vec4", 16, 8),
        l(a, "vec4", 16, 12)
      ];
      e = Vu(...u), this.instanceMatrixNode = e;
    }
    const t = e.mul(rn).xyz, r = Ms(e[0].xyz, e[1].xyz, e[2].xyz), n = Mr.div(Ce(r[0].dot(r[0]), r[1].dot(r[1]), r[2].dot(r[2]))), s = r.mul(n).xyz;
    rn.assign(t), Mr.assign(s);
  }
}
const bw = Lh, L0 = J(Lh);
re("InstanceNode", Lh);
class Oh extends nt {
  constructor(e, t, r = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = r;
  }
  getInputType() {
    return "buffer";
  }
}
const Fh = Oh, Ih = (c, e, t) => Me(new Oh(c, e, t));
re("BufferNode", Oh);
class At extends Oe {
  constructor(e = At.LOCAL) {
    super(), this.scope = e;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === At.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === At.GEOMETRY)
      r = Mt("tangent", "vec4");
    else if (t === At.LOCAL)
      r = ct(ui.xyz);
    else if (t === At.VIEW) {
      const n = Zs.mul(yc).xyz;
      r = Ln(ct(n));
    } else if (t === At.WORLD) {
      const n = Ci.transformDirection(Rs);
      r = Ln(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
At.GEOMETRY = "geometry";
At.LOCAL = "local";
At.VIEW = "view";
At.WORLD = "world";
const to = At, ui = ue(At, At.GEOMETRY), yc = ue(At, At.LOCAL), Ci = ue(At, At.VIEW), O0 = ue(At, At.WORLD), Ph = vo(Ci, "TransformedTangentView"), Nw = Ln(Ph.transformDirection(Rs));
re("TangentNode", At);
class Dh extends Oe {
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = ht.OBJECT, this.skinIndexNode = Mt("skinIndex", "uvec4"), this.skinWeightNode = Mt("skinWeight", "vec4"), this.bindMatrixNode = Ft(e.bindMatrix, "mat4"), this.bindMatrixInverseNode = Ft(e.bindMatrixInverse, "mat4"), this.boneMatricesNode = Ih(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length);
  }
  setup(e) {
    const { skinIndexNode: t, skinWeightNode: r, bindMatrixNode: n, bindMatrixInverseNode: s, boneMatricesNode: o } = this, i = o.element(t.x), a = o.element(t.y), l = o.element(t.z), u = o.element(t.w), h = n.mul(rn), d = ts(
      i.mul(r.x).mul(h),
      a.mul(r.y).mul(h),
      l.mul(r.z).mul(h),
      u.mul(r.w).mul(h)
    ), f = s.mul(d).xyz;
    let p = ts(
      r.x.mul(i),
      r.y.mul(a),
      r.z.mul(l),
      r.w.mul(u)
    );
    p = s.mul(p).mul(n);
    const m = p.transformDirection(Mr).xyz;
    rn.assign(f), Mr.assign(m), e.hasGeometryAttribute("tangent") && yc.assign(m);
  }
  generate(e, t) {
    if (t !== "void")
      return rn.build(e, t);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const F0 = Dh, I0 = J(Dh);
re("SkinningNode", Dh);
class Uh extends Oe {
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Ft(1), this.updateType = ht.OBJECT;
  }
  setupAttribute(e, t = rn) {
    const r = this.mesh, n = r.geometry.morphAttributes[e];
    t.mulAssign(this.morphBaseInfluence);
    for (let s = 0; s < n.length; s++) {
      const o = n[s], i = Ai(o.array, "vec3"), a = Cs(s, "float", r.morphTargetInfluences);
      t.addAssign(i.mul(a));
    }
  }
  setup() {
    this.setupAttribute("position");
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, r) => t + r, 0);
  }
}
const ww = Uh, P0 = J(Uh);
re("MorphNode", Uh);
class zh extends Oe {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return Pt.negate().reflect(Ct).transformDirection(Rs);
  }
}
const D0 = zh, U0 = ue(zh);
re("ReflectVectorNode", zh);
class Bh extends Mi {
  constructor(e, t = null, r = null) {
    super(e, t, r), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return U0;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.value;
    if (!s || s.isCubeTexture !== !0)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const o = nt.prototype.generate.call(this, e, "cubeTexture");
    if (t === "sampler")
      return o + "_sampler";
    if (e.isReference(t))
      return o;
    {
      const i = e.getDataFromNode(this);
      let a = i.propertyName;
      if (a === void 0) {
        const d = Ce(r.x.negate(), r.yz).build(e, "vec3"), f = e.getVarFromNode(this);
        a = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(this, o, d, m);
        } else
          p = e.getTexture(this, o, d);
        e.addLineFlowCode(`${a} = ${p}`), e.context.tempWrite !== !1 && (i.snippet = p, i.propertyName = a);
      }
      let l = a;
      const u = this.getNodeType(e);
      return e.needsColorSpaceToLinear(this.value) && (l = pc(_i(l, u), this.value.colorSpace).setup(e).build(e, u)), e.format(l, u, t);
    }
  }
}
const z0 = Bh, vc = J(Bh);
V("cubeTexture", vc);
re("CubeTextureNode", Bh);
class B0 extends Oe {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Ei = B0;
re("LightingNode", B0);
let sl = null;
class k0 extends Ei {
  constructor(e = null) {
    super(), this.updateType = ht.FRAME, this.light = e, this.rtt = null, this.shadowNode = null, this.color = new je(), this.colorNode = Ft(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    let t = this.shadowNode;
    if (t === null) {
      sl === null && (sl = e.createNodeMaterial("MeshBasicNodeMaterial"));
      const r = this.light.shadow, n = e.getRenderTarget(r.mapSize.width, r.mapSize.height), s = new Fm();
      s.minFilter = Ws, s.magFilter = Ws, s.image.width = r.mapSize.width, s.image.height = r.mapSize.height, s.compareFunction = hb, n.depthTexture = s, r.camera.updateProjectionMatrix();
      const o = Cs("bias", "float", r), i = Cs("normalBias", "float", r);
      let a = Ft(r.matrix).mul(Ah.add(gc.mul(i)));
      a = a.xyz.div(a.w);
      const l = a.x.greaterThanEqual(0).and(a.x.lessThanEqual(1)).and(a.y.greaterThanEqual(0)).and(a.y.lessThanEqual(1)).and(a.z.lessThanEqual(1));
      e.renderer.coordinateSystem === db ? a = Ce(
        a.x,
        a.y.oneMinus(),
        // WebGPU: Flip Y
        a.z.add(o).mul(2).sub(1)
        // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
      ) : a = Ce(
        a.x,
        a.y,
        a.z.add(o)
      ), t = ((h, d, f) => En(h, d).compare(f))(s, a.xy, a.z), this.rtt = n, this.colorNode = this.colorNode.mul(l.mix(1, t)), this.shadowNode = t, this.updateBeforeType = ht.RENDER;
    }
  }
  setup(e) {
    this.light.castShadow && this.setupShadow(e);
  }
  updateShadow(e) {
    const { rtt: t, light: r } = this, { renderer: n, scene: s } = e;
    s.overrideMaterial = sl, t.setSize(r.shadow.mapSize.width, r.shadow.mapSize.height), r.shadow.updateMatrices(r), n.setRenderTarget(t), n.render(s, r.shadow.camera), n.setRenderTarget(null), s.overrideMaterial = null;
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const rr = k0;
re("AnalyticLightNode", k0);
const Va = /* @__PURE__ */ new WeakMap(), Tw = (c) => c.sort((e, t) => e.id - t.id);
class kh extends Oe {
  constructor(e = []) {
    super("vec3"), this.totalDiffuseNode = Ce().temp("totalDiffuse"), this.totalSpecularNode = Ce().temp("totalSpecular"), this.outgoingLightNode = Ce().temp("outgoingLight"), this.lightNodes = e, this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  setup(e) {
    const t = e.context, r = t.lightingModel;
    let n = this.outgoingLightNode;
    if (r) {
      const { lightNodes: s, totalDiffuseNode: o, totalSpecularNode: i } = this;
      t.outgoingLight = n;
      const a = e.addStack();
      r.start(t, a, e);
      for (const g of s)
        g.build(e);
      r.indirectDiffuse(t, a, e), r.indirectSpecular(t, a, e), r.ambientOcclusion(t, a, e);
      const { backdrop: l, backdropAlpha: u } = t, { directDiffuse: h, directSpecular: d, indirectDiffuse: f, indirectSpecular: p } = t.reflectedLight;
      let m = h.add(f);
      l !== null && (m = Ce(u !== null ? u.mix(m, l) : l)), o.assign(m), i.assign(d.add(p)), n.assign(o.add(i)), r.finish(t, a, e), n = n.bypass(e.removeStack());
    }
    return n;
  }
  getHash(e) {
    if (this._hash === null) {
      let t = "";
      const r = this.lightNodes;
      for (const n of r)
        t += n.getHash(e) + " ";
      this._hash = t;
    }
    return this._hash;
  }
  getLightNodeByHash(e) {
    const t = this.lightNodes;
    for (const r of t)
      if (r.light.uuid === e)
        return r;
    return null;
  }
  fromLights(e = []) {
    const t = [];
    e = Tw(e);
    for (const r of e) {
      let n = this.getLightNodeByHash(r.uuid);
      if (n === null) {
        const s = r.constructor, o = Va.has(s) ? Va.get(s) : rr;
        n = Me(new o(r));
      }
      t.push(n);
    }
    return this.lightNodes = t, this._hash = null, this;
  }
}
const G0 = kh, Sw = (c) => Me(new kh().fromLights(c)), V0 = J(kh);
function Rr(c, e) {
  if (Va.has(c))
    throw new Error(`Redefinition of light node ${e.type}`);
  if (typeof c != "function")
    throw new Error(`Light ${c.name} is not a class`);
  if (typeof e != "function" || !e.type)
    throw new Error(`Light node ${e.type} is not a class`);
  Va.set(c, e);
}
class j0 extends Ei {
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    const r = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(r);
  }
}
const Gh = j0;
re("AONode", j0);
class Vh extends Qu {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.lightingModel = t, this.backdropNode = r, this.backdropAlphaNode = n, this._context = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this, r = Ce().temp("directDiffuse"), n = Ce().temp("directSpecular"), s = Ce().temp("indirectDiffuse"), o = Ce().temp("indirectSpecular"), i = {
      directDiffuse: r,
      directSpecular: n,
      indirectDiffuse: s,
      indirectSpecular: o
    };
    return {
      radiance: Ce().temp("radiance"),
      irradiance: Ce().temp("irradiance"),
      iblIrradiance: Ce().temp("iblIrradiance"),
      ambientOcclusion: Se(1).temp("ambientOcclusion"),
      reflectedLight: i,
      backdrop: e,
      backdropAlpha: t
    };
  }
  setup(e) {
    return this.context = this._context || (this._context = this.getContext()), this.context.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const _w = Vh, jh = J(Vh);
V("lightingContext", jh);
re("LightingContextNode", Vh);
class Wh extends St {
  constructor(e = Ch) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, t = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), r = e.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return rt(t, r);
  }
}
const W0 = Wh, xc = J(Wh);
re("EquirectUVNode", Wh);
class Hh extends nt {
  constructor(e) {
    super(0), this.textureNode = e, this.updateType = ht.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, r = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (r && r.width !== void 0) {
      const { width: n, height: s } = r;
      this.value = Math.log2(Math.max(n, s));
    }
  }
}
const H0 = Hh, Xh = J(Hh);
re("MaxMipLevelNode", Hh);
class $h extends Oe {
  constructor(e, t = null) {
    super("float"), this.textureNode = e, this.roughnessNode = t;
  }
  setup() {
    const { textureNode: e, roughnessNode: t } = this, r = Xh(e), n = t.mul(t).mul(Math.PI).div(t.add(1));
    return r.add(n.log2()).clamp(0, r);
  }
}
const X0 = $h, qh = J($h);
re("SpecularMIPLevelNode", $h);
const ap = /* @__PURE__ */ new WeakMap();
class $0 extends Ei {
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    let t = this.envNode;
    if (t.isTextureNode && t.value.isCubeTexture !== !0) {
      let a = ap.get(t.value);
      if (a === void 0) {
        const l = t.value, u = e.renderer, h = e.getCubeRenderTarget(512).fromEquirectangularTexture(u, l);
        a = vc(h.texture), ap.set(t.value, a);
      }
      t = a;
    }
    const r = Cs("envMapIntensity", "float", e.material), n = Zn(t, cp(uo, Ct)).mul(r), s = Zn(t, Mw(a0)).mul(Math.PI).mul(r), o = Pa(n);
    e.context.radiance.addAssign(o), e.context.iblIrradiance.addAssign(s);
    const i = e.context.lightingModel.clearcoatRadiance;
    if (i) {
      const a = Zn(t, cp(ii, gr)).mul(r), l = Pa(a);
      i.addAssign(l);
    }
  }
}
const cp = (c, e) => {
  let t = null, r = null;
  return {
    getUVNode: (n) => {
      let s = null;
      return t === null && (t = Pt.negate().reflect(e), t = c.mul(c).mix(t, e).normalize(), t = t.transformDirection(Rs)), n.isCubeTextureNode ? s = t : n.isTextureNode && (r === null && (r = xc(t)), s = r), s;
    },
    getSamplerLevelNode: () => c,
    getMIPLevelAlgorithmNode: (n, s) => qh(n, s)
  };
}, Mw = (c) => {
  let e = null;
  return {
    getUVNode: (t) => {
      let r = null;
      return t.isCubeTextureNode ? r = c : t.isTextureNode && (e === null && (e = xc(c), e = rt(e.x, e.y.oneMinus())), r = e), r;
    },
    getSamplerLevelNode: () => Se(1),
    getMIPLevelAlgorithmNode: (t, r) => qh(t, r)
  };
}, Jh = $0;
re("EnvironmentNode", $0);
const tu = /* @__PURE__ */ new Map();
class Yt extends fs {
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.unlit = this.constructor === Yt.prototype.constructor, this.fog = !0, this.lights = !0, this.normals = !0, this.colorSpace = !0, this.lightsNode = null, this.envNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.outputNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + sc(this);
  }
  build(e) {
    this.setup(e);
  }
  setup(e) {
    e.addStack(), e.stack.outputNode = this.setupPosition(e), e.addFlow("vertex", e.removeStack()), e.addStack();
    let t;
    if (this.unlit === !1) {
      this.normals === !0 && this.setupNormal(e), this.setupDiffuseColor(e), this.setupVariants(e);
      const r = this.setupLighting(e);
      t = this.setupOutput(e, st(r, qt.a)), Jg.assign(t), this.outputNode !== null && (t = this.outputNode);
    } else
      t = this.setupOutput(e, this.outputNode || st(0, 0, 0, 1));
    e.stack.outputNode = t, e.addFlow("fragment", e.removeStack());
  }
  setupPosition(e) {
    const t = e.object, r = t.geometry;
    return e.addStack(), (r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color) && P0(t).append(), t.isSkinnedMesh === !0 && I0(t).append(), t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && e.isAvailable("instance") === !0 && L0(t).append(), this.positionNode !== null && rn.assign(this.positionNode), e.context.vertex = e.removeStack(), this.vertexNode || A0();
  }
  setupDiffuseColor({ geometry: e }) {
    let t = this.colorNode ? st(this.colorNode) : bo;
    this.vertexColors === !0 && e.hasAttribute("color") && (t = st(t.xyz.mul(Mt("color")), t.a)), qt.assign(t);
    const r = this.opacityNode ? Se(this.opacityNode) : Sh;
    if (qt.a.assign(qt.a.mul(r)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const n = this.alphaTestNode !== null ? Se(this.alphaTestNode) : c0;
      qt.a.lessThanEqual(n).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === !0) {
      const e = ns.dFdx().cross(ns.dFdy()).normalize();
      Ct.assign(e);
    } else {
      const e = this.normalNode ? Ce(this.normalNode) : m0;
      Ct.assign(e);
    }
  }
  getEnvNode(e) {
    let t = null;
    return this.envNode ? t = this.envNode : this.envMap ? t = this.envMap.isCubeTexture ? vc(this.envMap) : En(this.envMap) : e.environmentNode && (t = e.environmentNode), t;
  }
  setupLights(e) {
    const t = this.getEnvNode(e), r = [];
    t && r.push(new Jh(t)), e.material.aoMap && r.push(new Gh(En(e.material.aoMap)));
    let n = this.lightsNode || e.lightsNode;
    return r.length > 0 && (n = V0([...n.lightNodes, ...r])), n;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: t } = e, { backdropNode: r, backdropAlphaNode: n, emissiveNode: s } = this, i = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let a = qt.rgb;
    if (i && i.hasLight !== !1) {
      const l = this.setupLightingModel(e);
      a = jh(i, l, r, n);
    } else
      r !== null && (a = Ce(n !== null ? bn(a, r, n) : r));
    return (s && s.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (a = a.add(Ce(s || u0))), a;
  }
  setupOutput(e, t) {
    const r = e.renderer, n = e.toneMappingNode;
    if (n && (t = st(n.context({ color: t.rgb }), t.a)), this.fog === !0) {
      const s = e.fogNode;
      s && (t = st(s.mixAssign(t.rgb), t.a));
    }
    if (this.colorSpace === !0) {
      const s = r.getRenderTarget();
      let o;
      s !== null ? Array.isArray(s.texture) ? o = s.texture[0].colorSpace : o = s.texture.colorSpace : o = r.outputColorSpace, o !== Rn && o !== Im && (t = t.linearToColorSpace(o));
    }
    return t;
  }
  setDefaultValues(e) {
    for (const r in e) {
      const n = e[r];
      this[r] === void 0 && (this[r] = n, n && n.clone && (this[r] = n.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const r in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, r) === void 0 && t[r].get !== void 0 && Object.defineProperty(this.constructor.prototype, r, t[r]);
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const r = kn.prototype.toJSON.call(this, e), n = ri(this);
    r.inputNodes = {};
    for (const { property: o, childNode: i } of n)
      r.inputNodes[o] = i.toJSON(e).uuid;
    function s(o) {
      const i = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, i.push(l);
      }
      return i;
    }
    if (t) {
      const o = s(e.textures), i = s(e.images), a = s(e.nodes);
      o.length > 0 && (r.textures = o), i.length > 0 && (r.images = i), a.length > 0 && (r.nodes = a);
    }
    return r;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.outputNode = e.outputNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
  static fromMaterial(e) {
    if (e.isNodeMaterial === !0)
      return e;
    const t = e.type.replace("Material", "NodeMaterial"), r = _o(t);
    if (r === void 0)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const n in e)
      r[n] = e[n];
    return r;
  }
}
function cn(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node material ${c} is not a class`);
  if (tu.has(c))
    throw new Error(`Redefinition of node material ${c}`);
  tu.set(c, e), e.type = c;
}
function _o(c) {
  const e = tu.get(c);
  if (e !== void 0)
    return new e();
}
cn("NodeMaterial", Yt);
const Aw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addNodeMaterial: cn,
  createNodeMaterialFromType: _o,
  default: Yt
}, Symbol.toStringTag, { value: "Module" }));
class Lr {
  constructor(e, t = null) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class Cw extends Lr {
  constructor(e, t = 0) {
    super(e, t), this.isFloatUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class Ew extends Lr {
  constructor(e, t = new Tt()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class Rw extends Lr {
  constructor(e, t = new ye()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class Lw extends Lr {
  constructor(e, t = new mt()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class Ow extends Lr {
  constructor(e, t = new je()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class Fw extends Lr {
  constructor(e, t = new Ts()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class Iw extends Lr {
  constructor(e, t = new Ge()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class Pw extends Cw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Dw extends Ew {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Uw extends Rw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class zw extends Lw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Bw extends Ow {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class kw extends Fw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Gw extends Iw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Yh extends Oe {
  constructor(e, t, r = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = r;
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const r = this.elseNode.getNodeType(e);
      if (e.getTypeLength(r) > e.getTypeLength(t))
        return r;
    }
    return t;
  }
  generate(e) {
    const t = this.getNodeType(e), r = { tempWrite: !1 }, { ifNode: n, elseNode: s } = this, o = n.getNodeType(e) !== "void" || s && s.getNodeType(e) !== "void", i = o ? An(t).build(e) : "", a = Zn(
      this.condNode
      /*, context*/
    ).build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${a} ) {

`).addFlowTab();
    let l = Zn(this.ifNode, r).build(e, t);
    if (l = o ? i + " = " + l + ";" : l, e.removeFlowTab().addFlowCode(e.tab + "	" + l + `

` + e.tab + "}"), s !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let u = Zn(s, r).build(e, t);
      u = i ? i + " = " + u + ";" : u, e.removeFlowTab().addFlowCode(e.tab + "	" + u + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return i;
  }
}
const Kh = Yh, br = J(Yh);
V("cond", br);
re("CondNode", Yh);
class Zh extends Oe {
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  if(e, t) {
    const r = new yr(t);
    return this._currentCond = br(e, r), this.add(this._currentCond);
  }
  elseif(e, t) {
    const r = new yr(t), n = br(e, r);
    return this._currentCond.elseNode = n, this._currentCond = n, this;
  }
  else(e) {
    return this._currentCond.elseNode = new yr(e), this;
  }
  build(e, ...t) {
    const r = Gu();
    oi(this);
    for (const n of this.nodes)
      n.build(e, "void");
    return oi(r), this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
  }
}
const Vw = Zh, nu = J(Zh);
re("StackNode", Zh);
class jw extends fb {
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, t) {
    const r = t.minFilter, n = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const s = new Za(5, 5, 5), o = xc(Ch), i = _o("MeshBasicNodeMaterial");
    i.colorNode = En(t, o, 0), i.side = Su, i.blending = pb;
    const a = new Jt(s, i), l = new Qa();
    return l.add(a), t.minFilter === To && (t.minFilter = po), new mb(1, 10, this).update(e, l), t.minFilter = r, t.currentGenerateMipmaps = n, a.geometry.dispose(), a.material.dispose(), this;
  }
}
const Ww = jw, Hw = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), Xw = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), $w = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]), qi = (c) => (c = Number(c), c + (c % 1 ? "" : ".0"));
class qw {
  constructor(e, t, r, n = null, s = null) {
    this.object = e, this.material = s || e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = r, this.scene = n, this.nodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.hashNodes = {}, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.toneMappingNode = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: [] }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: [], fragment: [], compute: [] }, this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }, this.bindingsArray = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = nu(), this.stacks = [], this.tab = "	", this.context = {
      keywords: new oh(),
      material: this.material,
      getMIPLevelAlgorithmNode: (o, i) => i.mul(Xh(o))
    }, this.cache = new cc(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  getRenderTarget(e, t, r) {
    return new gb(e, t, r);
  }
  getCubeRenderTarget(e, t) {
    return new Ww(e, t);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  getBindings() {
    let e = this.bindingsArray;
    if (e === null) {
      const t = this.bindings;
      this.bindingsArray = e = this.material !== null ? [...t.vertex, ...t.fragment] : t.compute;
    }
    return e;
  }
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  buildUpdateNodes() {
    for (const e of this.nodes) {
      const t = e.getUpdateType(), r = e.getUpdateBeforeType();
      t !== ht.NONE && this.updateNodes.push(e.getSelf()), r !== ht.NONE && this.updateBeforeNodes.push(e);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new je() : e === "vec2" ? t = new Tt() : e === "vec3" ? t = new ye() : e === "vec4" && (t = new mt())), e === "float")
      return qi(t);
    if (e === "int")
      return `${Math.round(t)}`;
    if (e === "uint")
      return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool")
      return t ? "true" : "false";
    if (e === "color")
      return `${this.getType("vec3")}( ${qi(t.r)}, ${qi(t.g)}, ${qi(t.b)} )`;
    const r = this.getTypeLength(e), n = this.getComponentType(e), s = (o) => this.getConst(n, o);
    if (r === 2)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (r === 3)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (r === 4)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (r > 4 && t && (t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (r > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  generateMethod(e) {
    return e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, t) {
    const r = this.attributes;
    for (const s of r)
      if (s.name === e)
        return s;
    const n = new Da(e, t);
    return r.push(n), n;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(e) {
    return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."), this.getTextureColorSpaceFromMap(e) === vn ? yb : vb;
  }
  getTextureColorSpaceFromMap(e) {
    let t;
    return e && e.isTexture ? t = e.colorSpace : e && e.isWebGLRenderTarget ? t = e.texture.colorSpace : t = Im, t;
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint")
      return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" ? "vec4" : e;
  }
  getTypeFromLength(e, t = "float") {
    if (e === 1)
      return t;
    const r = Hw.get(e);
    return (t === "float" ? "" : t[0]) + r;
  }
  getTypeFromArray(e) {
    return Xw.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const r = t.array, n = $w.has(r.constructor) ? e.itemSize : t.stride || e.itemSize, s = e.normalized;
    let o;
    return !(e instanceof xb) && s !== !0 && (o = this.getTypeFromArray(r)), this.getTypeFromLength(n, o);
  }
  getTypeLength(e) {
    const t = this.getVectorType(e), r = /vec([2-4])/.exec(t);
    return r !== null ? Number(r[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = nu(this.stack), this.stacks.push(Gu() || this.stack), oi(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, oi(this.stacks.pop()), e;
  }
  getDataFromNode(e, t = this.shaderStage) {
    const r = e.isGlobal(this) ? this.globalCache : this.cache;
    let n = r.getNodeData(e);
    return n === void 0 && (n = {}, r.setNodeData(e, n)), n[t] === void 0 && (n[t] = {}), n[t];
  }
  getNodeProperties(e, t = "any") {
    const r = this.getDataFromNode(e, t);
    return r.properties || (r.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, t) {
    const r = this.getDataFromNode(e);
    let n = r.bufferAttribute;
    if (n === void 0) {
      const s = this.uniforms.index++;
      n = new Da("nodeAttribute" + s, t, e), this.bufferAttributes.push(n), r.bufferAttribute = n;
    }
    return n;
  }
  getStructTypeFromNode(e, t = this.shaderStage, r = null) {
    const n = this.getDataFromNode(e, t);
    if (n.structType === void 0) {
      const o = this.structs.index++;
      e.name = `StructType${o}`, this.structs[t].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, t, r = this.shaderStage, n = null) {
    const s = this.getDataFromNode(e, r);
    let o = s.uniform;
    if (o === void 0) {
      const i = this.uniforms.index++;
      o = new nh(n || "nodeUniform" + i, t, e), this.uniforms[r].push(o), s.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, t = null, r = e.getNodeType(this), n = this.shaderStage) {
    const s = this.getDataFromNode(e, n);
    let o = s.variable;
    if (o === void 0) {
      const i = this.vars[n] || (this.vars[n] = []);
      t === null && (t = "nodeVar" + i.length), o = new lc(t, r), i.push(o), s.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, t) {
    const r = this.getDataFromNode(e, "any");
    let n = r.varying;
    if (n === void 0) {
      const s = this.varyings, o = s.length;
      n = new sh("nodeVarying" + o, t), s.push(n), r.varying = n;
    }
    return n;
  }
  getCodeFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e);
    let s = n.code;
    if (s === void 0) {
      const o = this.codes[r] || (this.codes[r] = []), i = o.length;
      s = new rh("nodeCode" + i, t), o.push(s), n.code = s;
    }
    return s;
  }
  addLineFlowCode(e) {
    return e === "" ? this : (e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const t = e.getNodeType(this), r = this.flowChildNode(e, t);
    return this.flowsData.set(e, r), r;
  }
  flowShaderNode(e) {
    const t = e.layout;
    let r;
    if (e.isArrayInput) {
      r = [];
      for (const o of t.inputs)
        r.push(new Ql(o.type, o.name));
    } else {
      r = {};
      for (const o of t.inputs)
        r[o.name] = new Ql(o.type, o.name);
    }
    e.layout = null;
    const n = e.call(r), s = this.flowStagesNode(n, t.type);
    return e.layout = t, s;
  }
  flowStagesNode(e, t = null) {
    const r = this.flow, n = this.vars, s = this.buildStage, o = {
      code: ""
    };
    this.flow = o, this.vars = {};
    for (const i of Jl)
      this.setBuildStage(i), o.result = e.build(this, t);
    return o.vars = this.getVars(this.shaderStage), this.flow = r, this.vars = n, this.setBuildStage(s), o;
  }
  flowChildNode(e, t = null) {
    const r = this.flow, n = {
      code: ""
    };
    return this.flow = n, n.result = e.build(this, t), this.flow = r, n;
  }
  flowNodeFromShaderStage(e, t, r = null, n = null) {
    const s = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(t, r);
    return n !== null && (o.code += `${this.tab + n} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(s), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, t) {
    return `${this.getType(e)} ${t}`;
  }
  getVars(e) {
    let t = "";
    const r = this.vars[e];
    if (r !== void 0)
      for (const n of r)
        t += `${this.getVar(n.type, n.name)}; `;
    return t;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const t = this.codes[e];
    let r = "";
    if (t !== void 0)
      for (const n of t)
        r += n.code + `
`;
    return r;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const e of Jl) {
      this.setBuildStage(e), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const t of sg) {
        this.setShaderStage(t);
        const r = this.flowNodes[t];
        for (const n of r)
          e === "generate" ? this.flowNode(n) : n.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, t) {
    if (t === "float")
      return new Pw(e);
    if (t === "vec2")
      return new Dw(e);
    if (t === "vec3")
      return new Uw(e);
    if (t === "vec4")
      return new zw(e);
    if (t === "color")
      return new Bw(e);
    if (t === "mat3")
      return new kw(e);
    if (t === "mat4")
      return new Gw(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  createNodeMaterial(e) {
    return _o(e);
  }
  getPrimitiveType(e) {
    let t;
    return e[0] === "i" ? t = "int" : e[0] === "u" ? t = "uint" : t = "float", t;
  }
  format(e, t, r) {
    if (t = this.getVectorType(t), r = this.getVectorType(r), t === r || r === null || this.isReference(r))
      return e;
    const n = this.getTypeLength(t), s = this.getTypeLength(r);
    return n > 4 || s > 4 || s === 0 ? e : n === s ? `${this.getType(r)}( ${e} )` : n > s ? this.format(`${e}.${"xyz".slice(0, s)}`, this.getTypeFromLength(s, this.getComponentType(t)), r) : s === 4 && n > 1 ? `${this.getType(r)}( ${this.format(e, t, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(r)}( ${this.format(e, t, "vec2")}, 0.0 )` : (n === 1 && s > 1 && t[0] !== r[0] && (e = `${this.getType(this.getPrimitiveType(r))}( ${e} )`), `${this.getType(r)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${bb} - NodeMaterial System
`;
  }
}
const q0 = qw;
class Jw {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, t) {
    let r = e.get(t);
    return r === void 0 && (r = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(t, r)), r;
  }
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateBeforeMap, r);
    t === ht.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.updateBefore(this)) : t === ht.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.updateBefore(this)) : t === ht.OBJECT && e.updateBefore(this);
  }
  updateNode(e) {
    const t = e.getUpdateType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateMap, r);
    t === ht.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.update(this)) : t === ht.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.update(this)) : t === ht.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
const Qh = Jw;
class J0 {
  constructor(e, t, r = null, n = "", s = !1) {
    this.type = e, this.name = t, this.count = r, this.qualifier = n, this.isConst = s;
  }
}
J0.isNodeFunctionInput = !0;
const ed = J0;
class Y0 extends Oe {
  constructor(e) {
    super(), this.types = e, this.isStructTypeNode = !0;
  }
  getMemberTypes() {
    return this.types;
  }
}
const Yw = Y0;
re("StructTypeNode", Y0);
class td extends Oe {
  constructor(...e) {
    super(), this.isOutputStructNode = !0, this.members = e;
  }
  setup(e) {
    super.setup(e);
    const t = this.members, r = [];
    for (let n = 0; n < t.length; n++)
      r.push(t[n].getNodeType(e));
    this.nodeType = e.getStructTypeFromNode(new Yw(r)).name;
  }
  generate(e, t) {
    const r = e.getVarFromNode(this);
    r.isOutputStructVar = !0;
    const n = e.getPropertyName(r), s = this.members, o = n !== "" ? n + "." : "";
    for (let i = 0; i < s.length; i++) {
      const a = s[i].build(e, t);
      e.addLineFlowCode(`${o}m${i} = ${a}`);
    }
    return n;
  }
}
const Kw = td, Zw = J(td);
re("OutputStructNode", td);
class nd extends Oe {
  constructor(e) {
    super(), this.seedNode = e;
  }
  setup() {
    const e = this.seedNode.uint().mul(747796405).add(2891336453), t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
    return t.shiftRight(22).bitXor(t).float().mul(1 / 2 ** 32);
  }
}
const Qw = nd, K0 = J(nd);
V("hash", K0);
re("HashNode", nd);
let rl;
class sd extends Kh {
  constructor(e) {
    rl = rl || _i("discard"), super(e, rl);
  }
}
const e2 = sd, t2 = J(sd), Z0 = (c) => t2(c).append();
V("discard", Z0);
re("DiscardNode", sd);
class rd extends Oe {
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode("i".charCodeAt() + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0)
      return t;
    const r = {};
    for (let n = 0, s = this.params.length - 1; n < s; n++) {
      const o = this.params[n], i = o.isNode !== !0 && o.name || this.getVarName(n), a = o.isNode !== !0 && o.type || "int";
      r[i] = _i(i, a);
    }
    return t.returnsNode = this.params[this.params.length - 1](r, e.addStack(), e), t.stackNode = e.removeStack(), t;
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e), r = { tempWrite: !1 }, n = this.params, s = t.stackNode;
    for (let a = 0, l = n.length - 1; a < l; a++) {
      const u = n[a];
      let h = null, d = null, f = null, p = null, m = null, g = null;
      u.isNode ? (p = "int", f = this.getVarName(a), h = "0", d = u.build(e, p), m = "<") : (p = u.type || "int", f = u.name || this.getVarName(a), h = u.start, d = u.end, m = u.condition, g = u.update, typeof h == "number" ? h = h.toString() : h && h.isNode && (h = h.build(e, p)), typeof d == "number" ? d = d.toString() : d && d.isNode && (d = d.build(e, p)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const b = { start: h, end: d, condition: m }, v = b.start, y = b.end;
      let x = "", N = "", w = "";
      g || (p === "int" ? m.includes("<") ? g = "++" : g = "--" : m.includes("<") ? g = "+= 1" : g = "-= 1"), x += e.getVar(p, f) + " = " + v, N += f + " " + m + " " + y, w += f + " " + g;
      const T = `for ( ${x}; ${N}; ${w} )`;
      e.addFlowCode((a === 0 ? `
` : "") + e.tab + T + ` {

`).addFlowTab();
    }
    const o = Zn(s, r).build(e, "void"), i = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + o);
    for (let a = 0, l = this.params.length - 1; a < l; a++)
      e.addFlowCode((a === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), i;
  }
}
const n2 = rd, Q0 = (...c) => Me(new rd(vr(c, "int"))).append();
V("loop", (c, ...e) => Yu(c, Q0(...e)));
re("LoopNode", rd);
class od extends St {
  constructor() {
    super("vec2");
  }
  setup() {
    const e = Ce(Pt.z, 0, Pt.x.negate()).normalize(), t = Pt.cross(e);
    return rt(e.dot(Ct), t.dot(Ct)).mul(0.495).add(0.5);
  }
}
const ev = od, s2 = ue(od);
re("MatcapUVNode", od);
class Dt extends nt {
  constructor(e = Dt.LOCAL, t = 1, r = 0) {
    super(r), this.scope = e, this.scale = t, this.updateType = ht.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(e) {
    const t = this.scope, r = this.scale;
    t === Dt.LOCAL ? this.value += e.deltaTime * r : t === Dt.DELTA ? this.value = e.deltaTime * r : t === Dt.FRAME ? this.value = e.frameId : this.value = e.time * r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope, e.scale = this.scale;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope, this.scale = e.scale;
  }
}
Dt.LOCAL = "local";
Dt.GLOBAL = "global";
Dt.DELTA = "delta";
Dt.FRAME = "frame";
const tv = Dt, id = (c, e = 0) => Me(new Dt(Dt.LOCAL, c, e)), r2 = (c, e = 0) => Me(new Dt(Dt.GLOBAL, c, e)), o2 = (c, e = 0) => Me(new Dt(Dt.DELTA, c, e)), i2 = ue(Dt, Dt.FRAME).uint();
re("TimerNode", Dt);
class Lt extends Oe {
  constructor(e = Lt.SINE, t = id()) {
    super(), this.method = e, this.timeNode = t;
  }
  getNodeType(e) {
    return this.timeNode.getNodeType(e);
  }
  setup() {
    const e = this.method, t = Me(this.timeNode);
    let r = null;
    return e === Lt.SINE ? r = t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5) : e === Lt.SQUARE ? r = t.fract().round() : e === Lt.TRIANGLE ? r = t.add(0.5).fract().mul(2).sub(1).abs() : e === Lt.SAWTOOTH && (r = t.fract()), r;
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Lt.SINE = "sine";
Lt.SQUARE = "square";
Lt.TRIANGLE = "triangle";
Lt.SAWTOOTH = "sawtooth";
const no = Lt, a2 = J(Lt, Lt.SINE), c2 = J(Lt, Lt.SQUARE), l2 = J(Lt, Lt.TRIANGLE), u2 = J(Lt, Lt.SAWTOOTH);
re("OscNode", Lt);
class ss extends St {
  constructor(e, t) {
    super(), this.scope = e, this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup() {
    const { scope: e, node: t } = this;
    let r = null;
    return e === ss.DIRECTION_TO_COLOR ? r = t.mul(0.5).add(0.5) : e === ss.COLOR_TO_DIRECTION && (r = t.mul(2).sub(1)), r;
  }
}
ss.DIRECTION_TO_COLOR = "directionToColor";
ss.COLOR_TO_DIRECTION = "colorToDirection";
const h2 = ss, ad = J(ss, ss.DIRECTION_TO_COLOR), nv = J(ss, ss.COLOR_TO_DIRECTION);
V("directionToColor", ad);
V("colorToDirection", nv);
re("PackingNode", ss);
class bc extends Oe {
  constructor(e, t, r, n, s) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = r, this.outLowNode = n, this.outHighNode = s, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: r, outLowNode: n, outHighNode: s, doClamp: o } = this;
    let i = e.sub(t).div(r.sub(t));
    return o === !0 && (i = i.clamp()), i.mul(s.sub(n)).add(n);
  }
}
const sv = bc, rv = J(bc, null, null, { doClamp: !1 }), ov = J(bc);
V("remap", rv);
V("remapClamp", ov);
re("RemapNode", bc);
class cd extends St {
  constructor(e, t, r = rt(0.5)) {
    super("vec2"), this.uvNode = e, this.rotationNode = t, this.centerNode = r;
  }
  setup() {
    const { uvNode: e, rotationNode: t, centerNode: r } = this, n = t.cos(), s = t.sin(), o = e.sub(r);
    return rt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      rt(n, s).dot(o),
      rt(s.negate(), n).dot(o)
    ).add(r);
  }
}
const iv = cd, av = J(cd);
V("rotateUV", av);
re("RotateUVNode", cd);
class ld extends Oe {
  constructor(e, t = yt(), r = Se(0)) {
    super("vec2"), this.countNode = e, this.uvNode = t, this.frameNode = r;
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: r } = this, { width: n, height: s } = r, o = e.mod(n.mul(s)).floor(), i = o.mod(n), a = s.sub(o.add(1).div(n).ceil()), l = r.reciprocal(), u = rt(i, a);
    return t.add(u).mul(l);
  }
}
const cv = ld, lv = J(ld);
re("SpriteSheetUVNode", ld);
class ud extends Oe {
  constructor(e, t = null, r = null, n = Se(1), s = Ah, o = gc) {
    super("vec4"), this.textureXNode = e, this.textureYNode = t, this.textureZNode = r, this.scaleNode = n, this.positionNode = s, this.normalNode = o;
  }
  setup() {
    const { textureXNode: e, textureYNode: t, textureZNode: r, scaleNode: n, positionNode: s, normalNode: o } = this;
    let i = o.abs().normalize();
    i = i.div(i.dot(Ce(1)));
    const a = s.yz.mul(n), l = s.zx.mul(n), u = s.xy.mul(n), h = e.value, d = t !== null ? t.value : h, f = r !== null ? r.value : h, p = En(h, a).mul(i.x), m = En(d, l).mul(i.y), g = En(f, u).mul(i.z);
    return ts(p, m, g);
  }
}
const uv = ud, hv = J(ud), dv = (...c) => hv(...c);
V("triplanarTexture", dv);
re("TriplanarTexturesNode", ud);
class Ot extends Oe {
  constructor(e = Ot.LOCAL) {
    super("vec3"), this.scope = e;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r;
    t === Ot.GEOMETRY ? r = li.cross(ui) : t === Ot.LOCAL ? r = Mr.cross(yc) : t === Ot.VIEW ? r = ps.cross(Ci) : t === Ot.WORLD && (r = gc.cross(O0));
    const n = r.mul(ui.w).xyz;
    return Ln(ct(n)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Ot.GEOMETRY = "geometry";
Ot.LOCAL = "local";
Ot.VIEW = "view";
Ot.WORLD = "world";
const so = Ot, d2 = ue(Ot, Ot.GEOMETRY), f2 = ue(Ot, Ot.LOCAL), fv = ue(Ot, Ot.VIEW), p2 = ue(Ot, Ot.WORLD), pv = Ln(Ct.cross(Ph).mul(ui.w)), m2 = Ln(pv.transformDirection(Rs));
re("BitangentNode", Ot);
const Nc = 1 / 6, mv = (c) => en(Nc, en(c, en(c, c.negate().add(3)).sub(3)).add(1)), su = (c) => en(Nc, en(c, en(c, en(3, c).sub(6))).add(4)), gv = (c) => en(Nc, en(c, en(c, en(-3, c).add(3)).add(3)).add(1)), ru = (c) => en(Nc, mh(c, 3)), lp = (c) => mv(c).add(su(c)), up = (c) => gv(c).add(ru(c)), hp = (c) => ts(-1, su(c).div(mv(c).add(su(c)))), dp = (c) => ts(1, ru(c).div(gv(c).add(ru(c)))), fp = (c, e, t) => {
  const r = c.uvNode, n = en(r, e.zw).add(0.5), s = dc(n), o = fc(n), i = lp(o.x), a = up(o.x), l = hp(o.x), u = dp(o.x), h = hp(o.y), d = dp(o.y), f = rt(s.x.add(l), s.y.add(h)).sub(0.5).mul(e.xy), p = rt(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy), m = rt(s.x.add(l), s.y.add(d)).sub(0.5).mul(e.xy), g = rt(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy), b = lp(o.y).mul(ts(i.mul(c.uv(f).level(t)), a.mul(c.uv(p).level(t)))), v = up(o.y).mul(ts(i.mul(c.uv(m).level(t)), a.mul(c.uv(g).level(t))));
  return b.add(v);
}, g2 = (c, e) => {
  const t = rt(c.size(Ia(e))), r = rt(c.size(Ia(e.add(1)))), n = xo(1, t), s = xo(1, r), o = fp(c, st(n, t), dc(e)), i = fp(c, st(s, r), dh(e));
  return fc(e).mix(o, i);
};
class hd extends St {
  constructor(e, t = Se(3)) {
    super("vec4"), this.textureNode = e, this.blurNode = t;
  }
  setup() {
    return g2(this.textureNode, this.blurNode);
  }
}
const y2 = hd, yv = J(hd);
V("bicubic", yv);
re("TextureBicubicNode", hd);
class dd extends Oe {
  constructor() {
    super("vec2"), this.isPointUVNode = !0;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const vv = dd, xv = ue(dd);
re("PointUVNode", dd);
class Gn extends Oe {
  constructor(e = Gn.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  setup(e) {
    const t = this.scope, r = this.scene !== null ? this.scene : e.scene;
    let n;
    return t === Gn.BACKGROUND_BLURRINESS ? n = Cs("backgroundBlurriness", "float", r) : t === Gn.BACKGROUND_INTENSITY ? n = Cs("backgroundIntensity", "float", r) : console.error("THREE.SceneNode: Unknown scope:", t), n;
  }
}
Gn.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Gn.BACKGROUND_INTENSITY = "backgroundIntensity";
const v2 = Gn, x2 = ue(Gn, Gn.BACKGROUND_BLURRINESS), b2 = ue(Gn, Gn.BACKGROUND_INTENSITY);
re("SceneNode", Gn);
class fd extends Fh {
  constructor(e, t, r = 0) {
    super(e, t, r), this.isStorageBufferNode = !0;
  }
  getInputType() {
    return "storageBuffer";
  }
}
const N2 = fd, w2 = (c, e, t) => Me(new fd(c, e, t));
re("StorageBufferNode", fd);
class pd extends Mi {
  constructor(e, t, r = null) {
    super(e, t), this.storeNode = r, this.isStoreTextureNode = !0;
  }
  getNodeType() {
    return "void";
  }
}
const T2 = pd, S2 = J(pd);
re("TextureStoreNode", pd);
class md extends mc {
  constructor(e, t, r = null) {
    super(e, t, r), this.userData = r;
  }
  update(e) {
    this.reference = this.userData !== null ? this.userData : e.object.userData, super.update(e);
  }
}
const _2 = md, M2 = (c, e, t) => Me(new md(c, e, t));
re("UserDataNode", md);
const A2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => e[r].lessThan(hh).cond(e[r], c[r].oneMinus().div(e[r]).oneMinus().max(0));
  return Ce(t("x"), t("y"), t("z"));
}), C2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => e[r].equal(1).cond(e[r], c[r].div(e[r].oneMinus()).max(0));
  return Ce(t("x"), t("y"), t("z"));
}), E2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => c[r].oneMinus().mul(e[r].oneMinus()).oneMinus();
  return Ce(t("x"), t("y"), t("z"));
}), R2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => c[r].lessThan(0.5).cond(c[r].mul(e[r], 2), c[r].oneMinus().mul(e[r].oneMinus()).oneMinus());
  return Ce(t("x"), t("y"), t("z"));
});
class Ut extends St {
  constructor(e, t, r) {
    super(), this.blendMode = e, this.baseNode = t, this.blendNode = r;
  }
  setup() {
    const { blendMode: e, baseNode: t, blendNode: r } = this, n = { base: t, blend: r };
    let s = null;
    return e === Ut.BURN ? s = A2(n) : e === Ut.DODGE ? s = C2(n) : e === Ut.SCREEN ? s = E2(n) : e === Ut.OVERLAY && (s = R2(n)), s;
  }
}
Ut.BURN = "burn";
Ut.DODGE = "dodge";
Ut.SCREEN = "screen";
Ut.OVERLAY = "overlay";
const ro = Ut, bv = J(Ut, Ut.BURN), Nv = J(Ut, Ut.DODGE), wv = J(Ut, Ut.OVERLAY), Tv = J(Ut, Ut.SCREEN);
V("burn", bv);
V("dodge", Nv);
V("overlay", wv);
V("screen", Tv);
re("BlendModeNode", Ut);
class gd extends Oe {
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    return e.getFrontFacing();
  }
}
const Sv = gd, _v = ue(gd), yd = Se(_v).mul(2).sub(1);
re("FrontFacingNode", gd);
const L2 = Ve(({ textureNode: c, bumpScale: e }) => {
  let t = c;
  if (t.isTextureNode !== !0 && t.traverse((o) => {
    o.isTextureNode === !0 && (t = o);
  }), t.isTextureNode !== !0)
    throw new Error("THREE.TSL: dHdxy_fwd() requires a TextureNode.");
  const r = Se(c), n = t.uvNode || yt(), s = (o) => c.cache().context({ getUVNode: () => o, forceUVContext: !0 });
  return rt(
    Se(s(n.add(n.dFdx()))).sub(r),
    Se(s(n.add(n.dFdy()))).sub(r)
  ).mul(e);
}), O2 = Ve((c) => {
  const { surf_pos: e, surf_norm: t, dHdxy: r } = c, n = e.dFdx().normalize(), s = e.dFdy().normalize(), o = t, i = s.cross(o), a = o.cross(n), l = n.dot(i).mul(yd), u = l.sign().mul(r.x.mul(i).add(r.y.mul(a)));
  return l.abs().mul(t).sub(u).normalize();
});
class vd extends St {
  constructor(e, t = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = L2({ textureNode: this.textureNode, bumpScale: e });
    return O2({
      surf_pos: ns,
      surf_norm: ps,
      dHdxy: t
    });
  }
}
const F2 = vd, Mv = J(vd);
V("bumpMap", Mv);
re("BumpMapNode", vd);
const I2 = Ve(({ color: c, adjustment: e }) => e.mix(Lv(c), c)), P2 = Ve(({ color: c, adjustment: e }) => {
  const t = ts(c.r, c.g, c.b).div(3), r = c.r.max(c.g.max(c.b)), n = r.sub(t).mul(e).mul(-3);
  return bn(c, r, n);
}), D2 = Ve(({ color: c, adjustment: e }) => {
  const t = Ms(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135), r = Ms(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046), n = t.mul(c), s = n.z.atan2(n.y).add(e), o = n.yz.length();
  return r.mul(Ce(n.x, o.mul(s.cos()), o.mul(s.sin())));
});
class on extends St {
  constructor(e, t, r = Se(1)) {
    super("vec3"), this.method = e, this.colorNode = t, this.adjustmentNode = r;
  }
  setup() {
    const { method: e, colorNode: t, adjustmentNode: r } = this, n = { color: t, adjustment: r };
    let s = null;
    return e === on.SATURATION ? s = I2(n) : e === on.VIBRANCE ? s = P2(n) : e === on.HUE ? s = D2(n) : console.error(`${this.type}: Method "${this.method}" not supported!`), s;
  }
}
on.SATURATION = "saturation";
on.VIBRANCE = "vibrance";
on.HUE = "hue";
const Jo = on, Av = J(on, on.SATURATION), Cv = J(on, on.VIBRANCE), Ev = J(on, on.HUE), Rv = Ce(0.2125, 0.7154, 0.0721), Lv = (c, e = Rv) => ph(c, e);
V("saturation", Av);
V("vibrance", Cv);
V("hue", Ev);
re("ColorAdjustmentNode", on);
const U2 = Ve((c) => {
  const { eye_pos: e, surf_norm: t, mapN: r, uv: n } = c, s = e.dFdx(), o = e.dFdy(), i = n.dFdx(), a = n.dFdy(), l = t, u = o.cross(l), h = l.cross(s), d = u.mul(i.x).add(h.mul(a.x)), f = u.mul(i.y).add(h.mul(a.y)), p = d.dot(d).max(f.dot(f)), m = yd.mul(p.inverseSqrt());
  return ts(d.mul(r.x, m), f.mul(r.y, m), l.mul(r.z)).normalize();
});
class xd extends St {
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = Yf;
  }
  setup(e) {
    const { normalMapType: t, scaleNode: r } = this;
    let n = this.node.mul(2).sub(1);
    r !== null && (n = Ce(n.xy.mul(r), n.z));
    let s = null;
    return t === Nb ? s = Th.mul(n).normalize() : t === Yf && (e.hasGeometryAttribute("tangent") === !0 ? s = Iv.mul(n).normalize() : s = U2({
      eye_pos: ns,
      surf_norm: ps,
      mapN: n,
      uv: yt()
    })), s;
  }
}
const Ov = xd, Fv = J(xd), Iv = Ms(Ci, fv, ps);
V("normalMap", Fv);
re("NormalMapNode", xd);
class bd extends St {
  constructor(e, t) {
    super(), this.sourceNode = e, this.stepsNode = t;
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const Pv = bd, Dv = J(bd);
V("posterize", Dv);
re("PosterizeNode", bd);
const z2 = Ve(({ color: c, exposure: e }) => c.mul(e).clamp()), B2 = Ve(({ color: c, exposure: e }) => (c = c.mul(e), c.div(c.add(1)).clamp())), k2 = Ve(({ color: c, exposure: e }) => {
  c = c.mul(e), c = c.sub(4e-3).max(0);
  const t = c.mul(c.mul(6.2).add(0.5)), r = c.mul(c.mul(6.2).add(1.7)).add(0.06);
  return t.div(r).pow(2.2);
}), G2 = Ve(({ color: c }) => {
  const e = c.mul(c.add(0.0245786)).sub(90537e-9), t = c.mul(c.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), V2 = Ve(({ color: c, exposure: e }) => {
  const t = Ms(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), r = Ms(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return c = c.mul(e).div(0.6), c = t.mul(c), c = G2({ color: c }), c = r.mul(c), c.clamp();
}), j2 = {
  [wb]: z2,
  [Tb]: B2,
  [Sb]: k2,
  [Pm]: V2
};
class Nd extends St {
  constructor(e = Kf, t = Se(1), r = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = r;
  }
  getCacheKey() {
    let e = super.getCacheKey();
    return e = "{toneMapping:" + this.toneMapping + ",nodes:" + e + "}", e;
  }
  setup(e) {
    const t = this.colorNode || e.context.color, r = this.toneMapping;
    if (r === Kf)
      return t;
    const n = { exposure: this.exposureNode, color: t }, s = j2[r];
    let o = null;
    return s ? o = s(n) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", r), o = t), o;
  }
}
const Uv = Nd, W2 = (c, e, t) => Me(new Nd(c, Me(e), Me(t)));
re("ToneMappingNode", Nd);
let ol, il;
class Ze extends Oe {
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Ze.COORDINATE || this.scope === Ze.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = ht.NONE;
    return (this.scope === Ze.RESOLUTION || this.scope === Ze.VIEWPORT) && (e = ht.FRAME), this.updateType = e, e;
  }
  update({ renderer: e }) {
    this.scope === Ze.VIEWPORT ? e.getViewport(il) : e.getDrawingBufferSize(ol);
  }
  setup(e) {
    const t = this.scope;
    if (t === Ze.COORDINATE)
      return;
    let r = null;
    if (t === Ze.RESOLUTION)
      r = Ft(ol || (ol = new Tt()));
    else if (t === Ze.VIEWPORT)
      r = Ft(il || (il = new mt()));
    else {
      const n = rt(new Ze(Ze.COORDINATE)), s = new Ze(Ze.RESOLUTION);
      r = n.div(s);
      let o = r.x, i = r.y;
      /bottom/i.test(t) && (i = i.oneMinus()), /right/i.test(t) && (o = o.oneMinus()), r = rt(o, i);
    }
    return r;
  }
  generate(e) {
    if (this.scope === Ze.COORDINATE) {
      let t = e.getFragCoord();
      if (e.isFlipY()) {
        const r = zv.build(e);
        t = `${e.getType("vec2")}( ${t}.x, ${r}.y - ${t}.y )`;
      }
      return t;
    }
    return super.generate(e);
  }
}
Ze.COORDINATE = "coordinate";
Ze.RESOLUTION = "resolution";
Ze.VIEWPORT = "viewport";
Ze.TOP_LEFT = "topLeft";
Ze.BOTTOM_LEFT = "bottomLeft";
Ze.TOP_RIGHT = "topRight";
Ze.BOTTOM_RIGHT = "bottomRight";
const ks = Ze, H2 = ue(Ze, Ze.COORDINATE), zv = ue(Ze, Ze.RESOLUTION), Nr = ue(Ze, Ze.VIEWPORT), wc = ue(Ze, Ze.TOP_LEFT), X2 = ue(Ze, Ze.BOTTOM_LEFT), $2 = ue(Ze, Ze.TOP_RIGHT), q2 = ue(Ze, Ze.BOTTOM_RIGHT);
re("ViewportNode", Ze);
const Do = new Tt();
class Tc extends Mi {
  constructor(e = wc, t = null, r = null) {
    r === null && (r = new Dm(), r.minFilter = To), super(r, e, t), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = ht.FRAME;
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(Do);
    const r = this.value;
    (r.image.width !== Do.width || r.image.height !== Do.height) && (r.image.width = Do.width, r.image.height = Do.height, r.needsUpdate = !0);
    const n = r.generateMipmaps;
    r.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(r), r.generateMipmaps = n;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
}
const wd = Tc, Bv = J(Tc), kv = J(Tc, null, null, { generateMipmaps: !0 });
V("viewportTexture", Bv);
V("viewportMipTexture", kv);
re("ViewportTextureNode", Tc);
let al = null;
class Td extends wd {
  constructor(e = wc, t = null) {
    al === null && (al = new Dm()), super(e, t, al);
  }
}
const J2 = Td, Gv = J(Td);
V("viewportSharedTexture", Gv);
re("ViewportSharedTextureNode", Td);
let zr = null;
class Sd extends wd {
  constructor(e = wc, t = null) {
    zr === null && (zr = new Fm(), zr.minFilter = To, zr.type = _b, zr.format = Mb), super(e, t, zr);
  }
}
const Y2 = Sd, _d = J(Sd);
V("viewportDepthTexture", _d);
re("ViewportDepthTextureNode", Sd);
class rs extends Oe {
  constructor(e, t = null) {
    super("float"), this.scope = e, this.textureNode = t, this.isViewportDepthNode = !0;
  }
  setup() {
    const { scope: e } = this;
    let t = null;
    if (e === rs.DEPTH)
      t = ou(ns.z, Sa, _a);
    else if (e === rs.DEPTH_TEXTURE) {
      const r = this.textureNode || _d(), n = Vv(r, Sa, _a);
      t = ou(n, Sa, _a);
    }
    return t;
  }
}
const ou = (c, e, t) => c.add(e).div(e.sub(t)), K2 = (c, e, t) => e.sub(t).mul(c).sub(e), Z2 = (c, e, t) => e.add(c).mul(t).div(e.sub(t).mul(c)), Vv = (c, e, t) => e.mul(t).div(t.sub(e).mul(c).sub(t));
rs.DEPTH = "depth";
rs.DEPTH_TEXTURE = "depthTexture";
const Q2 = rs, eT = ue(rs, rs.DEPTH), tT = J(rs, rs.DEPTH_TEXTURE);
re("ViewportDepthNode", rs);
class Md extends Oe {
  constructor(e = "", t = [], r = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = r, this._includes = t;
  }
  setIncludes(e) {
    return this._includes = e, this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const n of t)
      n.build(e);
    const r = e.getCodeFromNode(this, this.getNodeType(e));
    return r.code = this.code, r.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
const Ad = Md, Sc = J(Md), nT = (c, e) => Sc(c, e, "js"), sT = (c, e) => Sc(c, e, "wgsl"), Cd = (c, e) => Sc(c, e, "glsl");
re("CodeNode", Md);
class Ed extends St {
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [], r = this.functionNode, n = r.getInputs(e), s = this.parameters;
    if (Array.isArray(s))
      for (let i = 0; i < s.length; i++) {
        const a = n[i], l = s[i];
        t.push(l.build(e, a.type));
      }
    else
      for (const i of n) {
        const a = s[i.name];
        if (a !== void 0)
          t.push(a.build(e, i.type));
        else
          throw new Error(`FunctionCallNode: Input '${i.name}' not found in FunctionNode.`);
      }
    return `${r.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const rT = Ed, jv = (c, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? vr(e) : Si(e[0]), Me(new Ed(Me(c), e)));
V("call", jv);
re("FunctionCallNode", Ed);
class Rd extends Ad {
  constructor(e = "", t = [], r = "") {
    super(e, t, r), this.keywords = {};
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let r = t.nodeFunction;
    return r === void 0 && (r = e.parser.parseFunction(this.code), t.nodeFunction = r), r;
  }
  generate(e, t) {
    super.generate(e);
    const r = this.getNodeFunction(e), n = r.name, s = r.type, o = e.getCodeFromNode(this, s);
    n !== "" && (o.name = n);
    const i = e.getPropertyName(o);
    let a = this.getNodeFunction(e).getCode(i);
    const l = this.keywords, u = Object.keys(l);
    if (u.length > 0)
      for (const h of u) {
        const d = new RegExp(`\\b${h}\\b`, "g"), f = l[h].build(e, "property");
        a = a.replace(d, f);
      }
    return o.code = a + `
`, t === "property" ? i : e.format(`${i}()`, s, t);
  }
}
const Wv = Rd, Hv = (c, e = [], t = "") => {
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof o == "function" && (e[s] = o.functionNode);
  }
  const r = Me(new Rd(c, e, t)), n = (...s) => r.call(...s);
  return n.functionNode = r, n;
}, ln = (c, e) => Hv(c, e, "glsl"), oT = (c, e) => Hv(c, e, "wgsl");
re("FunctionNode", Rd);
class Ld extends Oe {
  constructor(e = null) {
    super(), this._value = e, this._cache = null, this.inputType = null, this.outpuType = null, this.events = new Ka(), this.isScriptableValueNode = !0;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e && (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer && (URL.revokeObjectURL(this._cache), this._cache = null), this._value = e, this.events.dispatchEvent({ type: "change" }), this.refresh());
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const e = this.value;
    if (e && this._cache === null && this.inputType === "URL" && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (e && e.value !== null && e.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof e.value == "string" || this.inputType === "Number" && typeof e.value == "number" || this.inputType === "Vector2" && e.value.isVector2 || this.inputType === "Vector3" && e.value.isVector3 || this.inputType === "Vector4" && e.value.isVector4 || this.inputType === "Color" && e.value.isColor || this.inputType === "Matrix3" && e.value.isMatrix3 || this.inputType === "Matrix4" && e.value.isMatrix4))
      return e.value;
    return this._cache || e;
  }
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : Se();
  }
  serialize(e) {
    super.serialize(e), this.value !== null ? this.inputType === "ArrayBuffer" ? e.value = Pu(this.value) : e.value = this.value ? this.value.toJSON(e.meta).uuid : null : e.value = null, e.inputType = this.inputType, e.outputType = this.outputType;
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null && (e.inputType === "ArrayBuffer" ? t = Du(e.value) : e.inputType === "Texture" ? t = e.meta.textures[e.value] : t = e.meta.nodes[e.value] || null), this.value = t, this.inputType = e.inputType, this.outputType = e.outputType;
  }
}
const iT = Ld, Yo = J(Ld);
V("scriptableValue", Yo);
re("ScriptableValueNode", Ld);
class Xv extends Map {
  get(e, t = null, ...r) {
    if (this.has(e))
      return super.get(e);
    if (t !== null) {
      const n = t(...r);
      return this.set(e, n), n;
    }
  }
}
class aT {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const Ma = new Xv();
class Od extends Oe {
  constructor(e = null, t = {}) {
    super(), this.codeNode = e, this.parameters = t, this._local = new Xv(), this._output = Yo(), this._outputs = {}, this._source = this.source, this._method = null, this._object = null, this._value = null, this._needsOutputUpdate = !0, this.onRefresh = this.onRefresh.bind(this), this.isScriptableNode = !0;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  getLocal(e) {
    return this._local.get(e);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e))
        return t;
  }
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e))
        return t;
  }
  setOutput(e, t) {
    const r = this._outputs;
    return r[e] === void 0 ? r[e] = Yo(t) : r[e].value = t, this;
  }
  getOutput(e) {
    return this._outputs[e];
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    const r = this.parameters;
    return t && t.isScriptableNode ? (this.deleteParameter(e), r[e] = t, r[e].getDefaultOutput().events.addEventListener("refresh", this.onRefresh)) : t && t.isScriptableValueNode ? (this.deleteParameter(e), r[e] = t, r[e].events.addEventListener("refresh", this.onRefresh)) : r[e] === void 0 ? (r[e] = Yo(t), r[e].events.addEventListener("refresh", this.onRefresh)) : r[e].value = t, this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(e) {
    let t = this.parameters[e];
    return t && (t.isScriptableNode && (t = t.getDefaultOutput()), t.events.removeEventListener("refresh", this.onRefresh)), this;
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters))
      this.deleteParameter(e);
    return this.needsUpdate = !0, this;
  }
  call(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n(...t);
  }
  async callAsync(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n.constructor.name === "AsyncFunction" ? await n(...t) : n(...t);
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  getObject() {
    if (this.needsUpdate && this.dispose(), this._object !== null)
      return this._object;
    const e = () => this.refresh(), t = (l, u) => this.setOutput(l, u), r = new aT(this), n = Ma.get("THREE"), s = Ma.get("TSL"), o = this.getMethod(this.codeNode), i = [r, this._local, Ma, e, t, n, s];
    this._object = o(...i);
    const a = this._object.layout;
    if (a && (a.cache === !1 && this._local.clear(), this._output.outputType = a.outputType || null, Array.isArray(a.elements)))
      for (const l of a.elements) {
        const u = l.id || l.name;
        l.inputType && (this.getParameter(u) === void 0 && this.setParameter(u, null), this.getParameter(u).inputType = l.inputType), l.outputType && (this.getOutput(u) === void 0 && this.setOutput(u, null), this.getOutput(u).outputType = l.outputType);
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let r = this.parameters[t];
      r.isScriptableNode && (r = r.getDefaultOutput()), r.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : Se();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate && this.dispose(), this._method !== null)
      return this._method;
    const e = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"], r = ["layout", "init", "main", "dispose"].join(", "), n = "var " + r + `; var output = {};
`, s = `
return { ...output, ` + r + " };", o = n + this.codeNode.code + s;
    return this._method = new Function(...e, o), this._method;
  }
  dispose() {
    this._method !== null && (this._object && typeof this._object.dispose == "function" && this._object.dispose(), this._method = null, this._object = null, this._source = null, this._value = null, this._needsOutputUpdate = !0, this._output.value = null, this._outputs = {});
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    return this.codeNode === null ? this : (this._needsOutputUpdate === !0 && (this._value = this.call("main"), this._needsOutputUpdate = !1), this._output.value = this._value, this);
  }
  _refresh() {
    this.needsUpdate = !0, this._exec(), this._output.refresh();
  }
}
const cT = Od, $v = J(Od);
V("scriptable", $v);
re("ScriptableNode", Od);
class Fd extends Oe {
  constructor(e, t) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = t;
  }
  mixAssign(e) {
    return this.mix(e, this.colorNode);
  }
  setup() {
    return this.factorNode;
  }
}
const _c = Fd, qv = J(Fd);
V("fog", qv);
re("FogNode", Fd);
class Id extends _c {
  constructor(e, t, r) {
    super(e), this.isFogRangeNode = !0, this.nearNode = t, this.farNode = r;
  }
  setup() {
    return As(this.nearNode, this.farNode, ns.z.negate());
  }
}
const Jv = Id, Yv = J(Id);
V("rangeFog", Yv);
re("FogRangeNode", Id);
class Pd extends _c {
  constructor(e, t) {
    super(e), this.isFogExp2Node = !0, this.densityNode = t;
  }
  setup() {
    const e = ns.z.negate(), t = this.densityNode;
    return t.mul(t, e, e).negate().exp().oneMinus();
  }
}
const Kv = Pd, Zv = J(Pd);
V("densityFog", Zv);
re("FogExp2Node", Pd);
let or = null, ir = null;
class Dd extends Oe {
  constructor(e = Se(), t = Se()) {
    super(), this.minNode = e, this.maxNode = t;
  }
  getVectorLength(e) {
    const t = e.getTypeLength(Hs(this.minNode.value)), r = e.getTypeLength(Hs(this.maxNode.value));
    return t > r ? t : r;
  }
  getNodeType(e) {
    return e.object.isInstancedMesh === !0 ? e.getTypeFromLength(this.getVectorLength(e)) : "float";
  }
  setup(e) {
    const t = e.object;
    let r = null;
    if (t.isInstancedMesh === !0) {
      const n = this.minNode.value, s = this.maxNode.value, o = e.getTypeLength(Hs(n)), i = e.getTypeLength(Hs(s));
      or = or || new mt(), ir = ir || new mt(), or.setScalar(0), ir.setScalar(0), o === 1 ? or.setScalar(n) : n.isColor ? or.set(n.r, n.g, n.b) : or.set(n.x, n.y, n.z || 0, n.w || 0), i === 1 ? ir.setScalar(s) : s.isColor ? ir.set(s.r, s.g, s.b) : ir.set(s.x, s.y, s.z || 0, s.w || 0);
      const a = 4, l = a * t.count, u = new Float32Array(l);
      for (let d = 0; d < l; d++) {
        const f = d % a, p = or.getComponent(f), m = ir.getComponent(f);
        u[d] = Qt.lerp(p, m, Math.random());
      }
      const h = this.getNodeType(e);
      r = Ih(u, "vec4", t.count).element($g).convert(h);
    } else
      r = Se(0);
    return r;
  }
}
const Qv = Dd, lT = J(Dd);
re("RangeNode", Dd);
class Ud extends Oe {
  constructor(e, t, r = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = t, this.workgroupSize = r, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = ht.OBJECT, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let r = t[0];
    for (let n = 1; n < t.length; n++)
      r *= t[n];
    this.dispatchCount = Math.ceil(e / r);
  }
  onInit() {
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: t } = e;
    if (t === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r);
    }
  }
}
const e1 = Ud, t1 = (c, e, t) => Me(new Ud(Me(c), e, t));
V("compute", t1);
re("ComputeNode", Ud);
class Qs extends Oe {
  constructor(e = Qs.TARGET_DIRECTION, t = null) {
    super(), this.scope = e, this.light = t;
  }
  setup() {
    const { scope: e, light: t } = this;
    let r = null;
    return e === Qs.TARGET_DIRECTION && (r = Rs.transformDirection(ka(t).sub(ka(t.target)))), r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Qs.TARGET_DIRECTION = "targetDirection";
const uT = Qs, zd = J(Qs, Qs.TARGET_DIRECTION);
re("LightNode", Qs);
const Bd = Ve((c) => {
  const { lightDistance: e, cutoffDistance: t, decayExponent: r } = c, n = e.pow(r).max(0.01).reciprocal();
  return t.greaterThan(0).cond(
    n.mul(e.div(t).pow4().oneMinus().clamp().pow2()),
    n
  );
});
class kd extends rr {
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  setup(e) {
    const { colorNode: t, cutoffDistanceNode: r, decayExponentNode: n, light: s } = this, o = e.context.lightingModel, i = Nh(s).sub(ns), a = i.normalize(), l = i.length(), u = Bd({
      lightDistance: l,
      cutoffDistance: r,
      decayExponent: n
    }), h = t.mul(u), d = e.context.reflectedLight;
    o.direct({
      lightDirection: a,
      lightColor: h,
      reflectedLight: d
    }, e.stack, e);
  }
}
const n1 = kd;
re("PointLightNode", kd);
Rr(ni, kd);
class Gd extends rr {
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, r = this.colorNode, n = zd(this.light), s = e.context.reflectedLight;
    t.direct({
      lightDirection: n,
      lightColor: r,
      reflectedLight: s
    }, e.stack, e);
  }
}
const hT = Gd;
re("DirectionalLightNode", Gd);
Rr(bi, Gd);
class Vd extends rr {
  constructor(e = null) {
    super(e), this.coneCosNode = Ft(0), this.penumbraCosNode = Ft(0), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: t, penumbraCosNode: r } = this;
    return As(t, r, e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, { colorNode: r, cutoffDistanceNode: n, decayExponentNode: s, light: o } = this, i = Nh(o).sub(ns), a = i.normalize(), l = a.dot(zd(o)), u = this.getSpotAttenuation(l), h = i.length(), d = Bd({
      lightDistance: h,
      cutoffDistance: n,
      decayExponent: s
    }), f = r.mul(u).mul(d), p = e.context.reflectedLight;
    t.direct({
      lightDirection: a,
      lightColor: f,
      reflectedLight: p
    }, e.stack, e);
  }
}
const s1 = Vd;
re("SpotLightNode", Vd);
Rr(Ni, Vd);
class dT extends Ni {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, n, s, o), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
const fT = dT;
class jd extends s1 {
  getSpotAttenuation(e) {
    const t = this.light.iesMap;
    let r = null;
    if (t && t.isTexture === !0) {
      const n = e.acos().mul(1 / Math.PI);
      r = En(t, rt(n, 0), 0).r;
    } else
      r = super.getSpotAttenuation(e);
    return r;
  }
}
const pT = jd;
re("IESSpotLightNode", jd);
Rr(fT, jd);
class Wd extends rr {
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
const mT = Wd;
re("AmbientLightNode", Wd);
Rr(_u, Wd);
class Hd extends rr {
  constructor(e = null) {
    super(e), this.lightPositionNode = ka(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Ft(new je());
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: r, lightDirectionNode: n } = this, o = ps.dot(n).mul(0.5).add(0.5), i = bn(r, t, o);
    e.context.irradiance.addAssign(i);
  }
}
const r1 = Hd;
re("HemisphereLightNode", Hd);
Rr(Um, Hd);
const gT = Ve((c) => {
  const e = c.uv.mul(2), t = e.x.floor(), r = e.y.floor();
  return t.add(r).mod(2).sign();
});
class Xd extends St {
  constructor(e = yt()) {
    super("float"), this.uvNode = e;
  }
  setup() {
    return gT({ uv: this.uvNode });
  }
}
const o1 = Xd, i1 = J(Xd);
V("checker", i1);
re("CheckerNode", Xd);
class yT extends Sr {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, n) {
    const s = new Ys(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      try {
        t(this.parse(JSON.parse(o)));
      } catch (i) {
        n ? n(i) : console.error(i), this.manager.itemError(e);
      }
    }, r, n);
  }
  parseNodes(e) {
    const t = {};
    if (e !== void 0) {
      for (const n of e) {
        const { uuid: s, type: o } = n;
        t[s] = Me(Kl(o)), t[s].uuid = s;
      }
      const r = { nodes: t, textures: this.textures };
      for (const n of e)
        n.meta = r, t[n.uuid].deserialize(n), delete n.meta;
    }
    return t;
  }
  parse(e) {
    const t = Me(Kl(e.type));
    t.uuid = e.uuid;
    const n = { nodes: this.parseNodes(e.nodes), textures: this.textures };
    return e.meta = n, t.deserialize(e), delete e.meta, t;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
const a1 = yT, vT = new Mu();
class c1 extends Yt {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.pointWidth = 1, this.pointColorNode = null, this.setDefaultValues(vT), this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor;
    this.vertexNode = Ve(() => {
      ct(rt(), "vUv").assign(yt());
      const r = Mt("instancePosition"), n = An("vec4", "mvPos");
      n.assign(Zs.mul(st(r, 1)));
      const s = Nr.z.div(Nr.w), o = hs.mul(n), i = An("vec2", "offset");
      return i.assign(tn.xy), i.assign(i.mul(_0)), i.assign(i.div(Nr.z)), i.y.assign(i.y.mul(s)), i.assign(i.mul(o.w)), o.assign(o.add(st(i, 0, 0))), o;
    })(), this.colorNode = Ve(() => {
      const r = ct(rt(), "vUv"), n = An("float", "alpha");
      n.assign(1);
      const s = r.x, o = r.y, i = s.mul(s).add(o.mul(o));
      if (e) {
        const l = An("float", "dlen");
        l.assign(i.fwidth()), n.assign(As(l.oneMinus(), l.add(1), i).oneMinus());
      } else
        i.greaterThan(1).discard();
      let a;
      return this.pointColorNode ? a = this.pointColorNode : t ? a = Mt("instanceColor").mul(bo) : a = bo, st(a, n);
    })(), this.needsUpdate = !0;
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const xT = c1;
cn("InstancedPointsNodeMaterial", c1);
const bT = new Au();
class l1 extends Yt {
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(bT), this.setValues(e);
  }
}
const u1 = l1;
cn("LineBasicNodeMaterial", l1);
const NT = new zm();
class h1 extends Yt {
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(NT), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, t = this.dashScaleNode ? Se(this.dashScaleNode) : Ga, r = this.dashSizeNode ? Se(this.dashSizeNode) : _h, n = this.dashSizeNode ? Se(this.dashGapNode) : Mh;
    xr.assign(r), ai.assign(n);
    const s = ct(Mt("lineDistance").mul(t));
    (e ? s.add(e) : s).mod(xr.add(ai)).greaterThan(xr).discard();
  }
}
const wT = h1;
cn("LineDashedNodeMaterial", h1);
const TT = new zm();
class d1 extends Yt {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.setDefaultValues(TT), this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.useDash = e.dashed, this.useWorldUnits = !1, this.dashOffset = 0, this.lineWidth = 1, this.lineColorNode = null, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor, r = this.dashed, n = this.worldUnits, s = Ve(({ start: i, end: a }) => {
      const l = hs.element(2).element(2), d = hs.element(3).element(2).mul(-0.5).div(l).sub(i.z).div(a.z.sub(i.z));
      return st(bn(i.xyz, a.xyz, d), a.w);
    });
    this.vertexNode = Ve(() => {
      ct(rt(), "vUv").assign(yt());
      const i = Mt("instanceStart"), a = Mt("instanceEnd"), l = An("vec4", "start"), u = An("vec4", "end");
      l.assign(Zs.mul(st(i, 1))), u.assign(Zs.mul(st(a, 1))), n && (ct(Ce(), "worldStart").assign(l.xyz), ct(Ce(), "worldEnd").assign(u.xyz));
      const h = Nr.z.div(Nr.w), d = hs.element(2).element(3).equal(-1);
      dr(d, () => {
        dr(l.z.lessThan(0).and(u.z.greaterThan(0)), () => {
          u.assign(s({ start: l, end: u }));
        }).elseif(u.z.lessThan(0).and(l.z.greaterThanEqual(0)), () => {
          l.assign(s({ start: u, end: l }));
        });
      });
      const f = hs.mul(l), p = hs.mul(u), m = f.xyz.div(f.w), g = p.xyz.div(p.w), b = g.xy.sub(m.xy).temp();
      b.x.assign(b.x.mul(h)), b.assign(b.normalize());
      const v = vo(st());
      if (n) {
        const y = u.xyz.sub(l.xyz).normalize(), x = tn.y.lessThan(0.5).cond(
          l.xyz.cross(y).normalize(),
          u.xyz.cross(y).normalize()
        );
        x.assign(tn.x.lessThan(0).cond(x.negate(), x));
        const N = y.dot(Ce(0, 0, 1));
        r || (l.assign(l.sub(st(y.mul(Yr).mul(0.5), 0))), u.assign(u.add(st(y.mul(Yr).mul(0.5), 0))), x.assign(x.sub(Ce(b.mul(N), 0))), x.z.assign(x.z.add(0.5))), dr(tn.y.greaterThan(1).or(tn.y.lessThan(0)), () => {
          x.assign(x.add(Ce(b.mul(2).mul(N), 0)));
        }), x.assign(x.mul(Yr).mul(0.5));
        const w = ct(st(), "worldPos");
        w.assign(tn.y.lessThan(0.5).cond(l, u)), w.assign(w.add(st(x, 0))), v.assign(hs.mul(w));
        const T = vo(Ce());
        T.assign(tn.y.lessThan(0.5).cond(m, g)), v.z.assign(T.z.mul(v.w));
      } else {
        const y = An("vec2", "offset");
        y.assign(rt(b.y, b.x.negate())), b.x.assign(b.x.div(h)), y.x.assign(y.x.div(h)), y.assign(tn.x.lessThan(0).cond(y.negate(), y)), dr(tn.y.lessThan(0), () => {
          y.assign(y.sub(b));
        }).elseif(tn.y.greaterThan(1), () => {
          y.assign(y.add(b));
        }), y.assign(y.mul(Yr)), y.assign(y.div(Nr.w)), v.assign(tn.y.lessThan(0.5).cond(f, p)), y.assign(y.mul(v.w)), v.assign(v.add(st(y, 0, 0)));
      }
      return v;
    })();
    const o = Ve(({ p1: i, p2: a, p3: l, p4: u }) => {
      const h = i.sub(l), d = u.sub(l), f = a.sub(i), p = h.dot(d), m = d.dot(f), g = h.dot(f), b = d.dot(d), y = f.dot(f).mul(b).sub(m.mul(m)), N = p.mul(m).sub(g.mul(b)).div(y).clamp(), w = p.add(m.mul(N)).div(b).clamp();
      return rt(N, w);
    });
    this.colorNode = Ve(() => {
      const i = ct(rt(), "vUv");
      if (r) {
        const u = this.offsetNode ? Se(this.offsetNodeNode) : eu, h = this.dashScaleNode ? Se(this.dashScaleNode) : Ga, d = this.dashSizeNode ? Se(this.dashSizeNode) : _h, f = this.dashSizeNode ? Se(this.dashGapNode) : Mh;
        xr.assign(d), ai.assign(f);
        const p = Mt("instanceDistanceStart"), m = Mt("instanceDistanceEnd"), g = tn.y.lessThan(0.5).cond(h.mul(p), Ga.mul(m)), b = ct(g.add(eu)), v = u ? b.add(u) : b;
        i.y.lessThan(-1).or(i.y.greaterThan(1)).discard(), v.mod(xr.add(ai)).greaterThan(xr).discard();
      }
      const a = An("float", "alpha");
      if (a.assign(1), n) {
        const u = ct(Ce(), "worldStart"), h = ct(Ce(), "worldEnd"), d = ct(st(), "worldPos").xyz.normalize().mul(1e5), f = h.sub(u), p = o({ p1: u, p2: h, p3: Ce(0, 0, 0), p4: d }), m = u.add(f.mul(p.x)), g = d.mul(p.y), y = m.sub(g).length().div(Yr);
        if (!r)
          if (e) {
            const x = y.fwidth();
            a.assign(As(x.negate().add(0.5), x.add(0.5), y).oneMinus());
          } else
            y.greaterThan(0.5).discard();
      } else if (e) {
        const u = i.x, h = i.y.greaterThan(0).cond(i.y.sub(1), i.y.add(1)), d = u.mul(u).add(h.mul(h)), f = An("float", "dlen");
        f.assign(d.fwidth()), dr(i.y.abs().greaterThan(1), () => {
          a.assign(As(f.oneMinus(), f.add(1), d).oneMinus());
        });
      } else
        dr(i.y.abs().greaterThan(1), () => {
          const u = i.x, h = i.y.greaterThan(0).cond(i.y.sub(1), i.y.add(1));
          u.mul(u).add(h.mul(h)).greaterThan(1).discard();
        });
      let l;
      if (this.lineColorNode)
        l = this.lineColorNode;
      else if (t) {
        const u = Mt("instanceColorStart"), h = Mt("instanceColorEnd");
        l = tn.y.lessThan(0.5).cond(u, h).mul(bo);
      } else
        l = bo;
      return st(l, a);
    })(), this.needsUpdate = !0;
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(e) {
    this.useWorldUnits !== e && (this.useWorldUnits = e, this.setupShaders());
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(e) {
    this.useDash !== e && (this.useDash = e, this.setupShaders());
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const ST = d1;
cn("Line2NodeMaterial", d1);
const _T = new Ab();
class f1 extends Yt {
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.colorSpace = !1, this.setDefaultValues(_T), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? Se(this.opacityNode) : Sh;
    qt.assign(st(ad(Ct), e));
  }
}
const MT = f1;
cn("MeshNormalNodeMaterial", f1);
const AT = new Cn();
class p1 extends Yt {
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(AT), this.setValues(e);
  }
}
const m1 = p1;
cn("MeshBasicNodeMaterial", p1);
const CT = Ve(({ f0: c, f90: e, dotVH: t }) => {
  const r = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return c.mul(r.oneMinus()).add(e.mul(r));
}), No = CT, ET = Ve((c) => c.diffuseColor.mul(1 / Math.PI)), hi = ET, RT = () => Se(0.25), LT = Ve(({ dotNH: c }) => za.mul(0.5 / Math.PI).add(1).mul(c.pow(za))), OT = Ve(({ lightDirection: c }) => {
  const e = c.add(Pt).normalize(), t = Ct.dot(e).clamp(), r = Pt.dot(e).clamp(), n = No({ f0: us, f90: 1, dotVH: r }), s = RT(), o = LT({ dotNH: t });
  return n.mul(s).mul(o);
});
class FT extends th {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = Ct.dot(e).clamp().mul(t);
    r.directDiffuse.addAssign(s.mul(hi({ diffuseColor: qt.rgb }))), this.specular === !0 && r.directSpecular.addAssign(s.mul(OT({ lightDirection: e })).mul(d0));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(hi({ diffuseColor: qt })));
  }
}
const $d = FT, IT = new Bm();
class g1 extends Yt {
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(IT), this.setValues(e);
  }
  setupLightingModel() {
    return new $d(!1);
  }
}
const PT = g1;
cn("MeshLambertNodeMaterial", g1);
const DT = new wa();
class y1 extends Yt {
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(DT), this.setValues(e);
  }
  setupLightingModel() {
    return new $d();
  }
  setupVariants() {
    const e = (this.shininessNode ? Se(this.shininessNode) : l0).max(1e-4);
    za.assign(e);
    const t = this.specularNode || h0;
    us.assign(t);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const UT = y1;
cn("MeshPhongNodeMaterial", y1);
const zT = Ve(() => {
  const c = li.dFdx().abs().max(li.dFdy().abs());
  return c.x.max(c.y).max(c.z);
}), v1 = zT, BT = Ve((c) => {
  const { roughness: e } = c, t = v1();
  let r = e.max(0.0525);
  return r = r.add(t), r = r.min(1), r;
}), x1 = BT, kT = Ve((c) => {
  const { alpha: e, dotNL: t, dotNV: r } = c, n = e.pow2(), s = t.mul(n.add(n.oneMinus().mul(r.pow2())).sqrt()), o = r.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt());
  return xo(0.5, s.add(o).max(hh));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), b1 = kT, GT = Ve(({ alpha: c, dotNH: e }) => {
  const t = c.pow2(), r = e.pow2().mul(t.oneMinus()).oneMinus();
  return t.div(r.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), N1 = GT, VT = Ve((c) => {
  const { lightDirection: e, f0: t, f90: r, roughness: n, iridescenceFresnel: s } = c, o = c.normalView || Ct, i = n.pow2(), a = e.add(Pt).normalize(), l = o.dot(e).clamp(), u = o.dot(Pt).clamp(), h = o.dot(a).clamp(), d = Pt.dot(a).clamp();
  let f = No({ f0: t, f90: r, dotVH: d });
  s && (f = hc.mix(f, s));
  const p = b1({ alpha: i, dotNL: l, dotNV: u }), m = N1({ alpha: i, dotNH: h });
  return f.mul(p).mul(m);
}), iu = VT, jT = Ve(({ roughness: c, dotNV: e }) => {
  const t = st(-1, -0.0275, -0.572, 0.022), r = st(1, 0.0425, 1.04, -0.04), n = c.mul(t).add(r), s = n.x.mul(n.x).min(e.mul(-9.28).exp2()).mul(n.x).add(n.y);
  return rt(-1.04, 1.04).mul(s).add(n.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), qd = jT, WT = Ve((c) => {
  const { dotNV: e, specularColor: t, specularF90: r, roughness: n } = c, s = qd({ dotNV: e, roughness: n });
  return t.mul(s.x).add(r.mul(s.y));
}), HT = WT, XT = Ve(({ f: c, f90: e, dotVH: t }) => {
  const r = t.oneMinus().saturate(), n = r.mul(r), s = r.mul(n, n).clamp(0, 0.9999);
  return c.sub(Ce(e).mul(s)).div(s.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), w1 = XT, $T = Ve(({ roughness: c, dotNH: e }) => {
  const t = c.pow2(), r = Se(1).div(t), s = e.pow2().oneMinus().max(78125e-7);
  return Se(2).add(r).mul(s.pow(r.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), qT = Ve(({ dotNV: c, dotNL: e }) => Se(1).div(Se(4).mul(e.add(c).sub(e.mul(c))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), JT = Ve(({ lightDirection: c }) => {
  const e = c.add(Pt).normalize(), t = Ct.dot(c).clamp(), r = Ct.dot(Pt).clamp(), n = Ct.dot(e).clamp(), s = $T({ roughness: uc, dotNH: n }), o = qT({ dotNV: r, dotNL: t });
  return mr.mul(s).mul(o);
}), YT = JT, KT = Ms(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), ZT = (c) => {
  const e = c.sqrt();
  return Ce(1).add(e).div(Ce(1).sub(e));
}, pp = (c, e) => c.sub(e).div(c.add(e)).pow2(), QT = (c, e) => {
  const t = c.mul(2 * Math.PI * 1e-9), r = Ce(54856e-17, 44201e-17, 52481e-17), n = Ce(1681e3, 1795300, 2208400), s = Ce(43278e5, 93046e5, 66121e5), o = Se(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let i = r.mul(s.mul(2 * Math.PI).sqrt()).mul(n.mul(t).add(e).cos()).mul(t.pow2().negate().mul(s).exp());
  return i = Ce(i.x.add(o), i.y, i.z).div(10685e-11), KT.mul(i);
}, eS = Ve(({ outsideIOR: c, eta2: e, cosTheta1: t, thinFilmThickness: r, baseF0: n }) => {
  const s = bn(c, e, As(0, 0.03, r)), o = c.div(s).pow2().mul(Se(1).sub(t.pow2())), a = Se(1).sub(o).sqrt(), l = pp(s, c), u = No({ f0: l, f90: 1, dotVH: t }), h = u.oneMinus(), d = s.lessThan(c).cond(Math.PI, 0), f = Se(Math.PI).sub(d), p = ZT(n.clamp(0, 0.9999)), m = pp(p, s.vec3()), g = No({ f0: m, f90: 1, dotVH: a }), b = Ce(
    p.x.lessThan(s).cond(Math.PI, 0),
    p.y.lessThan(s).cond(Math.PI, 0),
    p.z.lessThan(s).cond(Math.PI, 0)
  ), v = s.mul(r, a, 2), y = Ce(f).add(b), x = u.mul(g).clamp(1e-5, 0.9999), N = x.sqrt(), w = h.pow2().mul(g).div(Ce(1).sub(x));
  let _ = u.add(w), L = w.sub(h);
  for (let A = 1; A <= 2; ++A) {
    L = L.mul(N);
    const U = QT(Se(A).mul(v), Se(A).mul(y)).mul(2);
    _ = _.add(L.mul(U));
  }
  return _.max(Ce(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), tS = Ve(({ normal: c, viewDir: e, roughness: t }) => {
  const r = c.dot(e).saturate(), n = t.pow2(), s = br(
    t.lessThan(0.25),
    Se(-339.2).mul(n).add(Se(161.4).mul(t)).sub(25.9),
    Se(-8.48).mul(n).add(Se(14.3).mul(t)).sub(9.95)
  ), o = br(
    t.lessThan(0.25),
    Se(44).mul(n).sub(Se(23.7).mul(t)).add(3.26),
    Se(1.97).mul(n).sub(Se(3.27).mul(t)).add(0.72)
  );
  return br(t.lessThan(0.25), 0, Se(0.1).mul(t).sub(0.025)).add(s.mul(r).add(o).exp()).mul(1 / Math.PI).saturate();
}), cl = Ce(0.04), ll = Ce(1);
class nS extends th {
  constructor(e = !1, t = !1, r = !1) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = r, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start() {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = Ce().temp("clearcoatRadiance"), this.clearcoatSpecularDirect = Ce().temp("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = Ce().temp("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = Ce().temp("sheenSpecularDirect"), this.sheenSpecularIndirect = Ce().temp("sheenSpecularIndirect")), this.iridescence === !0) {
      const e = Ct.dot(Pt).clamp();
      this.iridescenceFresnel = eS({
        outsideIOR: Se(1),
        eta2: ah,
        cosTheta1: e,
        thinFilmThickness: ch,
        baseF0: us
      }), this.iridescenceF0 = w1({ f: this.iridescenceFresnel, f90: 1, dotVH: e });
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, r = Se(1)) {
    const n = Ct.dot(Pt).clamp(), s = qd({ roughness: uo, dotNV: n }), i = (this.iridescenceF0 ? hc.mix(us, this.iridescenceF0) : us).mul(s.x).add(r.mul(s.y)), l = s.x.add(s.y).oneMinus(), u = us.add(us.oneMinus().mul(0.047619)), h = i.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(i), t.addAssign(h.mul(l));
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = Ct.dot(e).clamp().mul(t);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(YT({ lightDirection: e }))), this.clearcoat === !0) {
      const i = gr.dot(e).clamp().mul(t);
      this.clearcoatSpecularDirect.addAssign(i.mul(iu({ lightDirection: e, f0: cl, f90: ll, roughness: ii, normalView: gr })));
    }
    r.directDiffuse.addAssign(s.mul(hi({ diffuseColor: qt.rgb }))), r.directSpecular.addAssign(s.mul(iu({ lightDirection: e, f0: us, f90: 1, roughness: uo, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(hi({ diffuseColor: qt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: r }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(t.mul(
      mr,
      tS({
        normal: Ct,
        viewDir: Pt,
        roughness: uc
      })
    )), this.clearcoat === !0) {
      const l = gr.dot(Pt).clamp(), u = HT({
        dotNV: l,
        specularColor: cl,
        specularF90: ll,
        roughness: ii
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(u));
    }
    const n = Ce().temp("singleScattering"), s = Ce().temp("multiScattering"), o = t.mul(1 / Math.PI);
    this.computeMultiscattering(n, s);
    const i = n.add(s), a = qt.mul(i.r.max(i.g).max(i.b).oneMinus());
    r.indirectSpecular.addAssign(e.mul(n)), r.indirectSpecular.addAssign(s.mul(o)), r.indirectDiffuse.addAssign(a.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
    const n = Ct.dot(Pt).clamp().add(e), s = uo.mul(-16).oneMinus().negate().exp2(), o = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), t.indirectDiffuse.mulAssign(e), t.indirectSpecular.mulAssign(o);
  }
  finish(e) {
    const { outgoingLight: t } = e;
    if (this.clearcoat === !0) {
      const r = gr.dot(Pt).clamp(), n = No({
        dotVH: r,
        f0: cl,
        f90: ll
      }), s = t.mul(Ua.mul(n).oneMinus()).add(this.clearcoatSpecularDirect, this.clearcoatSpecularIndirect).mul(Ua);
      t.assign(s);
    }
    if (this.sheen === !0) {
      const r = mr.r.max(mr.g).max(mr.b).mul(0.157).oneMinus(), n = t.mul(r).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      t.assign(n);
    }
  }
}
const Jd = nS, sS = new jn();
class T1 extends Yt {
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(sS), this.setValues(e);
  }
  setupLightingModel() {
    return new Jd();
  }
  setupVariants() {
    const e = this.metalnessNode ? Se(this.metalnessNode) : p0;
    qg.assign(e);
    let t = this.roughnessNode ? Se(this.roughnessNode) : f0;
    t = x1({ roughness: t }), uo.assign(t);
    const r = bn(Ce(0.04), qt.rgb, e);
    us.assign(r), qt.assign(st(qt.rgb.mul(e.oneMinus()), qt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const Yd = T1;
cn("MeshStandardNodeMaterial", T1);
const rS = new Es();
class S1 extends Yd {
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.setDefaultValues(rS), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  setupLightingModel() {
    return new Jd(this.useClearcoat, this.useSheen, this.useIridescence);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const t = this.clearcoatNode ? Se(this.clearcoatNode) : g0, r = this.clearcoatRoughnessNode ? Se(this.clearcoatRoughnessNode) : y0;
      Ua.assign(t), ii.assign(r);
    }
    if (this.useSheen) {
      const t = this.sheenNode ? Ce(this.sheenNode) : b0, r = this.sheenRoughnessNode ? Se(this.sheenRoughnessNode) : N0;
      mr.assign(t), uc.assign(r);
    }
    if (this.useIridescence) {
      const t = this.iridescenceNode ? Se(this.iridescenceNode) : w0, r = this.iridescenceIORNode ? Se(this.iridescenceIORNode) : T0, n = this.iridescenceThicknessNode ? Se(this.iridescenceThicknessNode) : S0;
      hc.assign(t), ah.assign(r), ch.assign(n);
    }
  }
  setupNormal(e) {
    super.setupNormal(e);
    const t = this.clearcoatNormalNode ? Ce(this.clearcoatNormalNode) : v0;
    gr.assign(t);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, super.copy(e);
  }
}
const _1 = S1;
cn("MeshPhysicalNodeMaterial", S1);
const oS = new Mu();
class M1 extends Yt {
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.normals = !1, this.transparent = !0, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.sizeNode = null, this.positionNode = null, this.setDefaultValues(oS), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
const Kd = M1;
cn("PointsNodeMaterial", M1);
const iS = new Cb();
class A1 extends Yt {
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this.normals = !1, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(iS), this.setValues(e);
  }
  setupPosition({ object: e, context: t }) {
    const { positionNode: r, rotationNode: n, scaleNode: s } = this, o = rn;
    let i = Zs.mul(Ce(r || 0)), a = rt(ci[0].xyz.length(), ci[1].xyz.length());
    s !== null && (a = a.mul(s));
    let l = o.xy;
    e.center && e.center.isVector2 === !0 && (l = l.sub(Ft(e.center).sub(0.5))), l = l.mul(a);
    const u = Se(n || x0), h = u.cos(), d = u.sin(), f = rt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      rt(h, d.negate()).dot(l),
      rt(d, h).dot(l)
    );
    i = st(i.xy.add(f), i.zw);
    const p = hs.mul(i);
    return t.vertex = o, p;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
}
const C1 = A1;
cn("SpriteNodeMaterial", A1);
const aS = wi.createMaterialFromType;
wi.createMaterialFromType = function(c) {
  const e = _o(c);
  return e !== void 0 ? e : aS.call(this, c);
};
class cS extends wi {
  constructor(e) {
    super(e), this.nodes = {};
  }
  parse(e) {
    const t = super.parse(e), r = this.nodes, n = e.inputNodes;
    for (const s in n) {
      const o = n[s];
      t[s] = r[o];
    }
    return t;
  }
  setNodes(e) {
    return this.nodes = e, this;
  }
}
const ja = cS;
class lS extends Eb {
  constructor(e) {
    super(e), this._nodesJSON = null;
  }
  parse(e, t) {
    this._nodesJSON = e.nodes;
    const r = super.parse(e, t);
    return this._nodesJSON = null, r;
  }
  parseNodes(e, t) {
    if (e !== void 0) {
      const r = new a1();
      return r.setTextures(t), r.parseNodes(e);
    }
    return {};
  }
  parseMaterials(e, t) {
    const r = {};
    if (e !== void 0) {
      const n = this.parseNodes(this._nodesJSON, t), s = new ja();
      s.setTextures(t), s.setNodes(n);
      for (let o = 0, i = e.length; o < i; o++) {
        const a = e[o];
        r[a.uuid] = s.parse(a);
      }
    }
    return r;
  }
}
const uS = lS;
class hS {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
const dS = hS;
class E1 {
  constructor(e, t, r = "", n = "") {
    this.type = e, this.inputs = t, this.name = r, this.presicion = n;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
E1.isNodeFunction = !0;
const fS = E1, pS = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, mS = /[a-z_0-9]+/ig, mp = "#pragma main", gS = (c) => {
  c = c.trim();
  const e = c.indexOf(mp), t = e !== -1 ? c.slice(e + mp.length) : c, r = t.match(pS);
  if (r !== null && r.length === 5) {
    const n = r[4], s = [];
    let o = null;
    for (; (o = mS.exec(n)) !== null; )
      s.push(o);
    const i = [];
    let a = 0;
    for (; a < s.length; ) {
      const p = s[a][0] === "const";
      p === !0 && a++;
      let m = s[a][0];
      m === "in" || m === "out" || m === "inout" ? a++ : m = "";
      const g = s[a++][0];
      let b = Number.parseInt(s[a][0]);
      Number.isNaN(b) === !1 ? a++ : b = null;
      const v = s[a++][0];
      i.push(new ed(g, v, b, m, p));
    }
    const l = t.substring(r[0].length), u = r[3] !== void 0 ? r[3] : "", h = r[2], d = r[1] !== void 0 ? r[1] : "", f = e !== -1 ? c.slice(0, e) : "";
    return {
      type: h,
      inputs: i,
      name: u,
      presicion: d,
      inputsCode: n,
      blockCode: l,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class yS extends fS {
  constructor(e) {
    const { type: t, inputs: r, name: n, presicion: s, inputsCode: o, blockCode: i, headerCode: a } = gS(e);
    super(t, r, n, s), this.inputsCode = o, this.blockCode = i, this.headerCode = a;
  }
  getCode(e = this.name) {
    let t;
    const r = this.blockCode;
    if (r !== "") {
      const { type: n, inputsCode: s, headerCode: o, presicion: i } = this;
      let a = `${n} ${e} ( ${s.trim()} )`;
      i !== "" && (a = `${i} ${a}`), t = o + a + r;
    } else
      t = "";
    return t;
  }
}
const vS = yS;
class xS extends dS {
  parseFunction(e) {
    return new vS(e);
  }
}
const R1 = xS, bS = Cd(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`), os = [bS], L1 = ln("float mx_perlin_noise_float( any p )", os), NS = ln("vec2 mx_perlin_noise_vec2( any p )", os), O1 = ln("vec3 mx_perlin_noise_vec3( any p )", os), wS = ln("float mx_cell_noise_float( vec3 p )", os), TS = ln("float mx_worley_noise_float( any p, float jitter, int metric )", os), SS = ln("vec2 mx_worley_noise_vec2( any p, float jitter, int metric )", os), _S = ln("vec3 mx_worley_noise_vec3( any p, float jitter, int metric )", os), MS = ln("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", os), AS = ln("vec2 mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", os), CS = ln("vec3 mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", os), ES = ln("vec4 mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", os), RS = ln(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`), LS = ln(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`), OS = Cd(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`), FS = [OS], IS = ln("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", FS), F1 = (c, e) => {
  c = Se(c), e = Se(e);
  const t = rt(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476);
  return As(c.sub(t), c.add(t), e);
}, I1 = (c, e, t, r) => bn(c, e, t[r].clamp()), PS = (c, e, t = yt()) => I1(c, e, t, "x"), DS = (c, e, t = yt()) => I1(c, e, t, "y"), P1 = (c, e, t, r, n) => bn(c, e, F1(t, r[n])), US = (c, e, t, r = yt()) => P1(c, e, t, r, "x"), zS = (c, e, t, r = yt()) => P1(c, e, t, r, "y"), BS = (c = 1, e = 0, t = yt()) => t.mul(c).add(e), kS = (c, e = 1) => (c = Se(c), c.abs().pow(e).mul(c.sign())), GS = (c, e = 1, t = 0.5) => Se(c).sub(t).mul(e).add(t), VS = (c = yt(), e = 1, t = 0) => L1(c.convert("vec2|vec3")).mul(e).add(t), jS = (c = yt(), e = 1, t = 0) => NS(c.convert("vec2|vec3")).mul(e).add(t), WS = (c = yt(), e = 1, t = 0) => O1(c.convert("vec2|vec3")).mul(e).add(t), HS = (c = yt(), e = 1, t = 0) => (c = c.convert("vec2|vec3"), st(O1(c), L1(c.add(rt(19, 73)))).mul(e).add(t)), XS = (c = yt(), e = 1) => TS(c.convert("vec2|vec3"), e, 1), $S = (c = yt(), e = 1) => SS(c.convert("vec2|vec3"), e, 1), qS = (c = yt(), e = 1) => _S(c.convert("vec2|vec3"), e, 1), JS = (c = yt()) => wS(c.convert("vec2|vec3")), YS = (c = yt(), e = 3, t = 2, r = 0.5, n = 1) => MS(c, e, t, r).mul(n), KS = (c = yt(), e = 3, t = 2, r = 0.5, n = 1) => AS(c, e, t, r).mul(n), ZS = (c = yt(), e = 3, t = 2, r = 0.5, n = 1) => CS(c, e, t, r).mul(n), QS = (c = yt(), e = 3, t = 2, r = 0.5, n = 1) => ES(c, e, t, r).mul(n), D1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AONode: Gh,
  AmbientLightNode: mT,
  AnalyticLightNode: rr,
  ArrayElementNode: rc,
  ArrayUniformNode: Vg,
  AssignNode: UN,
  AttributeNode: qu,
  BRDF_GGX: iu,
  BRDF_Lambert: hi,
  BitangentNode: so,
  BlendModeNode: ro,
  BufferAttributeNode: xw,
  BufferNode: Fh,
  BumpMapNode: F2,
  BypassNode: Hg,
  CacheNode: Xg,
  CameraNode: wh,
  CheckerNode: o1,
  CodeNode: Ad,
  ColorAdjustmentNode: Jo,
  ColorSpaceNode: $o,
  ComputeNode: e1,
  CondNode: Kh,
  ConstNode: On,
  ContextNode: Qu,
  ConvertNode: oc,
  CubeTextureNode: z0,
  DFGApprox: qd,
  D_GGX: N1,
  DirectionalLightNode: hT,
  DiscardNode: e2,
  EPSILON: hh,
  EnvironmentNode: Jh,
  EquirectUVNode: W0,
  ExpressionNode: r0,
  F_Schlick: No,
  FogExp2Node: Kv,
  FogNode: _c,
  FogRangeNode: Jv,
  FrontFacingNode: Sv,
  FunctionCallNode: rT,
  FunctionNode: Wv,
  GLSLNodeParser: R1,
  HashNode: Qw,
  HemisphereLightNode: r1,
  IESSpotLightNode: pT,
  INFINITY: ZN,
  If: dr,
  IndexNode: kN,
  InstanceNode: bw,
  InstancedPointsNodeMaterial: xT,
  JoinNode: cg,
  LightNode: uT,
  LightingContextNode: _w,
  LightingModel: th,
  LightingNode: Ei,
  LightsNode: G0,
  Line2NodeMaterial: ST,
  LineBasicNodeMaterial: u1,
  LineDashedNodeMaterial: wT,
  LoopNode: n2,
  MatcapUVNode: ev,
  MaterialNode: ws,
  MaterialReferenceNode: o0,
  MathNode: ke,
  MaxMipLevelNode: H0,
  MeshBasicNodeMaterial: m1,
  MeshLambertNodeMaterial: PT,
  MeshNormalNodeMaterial: MT,
  MeshPhongNodeMaterial: UT,
  MeshPhysicalNodeMaterial: _1,
  MeshStandardNodeMaterial: Yd,
  ModelNode: fw,
  ModelViewProjectionNode: M0,
  MorphNode: ww,
  Node: Oe,
  NodeAttribute: Da,
  NodeBuilder: q0,
  NodeCache: cc,
  NodeCode: rh,
  NodeFrame: Qh,
  NodeFunctionInput: ed,
  NodeKeywords: oh,
  NodeLoader: a1,
  NodeMaterial: Yt,
  NodeMaterialLoader: ja,
  NodeObjectLoader: uS,
  NodeShaderStage: ql,
  NodeType: xN,
  NodeUniform: nh,
  NodeUpdateType: ht,
  NodeUtils: bN,
  NodeVar: lc,
  NodeVarying: sh,
  NormalMapNode: Ov,
  NormalNode: qo,
  Object3DNode: gn,
  OperatorNode: Qg,
  OscNode: no,
  OutputStructNode: Kw,
  PackingNode: h2,
  ParameterNode: Ql,
  PhongLightingModel: $d,
  PhysicalLightingModel: Jd,
  PointLightNode: n1,
  PointUVNode: vv,
  PointsNodeMaterial: Kd,
  PositionNode: Bs,
  PosterizeNode: Pv,
  PropertyNode: ih,
  RangeNode: Qv,
  ReferenceNode: mc,
  ReflectVectorNode: D0,
  RemapNode: sv,
  RotateUVNode: iv,
  SceneNode: v2,
  Schlick_to_F0: w1,
  ScriptableNode: cT,
  ScriptableValueNode: iT,
  SetNode: hg,
  ShaderNode: yr,
  SkinningNode: F0,
  SpecularMIPLevelNode: X0,
  SplitNode: Fa,
  SpotLightNode: s1,
  SpriteNodeMaterial: C1,
  SpriteSheetUVNode: cv,
  StackNode: Vw,
  StorageBufferNode: N2,
  TBNViewMatrix: Iv,
  TangentNode: to,
  TempNode: St,
  TextureBicubicNode: y2,
  TextureNode: Mi,
  TextureStoreNode: T2,
  TimerNode: tv,
  ToneMappingNode: Uv,
  TriplanarTexturesNode: uv,
  UVNode: Yg,
  UniformNode: nt,
  UserDataNode: _2,
  V_GGX_SmithCorrelated: b1,
  VarNode: kg,
  VaryingNode: Wg,
  ViewportDepthNode: Q2,
  ViewportDepthTextureNode: Y2,
  ViewportNode: ks,
  ViewportSharedTextureNode: J2,
  ViewportTextureNode: wd,
  abs: fh,
  acos: My,
  add: ts,
  addLightNode: Rr,
  addNodeClass: re,
  addNodeElement: V,
  addNodeMaterial: cn,
  and: iy,
  append: yg,
  arrayBuffer: Ug,
  asin: _y,
  assign: jg,
  atan: Ay,
  atan2: zy,
  attribute: Mt,
  backgroundBlurriness: x2,
  backgroundIntensity: b2,
  bitAnd: ly,
  bitOr: uy,
  bitXor: hy,
  bitangentGeometry: d2,
  bitangentLocal: f2,
  bitangentView: fv,
  bitangentWorld: p2,
  bmat3: Og,
  bmat4: Pg,
  bool: bg,
  buffer: Ih,
  bufferAttribute: Ai,
  bumpMap: Mv,
  burn: bv,
  bvec2: Tg,
  bvec3: Mg,
  bvec4: Eg,
  bypass: Yu,
  cache: Pa,
  call: jv,
  cameraFar: _a,
  cameraNear: Sa,
  cameraNormalMatrix: uw,
  cameraPosition: dw,
  cameraProjectionMatrix: hs,
  cameraViewMatrix: Rs,
  cameraWorldMatrix: hw,
  ceil: dh,
  checker: i1,
  clamp: gh,
  clearcoat: Ua,
  clearcoatRoughness: ii,
  code: Sc,
  color: vg,
  colorSpaceToLinear: pc,
  colorToDirection: nv,
  compute: t1,
  cond: br,
  context: Zn,
  convert: Bg,
  cos: Ty,
  createNodeFromType: Kl,
  createNodeMaterialFromType: _o,
  cross: Xy,
  cubeTexture: vc,
  dFdx: Oy,
  dFdy: Fy,
  dashSize: xr,
  defaultBuildStages: Jl,
  defaultShaderStages: Qr,
  degrees: my,
  densityFog: Zv,
  depth: eT,
  depthTexture: tT,
  difference: Hy,
  diffuseColor: qt,
  directionToColor: ad,
  discard: Z0,
  distance: Wy,
  div: xo,
  dodge: Nv,
  dot: ph,
  dynamicBufferAttribute: C0,
  element: zg,
  equal: ty,
  equirectUV: xc,
  exp: gy,
  exp2: yy,
  expression: _i,
  faceDirection: yd,
  faceForward: Qy,
  float: Se,
  floor: dc,
  fog: qv,
  fract: fc,
  frameId: i2,
  frontFacing: _v,
  fwidth: Uy,
  gapSize: ai,
  getConstNodeType: gg,
  getCurrentStack: Gu,
  getDistanceAttenuation: Bd,
  getGeometryRoughness: v1,
  getRoughness: x1,
  global: Ma,
  glsl: Cd,
  glslFn: ln,
  greaterThan: sy,
  greaterThanEqual: oy,
  hash: K0,
  hue: Ev,
  imat3: Rg,
  imat4: Fg,
  instance: L0,
  instanceIndex: $g,
  instancedBufferAttribute: E0,
  instancedDynamicBufferAttribute: R0,
  int: Ia,
  inverseSqrt: Ny,
  iridescence: hc,
  iridescenceIOR: ah,
  iridescenceThickness: ch,
  ivec2: Ng,
  ivec3: Sg,
  ivec4: Ag,
  js: nT,
  label: eh,
  length: Ey,
  lessThan: ny,
  lessThanEqual: ry,
  lightTargetDirection: zd,
  lightingContext: jh,
  lights: Sw,
  lightsWithoutWrap: V0,
  linearToColorSpace: t0,
  linearTosRGB: n0,
  log: vy,
  log2: xy,
  loop: Q0,
  lumaCoeffs: Rv,
  luminance: Lv,
  mat3: Ms,
  mat4: Vu,
  matcapUV: s2,
  materialAlphaTest: c0,
  materialClearcoat: g0,
  materialClearcoatNormal: v0,
  materialClearcoatRoughness: y0,
  materialColor: bo,
  materialEmissive: u0,
  materialIridescence: w0,
  materialIridescenceIOR: T0,
  materialIridescenceThickness: S0,
  materialLineDashOffset: eu,
  materialLineDashSize: _h,
  materialLineGapSize: Mh,
  materialLineScale: Ga,
  materialLineWidth: Yr,
  materialMetalness: p0,
  materialNormal: m0,
  materialOpacity: Sh,
  materialPointWidth: _0,
  materialReference: i0,
  materialReflectivity: vw,
  materialRotation: x0,
  materialRoughness: f0,
  materialSheen: b0,
  materialSheenRoughness: N0,
  materialShininess: l0,
  materialSpecularColor: h0,
  materialSpecularStrength: d0,
  max: ky,
  maxMipLevel: Xh,
  metalness: qg,
  min: By,
  mix: bn,
  mod: Gy,
  modelDirection: pw,
  modelNormalMatrix: Th,
  modelPosition: mw,
  modelScale: gw,
  modelViewMatrix: Zs,
  modelViewPosition: yw,
  modelViewProjection: A0,
  modelWorldMatrix: ci,
  morph: P0,
  mul: en,
  mx_aastep: F1,
  mx_cell_noise_float: JS,
  mx_contrast: GS,
  mx_fractal_noise_float: YS,
  mx_fractal_noise_vec2: KS,
  mx_fractal_noise_vec3: ZS,
  mx_fractal_noise_vec4: QS,
  mx_hsvtorgb: RS,
  mx_noise_float: VS,
  mx_noise_vec2: jS,
  mx_noise_vec3: WS,
  mx_noise_vec4: HS,
  mx_ramplr: PS,
  mx_ramptb: DS,
  mx_rgbtohsv: LS,
  mx_safepower: kS,
  mx_splitlr: US,
  mx_splittb: zS,
  mx_srgb_texture_to_lin_rec709: IS,
  mx_transform_uv: BS,
  mx_worley_noise_float: XS,
  mx_worley_noise_vec2: $S,
  mx_worley_noise_vec3: qS,
  negate: Ry,
  nodeArray: vr,
  nodeImmutable: ue,
  nodeObject: Me,
  nodeObjects: Si,
  nodeProxy: J,
  normalGeometry: li,
  normalLocal: Mr,
  normalMap: Fv,
  normalView: ps,
  normalWorld: gc,
  normalize: Ln,
  objectDirection: ow,
  objectNormalMatrix: aw,
  objectPosition: ka,
  objectScale: lw,
  objectViewMatrix: iw,
  objectViewPosition: Nh,
  objectWorldMatrix: cw,
  oneMinus: Ly,
  or: ay,
  orthographicDepthToViewZ: K2,
  oscSawtooth: u2,
  oscSine: a2,
  oscSquare: c2,
  oscTriangle: l2,
  output: Jg,
  outputStruct: Zw,
  overlay: wv,
  parameter: YN,
  perspectiveDepthToViewZ: Vv,
  pointUV: xv,
  pointWidth: JN,
  positionGeometry: tn,
  positionLocal: rn,
  positionView: ns,
  positionViewDirection: Pt,
  positionWorld: Ah,
  positionWorldDirection: Ch,
  posterize: Dv,
  pow: mh,
  pow2: $y,
  pow3: qy,
  pow4: Jy,
  property: An,
  radians: py,
  range: lT,
  rangeFog: Yv,
  reciprocal: Py,
  reference: Cs,
  reflect: jy,
  reflectVector: U0,
  refract: Zy,
  remainder: ey,
  remap: rv,
  remapClamp: ov,
  rotateUV: av,
  roughness: uo,
  round: Iy,
  sRGBToLinear: s0,
  sampler: rw,
  saturate: Ky,
  saturation: Av,
  screen: Tv,
  scriptable: $v,
  scriptableValue: Yo,
  setCurrentStack: oi,
  shader: PN,
  shaderStages: sg,
  sheen: mr,
  sheenRoughness: uc,
  shiftLeft: dy,
  shiftRight: fy,
  shininess: za,
  sign: Cy,
  sin: wy,
  skinning: I0,
  smoothstep: As,
  specularColor: us,
  specularMIPLevel: qh,
  split: DN,
  spritesheetUV: lv,
  sqrt: by,
  stack: nu,
  step: Vy,
  storage: w2,
  string: Dg,
  sub: Ba,
  tan: Sy,
  tangentGeometry: ui,
  tangentLocal: yc,
  tangentView: Ci,
  tangentWorld: O0,
  temp: vo,
  texture: En,
  textureBicubic: yv,
  textureStore: S2,
  timerDelta: o2,
  timerGlobal: r2,
  timerLocal: id,
  toneMapping: W2,
  transformDirection: Yy,
  transformedBitangentView: pv,
  transformedBitangentWorld: m2,
  transformedClearcoatNormalView: gr,
  transformedNormalView: Ct,
  transformedNormalWorld: a0,
  transformedTangentView: Ph,
  transformedTangentWorld: Nw,
  triplanarTexture: dv,
  triplanarTextures: hv,
  trunc: Dy,
  tslFn: Ve,
  uint: xg,
  umat3: Lg,
  umat4: Ig,
  uniform: Ft,
  userData: M2,
  uv: yt,
  uvec2: wg,
  uvec3: _g,
  uvec4: Cg,
  varying: ct,
  vec2: rt,
  vec3: Ce,
  vec4: st,
  vectorComponents: nc,
  vertexIndex: GN,
  vibrance: Cv,
  viewZToOrthographicDepth: ou,
  viewZToPerspectiveDepth: Z2,
  viewport: Nr,
  viewportBottomLeft: X2,
  viewportBottomRight: q2,
  viewportCoordinate: H2,
  viewportDepthTexture: _d,
  viewportMipTexture: kv,
  viewportResolution: zv,
  viewportSharedTexture: Gv,
  viewportTexture: Bv,
  viewportTopLeft: wc,
  viewportTopRight: $2,
  wgsl: sT,
  wgslFn: oT,
  xor: cy
}, Symbol.toStringTag, { value: "Module" })), Ar = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new Set(), e_ = xn.prototype.clone;
xn.prototype.clone = function(c) {
  const e = e_.call(this, c);
  return Ar.set(this, e), e;
};
function U1() {
  for (const c of Wa)
    Ar.delete(c);
  Wa.clear();
}
function z1() {
  for (const c of Wa)
    Ar.delete(c);
  Wa.clear();
}
function B1(c, e, t) {
  U1();
  const r = c.clone(e);
  return c.traverse((n) => {
    if (!n.graph)
      return;
    const s = Ar.get(n);
    s && (s.graph = n.graph.clone(t || c, Ar));
  }), z1(), r;
}
const k1 = {
  BitangentNodeScope: {
    LOCAL: so.LOCAL,
    VIEW: so.VIEW,
    WORLD: so.WORLD,
    GEOMETRY: so.GEOMETRY
  },
  Blending: { AdditiveBlending: M.AdditiveBlending, CustomBlending: M.CustomBlending, MultiplyBlending: M.MultiplyBlending, NoBlending: M.NoBlending, NormalBlending: M.NormalBlending, SubtractiveBlending: M.SubtractiveBlending },
  BlendingDstFactor: { DstAlphaFactor: M.DstAlphaFactor, DstColorFactor: M.DstColorFactor, OneFactor: M.OneFactor, OneMinusDstAlphaFactor: M.OneMinusDstAlphaFactor, OneMinusDstColorFactor: M.OneMinusDstColorFactor, OneMinusSrcAlphaFactor: M.OneMinusSrcAlphaFactor, OneMinusSrcColorFactor: M.OneMinusSrcColorFactor, SrcAlphaFactor: M.SrcAlphaFactor, SrcColorFactor: M.SrcColorFactor, ZeroFactor: M.ZeroFactor },
  BlendingSrcFactor: { SrcAlphaSaturateFactor: M.SrcAlphaSaturateFactor },
  BlendingEquation: { AddEquation: M.AddEquation, MaxEquation: M.MaxEquation, MinEquation: M.MinEquation, ReverseSubtractEquation: M.ReverseSubtractEquation, SubtractEquation: M.SubtractEquation },
  BlendMode: {
    BURN: ro.BURN,
    DODGE: ro.DODGE,
    SCREEN: ro.SCREEN,
    OVERLAY: ro.OVERLAY
  },
  CameraNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION,
    PROJECTION_MATRIX: wh.PROJECTION_MATRIX
  },
  ColorAdjustmentMethod: {
    SATURATION: Jo.SATURATION,
    VIBRANCE: Jo.VIBRANCE,
    HUE: Jo.HUE
  },
  ColorSpace: { DisplayP3ColorSpace: M.DisplayP3ColorSpace, LinearDisplayP3ColorSpace: M.LinearDisplayP3ColorSpace, LinearSRGBColorSpace: M.LinearSRGBColorSpace, NoColorSpace: M.NoColorSpace, SRGBColorSpace: M.SRGBColorSpace },
  ColorSpaceNodeMethod: {
    LINEAR_TO_LINEAR: $o.LINEAR_TO_LINEAR,
    LINEAR_TO_sRGB: $o.LINEAR_TO_sRGB,
    sRGB_TO_LINEAR: $o.sRGB_TO_LINEAR
  },
  Combine: { AddOperation: M.AddOperation, MixOperation: M.MixOperation, MultiplyOperation: M.MultiplyOperation },
  CompressedPixelFormat: { RED_GREEN_RGTC2_Format: M.RED_GREEN_RGTC2_Format, RED_RGTC1_Format: M.RED_RGTC1_Format, RGBA_ASTC_10x10_Format: M.RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format: M.RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format: M.RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format: M.RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format: M.RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format: M.RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format: M.RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format: M.RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format: M.RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format: M.RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format: M.RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format: M.RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format: M.RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format: M.RGBA_ASTC_8x8_Format, RGBA_BPTC_Format: M.RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: M.RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format: M.RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format: M.RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format: M.RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format: M.RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format: M.RGBA_S3TC_DXT5_Format, RGB_BPTC_SIGNED_Format: M.RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format: M.RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format: M.RGB_ETC1_Format, RGB_ETC2_Format: M.RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format: M.RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format: M.RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: M.RGB_S3TC_DXT1_Format, SIGNED_RED_GREEN_RGTC2_Format: M.SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format: M.SIGNED_RED_RGTC1_Format },
  CoordinateSystem: { WebGLCoordinateSystem: M.WebGLCoordinateSystem, WebGPUCoordinateSystem: M.WebGPUCoordinateSystem },
  CubeTextureMapping: { CubeReflectionMapping: M.CubeReflectionMapping, CubeRefractionMapping: M.CubeRefractionMapping, CubeUVReflectionMapping: M.CubeUVReflectionMapping },
  DeepTexturePixelFormat: { DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat },
  DepthModes: { AlwaysDepth: M.AlwaysDepth, EqualDepth: M.EqualDepth, GreaterDepth: M.GreaterDepth, GreaterEqualDepth: M.GreaterEqualDepth, LessDepth: M.LessDepth, LessEqualDepth: M.LessEqualDepth, NeverDepth: M.NeverDepth, NotEqualDepth: M.NotEqualDepth },
  DepthPackingStrategies: { BasicDepthPacking: M.BasicDepthPacking, RGBADepthPacking: M.RGBADepthPacking },
  GLSLVersion: { GLSL1: M.GLSL1, GLSL3: M.GLSL3 },
  MagnificationTextureFilter: { LinearFilter: M.LinearFilter, NearestFilter: M.NearestFilter },
  Mapping: { EquirectangularReflectionMapping: M.EquirectangularReflectionMapping, EquirectangularRefractionMapping: M.EquirectangularRefractionMapping, UVMapping: M.UVMapping },
  MaterialNodeScope: {
    ALPHA_TEST: ws.ALPHA_TEST,
    COLOR: ws.COLOR,
    OPACITY: ws.OPACITY,
    ROUGHNESS: ws.ROUGHNESS,
    METALNESS: ws.METALNESS,
    EMISSIVE: ws.EMISSIVE,
    ROTATION: ws.ROTATION
  },
  MathNodeMethod1: {
    RADIANS: ke.RADIANS,
    DEGREES: ke.DEGREES,
    EXP: ke.EXP,
    EXP2: ke.EXP2,
    LOG: ke.LOG,
    LOG2: ke.LOG2,
    SQRT: ke.SQRT,
    INVERSE_SQRT: ke.INVERSE_SQRT,
    FLOOR: ke.FLOOR,
    CEIL: ke.CEIL,
    NORMALIZE: ke.NORMALIZE,
    FRACT: ke.FRACT,
    SIN: ke.SIN,
    COS: ke.COS,
    TAN: ke.TAN,
    ASIN: ke.ASIN,
    ACOS: ke.ACOS,
    ATAN: ke.ATAN,
    ABS: ke.ABS,
    SIGN: ke.SIGN,
    LENGTH: ke.LENGTH,
    NEGATE: ke.NEGATE,
    ONE_MINUS: ke.ONE_MINUS,
    DFDX: ke.DFDX,
    DFDY: ke.DFDY,
    ROUND: ke.ROUND
  },
  MathNodeMethod2: {
    ATAN2: ke.ATAN2,
    MIN: ke.MIN,
    MAX: ke.MAX,
    MOD: ke.MOD,
    STEP: ke.STEP,
    REFLECT: ke.REFLECT,
    DISTANCE: ke.DISTANCE,
    DOT: ke.DOT,
    CROSS: ke.CROSS,
    POW: ke.POW,
    TRANSFORM_DIRECTION: ke.TRANSFORM_DIRECTION
  },
  MathNodeMethod3: {
    MIX: ke.MIX,
    CLAMP: ke.CLAMP,
    REFRACT: ke.REFRACT,
    SMOOTHSTEP: ke.SMOOTHSTEP,
    FACEFORWARD: ke.FACEFORWARD
  },
  MinificationTextureFilter: { LinearFilter: M.LinearFilter, LinearMipMapLinearFilter: M.LinearMipMapLinearFilter, LinearMipMapNearestFilter: M.LinearMipMapNearestFilter, LinearMipmapLinearFilter: M.LinearMipmapLinearFilter, LinearMipmapNearestFilter: M.LinearMipmapNearestFilter, NearestFilter: M.NearestFilter, NearestMipMapLinearFilter: M.NearestMipMapLinearFilter, NearestMipMapNearestFilter: M.NearestMipMapNearestFilter, NearestMipmapLinearFilter: M.NearestMipmapLinearFilter, NearestMipmapNearestFilter: M.NearestMipmapNearestFilter },
  NodeTypeOption: "void,bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","),
  NormalMapTypes: { ObjectSpaceNormalMap: M.ObjectSpaceNormalMap, TangentSpaceNormalMap: M.TangentSpaceNormalMap },
  NormalNodeScope: {
    GEOMETRY: qo.GEOMETRY,
    LOCAL: qo.LOCAL,
    VIEW: qo.VIEW
  },
  Object3DNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION
  },
  OperatorNodeOp: ["=", "%", "&", "|", "^", ">>", "<<", "==", "&&", "||", "^^", "<", ">", "<=", ">=", "+", "-", "*", "/"],
  OscNodeMethod: {
    SINE: no.SINE,
    SQUARE: no.SQUARE,
    TRIANGLE: no.TRIANGLE,
    SAWTOOTH: no.SAWTOOTH
  },
  PixelFormatGPU: ["ALPHA", "DEPTH24_STENCIL8", "DEPTH32F_STENCIL8", "DEPTH_COMPONENT16", "DEPTH_COMPONENT24", "DEPTH_COMPONENT32F", "LUMINANCE", "LUMINANCE_ALPHA", "R11F_G11F_B10F", "R16F", "R16I", "R16UI", "R32F", "R32I", "R32UI", "R8", "R8I", "R8UI", "R8_SNORM", "RED_INTEGER", "RG16F", "RG16I", "RG16UI", "RG32F", "RG32I", "RG32UI", "RG8", "RG8I", "RG8UI", "RG8_SNORM", "RGB", "RGB10_A2", "RGB10_A2UI", "RGB16F", "RGB16I", "RGB16UI", "RGB32F", "RGB32I", "RGB32UI", "RGB565", "RGB5_A1", "RGB8", "RGB8I", "RGB8UI", "RGB8_SNORM", "RGB9_E5", "RGBA", "RGBA16F", "RGBA16I", "RGBA16UI", "RGBA32F", "RGBA32I", "RGBA32UI", "RGBA4", "RGBA8", "RGBA8I", "RGBA8UI", "RGBA8_SNORM", "SRGB8", "SRGB8_ALPHA8"],
  PositionNodeScope: {
    GEOMETRY: Bs.GEOMETRY,
    LOCAL: Bs.LOCAL,
    WORLD: Bs.WORLD,
    WORLD_DIRECTION: Bs.WORLD_DIRECTION,
    VIEW: Bs.VIEW,
    VIEW_DIRECTION: Bs.VIEW_DIRECTION
  },
  Precision: ["highp", "mediump", "lowp"],
  Side: { BackSide: M.BackSide, DoubleSide: M.DoubleSide, FrontSide: M.FrontSide, TwoPassDoubleSide: M.TwoPassDoubleSide },
  StencilFunc: { AlwaysStencilFunc: M.AlwaysStencilFunc, EqualStencilFunc: M.EqualStencilFunc, GreaterEqualStencilFunc: M.GreaterEqualStencilFunc, GreaterStencilFunc: M.GreaterStencilFunc, LessEqualStencilFunc: M.LessEqualStencilFunc, LessStencilFunc: M.LessStencilFunc, NeverStencilFunc: M.NeverStencilFunc, NotEqualStencilFunc: M.NotEqualStencilFunc },
  StencilOp: { DecrementStencilOp: M.DecrementStencilOp, DecrementWrapStencilOp: M.DecrementWrapStencilOp, IncrementStencilOp: M.IncrementStencilOp, IncrementWrapStencilOp: M.IncrementWrapStencilOp, InvertStencilOp: M.InvertStencilOp, KeepStencilOp: M.KeepStencilOp, ReplaceStencilOp: M.ReplaceStencilOp, ZeroStencilOp: M.ZeroStencilOp },
  TangentNodeScope: {
    LOCAL: to.LOCAL,
    VIEW: to.VIEW,
    WORLD: to.WORLD,
    GEOMETRY: to.GEOMETRY
  },
  TextureComparisonFunction: { AlwaysCompare: M.AlwaysCompare, EqualCompare: M.EqualCompare, GreaterCompare: M.GreaterCompare, GreaterEqualCompare: M.GreaterEqualCompare, LessCompare: M.LessCompare, LessEqualCompare: M.LessEqualCompare, NeverCompare: M.NeverCompare, NotEqualCompare: M.NotEqualCompare },
  TextureDataType: { ByteType: M.ByteType, FloatType: M.FloatType, HalfFloatType: M.HalfFloatType, IntType: M.IntType, ShortType: M.ShortType, UnsignedByteType: M.UnsignedByteType, UnsignedInt248Type: M.UnsignedInt248Type, UnsignedIntType: M.UnsignedIntType, UnsignedShort4444Type: M.UnsignedShort4444Type, UnsignedShort5551Type: M.UnsignedShort5551Type, UnsignedShortType: M.UnsignedShortType },
  TextureEncoding: { LinearEncoding: M.LinearEncoding, sRGBEncoding: M.sRGBEncoding },
  ToneMapping: {
    NoToneMapping: M.NoToneMapping,
    LinearToneMapping: M.LinearToneMapping,
    ReinhardToneMapping: M.ReinhardToneMapping,
    CineonToneMapping: M.CineonToneMapping,
    ACESFilmicToneMapping: M.ACESFilmicToneMapping,
    CustomToneMapping: M.CustomToneMapping
  },
  ViewportNodeScope: {
    COORDINATE: ks.COORDINATE,
    RESOLUTION: ks.RESOLUTION,
    TOP_LEFT: ks.TOP_LEFT,
    BOTTOM_LEFT: ks.BOTTOM_LEFT,
    TOP_RIGHT: ks.TOP_RIGHT,
    BOTTOM_RIGHT: ks.BOTTOM_RIGHT
  },
  WebGL1PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGFormat: M.RGFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  WebGL2PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGBAFormat: M.RGBAFormat, RGBAIntegerFormat: M.RGBAIntegerFormat, RGFormat: M.RGFormat, RGIntegerFormat: M.RGIntegerFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  Wrapping: { ClampToEdgeWrapping: M.ClampToEdgeWrapping, MirroredRepeatWrapping: M.MirroredRepeatWrapping, RepeatWrapping: M.RepeatWrapping }
}, Ha = {
  AmbientLight: {
    cls: M.AmbientLight,
    isAmbientLight: !0,
    members: {
      // type: "string | 'AmbientLight'"
    },
    proto: "Light"
  },
  AmbientLightProbe: {
    // cls: THREE.AmbientLightProbe,
    isAmbientLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  ArrayCamera: {
    cls: M.ArrayCamera,
    isArrayCamera: !0,
    members: { cameras: "PerspectiveCamera[]" },
    proto: "PerspectiveCamera"
  },
  Audio: {
    cls: M.Audio,
    members: {},
    proto: "Object3D"
  },
  AudioListener: {
    cls: M.AudioListener,
    members: {},
    proto: "Object3D"
  },
  Camera: {
    cls: M.Camera,
    isCamera: !0,
    members: {
      coordinateSystem: "types.CoordinateSystem",
      // layers: 'Layers',
      matrixWorldInverse: "Matrix4",
      projectionMatrix: "Matrix4",
      projectionMatrixInverse: "Matrix4"
      // type: "string | 'Camera'"
    },
    proto: "Object3D"
  },
  CanvasTexture: {
    cls: M.CanvasTexture,
    isCanvasTexture: !0,
    members: {},
    proto: "Texture"
  },
  CompressedArrayTexture: {
    cls: M.CompressedArrayTexture,
    isCompressedArrayTexture: !0,
    members: { wrapR: "types.Wrapping" },
    proto: "CompressedTexture"
  },
  CompressedTexture: {
    cls: M.CompressedTexture,
    isCompressedTexture: !0,
    members: {
      flipY: "boolean",
      format: "types.CompressedPixelFormat",
      generateMipmaps: "boolean"
      // mipmaps: 'ImageData[]'
    },
    proto: "Texture"
  },
  CubeCamera: {
    cls: M.CubeCamera,
    members: {
      coordinateSystem: "types.CoordinateSystem"
      // renderTarget: 'WebGLCubeRenderTarget',
      // type: "string | 'CubeCamera'"
    },
    proto: "Object3D"
  },
  CubeTexture: {
    cls: M.CubeTexture,
    isCubeTexture: !0,
    members: {
      flipY: "boolean",
      mapping: "types.CubeTextureMapping"
    },
    proto: "Texture"
  },
  Data3DTexture: {
    cls: M.Data3DTexture,
    isData3DTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "types.Wrapping"
    },
    proto: "Texture"
  },
  DataArrayTexture: {
    cls: M.DataArrayTexture,
    isDataArrayTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "boolean"
    },
    proto: "Texture"
  },
  DataTexture: {
    cls: M.DataTexture,
    isDataTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number"
    },
    proto: "Texture"
  },
  DepthTexture: {
    cls: M.DepthTexture,
    isDepthTexture: !0,
    members: {
      compareFunction: "types.TextureComparisonFunction | null",
      flipY: "boolean",
      format: "types.DeepTexturePixelFormat",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      type: "types.TextureDataType"
    },
    proto: "Texture"
  },
  DirectionalLight: {
    cls: M.DirectionalLight,
    isDirectionalLight: !0,
    members: {
      castShadow: "boolean",
      position: "Vector3",
      // shadow: 'DirectionalLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'DirectionalLight'"
    },
    proto: "Light"
  },
  DirectionalLightShadow: {
    cls: M.DirectionalLightShadow,
    isDirectionalLightShadow: !0,
    members: {
      camera: "OrthographicCamera"
    },
    proto: "LightShadow"
  },
  Fog: {
    cls: M.Fog,
    isFog: !0,
    members: {
      color: "Color",
      far: "number",
      // name: 'string',
      near: "number"
    },
    proto: "FogBase"
  },
  FogExp2: {
    cls: M.FogExp2,
    isFogExp2: !0,
    members: {
      color: "Color",
      density: "number"
      // name: 'string'
    },
    proto: "FogBase"
  },
  FramebufferTexture: {
    cls: M.FramebufferTexture,
    isFramebufferTexture: !0,
    members: {
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter"
    },
    proto: "Texture"
  },
  HemisphereLight: {
    cls: M.HemisphereLight,
    isHemisphereLight: !0,
    members: {
      color: "Color",
      groundColor: "Color",
      position: "Vector3"
      // type: "string | 'HemisphereLight'"
    },
    proto: "Light"
  },
  HemisphereLightProbe: {
    // cls: THREE.HemisphereLightProbe,
    isHemisphereLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  InstancedMesh: {
    cls: M.InstancedMesh,
    members: {
      count: "number"
    },
    proto: "Mesh"
  },
  Light: {
    cls: M.Light,
    isLight: !0,
    members: {
      color: "Color",
      intensity: "number",
      shadow: "LightShadow"
      // type: "string | 'Light'"
    },
    proto: "Object3D"
  },
  LightProbe: {
    cls: M.LightProbe,
    isLightProbe: !0,
    members: {
      sh: "SphericalHarmonics3"
    },
    proto: "Light"
  },
  LightShadow: {
    cls: M.LightShadow,
    members: {
      // autoUpdate: 'boolean',
      bias: "number",
      blurSamples: "number",
      camera: "Camera",
      // map: 'WebGLRenderTarget | null',
      // mapPass: 'WebGLRenderTarget | null',
      mapSize: "Vector2",
      matrix: "Matrix4",
      // needsUpdate: 'boolean',
      normalBias: "number",
      radius: "number"
    }
  },
  LineBasicMaterial: {
    cls: M.LineBasicMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      linecap: "string",
      linejoin: "string",
      linewidth: "number",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  LineDashedMaterial: {
    cls: M.LineDashedMaterial,
    isLineDashedMaterial: !0,
    members: {
      dashSize: "number",
      gapSize: "number",
      scale: "number"
      // type: 'string'
    },
    proto: "LineBasicMaterial"
  },
  Material: {
    cls: M.Material,
    isMaterial: !0,
    members: {
      alphaHash: "boolean",
      // alphaTest: 'number',
      // alphaToCoverage: 'boolean',
      // blendDst: 'types.BlendingDstFactor',
      // blendDstAlpha: 'number | null',
      // blendEquation: 'types.BlendingEquation',
      // blendEquationAlpha: 'number | null',
      blendSrc: "types.BlendingSrcFactor | types.BlendingDstFactor",
      blendSrcAlpha: "number | null",
      blending: "types.Blending",
      // clipIntersection: 'boolean',
      // clipShadows: 'boolean',
      // clippingPlanes: 'Plane[]',
      // colorWrite: 'boolean',
      // defines: 'undefined | { [key: string]: any }',
      depthFunc: "types.DepthModes",
      depthTest: "boolean",
      depthWrite: "boolean",
      // dithering: 'boolean',
      // forceSinglePass: 'boolean',
      // id: 'number',
      // name: 'string',
      // needsUpdate: 'boolean',
      opacity: "number",
      // polygonOffset: 'boolean',
      // polygonOffsetFactor: 'number',
      // polygonOffsetUnits: 'number',
      precision: "types.Precision | null",
      premultipliedAlpha: "boolean",
      shadowSide: "types.Side | null",
      side: "types.Side",
      stencilFail: "types.StencilOp",
      stencilFunc: "types.StencilFunc",
      stencilFuncMask: "number",
      stencilRef: "number",
      stencilWrite: "boolean",
      stencilWriteMask: "number",
      stencilZFail: "types.StencilOp",
      stencilZPass: "types.StencilOp",
      toneMapped: "boolean",
      transparent: "boolean",
      // type: 'string',
      // userData: 'any',
      // uuid: 'string',
      // version: 'number',
      // vertexColors: 'boolean',
      visible: "boolean"
    },
    proto: "EventDispatcher"
  },
  Mesh: {
    cls: M.Mesh,
    members: {
      castShadow: "boolean",
      receiveShadow: "boolean",
      material: "Material"
    },
    proto: "Object3D"
  },
  MeshBasicMaterial: {
    cls: M.MeshBasicMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      color: "Color",
      combine: "types.Combine",
      envMap: "Texture | null",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDepthMaterial: {
    cls: M.MeshDepthMaterial,
    members: {
      alphaMap: "Texture | null",
      depthPacking: "types.DepthPackingStrategies",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDistanceMaterial: {
    cls: M.MeshDistanceMaterial,
    members: {
      alphaMap: "Texture | null",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshLambertMaterial: {
    cls: M.MeshLambertMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshMatcapMaterial: {
    cls: M.MeshMatcapMaterial,
    members: {
      alphaMap: "Texture | null",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      fog: "boolean",
      map: "Texture | null",
      matcap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshNormalMaterial: {
    cls: M.MeshNormalMaterial,
    members: {
      bumpMap: "Texture | null",
      bumpScale: "number",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhongMaterial: {
    cls: M.MeshPhongMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metal: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      shininess: "number",
      specular: "Color",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhysicalMaterial: {
    cls: M.MeshPhysicalMaterial,
    members: {
      anisotropy: "number",
      anisotropyMap: "Texture | null",
      anisotropyRotation: "number",
      attenuationColor: "Color",
      attenuationDistance: "number",
      clearcoat: "number",
      clearcoatMap: "Texture | null",
      clearcoatNormalMap: "Texture | null",
      clearcoatNormalScale: "Vector2",
      clearcoatRoughness: "number",
      clearcoatRoughnessMap: "Texture | null",
      // defines: '{ [key: string]: any }',
      ior: "number",
      iridescence: "number",
      iridescenceIOR: "number",
      iridescenceMap: "Texture | null",
      iridescenceThicknessMap: "Texture | null",
      iridescenceThicknessRange: "number[]",
      reflectivity: "number",
      sheen: "number",
      sheenColor: "Color",
      sheenColorMap: "Texture | null",
      sheenRoughness: "number",
      sheenRoughnessMap: "Texture | null",
      specularColor: "Color",
      specularColorMap: "Texture | null",
      specularIntensity: "number",
      specularIntensityMap: "Texture | null",
      thickness: "number",
      thicknessMap: "Texture | null",
      transmission: "number",
      transmissionMap: "Texture | null"
      // type: 'string'
    },
    proto: "MeshStandardMaterial"
  },
  MeshStandardMaterial: {
    cls: M.MeshStandardMaterial,
    isMeshStandardMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }', 
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      envMapIntensity: "number",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metalness: "number",
      metalnessMap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      roughness: "number",
      roughnessMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshToonMaterial: {
    cls: M.MeshToonMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      fog: "boolean",
      gradientMap: "Texture | null",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  Object3D: {
    cls: M.Object3D,
    isObject3D: !0,
    members: {
      up: "Vector3",
      position: "Vector3",
      rotation: "Euler",
      scale: "Vector3",
      visible: "Boolean"
    }
  },
  OrthographicCamera: {
    cls: M.OrthographicCamera,
    isOrthographicCamera: !0,
    members: {
      bottom: "number",
      far: "number",
      left: "number",
      near: "number",
      right: "number",
      top: "number",
      // type: "string | 'OrthographicCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PerspectiveCamera: {
    cls: M.PerspectiveCamera,
    isPerspectiveCamera: !0,
    members: {
      aspect: "number",
      far: "number",
      filmGauge: "number",
      filmOffset: "number",
      focus: "number",
      fov: "number",
      near: "number",
      //   type: "string | 'PerspectiveCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PointLight: {
    cls: M.PointLight,
    members: {
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      power: "number",
      // shadow: 'PointLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number"
      // type: 'string'
    },
    proto: "Light"
  },
  PointLightShadow: {
    cls: M.PointLightShadow,
    isPointLightShadow: !0,
    members: {},
    proto: "LightShadow"
  },
  Points: {
    cls: M.Points,
    members: {
      material: "Material"
    },
    proto: "Object3D"
  },
  PointsMaterial: {
    cls: M.PointsMaterial,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      size: "number",
      sizeAttenuation: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  PositionalAudio: {
    cls: M.PositionalAudio,
    members: {},
    proto: "Audio"
  },
  RawShaderMaterial: {
    cls: M.RawShaderMaterial,
    members: {},
    proto: "ShaderMaterial"
  },
  RectAreaLight: {
    cls: M.RectAreaLight,
    isRectAreaLight: !0,
    members: {
      height: "number",
      intensity: "number",
      power: "number",
      // type: "string | 'RectAreaLight'",
      width: "number"
    },
    proto: "Light"
  },
  Scene: {
    cls: M.Scene,
    isScene: !0,
    members: {
      background: "Color | Texture | CubeTexture | null",
      backgroundBlurriness: "number",
      backgroundIntensity: "number",
      environment: "Texture | null",
      fog: "FogBase | null",
      overrideMaterial: "Material | null"
      // type: "'Scene'"
    },
    proto: "Object3D"
  },
  ShaderMaterial: {
    cls: M.ShaderMaterial,
    isShaderMaterial: !0,
    members: {
      // clipping: 'boolean',
      //   defaultAttributeValues: 'any',
      //   defines: '{ [key: string]: any }', derivatives: 'any',
      //   extensions: `{
      //     derivatives: boolean;
      //     fragDepth: boolean;
      //     drawBuffers: boolean;
      //     shaderTextureLOD: boolean;
      // }`,
      fog: "boolean",
      // fragmentShader: 'string',
      // glslVersion: 'types.GLSLVersion | null',
      // index0AttributeName: 'string | undefined', lights: 'boolean', linewidth: 'number',
      // type: 'string',
      // uniforms: '{ [uniform: string]: IUniform }',
      // uniformsGroups: 'UniformsGroup[]',
      // uniformsNeedUpdate: 'boolean',
      // vertexShader: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  ShadowMaterial: {
    cls: M.ShadowMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  Source: {
    cls: M.Source,
    isSource: !0,
    members: {
      // data: 'any', id: 'number', uuid: 'string', version: 'number'
    }
  },
  SphericalHarmonics3: {
    cls: M.SphericalHarmonics3,
    isSphericalHarmonics3: !0,
    members: { coefficients: "Vector3[]" }
  },
  SpotLight: {
    cls: M.SpotLight,
    isSpotLight: !0,
    members: {
      angle: "number",
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      map: "Texture | null",
      penumbra: "number",
      position: "Vector3",
      power: "number",
      // shadow: 'SpotLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'SpotLight'"
    },
    proto: "Light"
  },
  SpotLightShadow: {
    cls: M.SpotLightShadow,
    isSpotLightShadow: !0,
    members: { camera: "PerspectiveCamera", focus: "number" },
    proto: "LightShadow"
  },
  SpriteMaterial: {
    cls: M.SpriteMaterial,
    isSpriteMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      rotation: "number",
      sizeAttenuation: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  StereoCamera: {
    cls: M.StereoCamera,
    members: {
      aspect: "number",
      cameraL: "PerspectiveCamera",
      cameraR: "PerspectiveCamera",
      eyeSep: "number"
      // type: "'StereoCamera'"
    },
    proto: "Camera"
  },
  Texture: {
    cls: M.Texture,
    isTexture: !0,
    members: {
      anisotropy: "number",
      center: "Vector2",
      channel: "number",
      colorSpace: "types.ColorSpace",
      encoding: "types.TextureEncoding",
      flipY: "boolean",
      format: "types.WebGL1PixelFormat | types.WebGL2PixelFormat | types.DeepTexturePixelFormat | types.CompressedPixelFormat",
      generateMipmaps: "boolean",
      // id: 'number',
      image: "Image",
      internalFormat: "types.PixelFormatGPU | null",
      // isRenderTargetTexture: 'boolean',
      magFilter: "types.MagnificationTextureFilter",
      mapping: "types.Mapping | types.CubeTextureMapping",
      matrix: "Matrix3",
      // matrixAutoUpdate: 'boolean', minFilter: 'types.MinificationTextureFilter', mipmaps: 'any[]',
      // name: 'string',
      // needsPMREMUpdate: 'boolean',
      offset: "Vector2",
      // onUpdate: '() => void',
      premultiplyAlpha: "boolean",
      repeat: "Vector2",
      rotation: "number",
      // source: 'Source',
      type: "types.TextureDataType",
      unpackAlignment: "number",
      // userData: 'any',
      // uuid: 'string', version: 'number',
      wrapS: "types.Wrapping",
      wrapT: "types.Wrapping"
    },
    proto: "EventDispatcher"
  },
  VideoTexture: {
    cls: M.VideoTexture,
    isVideoTexture: !0,
    members: { generateMipmaps: "boolean", magFilter: "types.MagnificationTextureFilter", minFilter: "types.MinificationTextureFilter" },
    proto: "Texture"
  }
}, di = {
  AONode: {
    cls: Gh,
    group: "lighting",
    members: { aoNode: "Node | null" },
    proto: "LightingNode"
  },
  AnalyticLightNode: {
    cls: rr,
    group: "lighting",
    members: { colorNode: "Node", light: "Light | null" },
    proto: "LightingNode"
  },
  ArrayElementNode: {
    cls: rc,
    group: "utils",
    members: { indexNode: "Node", node: "Node" },
    proto: "TempNode"
  },
  ArrayUniformNode: {
    cls: Vg,
    group: "core",
    isArrayUniformNode: !0,
    members: { nodes: "Node[]" },
    proto: "UniformNode"
  },
  AttributeNode: {
    cls: qu,
    group: "core",
    members: {},
    proto: "Node"
  },
  BitangentNode: {
    cls: so,
    group: "accessors",
    members: { scope: "types.BitangentNodeScope" },
    proto: "Node"
  },
  BlendModeNode: {
    cls: ro,
    group: "display",
    members: { baseNode: "Node", blendMode: "types.BlendMode", blendNode: "Node" },
    proto: "TempNode"
  },
  BufferNode: {
    cls: Fh,
    group: "accessors",
    isBufferNode: !0,
    members: { bufferCount: "number", bufferType: "string" },
    proto: "UniformNode"
  },
  BypassNode: {
    cls: Hg,
    group: "core",
    isBypassNode: !0,
    members: { callNode: "Node", outputNode: "Node" },
    proto: "Node"
  },
  CacheNode: {
    cls: Xg,
    group: "core",
    isCacheNode: !0,
    members: { cache: "NodeCache", node: "Node" },
    proto: "Node"
  },
  CameraNode: {
    cls: wh,
    group: "accessors",
    members: { scope: "types.CameraNodeScope" },
    proto: "Object3DNode"
  },
  CheckerNode: {
    cls: o1,
    group: "procedural",
    members: { uvNode: "Node" },
    proto: "TempNode"
  },
  CodeNode: {
    cls: Ad,
    group: "code",
    isCodeNode: !0,
    members: { code: "string" },
    proto: "Node"
  },
  ColorAdjustmentNode: {
    cls: Jo,
    group: "display",
    members: { adjustmentNode: "Node", colorNode: "Node", method: "types.ColorAdjustmentMethod" },
    proto: "TempNode"
  },
  ColorSpaceNode: {
    cls: $o,
    group: "display",
    members: { method: "types.ColorSpaceNodeMethod", node: "Node" },
    proto: "TempNode"
  },
  ComputeNode: {
    cls: e1,
    group: "gpgpu",
    isComputeNode: !0,
    members: { count: "number", dispatchCount: "number", workgroupSize: "number[]" },
    proto: "Node"
  },
  CondNode: {
    cls: Kh,
    group: "math",
    members: { condNode: "Node", elseNode: "Node", ifNode: "Node" },
    proto: "Node"
  },
  ConstNode: {
    cls: On,
    group: "core",
    isConstNode: !0,
    members: {},
    proto: "InputNode"
  },
  ContextNode: {
    cls: Qu,
    group: "core",
    isContextNode: !0,
    members: { context: "Object", node: "Node" },
    proto: "Node"
  },
  ConvertNode: {
    cls: oc,
    group: "utils",
    members: { convertTo: "types.NodeTypeOption", node: "Node" },
    proto: "Node"
  },
  CubeTextureNode: {
    cls: z0,
    group: "accessors",
    isCubeTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "CubeTexture" },
    proto: "TextureNode"
  },
  EnvironmentNode: {
    cls: Jh,
    group: "lighting",
    members: { envNode: "Node | null" },
    proto: "LightingNode"
  },
  EquirectUVNode: {
    cls: W0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  ExpressionNode: {
    cls: r0,
    group: "code",
    members: { snipped: "string" },
    proto: "TempNode"
  },
  FogExp2Node: {
    cls: Kv,
    group: "fog",
    isFogExp2Node: !0,
    members: { densityNode: "Node" },
    proto: "FogNode"
  },
  FogNode: {
    cls: _c,
    group: "fog",
    isFogNode: !0,
    members: { colorNode: "Node", factorNode: "Node" },
    proto: "Node"
  },
  FogRangeNode: {
    cls: Jv,
    group: "fog",
    isFogRangeNode: !0,
    members: { farNode: "Node", nearNode: "Node" },
    proto: "FogNode"
  },
  FrontFacingNode: {
    cls: Sv,
    group: "display",
    isFrontFacingNode: !0,
    members: {},
    proto: "Node"
  },
  // FunctionCallNode: {
  //   cls: Nodes.FunctionCallNode,
  //   group: 'code',
  //   members: {
  //     functionNode: 'FunctionNode<P>',
  //     parameters: '{ [name: string]: Node }'
  //   },
  //   proto: 'TempNode'
  // },
  FunctionNode: {
    cls: Wv,
    group: "code",
    members: { keywords: "{ [key: string]: Node }" },
    proto: "CodeNode"
  },
  HemisphereLightNode: {
    cls: r1,
    group: "lighting",
    members: { groundColorNode: "Node", lightDirectionNode: "Node", lightPositionNode: "Object3DNode" },
    proto: "AnalyticLightNode"
  },
  InputNode: {
    // cls: Nodes.InputNode,
    group: "core",
    isInputNode: !0,
    members: { precision: "types.Precision | null", value: "Color | Vector2 | Vector3 | Vector4 | Matrix3 | Matrix4 | boolean | number" },
    proto: "Node"
  },
  // InstanceNode: {
  //   cls: Nodes.InstanceNode,
  //   group: 'accessors',
  //   members: { instanceMatrixNode: 'Node', instanceMesh: 'InstancedMesh' },
  //   proto: 'Node'
  // },
  // LightingContextNode: {
  //   cls: Nodes.LightingContextNode,
  //   group: 'lighting',
  //   members: { lightingModelNode: 'LightingModelNode | null' },
  //   proto: 'ContextNode'
  // },
  LightingNode: {
    cls: Ei,
    group: "lighting",
    members: {},
    proto: "Node"
  },
  LightsNode: {
    cls: G0,
    group: "lighting",
    members: { lightNodes: "LightingNode[]" },
    proto: "Node"
  },
  LineBasicNodeMaterial: {
    cls: u1,
    group: "materials",
    isLineBasicNodeMaterial: !0,
    members: {},
    proto: ["LineBasicMaterial", "NodeMaterial"]
  },
  MatcapUVNode: {
    cls: ev,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  MaterialNode: {
    cls: ws,
    group: "accessors",
    members: { scope: "types.MaterialNodeScope" },
    proto: "Node"
  },
  MaterialReferenceNode: {
    cls: o0,
    group: "accessors",
    members: {},
    proto: "ReferenceNode"
  },
  MathNode: {
    cls: ke,
    group: "math",
    members: { aNode: "Node", bNode: "Node | null", cNode: "Node | null", method: "types.MathNodeMethod1 | types.MathNodeMethod2 | types.MathNodeMethod3" },
    proto: "TempNode"
  },
  MaxMipLevelNode: {
    cls: H0,
    group: "utils",
    members: { textureNode: "TextureNode" },
    proto: "UniformNode"
  },
  MeshBasicNodeMaterial: {
    cls: m1,
    group: "materials",
    isMeshBasicNodeMaterial: !0,
    members: { lights: "true" },
    proto: ["MeshBasicMaterial", "NodeMaterial"]
  },
  MeshPhysicalNodeMaterial: {
    cls: _1,
    group: "materials",
    members: { attenuationColorNode: "Node | null", attenuationDistanceNode: "Node | null", iridescenceIORNode: "null | Node", iridescenceNode: "null | CheckerNode", iridescenceThicknessNode: "null | Node", specularColorNode: "Node | null", specularIntensityNode: "Node | null", thicknessNode: "Node | null", transmissionNode: "Node | null" },
    proto: ["MeshPhysicalMaterial", "MeshStandardNodeMaterial"]
  },
  MeshStandardNodeMaterial: {
    cls: Yd,
    group: "materials",
    isMeshStandardNodeMaterial: !0,
    members: { clearcoatNode: "Node | null", clearcoatRoughnessNode: "Node | null", emissiveNode: "Node | null", metalnessNode: "Node | null", roughnessNode: "Node | null" },
    proto: ["MeshStandardMaterial", "NodeMaterial"]
  },
  ModelViewProjectionNode: {
    cls: M0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  Node: {
    cls: Oe,
    group: "core",
    isNode: !0,
    members: {
      // id: 'number',
      // nodeType: 'NodeTypeOption | null',
      // type: 'string',
      // updateType: 'NodeUpdateTypeOption',
      // uuid: 'string'
    }
  },
  NodeAttribute: {
    cls: Da,
    group: "core",
    isNodeAttribute: !0,
    members: { name: "string", type: "string" }
  },
  // NodeBuilder: {
  //   cls: Nodes.NodeBuilder,
  //   group: 'core',
  //   members: { buildStage: 'BuildStageOption | null', cache: 'NodeCache', computeShader: 'string', flowsData: 'any', fogNode: 'FogNode', fragmentShader: 'string', geometry: 'BufferGeometry', globalCache: 'NodeCache', hashNodes: '{ [hash: string]: Node }', lightsNode: 'LightsNode', material: 'Material', nodes: 'Node[]', object: 'Object3D', parser: 'NodeParser', renderer: 'Renderer', shaderStage: 'NodeShaderStageOption | null', stack: 'Node[]', updateNodes: 'Node[]', vertexShader: 'string' }
  // },
  NodeCache: {
    cls: cc,
    group: "core",
    members: {
      // id: 'number', nodesData: 'WeakMap<Node, NodeData>' 
    }
  },
  NodeCode: {
    cls: rh,
    group: "core",
    isNodeCode: !0,
    members: {}
  },
  // NodeFrame: {
  //   cls: Nodes.NodeFrame,
  //   group: 'core',
  //   members: { camera: 'null | Camera', deltaTime: 'number', frameId: 'number', material: 'null | Material', object: 'null | Object3D', renderer: 'null | Renderer', startTime: 'null | number', time: 'number' }
  // },
  NodeFunction: {
    // cls: Nodes.NodeFunction,
    group: "core",
    isNodeFunction: !0,
    members: { inputs: "NodeFunctionInput[]", name: "string", presicion: "string", type: "string" }
  },
  NodeFunctionInput: {
    cls: ed,
    group: "core",
    isNodeFunctionInput: !0,
    members: { count: "null | number", isConst: "boolean", qualifier: "string" }
  },
  NodeKeywords: {
    cls: oh,
    group: "core",
    members: {
      keywords: "string[]",
      // keywordsCallback: '{ [name: string]: (name: string) => Node }',
      nodes: "Node[]"
    }
  },
  // NodeLoader: {
  //   cls: Nodes.NodeLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'Loader<NodeLoaderResult>'
  // },
  NodeMaterial: {
    cls: Yt,
    group: "materials",
    isNodeMaterial: !0,
    members: {
      alphaTestNode: "Node | null",
      backdropAlphaNode: "Node | null",
      backdropNode: "Node | null",
      colorNode: "Node | null",
      envNode: "Node | null",
      lights: "true",
      lightsNode: "Node | null",
      normalNode: "Node | null",
      normals: "true",
      opacityNode: "Node | null",
      positionNode: "Node | null"
      // type: 'string'
    },
    proto: "ShaderMaterial"
  },
  // NodeMaterialLoader: {
  //   cls: Nodes.NodeMaterialLoader,
  //   group: 'loaders',
  //   members: { nodes: 'NodeLoaderResult' },
  //   proto: 'MaterialLoader'
  // },
  // NodeObjectLoader: {
  //   cls: Nodes.NodeObjectLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'ObjectLoader'
  // },
  // NodeParser: {
  //   // cls: Nodes.NodeParser,
  //   group: 'core',
  //   members: {}
  // },
  NodeUniform: {
    cls: nh,
    group: "core",
    isNodeUniform: !0,
    members: { name: "string", needsUpdate: "boolean", node: "InputNode", type: "string", value: "NodeValueOption" }
  },
  NodeVar: {
    cls: lc,
    group: "core",
    isNodeVar: !0,
    members: { name: "string", type: "string" }
  },
  NodeVarying: {
    cls: sh,
    group: "core",
    isNodeVarying: !0,
    members: { needsInterpolation: "false" },
    proto: "NodeVar"
  },
  NormalMapNode: {
    cls: Ov,
    group: "display",
    members: { node: "Node", normalMapType: "types.NormalMapTypes", scaleNode: "Node | null" },
    proto: "TempNode"
  },
  NormalNode: {
    cls: qo,
    group: "accessors",
    members: { scope: "types.NormalNodeScope" },
    proto: "Node"
  },
  Object3DNode: {
    cls: gn,
    group: "accessors",
    members: { object3d: "Object3D | null", scope: "types.Object3DNodeScope" },
    proto: "Node"
  },
  OperatorNode: {
    cls: Qg,
    group: "math",
    members: { aNode: "Node", bNode: "Node", op: "types.OperatorNodeOp" },
    proto: "TempNode"
  },
  OscNode: {
    cls: no,
    group: "utils",
    members: { method: "types.OscNodeMethod", timeNode: "Node" },
    proto: "Node"
  },
  PointLightNode: {
    cls: n1,
    group: "lighting",
    members: { coneCosNode: "Node", cutoffDistanceNode: "Node", decayExponentNode: "Node", directionNode: "Node", penumbraCosNode: "Node" },
    proto: "AnalyticLightNode"
  },
  PointUVNode: {
    cls: vv,
    group: "accessors",
    isPointUVNode: !0,
    members: {},
    proto: "Node"
  },
  PointsNodeMaterial: {
    cls: Kd,
    group: "materials",
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", isPointsNodeMateria: "true", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", sizeNode: "Node | null" },
    proto: ["PointsMaterial", "NodeMaterial"]
  },
  PositionNode: {
    cls: Bs,
    group: "accessors",
    members: { scope: "types.PositionNodeScope" },
    proto: "Node"
  },
  PosterizeNode: {
    cls: Pv,
    group: "display",
    members: { sourceNode: "Node", stepsNode: "Node" },
    proto: "Node"
  },
  PropertyNode: {
    cls: ih,
    group: "core",
    members: {},
    proto: "Node"
  },
  RangeNode: {
    cls: Qv,
    group: "geometry",
    members: { max: "number | Color | Vector2 | Vector3 | Vector4", min: "number | Color | Vector2 | Vector3 | Vector4" },
    proto: "Node"
  },
  ReferenceNode: {
    cls: mc,
    group: "accessors",
    members: { node: "Node | null", object: "Object", property: "string", uniformType: "string" },
    proto: "Node"
  },
  ReflectVectorNode: {
    cls: D0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  RemapNode: {
    cls: sv,
    group: "utils",
    members: { doClamp: "boolean", inHighNode: "Node", inLowNode: "Node", node: "Node", outHighNode: "Node", outLowNode: "Node" },
    proto: "Node"
  },
  RotateUVNode: {
    cls: iv,
    group: "utils",
    members: { centerNode: "Node", rotationNode: "Node", uvNode: "Node" },
    proto: "TempNode"
  },
  SkinningNode: {
    cls: F0,
    group: "accessors",
    members: { bindMatrixInverseNode: "Node", bindMatrixNode: "Node", boneMatricesNode: "Node", skinIndexNode: "Node", skinWeightNode: "Node" },
    proto: "Node"
  },
  SpecularMIPLevelNode: {
    cls: X0,
    group: "utils",
    members: { roughnessNode: "Node | null", textureNode: "TextureNode" },
    proto: "Node"
  },
  SpriteNodeMaterial: {
    cls: C1,
    group: "materials",
    isSpriteNodeMaterial: !0,
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", rotationNode: "Node | null", scaleNode: "Node | null" },
    proto: ["SpriteMaterial", "NodeMaterial"]
  },
  SpriteSheetUVNode: {
    cls: cv,
    group: "utils",
    members: { countNode: "Node", frameNode: "Node", uvNode: "Node" },
    proto: "Node"
  },
  // StackNode: {
  //   cls: Nodes.StackNode,
  //   group: 'core',
  //   isStackNode: true,
  //   members: { nodes: 'Node[]', outputNode: 'Node | null' },
  //   proto: 'Node'
  // },
  // StorageBufferNode: {
  //   // cls: Nodes.StorageBufferNode,
  //   group: 'accessors',
  //   members: {},
  //   proto: 'BufferNode'
  // },
  TangentNode: {
    cls: to,
    group: "accessors",
    members: { scope: "types.TangentNodeScope" },
    proto: "Node"
  },
  TempNode: {
    cls: St,
    group: "core",
    isTempNode: !0,
    members: {},
    proto: "Node"
  },
  TextureNode: {
    cls: Mi,
    group: "accessors",
    isTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "Texture" },
    proto: "UniformNode"
  },
  TimerNode: {
    cls: tv,
    group: "utils",
    members: {
      scale: "number"
      // scope: 'TimerNodeScope'
    },
    proto: "UniformNode"
  },
  ToneMappingNode: {
    cls: Uv,
    group: "display",
    members: { colorNode: "Node | null", exposureNode: "Node", toneMapping: "types.ToneMapping" },
    proto: "TempNode"
  },
  TriplanarTexturesNode: {
    cls: uv,
    group: "utils",
    members: {
      normalNode: "PositionNode",
      positionNode: "PositionNode",
      scaleNode: "Node",
      textureXNode: "TextureNode",
      textureYNode: "TextureNode | null",
      textureZNode: "TextureNode | null"
    },
    proto: "Node"
  },
  UVNode: {
    cls: Yg,
    group: "accessors",
    isUVNode: !0,
    members: { index: "number" },
    proto: "AttributeNode"
  },
  UniformNode: {
    cls: nt,
    group: "core",
    isUniformNode: !0,
    members: {},
    proto: "InputNode"
  },
  // UserDataNode: {
  //   cls: Nodes.UserDataNode,
  //   group: 'accessors',
  //   members: { userData: 'NodeUserData | null' },
  //   proto: 'ReferenceNode<NodeUserData>'
  // },
  VarNode: {
    cls: kg,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  VaryingNode: {
    cls: Wg,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  ViewportNode: {
    cls: ks,
    group: "display",
    isViewportNode: !0,
    members: { scope: "types.ViewportNodeScope" },
    proto: "Node"
  }
};
let Uo = console;
const ze = {
  debug(...c) {
    Uo.debug(...c);
  },
  notice(...c) {
    Uo.info(...c);
  },
  warn(...c) {
    Uo.warn(...c);
  },
  error(...c) {
    Uo.error(...c);
  },
  panic(...c) {
    return Uo.error(...c), `${c}`;
  }
}, gp = {};
function yp(c) {
  const e = Object.entries(c);
  return e.forEach((t) => delete c[t[0]]), e.sort((t, r) => t[0].localeCompare(r[0])), e.forEach((t) => c[t[0]] = t[1]), c;
}
function Mc(c) {
  return /Material$/.test(c) || !!di[c];
}
const t_ = new Set("bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","));
function n_(c) {
  return t_.has(c);
}
const s_ = new Set("void,Boolean,Number,String,Script,Color,Vector2,Vector3,Vector4,Matrix3,Matrix4,Euler,Audio,Image,Texture,CubeTexture,Material,Object3D,Object".split(","));
function r_(c) {
  return s_.has(c.split("[")[0]);
}
function o_(c) {
  return n_(c) || r_(c);
}
function i_(c, e) {
  for (const t of c)
    if (!e.includes(t))
      return !1;
  return !0;
}
function a_(c, e) {
  return c[`is${e}`];
}
function au(c, e) {
  if (c === e)
    return !0;
  const t = Zd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (au(r, e))
        return !0;
    return !1;
  }
  return au(t.proto, e);
}
function c_(c, e) {
  if (e.includes(c))
    return !0;
  for (const t of e)
    if (au(c, t))
      return !0;
  return !1;
}
function fi(c, e) {
  if (c === e)
    return !0;
  const t = Zd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (fi(r, e))
        return !0;
    return !1;
  }
  return fi(t.proto, e);
}
function l_(c) {
  let e = null, t = null;
  const r = [];
  for (const n of c) {
    if (/^".+"$/.test(n)) {
      const i = /^"(.+)"$/.exec(n)[1];
      t ? t.push(i) : (t = [i], r.push(t));
      continue;
    }
    const [, s, o] = /^([^[\]]+)(\[\])?$/.exec(n) || [];
    if (s.startsWith("types.")) {
      const i = k1[s.substring(6)];
      if (!i)
        throw ze.panic(`type[${s}] not found`);
      Array.isArray(i) ? t ? t.push(...i) : (t = [...i], r.push(t)) : e ? Object.assign(e, i) : (e = { ...i }, r.push(e));
    } else
      n === "null" ? r.push(null) : s === "boolean" || /true|false/i.test(n) ? r.push("Boolean" + (o || "")) : s === "string" ? r.push("String" + (o || "")) : s === "number" ? r.push("Number" + (o || "")) : (!o_(s) && !Mc(s) && ze.warn(`type[${n}] unsupported!`), r.push(n));
  }
  return r;
}
function vp(c, e, t) {
  for (const [r, n] of Object.entries(e)) {
    const s = l_(n.replace(/\s/mg, "").split("|")), [, o, i] = /^(.+)(Node)$/.exec(r) || [, r], a = !!i || s.findIndex((u) => typeof u == "string" && Mc(u)) !== -1, l = c[o] || (c[o] = { types: s, direct: t });
    a && (l.nname = r), u_(l.types, s);
  }
  return c;
}
function u_(c, e) {
  const t = c.filter((r) => r !== null && !Mc(r) && !e.includes(r));
  for (const r of e)
    c.includes(r) || c.push(JSON.parse(JSON.stringify(r)));
  t.forEach((r) => c.splice(c.indexOf(r), 1));
}
function h_(c, e) {
  for (const t of e)
    c.includes(t) || c.push(JSON.parse(JSON.stringify(t)));
}
function xp(c, e) {
  for (const [t, r] of Object.entries(e)) {
    const n = c[t];
    if (!n) {
      c[t] = JSON.parse(JSON.stringify(r));
      continue;
    }
    if (n.nname && r.nname && n.nname !== r.nname)
      throw ze.panic("type mismatched!");
    n.nname || (n.nname = r.nname), h_(n.types, r.types);
  }
  return c;
}
function Xa(c) {
  const e = (t) => {
    const r = gp[t];
    if (r)
      return r;
    const n = { in: {}, out: {} }, s = di[t] || Ha[t];
    if (!s)
      return n;
    let o = s.proto;
    if (o) {
      o = Array.isArray(o) ? o : [o];
      for (const i of o) {
        const a = e(i);
        xp(n.in, a.in), xp(n.out, a.out);
      }
    }
    return vp(n.in, s.members, "in"), s.out && vp(n.out, s.out, "out"), yp(n.in), yp(n.out), gp[t] = n, n;
  };
  return e(c);
}
function bp(c) {
  const e = p_(c);
  if (!e)
    throw ze.panic(`Node constructor[${c}] not found!`);
  return e.clsName;
}
function d_(c) {
  const e = Zd(c);
  if (e)
    return e.proto;
}
function Zd(c) {
  return di[c] || Ha[c];
}
function Ls(c, e, t, r, n) {
  if (di[c])
    throw ze.panic(`class[${c}] exists`);
  if (re(c, e), di[c] = { cls: e, members: t || {}, proto: r }, n)
    for (const [o, i] of Object.entries(n))
      Ac(o, i);
}
const f_ = [], $a = {};
function Ac(c, e) {
  if ($a[c])
    throw ze.panic(`Node Constructor[${c}] aready exists`);
  const r = (e.group || `Others.${c}`).split(".");
  let n = f_;
  const s = r.pop();
  for (const l of r) {
    let u = n.find((h) => h.name === l);
    u || (u = {
      name: l,
      icon: "",
      children: []
    }, n.push(u)), n = u.children;
  }
  if (n.find((l) => l.name === c))
    throw ze.panic(`Node Constructor[${c}] aready exists`);
  const i = Xa(e.clsName), a = {
    name: c,
    ...e,
    title: s || c,
    in: { ...i.in },
    out: { ...i.out }
  };
  $a[c] = a, n.push(a);
}
function p_(c) {
  return $a[c];
}
function cu(c, e) {
  const t = $a[c];
  if (!t)
    throw ze.panic(`Node Constructor[${c}] not found`);
  const r = t.func();
  if (e)
    if (r.copy)
      r.copy(e);
    else
      for (const n of [...Object.keys(t.in), ...Object.keys(t.out)]) {
        const s = e[n], o = typeof s, i = r[n];
        o === "undefined" || s === null || o === "boolean" || o === "string" || o === "number" ? r[n] = s : s.clone ? r[n] = s.clone() : i && i.copy ? i.copy(s) : r[n] = s;
      }
  return r;
}
const { createNodeMaterialFromType: m_ } = Aw, g_ = wi.createMaterialFromType, qa = {};
wi.createMaterialFromType = function(c) {
  const e = m_(c);
  return e || (qa[c] ? new qa[c]() : g_.call(this, c));
};
function y_(c, e) {
  if (qa[c])
    throw ze.panic(`Material[${c}] aready exists`);
  qa[c] = e;
}
const Np = {};
function Ye(c, e) {
  if (Np[c])
    throw ze.panic(`Class[${c}] aready exists`);
  if (Np[c] = e, Ha[c] || (Ha[c] = e), fi(c, "Object3D")) {
    if (pi[c])
      return;
    pi[c] = (t) => e.create(t || {});
  }
}
const pi = {
  AmbientLight: (c) => new M.AmbientLight(c.color, c.intensity),
  Bone: (c) => new M.Bone(),
  DirectionalLight: (c) => new M.DirectionalLight(c.color, c.intensity),
  HemisphereLight: (c) => new M.HemisphereLight(c.color, c.groundColor, c.intensity),
  Group: (c) => new M.Group(),
  InstancedMesh: (c) => {
    const e = new M.InstancedMesh(c.geometry, c.material, c.count), t = c.instanceMatrix, r = c.instanceColor;
    return e.instanceMatrix = new M.InstancedBufferAttribute(new Float32Array(t.array), 16), r !== void 0 && (e.instanceColor = new M.InstancedBufferAttribute(new Float32Array(r.array), r.itemSize)), e;
  },
  LOD: (c) => new M.LOD(),
  Line: (c) => new M.Line(c.geometry, c.material),
  LineLoop: (c) => new M.LineLoop(c.geometry, c.material),
  LineSegments: (c) => new M.LineSegments(c.geometry, c.material),
  LightProbe: (c) => new M.LightProbe().fromJSON(c),
  Mesh: (c) => new M.Mesh(c.geometry, c.material),
  Object3D: (c) => new M.Object3D(),
  OrthographicCamera: (c) => new M.OrthographicCamera(c.left, c.right, c.top, c.bottom, c.near, c.far),
  PerspectiveCamera: (c) => new M.PerspectiveCamera(c.fov, c.aspect, c.near, c.far),
  PointCloud: (c) => new M.Points(c.geometry, c.material),
  PointLight: (c) => new M.PointLight(c.color, c.intensity, c.distance, c.decay),
  Points: (c) => new M.Points(c.geometry, c.material),
  RectAreaLight: (c) => new M.RectAreaLight(c.color, c.intensity, c.width, c.height),
  Scene: (c) => new M.Scene(),
  SpotLight: (c) => new M.SpotLight(c.color, c.intensity, c.distance, c.angle, c.penumbra, c.decay),
  SkinnedMesh: (c) => new M.SkinnedMesh(c.geometry, c.material),
  Sprite: (c) => new M.Sprite(c.material)
}, v_ = new Set(Object.keys(pi));
function x_(c, e) {
  const t = pi[c];
  if (t)
    return t(e);
  throw ze.panic(`object class[${c}] not found`);
}
function b_(c) {
  return !!pi[c];
}
function G1(c) {
  if (v_.has(c))
    return c;
  const e = d_(c);
  if (e)
    return G1(e);
}
function _s(c) {
  Object.keys(c).forEach((e) => delete c[e]);
}
const Vt = Symbol("getProxyRawObject");
function Qd(c, e) {
  return new Proxy(c, {
    get(t, r, n) {
      if (r === Vt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      if (Reflect.get(t, r, s) === n)
        return !0;
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else
        i = Reflect.set(t, r, n, t);
      return i && e && e(r, n), i;
    }
  });
}
function er(c, e) {
  e || (e = {});
  for (const [t, r] of Object.entries(c))
    r && typeof r == "object" && r.toArray ? e[t] = r.toArray() : e[t] = c[t];
  return e;
}
function tr(c, e) {
  const t = [];
  for (const [r, n] of Object.entries(c)) {
    const s = e[r];
    s == null || s === n || (t.push(r), typeof n == "object" && n.fromArray ? n.fromArray(s) : c[r] = s);
  }
  return t;
}
Ye("Object3D", {
  // cls: Object3D,
  create: () => new xn(),
  members: {},
  group: "Objects.Empty Object3D",
  icon: "box"
});
const Ji = new M.Matrix4();
let ul, wp, Tp;
function V1(c, e, t) {
  var l, u;
  if (!t || !t.geometry)
    return 0;
  ul || (ul = new Ammo.btVector3(), wp = new Ammo.btVector3(), Tp = new Ammo.btVector3());
  const r = t.geometry, n = ((l = r.attributes.position) == null ? void 0 : l.array) || [], s = ((u = r.index) == null ? void 0 : u.array) || [];
  let o = 0, i;
  if (e && e !== t) {
    let h;
    e.quaternion ? h = e.quaternion : e.rotation ? h = new M.Quaternion().setFromEuler(e.rotation) : h = new M.Quaternion().identity();
    const d = new M.Matrix4().compose(new M.Vector3(1, 1, 1), h, e.position);
    Ji.copy(d.invert()), t.updateWorldMatrix(!1, !1), i = t.matrixWorld.clone().multiply(Ji);
  } else
    Ji.makeScale(t.scale.x, t.scale.y, t.scale.z), i = Ji;
  const a = s.length / 3;
  for (let h = 0; h < a; h++) {
    const d = [];
    for (let f = 0; f < 3; f++) {
      let p = new M.Vector3(n[s[h * 3 + f] * 3 + 0], n[s[h * 3 + f] * 3 + 1], n[s[h * 3 + f] * 3 + 2]);
      p = p.applyMatrix4(i);
      let m;
      f == 0 ? m = ul : f == 1 ? m = wp : m = Tp, m.setValue(p.x, p.y, p.z), d.push(m);
    }
    c.addTriangle(d[0], d[1], d[2]), o++;
  }
  return t.children.forEach((h) => {
    o += V1(c, e, h);
  }), o;
}
var $s;
((c) => {
  function e(o) {
    return new ammo.btVector3(o.x, o.y, o.z);
  }
  c.t2aVector3 = e;
  function t(o) {
    return new M.Vector3(o.x(), o.y(), o.z());
  }
  c.a2tVector3 = t;
  function r(o) {
    var a, l;
    const i = o.geometry;
    if (i)
      if (i.type === "PlaneGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = new ammo.btBoxShape(new ammo.btVector3(d, f, 0));
        return p.setMargin(0.01), p;
      } else if (i.type === "BoxGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = h.depth !== void 0 ? h.depth / 2 : 0.5, m = new ammo.btBoxShape(new ammo.btVector3(d, f, p));
        return m.setMargin(1e-3), m;
      } else if (i.type === "CylinderGeometry") {
        const h = i.parameters, d = new ammo.btCylinderShape(new ammo.btVector3(h.radiusBottom, h.height, h.radiusTop));
        return d.setMargin(0.01), d;
      } else if (i.type === "ConeGeometry") {
        const h = i.parameters, d = new ammo.btConeShape(h.radius, h.height);
        return d.setMargin(0.01), d;
      } else if (i.type === "CapsuleGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = h.length !== void 0 ? h.length : 1, p = new ammo.btCapsuleShape(d, f);
        return p.setMargin(0.01), p;
      } else if (i.type === "SphereGeometry" || i.type === "IcosahedronGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = new ammo.btSphereShape(d);
        return f.setMargin(1e-3), f;
      } else {
        const u = new ammo.btTriangleMesh(!0, !0), h = ((a = i.attributes.position) == null ? void 0 : a.array) || [], d = ((l = i.index) == null ? void 0 : l.array) || [];
        for (let p = 0; p * 3 < d.length; p += 1)
          u.addTriangle(
            new ammo.btVector3(
              h[d[p * 3] * 3],
              h[d[p * 3] * 3 + 1],
              h[d[p * 3] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 1] * 3],
              h[d[p * 3 + 1] * 3 + 1],
              h[d[p * 3 + 1] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 2] * 3],
              h[d[p * 3 + 2] * 3 + 1],
              h[d[p * 3 + 2] * 3 + 2]
            ),
            !1
          );
        const f = new ammo.btConvexTriangleMeshShape(u, !0);
        return f.setMargin(1e-3), f;
      }
    else {
      const u = new ammo.btTriangleMesh(!0, !0), d = V1(u, o, o) ? new Ammo.btBvhTriangleMeshShape(u, !0) : new Ammo.btCompoundShape();
      return d.setMargin(0.01), d;
    }
  }
  c.createShape = r;
  function n(o, i = 0, a) {
    const l = a || r(o);
    function u(d, f, p) {
      const m = d.position, g = d.quaternion, b = new ammo.btTransform();
      b.setIdentity(), b.setOrigin(new ammo.btVector3(m.x, m.y, m.z)), b.setRotation(new ammo.btQuaternion(g.x, g.y, g.z, g.w));
      const v = new ammo.btDefaultMotionState(b), y = new ammo.btVector3(0, 0, 0);
      p.calculateLocalInertia(f, y);
      const x = new ammo.btRigidBodyConstructionInfo(f, v, p, y);
      return new ammo.btRigidBody(x);
    }
    function h(d, f, p) {
      const m = d.instanceMatrix.array, g = [];
      for (let b = 0; b < d.count; b++) {
        const v = b * 16, y = new ammo.btTransform();
        y.setFromOpenGLMatrix(w_(m, v, v + 16));
        const x = new ammo.btDefaultMotionState(y), N = new ammo.btVector3(0, 0, 0);
        p.calculateLocalInertia(f, N);
        const w = new ammo.btRigidBodyConstructionInfo(f, x, p, N), T = new ammo.btRigidBody(w);
        g.push(T);
      }
      return g;
    }
    return o.isInstancedMesh ? h(o, i, l) : (o.isMesh, u(o, i, l));
  }
  c.createBody = n;
  function s(o) {
    ammo.destroy(o);
  }
  c.destroyBody = s;
})($s || ($s = {}));
class N_ {
  constructor(e = -9.82) {
    G(this, "world");
    G(this, "collisionConfiguration");
    G(this, "dispatcher");
    G(this, "broadphase");
    G(this, "solver");
    G(this, "softBodySolver");
    G(this, "softBodyHelpers");
    G(this, "worldTransform");
    G(this, "destroyed", !1);
    G(this, "meshes", []);
    G(this, "meshMap", /* @__PURE__ */ new WeakMap());
    G(this, "meshIdx", {});
    G(this, "conllisionMap", /* @__PURE__ */ new Set());
    this.collisionConfiguration = new ammo.btDefaultCollisionConfiguration(), this.dispatcher = new ammo.btCollisionDispatcher(this.collisionConfiguration), this.broadphase = new ammo.btDbvtBroadphase(), this.solver = new ammo.btSequentialImpulseConstraintSolver(), this.softBodySolver = new ammo.btDefaultSoftBodySolver(), this.softBodyHelpers = new Ammo.btSoftBodyHelpers(), this.world = new ammo.btSoftRigidDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collisionConfiguration, this.softBodySolver), this.world.setGravity(new ammo.btVector3(0, e, 0)), this.worldTransform = new ammo.btTransform();
  }
  dispose() {
    if (!this.destroyed) {
      for (const e of this.meshes) {
        const t = this.meshMap.get(e);
        this.meshMap.delete(e), ammo.destroy(t);
      }
      this.meshes.length = 0, ammo.destroy(this.collisionConfiguration), ammo.destroy(this.dispatcher), ammo.destroy(this.broadphase), ammo.destroy(this.solver), ammo.destroy(this.softBodySolver), ammo.destroy(this.softBodyHelpers), ammo.destroy(this.world), ammo.destroy(this.worldTransform), this.destroyed = !0;
    }
  }
  addMesh(e, t) {
    if (t) {
      if (Array.isArray(t))
        for (const r of t)
          this.world.addRigidBody(r);
      else
        this.world.addRigidBody(t);
      this.meshes.push(e), this.meshMap.set(e, t), e.id && (this.meshIdx[e.id] = e);
    }
    e.world = this;
  }
  removeMesh(e) {
    const t = this.meshMap.get(e), r = this.meshes.indexOf(e);
    if (!t) {
      e.world = void 0;
      return;
    }
    if (r !== -1 && this.meshes.splice(r, 1), this.meshMap.delete(e), delete this.meshIdx[e.id], Array.isArray(t))
      for (const n of t)
        this.world.removeRigidBody(n);
    else
      this.world.removeRigidBody(t);
    e.world = void 0;
  }
  findBody(e) {
    return this.meshMap.get(e);
  }
  setMeshPosition(e, t, r = 0) {
    if (e.isInstancedMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      const s = n[r];
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), s.setWorldTransform(this.worldTransform);
    } else if (e.isMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), n.setWorldTransform(this.worldTransform);
    }
  }
  detectCollision() {
    const e = this.dispatcher.getNumManifolds(), t = /* @__PURE__ */ new Set();
    for (let n = 0; n < e; n++) {
      const s = this.dispatcher.getManifoldByIndexInternal(n), o = s.getBody0().getUserIndex(), i = s.getBody1().getUserIndex();
      t.add(`${o}:${i}`);
    }
    for (const n of t) {
      if (this.conllisionMap.has(n))
        continue;
      this.conllisionMap.add(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionEnter", target: a }), a.dispatchEvent({ type: "onCollisionEnter", target: i }));
    }
    const r = [];
    for (const n of this.conllisionMap)
      t.has(n) || r.push(n);
    for (const n of r) {
      this.conllisionMap.delete(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionLeave", target: a }), a.dispatchEvent({ type: "onCollisionLeave", target: i }));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  step(e, t) {
    if (e) {
      this.world.stepSimulation(e, 10), this.detectCollision();
      for (let r = 0, n = this.meshes.length; r < n; r++) {
        const s = this.meshes[r];
        if (s.mass) {
          if (s.isInstancedMesh) {
            const o = s.instanceMatrix.array, i = this.meshMap.get(s);
            for (let a = 0; a < i.length; a++) {
              i[a].getMotionState().getWorldTransform(this.worldTransform);
              const h = this.worldTransform.getOrigin(), d = this.worldTransform.getRotation();
              T_(h, d, o, a * 16);
            }
            s.instanceMatrix.needsUpdate = !0, s.computeBoundingSphere();
          } else if (s.isMesh) {
            this.meshMap.get(s).getMotionState().getWorldTransform(this.worldTransform);
            const a = this.worldTransform.getOrigin(), l = this.worldTransform.getRotation();
            s.position.set(a.x(), a.y(), a.z()), s.quaternion.set(l.x(), l.y(), l.z(), l.w());
          }
        }
      }
    }
  }
}
function w_(c, e, t) {
  const r = [], n = e + t;
  for (let s = e; s < n; s++)
    r.push(c[s]);
  return r;
}
function T_(c, e, t, r) {
  const n = e.x(), s = e.y(), o = e.z(), i = e.w(), a = n + n, l = s + s, u = o + o, h = n * a, d = n * l, f = n * u, p = s * l, m = s * u, g = o * u, b = i * a, v = i * l, y = i * u;
  t[r + 0] = 1 - (p + g), t[r + 1] = d + y, t[r + 2] = f - v, t[r + 3] = 0, t[r + 4] = d - y, t[r + 5] = 1 - (h + g), t[r + 6] = m + b, t[r + 7] = 0, t[r + 8] = f + v, t[r + 9] = m - b, t[r + 10] = 1 - (h + p), t[r + 11] = 0, t[r + 12] = c.x(), t[r + 13] = c.y(), t[r + 14] = c.z(), t[r + 15] = 1;
}
var Cc = /* @__PURE__ */ ((c) => (c[c.Ghost = 0] = "Ghost", c[c.RigidBody = 1] = "RigidBody", c))(Cc || {});
k1.BodyType = {
  Ghost: 0,
  RigidBody: 1
  // SoftBody: 2,
};
const ar = 1e-3;
class Nn extends Jt {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Za(), r || new Cn({ wireframe: !0 }));
    G(this, "isEntity", !0);
    G(this, "geo");
    G(this, "geoMatrix", new Ge().identity());
    G(this, "physicalBody", null);
    G(this, "world");
    G(this, "_tmpAmmoVectorA", new Ammo.btVector3(0, 0, 0));
    G(this, "_tmpAmmoQuaternion", new Ammo.btQuaternion(0, 0, 0, 1));
    this._bodyType = n, this._mass = s, this.type = "Entity", t || this.rebuildBody(), this.geo = Qd(Object.assign({}, this.parameters), () => {
      this.rebuildGeometry();
    });
  }
  get mass() {
    return this._mass;
  }
  set mass(t) {
    this._mass !== t && (this._mass === 0 || t === 0 ? (this._mass = t, this.rebuildBody()) : this.physicalBody.setMassProps(t));
  }
  get bodyType() {
    return this._bodyType;
  }
  set bodyType(t) {
    this._bodyType !== t && (this._bodyType = t, this.rebuildBody());
  }
  get parameters() {
    return this.geometry.parameters || {};
  }
  moveTo(t) {
    this.physicalBody && this.setPhysicsBodyTransformation(t), this.position.copy(t);
  }
  applyTranslation(t) {
    return this.applyGeoMatrix4(new Ge().makeTranslation(t));
  }
  applyRotationFromEuler(t) {
    return this.applyGeoMatrix4(new Ge().makeRotationFromEuler(t));
  }
  applyScale(t) {
    return this.applyGeoMatrix4(new Ge().makeScale(t.x, t.y, t.z));
  }
  applyGeoMatrix4(t) {
    this.geoMatrix.premultiply(t), this.geometry.applyMatrix4(t);
  }
  clone(t) {
    const r = super.clone(t), n = this._mass || 0, s = this._bodyType || 0;
    (n !== this._mass || s !== this._bodyType) && (r._mass = n, r._bodyType = s, r.rebuildBody());
    const o = r.geo[Vt];
    return Object.assign(o, this.parameters), r.geoMatrix.copy(this.geoMatrix), r;
  }
  serialize(t) {
    t.mass = this._mass, t.bodyType = this._bodyType, t.geoMatrix = this.geoMatrix.toArray();
  }
  deserialize(t) {
    const r = t.mass || 0, n = t.bodyType || 0;
    (r !== this._mass || n !== this._bodyType) && (this._mass = r, this._bodyType = n, this.rebuildBody());
    const s = this.geo[Vt];
    Object.assign(s, this.parameters), t.geoMatrix && (this.geoMatrix.fromArray(t.geoMatrix), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox()), this.setPhysicsBodyTransformation(this.position);
  }
  dispose() {
    if (this.material instanceof kn)
      this.material.dispose();
    else if (Array.isArray(this.material))
      for (const t of this.material)
        t.material.dispose();
    this.physicalBody && (this.world && this.world.removeMesh(this), $s.destroyBody(this.physicalBody), this.physicalBody = null);
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose(), this.geometry = t.fromJSON(this.geo[Vt]), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
  rebuildBody() {
    const t = this.world;
    this.physicalBody && (this.world && this.world.removeMesh(this), $s.destroyBody(this.physicalBody)), this._bodyType !== 0 ? (this.physicalBody = $s.createBody(this, this._mass), this.physicalBody.setUserIndex(this.id), t && t.addMesh(this, this.physicalBody)) : this.physicalBody = null;
  }
  /**
   * Sets the babylon object's position/rotation from the physics body's position/rotation
   * @param impostor imposter containing the physics body and babylon object
   * @param newPosition new position
   * @param newRotation new rotation
   */
  setPhysicsBodyTransformation(t, r) {
    if (!this.physicalBody)
      return;
    const n = this.physicalBody.getWorldTransform();
    if (Math.abs(n.getOrigin().x() - t.x) > ar || Math.abs(n.getOrigin().y() - t.y) > ar || Math.abs(n.getOrigin().z() - t.z) > ar || r && (Math.abs(n.getRotation().x() - r.x) > ar || Math.abs(n.getRotation().y() - r.y) > ar || Math.abs(n.getRotation().z() - r.z) > ar || Math.abs(n.getRotation().w() - r.w) > ar))
      if (this._tmpAmmoVectorA.setValue(t.x, t.y, t.z), n.setOrigin(this._tmpAmmoVectorA), r && (this._tmpAmmoQuaternion.setValue(r.x, r.y, r.z, r.w), n.setRotation(this._tmpAmmoQuaternion)), this.physicalBody.setWorldTransform(n), this.mass == 0) {
        const s = this.physicalBody.getMotionState();
        s && s.setWorldTransform(n);
      } else
        this.physicalBody.activate();
  }
}
Ye("Entity", {
  create: ({ material: c, geometry: e } = {}) => new Nn(e, c),
  members: {
    mass: "Number",
    bodyType: "types.BodyType"
  },
  proto: "Mesh",
  group: "",
  icon: ""
});
const S_ = 1024, __ = 1024, hl = new ye(), M_ = new ye(), sn = {
  /** world time delta */
  delta: 0,
  /** world current time */
  now: 0,
  /** to y axis */
  gravity: new ye(0, -9.8, 0),
  windForce: new ye(),
  scene: null,
  gpuComputeRender: null,
  /** wait for x miliseconds */
  wait(c) {
    return new Promise((e) => {
      setTimeout(e, c, !0);
    });
  },
  random(c, e) {
    return c + Math.floor(Math.random() * (e - c + 1));
  },
  randomChoice(c) {
    if (Array.isArray(c)) {
      const e = Math.floor(Math.random() * c.length);
      return c[e];
    } else {
      const e = Object.keys(c), t = Math.floor(Math.random() * e.length);
      return c[t];
    }
  },
  calcObjectPosition(c, e, t, r) {
    if (t <= 0)
      return [c, e];
    const n = r ? hl.copy(e).normalize().multiply(e).multiply(e).multiplyScalar(-r) : hl.set(0, 0, 0);
    n.add(this.windForce);
    const s = n.divideScalar(t);
    s.add(this.gravity);
    const o = s.multiplyScalar(this.delta).add(e);
    return [M_.copy(o).add(e).multiplyScalar(0.5 * this.delta).add(c), hl];
  },
  combineBuffer(c, e, t) {
    let r = 0, n = 3;
    c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        n = f.itemSize, r += f.array.length;
      }
    });
    const s = r / n, o = t && s > t ? Math.ceil(s / t) : 1, i = Math.ceil(r / (n * o)), a = new Float32Array(i * n);
    let l = 0, u = 0, h = 0;
    return c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        if (o === 1)
          a.set(f.array, h * n), l += f.array.length, h += f.array.length / n, u = l / n;
        else {
          const p = f.count;
          for (let m = 0; m < p; m++)
            u % o === 0 && (a[h * n] = f.array[m * n], a[h * n + 1] = f.array[m * n + 1], a[h * n + 2] = f.array[m * n + 2], h++), u++;
          l += f.array.length;
        }
      }
    }), new ao(a, n);
  }
};
class ef extends Qa {
  constructor() {
    super();
    G(this, "isPhysicalScene", !0);
    G(this, "physics");
    G(this, "windForce", new ye());
    /** to y axis */
    G(this, "_gravity", -9.8);
    G(this, "objectsTrash", {});
    this.type = "PhysicalScene", this.physics = new N_(this._gravity);
  }
  get gravity() {
    return this._gravity;
  }
  set gravity(t) {
    this._gravity !== t && (this._gravity = t, this.physics.world.setGravity(new Ammo.btVector3(0, this._gravity, 0)));
  }
  update(t, r, n, s, o = !1) {
    sn.scene = this, sn.gravity.y = this._gravity;
    const i = this.windForce.clone().multiplyScalar(0.5 + 0.5 * Math.sin(s / 2e3));
    if (sn.windForce.copy(i), !o) {
      for (const a of this.children)
        a.visible && a.graph && a.graph.update(t, r, n, s);
      this.physics.step(n, s);
    }
  }
  add(...t) {
    super.add(...t);
    for (const r of t)
      delete this.objectsTrash[r.id], r instanceof Nn && this.physics.addMesh(r, r.physicalBody), r.dispatchEvent({ type: "onBorn", source: this, object: r });
    return this;
  }
  remove(...t) {
    super.remove(...t);
    for (const r of t)
      r instanceof Nn && this.physics.removeMesh(r), r.dispatchEvent({ type: "onDead", source: this, object: r }), this.objectsTrash[r.id] = r;
    return this;
  }
  serialize(t) {
    t.gravity = this.gravity, t.windForce = this.windForce.toArray();
  }
  deserialize(t) {
    t.gravity && (this.gravity = t.gravity), t.windForce && this.windForce.fromArray(t.windForce);
  }
  active() {
    this.dispatchEvent({ type: "onBorn", source: this, object: this });
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onBorn", source: this, object: t });
  }
  deactive() {
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onDead", source: this, object: t });
    this.dispatchEvent({ type: "onDead", source: this, object: this });
  }
  dispose() {
    for (const t of Object.values(this.objectsTrash))
      t.traverse((r) => {
        if (r.dispose)
          r.dispose();
        else if (r.geometry instanceof Kn && r.geometry.dispose(), r.material instanceof kn)
          r.material.dispose();
        else if (Array.isArray(r.material))
          for (const n of r.material)
            n.dispose();
      });
    this.physics.dispose();
  }
}
Ye("PhysicalScene", {
  // cls: PhysicalScene,
  members: {
    gravity: "Number",
    windForce: "Vector3"
  },
  proto: "Scene",
  group: "Scenes.Physical Scene",
  icon: "scene",
  create: () => new ef()
});
const Sp = new nr(), Yi = new ye();
class j1 extends km {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new yn(e, 3)), this.setAttribute("uv", new yn(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Oa(t, 6, 1);
    return this.setAttribute("instanceStart", new js(r, 3, 0)), this.setAttribute("instanceEnd", new js(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Oa(t, 6, 1);
    return this.setAttribute("instanceColorStart", new js(r, 3, 0)), this.setAttribute("instanceColorEnd", new js(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Rb(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new nr());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Sp.setFromBufferAttribute(t), this.boundingBox.union(Sp));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ti()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Yi.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Yi)), Yi.fromBufferAttribute(t, s), n = Math.max(n, r.distanceToSquared(Yi));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
co.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Tt(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ls.line = {
  uniforms: sr.merge([
    co.common,
    co.fog,
    co.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class tf extends fs {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: sr.clone(ls.line.uniforms),
      vertexShader: ls.line.vertexShader,
      fragmentShader: ls.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const _p = new ye(), Mp = new ye(), Wt = new mt(), Ht = new mt(), as = new mt(), dl = new ye(), fl = new Ge(), $t = new Lb(), Ap = new ye(), Ki = new nr(), Zi = new Ti(), cs = new mt();
let ds, wr;
function Cp(c, e, t) {
  return cs.set(0, 0, -e, 1).applyMatrix4(c.projectionMatrix), cs.multiplyScalar(1 / cs.w), cs.x = wr / t.width, cs.y = wr / t.height, cs.applyMatrix4(c.projectionMatrixInverse), cs.multiplyScalar(1 / cs.w), Math.abs(Math.max(cs.x, cs.y));
}
function A_(c, e) {
  const t = c.matrixWorld, r = c.geometry, n = r.attributes.instanceStart, s = r.attributes.instanceEnd, o = Math.min(r.instanceCount, n.count);
  for (let i = 0, a = o; i < a; i++) {
    $t.start.fromBufferAttribute(n, i), $t.end.fromBufferAttribute(s, i), $t.applyMatrix4(t);
    const l = new ye(), u = new ye();
    ds.distanceSqToSegment($t.start, $t.end, u, l), u.distanceTo(l) < wr * 0.5 && e.push({
      point: u,
      pointOnLine: l,
      distance: ds.origin.distanceTo(u),
      object: c,
      face: null,
      faceIndex: i,
      uv: null,
      uv1: null
    });
  }
}
function C_(c, e, t) {
  const r = e.projectionMatrix, s = c.material.resolution, o = c.matrixWorld, i = c.geometry, a = i.attributes.instanceStart, l = i.attributes.instanceEnd, u = Math.min(i.instanceCount, a.count), h = -e.near;
  ds.at(1, as), as.w = 1, as.applyMatrix4(e.matrixWorldInverse), as.applyMatrix4(r), as.multiplyScalar(1 / as.w), as.x *= s.x / 2, as.y *= s.y / 2, as.z = 0, dl.copy(as), fl.multiplyMatrices(e.matrixWorldInverse, o);
  for (let d = 0, f = u; d < f; d++) {
    if (Wt.fromBufferAttribute(a, d), Ht.fromBufferAttribute(l, d), Wt.w = 1, Ht.w = 1, Wt.applyMatrix4(fl), Ht.applyMatrix4(fl), Wt.z > h && Ht.z > h)
      continue;
    if (Wt.z > h) {
      const y = Wt.z - Ht.z, x = (Wt.z - h) / y;
      Wt.lerp(Ht, x);
    } else if (Ht.z > h) {
      const y = Ht.z - Wt.z, x = (Ht.z - h) / y;
      Ht.lerp(Wt, x);
    }
    Wt.applyMatrix4(r), Ht.applyMatrix4(r), Wt.multiplyScalar(1 / Wt.w), Ht.multiplyScalar(1 / Ht.w), Wt.x *= s.x / 2, Wt.y *= s.y / 2, Ht.x *= s.x / 2, Ht.y *= s.y / 2, $t.start.copy(Wt), $t.start.z = 0, $t.end.copy(Ht), $t.end.z = 0;
    const m = $t.closestPointToPointParameter(dl, !0);
    $t.at(m, Ap);
    const g = Qt.lerp(Wt.z, Ht.z, m), b = g >= -1 && g <= 1, v = dl.distanceTo(Ap) < wr * 0.5;
    if (b && v) {
      $t.start.fromBufferAttribute(a, d), $t.end.fromBufferAttribute(l, d), $t.start.applyMatrix4(o), $t.end.applyMatrix4(o);
      const y = new ye(), x = new ye();
      ds.distanceSqToSegment($t.start, $t.end, x, y), t.push({
        point: x,
        pointOnLine: y,
        distance: ds.origin.distanceTo(x),
        object: c,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class E_ extends Jt {
  constructor(e = new j1(), t = new tf({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, i = 0, a = t.count; o < a; o++, i += 2)
      _p.fromBufferAttribute(t, o), Mp.fromBufferAttribute(r, o), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + _p.distanceTo(Mp);
    const s = new Oa(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new js(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new js(s, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, n = e.camera;
    n === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    ds = e.ray;
    const o = this.matrixWorld, i = this.geometry, a = this.material;
    wr = a.linewidth + s, i.boundingSphere === null && i.computeBoundingSphere(), Zi.copy(i.boundingSphere).applyMatrix4(o);
    let l;
    if (r)
      l = wr * 0.5;
    else {
      const h = Math.max(n.near, Zi.distanceToPoint(ds.origin));
      l = Cp(n, h, a.resolution);
    }
    if (Zi.radius += l, ds.intersectsSphere(Zi) === !1)
      return;
    i.boundingBox === null && i.computeBoundingBox(), Ki.copy(i.boundingBox).applyMatrix4(o);
    let u;
    if (r)
      u = wr * 0.5;
    else {
      const h = Math.max(n.near, Ki.distanceToPoint(ds.origin));
      u = Cp(n, h, a.resolution);
    }
    Ki.expandByScalar(u), ds.intersectsBox(Ki) !== !1 && (r ? A_(this, t) : C_(this, n, t));
  }
}
class W1 extends j1 {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class R_ extends E_ {
  constructor(e = new W1(), t = new tf({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class pl extends W1 {
  constructor() {
    super(...arguments);
    G(this, "isBezieoLineGeometry", !0);
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    return t.uuid = this.uuid, t.type = "BufferGeometry", t.data = {}, t;
  }
}
class mi extends tf {
  constructor() {
    super();
    G(this, "isBezierLineMaterial", !0);
    this.type = "BezierLineMaterial";
  }
}
class H1 extends R_ {
  constructor() {
    super(new pl(), new mi());
    G(this, "isBezierLine", !0);
    G(this, "fromPosition", new ye());
    G(this, "toPosition", new ye(1, 1, 0));
    G(this, "ctrl1", new ye(0.2, 0.1, 0));
    G(this, "ctrl2", new ye(0.8, 0.9, 0));
    G(this, "density", 10);
    G(this, "_tmpSize", new Tt());
    this.type = "BezierLine", this.material.worldUnits = !0, this.material.linewidth = 0.1, this.onBeforeRender = (t, r, n, s, o, i) => {
      const { x: a, y: l } = t.getSize(this._tmpSize);
      (this.material.resolution.x !== a || this.material.resolution.y !== l) && (this.material.resolution.set(a, l), this.material.uniformsNeedUpdate = !0);
    }, this.updatePositions();
  }
  updatePositions() {
    const t = new Ob(this.fromPosition, this.ctrl1, this.ctrl2, this.toPosition), r = Math.abs(this.fromPosition.clone().distanceTo(this.toPosition)), n = t.getPoints(this.density * r);
    this.geometry.setPositions(n.map((s) => [s.x, s.y, s.z]).flat()), this.computeLineDistances();
  }
  serialize(t) {
    t.type = "BezierLine", t.fromPosition = this.fromPosition.toArray(), t.toPosition = this.toPosition.toArray(), t.ctrl1 = this.ctrl1.toArray(), t.ctrl2 = this.ctrl2.toArray(), t.density = this.density;
  }
  deserialize(t) {
    this.fromPosition.fromArray(t.fromPosition), this.toPosition.fromArray(t.toPosition), this.ctrl1.fromArray(t.ctrl1), this.ctrl2.fromArray(t.ctrl2), this.density = t.density, this.geometry instanceof pl || (this.geometry = new pl()), this.updatePositions();
  }
}
y_("BezierLineMaterial", mi);
Ye("BezierLine", {
  // cls: BezierLine,
  create: () => new H1(),
  members: {
    fromPosition: "Vector3",
    toPosition: "Vector3",
    ctrl1: "Vector3",
    ctrl2: "Vector3",
    density: "Number"
  },
  proto: "Mesh",
  group: "Objects.Bezier Line",
  icon: "line"
});
Ls("BezierLineMaterial", mi, {
  color: "Color",
  dashed: "Boolean",
  dashScale: "Number",
  dashSize: "Number",
  dashOffset: "Number",
  gapSize: "Number",
  opacity: "Number",
  linewidth: "Number",
  alphaToCoverage: "Boolean",
  worldUnits: "Boolean"
}, "ShaderMaterial", {
  bezierLineMaterial: { clsName: "bezierLineMaterial", func: () => new mi(), group: "Material.Bezier Line Material", icon: "brand-medium" }
});
Ye("PerspectiveCamera", {
  // cls: PerspectiveCamera,
  create: () => new _r(),
  members: {},
  group: "Cameras.Perspective Camera",
  icon: "camera"
});
Ye("OrthographicCamera", {
  // cls: OrthographicCamera,
  create: () => new ec(),
  members: {},
  group: "Cameras.Orthographic Camera",
  icon: "camera"
});
class X1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isBox", !0);
    this.type = "Box";
  }
}
Ye("Box", {
  create: ({ material: c, geometry: e } = {}) => new X1(e, c || new jn()),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.depthSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Box",
  icon: "box"
});
class $1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCapsule", !0);
    this.type = "Capsule";
  }
}
Ye("Capsule", {
  create: ({ material: c, geometry: e } = {}) => new $1(e || new Gm(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Capsule",
  icon: "capsule"
});
class q1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCone", !0);
    this.type = "Cone";
  }
}
Ye("Cone", {
  create: ({ material: c, geometry: e } = {}) => new q1(e || new Fb(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cone",
  icon: "cone"
});
class J1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCylinder", !0);
    this.type = "Cylinder";
  }
}
Ye("Cylinder", {
  create: ({ material: c, geometry: e } = {}) => new J1(e || new Ib(), c || new jn()),
  members: {
    "geo.radiusTop": "Number",
    "geo.radiusBottom": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cylinder",
  icon: "cylinder"
});
let Y1 = class extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isSphere", !0);
    this.type = "Sphere";
  }
};
Ye("Sphere", {
  create: ({ material: c, geometry: e } = {}) => new Y1(e || new tc(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.phiStart": "Number",
    "geo.phiLength": "Number",
    "geo.phiSegments": "Number",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Sphere",
  icon: "sphere"
});
class K1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorus", !0);
    this.type = "Torus";
  }
}
Ye("Torus", {
  create: ({ material: c, geometry: e } = {}) => new K1(e || new Pb(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.arc": "Number"
  },
  proto: "Entity",
  group: "Entities.Torus",
  icon: "ring"
});
class Z1 extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorusKnot", !0);
    this.type = "TorusKnot";
  }
}
Ye("TorusKnot", {
  create: ({ material: c, geometry: e } = {}) => new Z1(e || new Db(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.p": "Number",
    "geo.q": "Number"
  },
  proto: "Entity",
  group: "Entities.TorusKnot",
  icon: "pipe"
});
const L_ = {
  curveSegments: 12,
  steps: 1,
  depth: 1,
  bevelEnabled: !0,
  bevelThickness: 0.2,
  bevelSize: 0.1,
  bevelOffset: 0,
  bevelSegments: 3
};
let Or = class extends Nn {
  constructor(t, r, n, s = 0, o = 0) {
    super(t || new Vm(), r || new jn(), s, o);
    G(this, "isShape", !0);
    G(this, "shapes", []);
    G(this, "props");
    this.type = "Shape", this.props = Qd({ ...n }, () => {
      this.rebuildShapes();
    }), t || this.rebuildShapes();
  }
  get parameters() {
    var r;
    const t = ((r = this.geometry.parameters) == null ? void 0 : r.options) || {};
    return Object.keys(t).length ? t : { ...L_ };
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Vt], s = er(n), o = r.props[Vt];
    return tr(o, s), r;
  }
  serialize(t) {
    super.serialize(t);
    const r = this.props[Vt];
    t.props = er(r);
  }
  deserialize(t) {
    if (super.deserialize(t), t.props) {
      const r = this.props[Vt];
      tr(r, t.props);
    }
    this.shapes = Array.isArray(this.geometry.parameters.shapes) ? this.geometry.parameters.shapes : [this.geometry.parameters.shapes];
  }
  rebuildShapes() {
    this.rebuildGeometry();
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose();
    const r = this.geo[Vt];
    this.geometry = t.fromJSON({ shapes: this.shapes.map((n, s) => s), options: r }, this.shapes), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
};
Ye("Shape", {
  create: ({ material: c, geometry: e } = {}) => new Or(e, c),
  members: {
    "geo.curveSegments": "Number",
    "geo.steps": "Number",
    "geo.depth": "Number",
    "geo.bevelEnabled": "Boolean",
    "geo.bevelThickness": "Number",
    "geo.bevelSize": "Number",
    "geo.bevelOffset": "Number",
    "geo.bevelSegments": "Number"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class Q1 extends Nn {
  constructor(t, r) {
    super(t || new Er(), r || new jn(), Cc.Ghost, 0);
    G(this, "isPlane", !0);
    this.type = "Plane";
  }
}
Ye("Plane", {
  create: ({ material: c, geometry: e } = {}) => new Q1(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number"
  },
  /** yes, we hide mass and body-type properties */
  proto: "Mesh",
  group: "Shapes.Plane",
  icon: "plane"
});
class ex extends Or {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { vec1: new Tt(0, 0), vec2: new Tt(1, 0), vec3: new Tt(0, 1) }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeTriangle";
  }
  rebuildShapes() {
    const t = new Cu(), r = new So();
    t.subPaths.push(r);
    const { vec1: n, vec2: s, vec3: o } = this.props;
    r.moveTo(n.x, n.y), r.lineTo(s.x, s.y), r.lineTo(o.x, o.y), r.lineTo(n.x, n.y), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeTriangle", {
  create: ({ material: c, geometry: e } = {}) => new ex(e, c),
  members: {
    "props.vec1": "Vector2",
    "props.vec2": "Vector2",
    "props.vec3": "Vector2"
  },
  proto: "Shape",
  group: "Shapes.Triangle",
  icon: "triangle"
});
class tx extends Or {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { size: 1 }, n, s);
    G(this, "isShapeSquare", !0);
    this.type = "ShapeSquare";
  }
  rebuildShapes() {
    const t = new So(), { size: r } = this.props;
    t.moveTo(0, 0), t.lineTo(r, 0), t.lineTo(r, r), t.lineTo(0, r), t.lineTo(0, 0), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeSquare", {
  create: ({ material: c, geometry: e } = {}) => new tx(e, c),
  members: {
    "props.size": "Number"
  },
  proto: "Shape",
  group: "Shapes.Square",
  icon: "square"
});
class nx extends Or {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { width: 1, height: 1, radius: 0.2 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeRounded";
  }
  rebuildShapes() {
    const t = new Cu(), r = new So();
    t.subPaths.push(r);
    const { width: n, height: s, radius: o } = this.props;
    r.moveTo(0, o), r.lineTo(0, s - o), r.quadraticCurveTo(0, s, o, s), r.lineTo(0 + n - o, s), r.quadraticCurveTo(n, s, n, s - o), r.lineTo(0 + n, o), r.quadraticCurveTo(n, 0, n - o, 0), r.lineTo(o, 0), r.quadraticCurveTo(0, 0, 0, o), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeRounded", {
  create: ({ material: c, geometry: e } = {}) => new nx(e, c),
  members: {
    "props.width": "Number",
    "props.height": "Number",
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Rounded rectangle",
  icon: "square"
});
class sx extends Or {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeCircle";
  }
  rebuildShapes() {
    const t = new So(), { radius: r } = this.props;
    t.moveTo(0, r).quadraticCurveTo(r, r, r, 0).quadraticCurveTo(r, -r, 0, -r).quadraticCurveTo(-r, -r, -r, 0).quadraticCurveTo(-r, r, 0, r), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeCircle", {
  create: ({ material: c, geometry: e } = {}) => new sx(e, c),
  members: {
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Circle",
  icon: "ring"
});
class rx extends Or {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1, innerRadius: 0.5 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeArc";
  }
  rebuildShapes() {
    const t = new So(), { radius: r, innerRadius: n } = this.props;
    t.moveTo(r, 0).absarc(0, 0, r, 0, Math.PI * 2, !1);
    const s = new Ub().moveTo(n, 0).absarc(0, 0, n, 0, Math.PI * 2, !0);
    t.holes.push(s), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeArc", {
  create: ({ material: c, geometry: e } = {}) => new rx(e, c),
  members: {
    "props.radius": "Number",
    "props.innerRadius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Arc Circle",
  icon: "ring"
});
Ye("PointLight", {
  // cls: PointLight,
  create: () => {
    const c = new ni();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Point Light",
  icon: "bulb"
});
Ye("SpotLight", {
  // cls: SpotLight,
  create: () => {
    const c = new Ni();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Spot Light",
  icon: "bulb"
});
Ye("DirectionalLight", {
  // cls: DirectionalLight,
  create: () => {
    const c = new bi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c.shadow.bias = -0.1, c;
  },
  members: {},
  group: "Lights.Directional Light",
  icon: "bulb"
});
Ye("AmbientLight", {
  // cls: AmbientLight,
  create: () => new _u(),
  members: {},
  group: "Lights.Ambient Light",
  icon: "bulb"
});
Ye("HemisphereLight", {
  // cls: HemisphereLight,
  create: () => new Um(),
  members: {},
  group: "Lights.Hemisphere Light",
  icon: "bulb"
});
function O_() {
  var c = /* @__PURE__ */ Object.create(null);
  function e(n, s) {
    var o = n.id, i = n.name, a = n.dependencies;
    a === void 0 && (a = []);
    var l = n.init;
    l === void 0 && (l = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !c[o])
      try {
        a = a.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = c[d.id].value), d;
        }), l = r("<" + i + ">.init", l), u && (u = r("<" + i + ">.getTransferables", u));
        var h = null;
        typeof l == "function" ? h = l.apply(void 0, a) : console.error("worker module init function failed to rehydrate"), c[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, s(h);
      } catch (d) {
        d && d.noLog || console.error(d), s(d);
      }
  }
  function t(n, s) {
    var o, i = n.id, a = n.args;
    (!c[i] || typeof c[i].value != "function") && s(new Error("Worker module " + i + ": not found or its 'init' did not return a function"));
    try {
      var l = (o = c[i]).value.apply(o, a);
      l && typeof l.then == "function" ? l.then(u, function(h) {
        return s(h instanceof Error ? h : new Error("" + h));
      }) : u(l);
    } catch (h) {
      s(h);
    }
    function u(h) {
      try {
        var d = c[i].getTransferables && c[i].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), s(h, d);
      } catch (f) {
        console.error(f), s(f);
      }
    }
  }
  function r(n, s) {
    var o = void 0;
    self.troikaDefine = function(a) {
      return o = a;
    };
    var i = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(i);
    } catch (a) {
      console.error(a);
    }
    return URL.revokeObjectURL(i), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var s = n.data, o = s.messageId, i = s.action, a = s.data;
    try {
      i === "registerModule" && e(a, function(l) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof l == "function" }
        });
      }), i === "callModule" && t(a, function(l, u) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: l
        }, u || void 0);
      });
    } catch (l) {
      postMessage({
        messageId: o,
        success: !1,
        error: l.stack
      });
    }
  });
}
function F_(c) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = c.dependencies, r = c.init;
    t = Array.isArray(t) ? t.map(
      function(s) {
        return s && s._getInitResult ? s._getInitResult() : s;
      }
    ) : [];
    var n = Promise.all(t).then(function(s) {
      return r.apply(null, s);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var ox = function() {
  var c = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), c = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return ox = function() {
    return c;
  }, c;
}, I_ = 0, P_ = 0, ml = !1, Ko = /* @__PURE__ */ Object.create(null), Zo = /* @__PURE__ */ Object.create(null), lu = /* @__PURE__ */ Object.create(null);
function ms(c) {
  if ((!c || typeof c.init != "function") && !ml)
    throw new Error("requires `options.init` function");
  var e = c.dependencies, t = c.init, r = c.getTransferables, n = c.workerId;
  if (!ox())
    return F_(c);
  n == null && (n = "#default");
  var s = "workerModule" + ++I_, o = c.name || s, i = null;
  e = e && e.map(function(l) {
    return typeof l == "function" && !l.workerModuleData && (ml = !0, l = ms({
      workerId: n,
      name: "<" + o + "> function dependency: " + l.name,
      init: `function(){return (
` + Aa(l) + `
)}`
    }), ml = !1), l && l.workerModuleData && (l = l.workerModuleData), l;
  });
  function a() {
    for (var l = [], u = arguments.length; u--; )
      l[u] = arguments[u];
    if (!i) {
      i = Ep(n, "registerModule", a.workerModuleData);
      var h = function() {
        i = null, Zo[n].delete(h);
      };
      (Zo[n] || (Zo[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return i.then(function(d) {
      var f = d.isCallable;
      if (f)
        return Ep(n, "callModule", { id: s, args: l });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return a.workerModuleData = {
    isWorkerModule: !0,
    id: s,
    name: o,
    dependencies: e,
    init: Aa(t),
    getTransferables: r && Aa(r)
  }, a;
}
function D_(c) {
  Zo[c] && Zo[c].forEach(function(e) {
    e();
  }), Ko[c] && (Ko[c].terminate(), delete Ko[c]);
}
function Aa(c) {
  var e = c.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function U_(c) {
  var e = Ko[c];
  if (!e) {
    var t = Aa(O_);
    e = Ko[c] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + c.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var n = r.data, s = n.messageId, o = lu[s];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete lu[s], o(n);
    };
  }
  return e;
}
function Ep(c, e, t) {
  return new Promise(function(r, n) {
    var s = ++P_;
    lu[s] = function(o) {
      o.success ? r(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, U_(c).postMessage({
      messageId: s,
      action: e,
      data: t
    });
  });
}
function ix() {
  var c = function(e) {
    function t(H, X, C, F, I, k, z, Q) {
      var W = 1 - z;
      Q.x = W * W * H + 2 * W * z * C + z * z * I, Q.y = W * W * X + 2 * W * z * F + z * z * k;
    }
    function r(H, X, C, F, I, k, z, Q, W, q) {
      var ie = 1 - W;
      q.x = ie * ie * ie * H + 3 * ie * ie * W * C + 3 * ie * W * W * I + W * W * W * z, q.y = ie * ie * ie * X + 3 * ie * ie * W * F + 3 * ie * W * W * k + W * W * W * Q;
    }
    function n(H, X) {
      for (var C = /([MLQCZ])([^MLQCZ]*)/g, F, I, k, z, Q; F = C.exec(H); ) {
        var W = F[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(q) {
          return parseFloat(q);
        });
        switch (F[1]) {
          case "M":
            z = I = W[0], Q = k = W[1];
            break;
          case "L":
            (W[0] !== z || W[1] !== Q) && X("L", z, Q, z = W[0], Q = W[1]);
            break;
          case "Q": {
            X("Q", z, Q, z = W[2], Q = W[3], W[0], W[1]);
            break;
          }
          case "C": {
            X("C", z, Q, z = W[4], Q = W[5], W[0], W[1], W[2], W[3]);
            break;
          }
          case "Z":
            (z !== I || Q !== k) && X("L", z, Q, I, k);
            break;
        }
      }
    }
    function s(H, X, C) {
      C === void 0 && (C = 16);
      var F = { x: 0, y: 0 };
      n(H, function(I, k, z, Q, W, q, ie, ae, $) {
        switch (I) {
          case "L":
            X(k, z, Q, W);
            break;
          case "Q": {
            for (var O = k, te = z, Z = 1; Z < C; Z++)
              t(
                k,
                z,
                q,
                ie,
                Q,
                W,
                Z / (C - 1),
                F
              ), X(O, te, F.x, F.y), O = F.x, te = F.y;
            break;
          }
          case "C": {
            for (var Y = k, ee = z, pe = 1; pe < C; pe++)
              r(
                k,
                z,
                q,
                ie,
                ae,
                $,
                Q,
                W,
                pe / (C - 1),
                F
              ), X(Y, ee, F.x, F.y), Y = F.x, ee = F.y;
            break;
          }
        }
      });
    }
    var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", i = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", a = /* @__PURE__ */ new WeakMap(), l = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(H, X) {
      var C = H.getContext ? H.getContext("webgl", l) : H, F = a.get(C);
      if (!F) {
        let ie = function(Y) {
          var ee = k[Y];
          if (!ee && (ee = k[Y] = C.getExtension(Y), !ee))
            throw new Error(Y + " not supported");
          return ee;
        }, ae = function(Y, ee) {
          var pe = C.createShader(ee);
          return C.shaderSource(pe, Y), C.compileShader(pe), pe;
        }, $ = function(Y, ee, pe, ne) {
          if (!z[Y]) {
            var he = {}, fe = {}, K = C.createProgram();
            C.attachShader(K, ae(ee, C.VERTEX_SHADER)), C.attachShader(K, ae(pe, C.FRAGMENT_SHADER)), C.linkProgram(K), z[Y] = {
              program: K,
              transaction: function(me) {
                C.useProgram(K), me({
                  setUniform: function(de, qe) {
                    for (var le = [], Ne = arguments.length - 2; Ne-- > 0; )
                      le[Ne] = arguments[Ne + 2];
                    var ve = fe[qe] || (fe[qe] = C.getUniformLocation(K, qe));
                    C["uniform" + de].apply(C, [ve].concat(le));
                  },
                  setAttribute: function(de, qe, le, Ne, ve) {
                    var Te = he[de];
                    Te || (Te = he[de] = {
                      buf: C.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: C.getAttribLocation(K, de),
                      data: null
                    }), C.bindBuffer(C.ARRAY_BUFFER, Te.buf), C.vertexAttribPointer(Te.loc, qe, C.FLOAT, !1, 0, 0), C.enableVertexAttribArray(Te.loc), I ? C.vertexAttribDivisor(Te.loc, Ne) : ie("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Te.loc, Ne), ve !== Te.data && (C.bufferData(C.ARRAY_BUFFER, ve, le), Te.data = ve);
                  }
                });
              }
            };
          }
          z[Y].transaction(ne);
        }, O = function(Y, ee) {
          W++;
          try {
            C.activeTexture(C.TEXTURE0 + W);
            var pe = Q[Y];
            pe || (pe = Q[Y] = C.createTexture(), C.bindTexture(C.TEXTURE_2D, pe), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MIN_FILTER, C.NEAREST), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MAG_FILTER, C.NEAREST)), C.bindTexture(C.TEXTURE_2D, pe), ee(pe, W);
          } finally {
            W--;
          }
        }, te = function(Y, ee, pe) {
          var ne = C.createFramebuffer();
          q.push(ne), C.bindFramebuffer(C.FRAMEBUFFER, ne), C.activeTexture(C.TEXTURE0 + ee), C.bindTexture(C.TEXTURE_2D, Y), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_2D, Y, 0);
          try {
            pe(ne);
          } finally {
            C.deleteFramebuffer(ne), C.bindFramebuffer(C.FRAMEBUFFER, q[--q.length - 1] || null);
          }
        }, Z = function() {
          k = {}, z = {}, Q = {}, W = -1, q.length = 0;
        };
        var I = typeof WebGL2RenderingContext < "u" && C instanceof WebGL2RenderingContext, k = {}, z = {}, Q = {}, W = -1, q = [];
        C.canvas.addEventListener("webglcontextlost", function(Y) {
          Z(), Y.preventDefault();
        }, !1), a.set(C, F = {
          gl: C,
          isWebGL2: I,
          getExtension: ie,
          withProgram: $,
          withTexture: O,
          withTextureFramebuffer: te,
          handleContextLoss: Z
        });
      }
      X(F);
    }
    function h(H, X, C, F, I, k, z, Q) {
      z === void 0 && (z = 15), Q === void 0 && (Q = null), u(H, function(W) {
        var q = W.gl, ie = W.withProgram, ae = W.withTexture;
        ae("copy", function($, O) {
          q.texImage2D(q.TEXTURE_2D, 0, q.RGBA, I, k, 0, q.RGBA, q.UNSIGNED_BYTE, X), ie("copy", o, i, function(te) {
            var Z = te.setUniform, Y = te.setAttribute;
            Y("aUV", 2, q.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", O), q.bindFramebuffer(q.FRAMEBUFFER, Q || null), q.disable(q.BLEND), q.colorMask(z & 8, z & 4, z & 2, z & 1), q.viewport(C, F, I, k), q.scissor(C, F, I, k), q.drawArrays(q.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(H, X, C) {
      var F = H.width, I = H.height;
      u(H, function(k) {
        var z = k.gl, Q = new Uint8Array(F * I * 4);
        z.readPixels(0, 0, F, I, z.RGBA, z.UNSIGNED_BYTE, Q), H.width = X, H.height = C, h(z, Q, 0, 0, F, I);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function p(H, X, C, F, I, k) {
      k === void 0 && (k = 1);
      var z = new Uint8Array(H * X), Q = F[2] - F[0], W = F[3] - F[1], q = [];
      s(C, function(Y, ee, pe, ne) {
        q.push({
          x1: Y,
          y1: ee,
          x2: pe,
          y2: ne,
          minX: Math.min(Y, pe),
          minY: Math.min(ee, ne),
          maxX: Math.max(Y, pe),
          maxY: Math.max(ee, ne)
        });
      }), q.sort(function(Y, ee) {
        return Y.maxX - ee.maxX;
      });
      for (var ie = 0; ie < H; ie++)
        for (var ae = 0; ae < X; ae++) {
          var $ = te(
            F[0] + Q * (ie + 0.5) / H,
            F[1] + W * (ae + 0.5) / X
          ), O = Math.pow(1 - Math.abs($) / I, k) / 2;
          $ < 0 && (O = 1 - O), O = Math.max(0, Math.min(255, Math.round(O * 255))), z[ae * H + ie] = O;
        }
      return z;
      function te(Y, ee) {
        for (var pe = 1 / 0, ne = 1 / 0, he = q.length; he--; ) {
          var fe = q[he];
          if (fe.maxX + ne <= Y)
            break;
          if (Y + ne > fe.minX && ee - ne < fe.maxY && ee + ne > fe.minY) {
            var K = b(Y, ee, fe.x1, fe.y1, fe.x2, fe.y2);
            K < pe && (pe = K, ne = Math.sqrt(pe));
          }
        }
        return Z(Y, ee) && (ne = -ne), ne;
      }
      function Z(Y, ee) {
        for (var pe = 0, ne = q.length; ne--; ) {
          var he = q[ne];
          if (he.maxX <= Y)
            break;
          var fe = he.y1 > ee != he.y2 > ee && Y < (he.x2 - he.x1) * (ee - he.y1) / (he.y2 - he.y1) + he.x1;
          fe && (pe += he.y1 < he.y2 ? 1 : -1);
        }
        return pe !== 0;
      }
    }
    function m(H, X, C, F, I, k, z, Q, W, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0), g(H, X, C, F, I, k, z, null, Q, W, q);
    }
    function g(H, X, C, F, I, k, z, Q, W, q, ie) {
      k === void 0 && (k = 1), W === void 0 && (W = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0);
      for (var ae = p(H, X, C, F, I, k), $ = new Uint8Array(ae.length * 4), O = 0; O < ae.length; O++)
        $[O * 4 + ie] = ae[O];
      h(z, $, W, q, H, X, 1 << 3 - ie, Q);
    }
    function b(H, X, C, F, I, k) {
      var z = I - C, Q = k - F, W = z * z + Q * Q, q = W ? Math.max(0, Math.min(1, ((H - C) * z + (X - F) * Q) / W)) : 0, ie = H - (C + q * z), ae = X - (F + q * Q);
      return ie * ie + ae * ae;
    }
    var v = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: p,
      generateIntoCanvas: m,
      generateIntoFramebuffer: g
    }), y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", N = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", w = new Float32Array([0, 0, 2, 0, 0, 2]), T = null, _ = !1, L = {}, A = /* @__PURE__ */ new WeakMap();
    function U(H) {
      if (!_ && !D(H))
        throw new Error("WebGL generation not supported");
    }
    function S(H, X, C, F, I, k, z) {
      if (k === void 0 && (k = 1), z === void 0 && (z = null), !z && (z = T, !z)) {
        var Q = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Q)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        z = T = Q.getContext("webgl", { depth: !1 });
      }
      U(z);
      var W = new Uint8Array(H * X * 4);
      u(z, function($) {
        var O = $.gl, te = $.withTexture, Z = $.withTextureFramebuffer;
        te("readable", function(Y, ee) {
          O.texImage2D(O.TEXTURE_2D, 0, O.RGBA, H, X, 0, O.RGBA, O.UNSIGNED_BYTE, null), Z(Y, ee, function(pe) {
            E(
              H,
              X,
              C,
              F,
              I,
              k,
              O,
              pe,
              0,
              0,
              0
              // red channel
            ), O.readPixels(0, 0, H, X, O.RGBA, O.UNSIGNED_BYTE, W);
          });
        });
      });
      for (var q = new Uint8Array(H * X), ie = 0, ae = 0; ie < W.length; ie += 4)
        q[ae++] = W[ie];
      return q;
    }
    function R(H, X, C, F, I, k, z, Q, W, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0), E(H, X, C, F, I, k, z, null, Q, W, q);
    }
    function E(H, X, C, F, I, k, z, Q, W, q, ie) {
      k === void 0 && (k = 1), W === void 0 && (W = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0), U(z);
      var ae = [];
      s(C, function($, O, te, Z) {
        ae.push($, O, te, Z);
      }), ae = new Float32Array(ae), u(z, function($) {
        var O = $.gl, te = $.isWebGL2, Z = $.getExtension, Y = $.withProgram, ee = $.withTexture, pe = $.withTextureFramebuffer, ne = $.handleContextLoss;
        if (ee("rawDistances", function(he, fe) {
          (H !== he._lastWidth || X !== he._lastHeight) && O.texImage2D(
            O.TEXTURE_2D,
            0,
            O.RGBA,
            he._lastWidth = H,
            he._lastHeight = X,
            0,
            O.RGBA,
            O.UNSIGNED_BYTE,
            null
          ), Y("main", y, x, function(K) {
            var Ae = K.setAttribute, me = K.setUniform, be = !te && Z("ANGLE_instanced_arrays"), de = !te && Z("EXT_blend_minmax");
            Ae("aUV", 2, O.STATIC_DRAW, 0, w), Ae("aLineSegment", 4, O.DYNAMIC_DRAW, 1, ae), me.apply(void 0, ["4f", "uGlyphBounds"].concat(F)), me("1f", "uMaxDistance", I), me("1f", "uExponent", k), pe(he, fe, function(qe) {
              O.enable(O.BLEND), O.colorMask(!0, !0, !0, !0), O.viewport(0, 0, H, X), O.scissor(0, 0, H, X), O.blendFunc(O.ONE, O.ONE), O.blendEquationSeparate(O.FUNC_ADD, te ? O.MAX : de.MAX_EXT), O.clear(O.COLOR_BUFFER_BIT), te ? O.drawArraysInstanced(O.TRIANGLES, 0, 3, ae.length / 4) : be.drawArraysInstancedANGLE(O.TRIANGLES, 0, 3, ae.length / 4);
            });
          }), Y("post", o, N, function(K) {
            K.setAttribute("aUV", 2, O.STATIC_DRAW, 0, w), K.setUniform("1i", "tex", fe), O.bindFramebuffer(O.FRAMEBUFFER, Q), O.disable(O.BLEND), O.colorMask(ie === 0, ie === 1, ie === 2, ie === 3), O.viewport(W, q, H, X), O.scissor(W, q, H, X), O.drawArrays(O.TRIANGLES, 0, 3);
          });
        }), O.isContextLost())
          throw ne(), new Error("webgl context lost");
      });
    }
    function D(H) {
      var X = !H || H === T ? L : H.canvas || H, C = A.get(X);
      if (C === void 0) {
        _ = !0;
        var F = null;
        try {
          var I = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], k = S(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            H
          );
          C = k && I.length === k.length && k.every(function(z, Q) {
            return z === I[Q];
          }), C || (F = "bad trial run results", console.info(I, k));
        } catch (z) {
          C = !1, F = z.message;
        }
        F && console.warn("WebGL SDF generation not supported:", F), _ = !1, A.set(X, C);
      }
      return C;
    }
    var P = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: S,
      generateIntoCanvas: R,
      generateIntoFramebuffer: E,
      isSupported: D
    });
    function se(H, X, C, F, I, k) {
      I === void 0 && (I = Math.max(F[2] - F[0], F[3] - F[1]) / 2), k === void 0 && (k = 1);
      try {
        return S.apply(P, arguments);
      } catch (z) {
        return console.info("WebGL SDF generation failed, falling back to JS", z), p.apply(v, arguments);
      }
    }
    function oe(H, X, C, F, I, k, z, Q, W, q) {
      I === void 0 && (I = Math.max(F[2] - F[0], F[3] - F[1]) / 2), k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0);
      try {
        return R.apply(P, arguments);
      } catch (ie) {
        return console.info("WebGL SDF generation failed, falling back to JS", ie), m.apply(v, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = se, e.generateIntoCanvas = oe, e.javascript = v, e.pathToLineSegments = s, e.webgl = P, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
function ax() {
  var c = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, n = {};
    r.L = 1, n[1] = "L", Object.keys(t).forEach(function(ne, he) {
      r[ne] = 1 << he + 1, n[r[ne]] = ne;
    }), Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI, o = r.L | r.R | r.AL, i = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, a = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, l = r.S | r.WS | r.B | s | r.PDI | a, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var ne = function(fe) {
          if (t.hasOwnProperty(fe)) {
            var K = 0;
            t[fe].split(",").forEach(function(Ae) {
              var me = Ae.split("+"), be = me[0], de = me[1];
              be = parseInt(be, 36), de = de ? parseInt(de, 36) : 0, u.set(K += be, r[fe]);
              for (var qe = 0; qe < de; qe++)
                u.set(++K, r[fe]);
            });
          }
        };
        for (var he in t)
          ne(he);
      }
    }
    function d(ne) {
      return h(), u.get(ne.codePointAt(0)) || r.L;
    }
    function f(ne) {
      return n[d(ne)];
    }
    var p = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(ne, he) {
      var fe = 36, K = 0, Ae = /* @__PURE__ */ new Map(), me = he && /* @__PURE__ */ new Map(), be;
      return ne.split(",").forEach(function de(qe) {
        if (qe.indexOf("+") !== -1)
          for (var le = +qe; le--; )
            de(be);
        else {
          be = qe;
          var Ne = qe.split(">"), ve = Ne[0], Te = Ne[1];
          ve = String.fromCodePoint(K += parseInt(ve, fe)), Te = String.fromCodePoint(K += parseInt(Te, fe)), Ae.set(ve, Te), he && me.set(Te, ve);
        }
      }), { map: Ae, reverseMap: me };
    }
    var g, b, v;
    function y() {
      if (!g) {
        var ne = m(p.pairs, !0), he = ne.map, fe = ne.reverseMap;
        g = he, b = fe, v = m(p.canonical, !1).map;
      }
    }
    function x(ne) {
      return y(), g.get(ne) || null;
    }
    function N(ne) {
      return y(), b.get(ne) || null;
    }
    function w(ne) {
      return y(), v.get(ne) || null;
    }
    var T = r.L, _ = r.R, L = r.EN, A = r.ES, U = r.ET, S = r.AN, R = r.CS, E = r.B, D = r.S, P = r.ON, se = r.BN, oe = r.NSM, H = r.AL, X = r.LRO, C = r.RLO, F = r.LRE, I = r.RLE, k = r.PDF, z = r.LRI, Q = r.RLI, W = r.FSI, q = r.PDI;
    function ie(ne, he) {
      for (var fe = 125, K = new Uint32Array(ne.length), Ae = 0; Ae < ne.length; Ae++)
        K[Ae] = d(ne[Ae]);
      var me = /* @__PURE__ */ new Map();
      function be(dn, Xn) {
        var fn = K[dn];
        K[dn] = Xn, me.set(fn, me.get(fn) - 1), fn & i && me.set(i, me.get(i) - 1), me.set(Xn, (me.get(Xn) || 0) + 1), Xn & i && me.set(i, (me.get(i) || 0) + 1);
      }
      for (var de = new Uint8Array(ne.length), qe = /* @__PURE__ */ new Map(), le = [], Ne = null, ve = 0; ve < ne.length; ve++)
        Ne || le.push(Ne = {
          start: ve,
          end: ne.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: he === "rtl" ? 1 : he === "ltr" ? 0 : qf(ve, !1)
        }), K[ve] & E && (Ne.end = ve, Ne = null);
      for (var Te = I | F | C | X | s | q | k | E, Pe = function(dn) {
        return dn + (dn & 1 ? 1 : 2);
      }, Je = function(dn) {
        return dn + (dn & 1 ? 2 : 1);
      }, _e = 0; _e < le.length; _e++) {
        Ne = le[_e];
        var Ue = [{
          _level: Ne.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], ge = void 0, We = 0, $e = 0, dt = 0;
        me.clear();
        for (var Qe = Ne.start; Qe <= Ne.end; Qe++) {
          var xe = K[Qe];
          if (ge = Ue[Ue.length - 1], me.set(xe, (me.get(xe) || 0) + 1), xe & i && me.set(i, (me.get(i) || 0) + 1), xe & Te)
            if (xe & (I | F)) {
              de[Qe] = ge._level;
              var Fe = (xe === I ? Je : Pe)(ge._level);
              Fe <= fe && !We && !$e ? Ue.push({
                _level: Fe,
                _override: 0,
                _isolate: 0
              }) : We || $e++;
            } else if (xe & (C | X)) {
              de[Qe] = ge._level;
              var Bt = (xe === C ? Je : Pe)(ge._level);
              Bt <= fe && !We && !$e ? Ue.push({
                _level: Bt,
                _override: xe & C ? _ : T,
                _isolate: 0
              }) : We || $e++;
            } else if (xe & s) {
              xe & W && (xe = qf(Qe + 1, !0) === 1 ? Q : z), de[Qe] = ge._level, ge._override && be(Qe, ge._override);
              var Ee = (xe === Q ? Je : Pe)(ge._level);
              Ee <= fe && We === 0 && $e === 0 ? (dt++, Ue.push({
                _level: Ee,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Qe
              })) : We++;
            } else if (xe & q) {
              if (We > 0)
                We--;
              else if (dt > 0) {
                for ($e = 0; !Ue[Ue.length - 1]._isolate; )
                  Ue.pop();
                var Le = Ue[Ue.length - 1]._isolInitIndex;
                Le != null && (qe.set(Le, Qe), qe.set(Qe, Le)), Ue.pop(), dt--;
              }
              ge = Ue[Ue.length - 1], de[Qe] = ge._level, ge._override && be(Qe, ge._override);
            } else
              xe & k ? (We === 0 && ($e > 0 ? $e-- : !ge._isolate && Ue.length > 1 && (Ue.pop(), ge = Ue[Ue.length - 1])), de[Qe] = ge._level) : xe & E && (de[Qe] = Ne.level);
          else
            de[Qe] = ge._level, ge._override && xe !== se && be(Qe, ge._override);
        }
        for (var tt = [], De = null, we = Ne.start; we <= Ne.end; we++) {
          var He = K[we];
          if (!(He & a)) {
            var vt = de[we], at = He & s, ot = He === q;
            De && vt === De._level ? (De._end = we, De._endsWithIsolInit = at) : tt.push(De = {
              _start: we,
              _end: we,
              _level: vt,
              _startsWithPDI: ot,
              _endsWithIsolInit: at
            });
          }
        }
        for (var It = [], Fn = 0; Fn < tt.length; Fn++) {
          var un = tt[Fn];
          if (!un._startsWithPDI || un._startsWithPDI && !qe.has(un._start)) {
            for (var wn = [De = un], In = void 0; De && De._endsWithIsolInit && (In = qe.get(De._end)) != null; )
              for (var hn = Fn + 1; hn < tt.length; hn++)
                if (tt[hn]._start === In) {
                  wn.push(De = tt[hn]);
                  break;
                }
            for (var xt = [], Wn = 0; Wn < wn.length; Wn++)
              for (var Cf = wn[Wn], Dc = Cf._start; Dc <= Cf._end; Dc++)
                xt.push(Dc);
            for (var nb = de[xt[0]], Ef = Ne.level, Ii = xt[0] - 1; Ii >= 0; Ii--)
              if (!(K[Ii] & a)) {
                Ef = de[Ii];
                break;
              }
            var Uc = xt[xt.length - 1], sb = de[Uc], Rf = Ne.level;
            if (!(K[Uc] & s)) {
              for (var Pi = Uc + 1; Pi <= Ne.end; Pi++)
                if (!(K[Pi] & a)) {
                  Rf = de[Pi];
                  break;
                }
            }
            It.push({
              _seqIndices: xt,
              _sosType: Math.max(Ef, nb) % 2 ? _ : T,
              _eosType: Math.max(Rf, sb) % 2 ? _ : T
            });
          }
        }
        for (var zc = 0; zc < It.length; zc++) {
          var Bc = It[zc], Ie = Bc._seqIndices, Mo = Bc._sosType, rb = Bc._eosType, Ir = de[Ie[0]] & 1 ? _ : T;
          if (me.get(oe))
            for (var Di = 0; Di < Ie.length; Di++) {
              var Lf = Ie[Di];
              if (K[Lf] & oe) {
                for (var kc = Mo, Ui = Di - 1; Ui >= 0; Ui--)
                  if (!(K[Ie[Ui]] & a)) {
                    kc = K[Ie[Ui]];
                    break;
                  }
                be(Lf, kc & (s | q) ? P : kc);
              }
            }
          if (me.get(L))
            for (var zi = 0; zi < Ie.length; zi++) {
              var Of = Ie[zi];
              if (K[Of] & L)
                for (var Bi = zi - 1; Bi >= -1; Bi--) {
                  var Ff = Bi === -1 ? Mo : K[Ie[Bi]];
                  if (Ff & o) {
                    Ff === H && be(Of, S);
                    break;
                  }
                }
            }
          if (me.get(H))
            for (var Gc = 0; Gc < Ie.length; Gc++) {
              var If = Ie[Gc];
              K[If] & H && be(If, _);
            }
          if (me.get(A) || me.get(R))
            for (var Ao = 1; Ao < Ie.length - 1; Ao++) {
              var Vc = Ie[Ao];
              if (K[Vc] & (A | R)) {
                for (var Pr = 0, jc = 0, Wc = Ao - 1; Wc >= 0 && (Pr = K[Ie[Wc]], !!(Pr & a)); Wc--)
                  ;
                for (var Hc = Ao + 1; Hc < Ie.length && (jc = K[Ie[Hc]], !!(jc & a)); Hc++)
                  ;
                Pr === jc && (K[Vc] === A ? Pr === L : Pr & (L | S)) && be(Vc, Pr);
              }
            }
          if (me.get(L))
            for (var is = 0; is < Ie.length; is++) {
              var ob = Ie[is];
              if (K[ob] & L) {
                for (var ki = is - 1; ki >= 0 && K[Ie[ki]] & (U | a); ki--)
                  be(Ie[ki], L);
                for (is++; is < Ie.length && K[Ie[is]] & (U | a | L); is++)
                  K[Ie[is]] !== L && be(Ie[is], L);
              }
            }
          if (me.get(U) || me.get(A) || me.get(R))
            for (var Co = 0; Co < Ie.length; Co++) {
              var Pf = Ie[Co];
              if (K[Pf] & (U | A | R)) {
                be(Pf, P);
                for (var Gi = Co - 1; Gi >= 0 && K[Ie[Gi]] & a; Gi--)
                  be(Ie[Gi], P);
                for (var Vi = Co + 1; Vi < Ie.length && K[Ie[Vi]] & a; Vi++)
                  be(Ie[Vi], P);
              }
            }
          if (me.get(L))
            for (var Xc = 0, Df = Mo; Xc < Ie.length; Xc++) {
              var Uf = Ie[Xc], $c = K[Uf];
              $c & L ? Df === T && be(Uf, T) : $c & o && (Df = $c);
            }
          if (me.get(i)) {
            var Eo = _ | L | S, zf = Eo | T, ji = [];
            {
              for (var Dr = [], Ur = 0; Ur < Ie.length; Ur++)
                if (K[Ie[Ur]] & i) {
                  var Ro = ne[Ie[Ur]], Bf = void 0;
                  if (x(Ro) !== null)
                    if (Dr.length < 63)
                      Dr.push({ char: Ro, seqIndex: Ur });
                    else
                      break;
                  else if ((Bf = N(Ro)) !== null)
                    for (var Lo = Dr.length - 1; Lo >= 0; Lo--) {
                      var qc = Dr[Lo].char;
                      if (qc === Bf || qc === N(w(Ro)) || x(w(qc)) === Ro) {
                        ji.push([Dr[Lo].seqIndex, Ur]), Dr.length = Lo;
                        break;
                      }
                    }
                }
              ji.sort(function(dn, Xn) {
                return dn[0] - Xn[0];
              });
            }
            for (var Jc = 0; Jc < ji.length; Jc++) {
              for (var kf = ji[Jc], Wi = kf[0], Yc = kf[1], Gf = !1, Hn = 0, Kc = Wi + 1; Kc < Yc; Kc++) {
                var Vf = Ie[Kc];
                if (K[Vf] & zf) {
                  Gf = !0;
                  var jf = K[Vf] & Eo ? _ : T;
                  if (jf === Ir) {
                    Hn = jf;
                    break;
                  }
                }
              }
              if (Gf && !Hn) {
                Hn = Mo;
                for (var Zc = Wi - 1; Zc >= 0; Zc--) {
                  var Wf = Ie[Zc];
                  if (K[Wf] & zf) {
                    var Hf = K[Wf] & Eo ? _ : T;
                    Hf !== Ir ? Hn = Hf : Hn = Ir;
                    break;
                  }
                }
              }
              if (Hn) {
                if (K[Ie[Wi]] = K[Ie[Yc]] = Hn, Hn !== Ir) {
                  for (var Oo = Wi + 1; Oo < Ie.length; Oo++)
                    if (!(K[Ie[Oo]] & a)) {
                      d(ne[Ie[Oo]]) & oe && (K[Ie[Oo]] = Hn);
                      break;
                    }
                }
                if (Hn !== Ir) {
                  for (var Fo = Yc + 1; Fo < Ie.length; Fo++)
                    if (!(K[Ie[Fo]] & a)) {
                      d(ne[Ie[Fo]]) & oe && (K[Ie[Fo]] = Hn);
                      break;
                    }
                }
              }
            }
            for (var Os = 0; Os < Ie.length; Os++)
              if (K[Ie[Os]] & i) {
                for (var Xf = Os, Qc = Os, el = Mo, Io = Os - 1; Io >= 0; Io--)
                  if (K[Ie[Io]] & a)
                    Xf = Io;
                  else {
                    el = K[Ie[Io]] & Eo ? _ : T;
                    break;
                  }
                for (var $f = rb, Po = Os + 1; Po < Ie.length; Po++)
                  if (K[Ie[Po]] & (i | a))
                    Qc = Po;
                  else {
                    $f = K[Ie[Po]] & Eo ? _ : T;
                    break;
                  }
                for (var tl = Xf; tl <= Qc; tl++)
                  K[Ie[tl]] = el === $f ? el : Ir;
                Os = Qc;
              }
          }
        }
        for (var Tn = Ne.start; Tn <= Ne.end; Tn++) {
          var ib = de[Tn], Hi = K[Tn];
          if (ib & 1 ? Hi & (T | L | S) && de[Tn]++ : Hi & _ ? de[Tn]++ : Hi & (S | L) && (de[Tn] += 2), Hi & a && (de[Tn] = Tn === 0 ? Ne.level : de[Tn - 1]), Tn === Ne.end || d(ne[Tn]) & (D | E))
            for (var Xi = Tn; Xi >= 0 && d(ne[Xi]) & l; Xi--)
              de[Xi] = Ne.level;
        }
      }
      return {
        levels: de,
        paragraphs: le
      };
      function qf(dn, Xn) {
        for (var fn = dn; fn < ne.length; fn++) {
          var Fs = K[fn];
          if (Fs & (_ | H))
            return 1;
          if (Fs & (E | T) || Xn && Fs === q)
            return 0;
          if (Fs & s) {
            var Jf = ab(fn);
            fn = Jf === -1 ? ne.length : Jf;
          }
        }
        return 0;
      }
      function ab(dn) {
        for (var Xn = 1, fn = dn + 1; fn < ne.length; fn++) {
          var Fs = K[fn];
          if (Fs & E)
            break;
          if (Fs & q) {
            if (--Xn === 0)
              return fn;
          } else
            Fs & s && Xn++;
        }
        return -1;
      }
    }
    var ae = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", $;
    function O() {
      if (!$) {
        var ne = m(ae, !0), he = ne.map, fe = ne.reverseMap;
        fe.forEach(function(K, Ae) {
          he.set(Ae, K);
        }), $ = he;
      }
    }
    function te(ne) {
      return O(), $.get(ne) || null;
    }
    function Z(ne, he, fe, K) {
      var Ae = ne.length;
      fe = Math.max(0, fe == null ? 0 : +fe), K = Math.min(Ae - 1, K == null ? Ae - 1 : +K);
      for (var me = /* @__PURE__ */ new Map(), be = fe; be <= K; be++)
        if (he[be] & 1) {
          var de = te(ne[be]);
          de !== null && me.set(be, de);
        }
      return me;
    }
    function Y(ne, he, fe, K) {
      var Ae = ne.length;
      fe = Math.max(0, fe == null ? 0 : +fe), K = Math.min(Ae - 1, K == null ? Ae - 1 : +K);
      var me = [];
      return he.paragraphs.forEach(function(be) {
        var de = Math.max(fe, be.start), qe = Math.min(K, be.end);
        if (de < qe) {
          for (var le = he.levels.slice(de, qe + 1), Ne = qe; Ne >= de && d(ne[Ne]) & l; Ne--)
            le[Ne] = be.level;
          for (var ve = be.level, Te = 1 / 0, Pe = 0; Pe < le.length; Pe++) {
            var Je = le[Pe];
            Je > ve && (ve = Je), Je < Te && (Te = Je | 1);
          }
          for (var _e = ve; _e >= Te; _e--)
            for (var Ue = 0; Ue < le.length; Ue++)
              if (le[Ue] >= _e) {
                for (var ge = Ue; Ue + 1 < le.length && le[Ue + 1] >= _e; )
                  Ue++;
                Ue > ge && me.push([ge + de, Ue + de]);
              }
        }
      }), me;
    }
    function ee(ne, he, fe, K) {
      var Ae = pe(ne, he, fe, K), me = [].concat(ne);
      return Ae.forEach(function(be, de) {
        me[de] = (he.levels[be] & 1 ? te(ne[be]) : null) || ne[be];
      }), me.join("");
    }
    function pe(ne, he, fe, K) {
      for (var Ae = Y(ne, he, fe, K), me = [], be = 0; be < ne.length; be++)
        me[be] = be;
      return Ae.forEach(function(de) {
        for (var qe = de[0], le = de[1], Ne = me.slice(qe, le + 1), ve = Ne.length; ve--; )
          me[le - ve] = Ne[ve];
      }), me;
    }
    return e.closingToOpeningBracket = N, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = w, e.getEmbeddingLevels = ie, e.getMirroredCharacter = te, e.getMirroredCharactersMap = Z, e.getReorderSegments = Y, e.getReorderedIndices = pe, e.getReorderedString = ee, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
const cx = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function uu(c) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, n) {
    let s = jm[n];
    return s ? uu(s) : r;
  }
  return c.replace(e, t);
}
const Xt = [];
for (let c = 0; c < 256; c++)
  Xt[c] = (c < 16 ? "0" : "") + c.toString(16);
function z_() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Xt[c & 255] + Xt[c >> 8 & 255] + Xt[c >> 16 & 255] + Xt[c >> 24 & 255] + "-" + Xt[e & 255] + Xt[e >> 8 & 255] + "-" + Xt[e >> 16 & 15 | 64] + Xt[e >> 24 & 255] + "-" + Xt[t & 63 | 128] + Xt[t >> 8 & 255] + "-" + Xt[t >> 16 & 255] + Xt[t >> 24 & 255] + Xt[r & 255] + Xt[r >> 8 & 255] + Xt[r >> 16 & 255] + Xt[r >> 24 & 255]).toUpperCase();
}
const cr = Object.assign || function() {
  let c = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (c[n] = r[n]);
  }
  return c;
}, B_ = Date.now(), Rp = /* @__PURE__ */ new WeakMap(), Lp = /* @__PURE__ */ new Map();
let k_ = 1e10;
function hu(c, e) {
  const t = W_(e);
  let r = Rp.get(c);
  if (r || Rp.set(c, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const n = `_onBeforeCompile${t}`, s = function(l, u) {
    c.onBeforeCompile.call(this, l, u);
    const h = this.customProgramCacheKey() + "|" + l.vertexShader + "|" + l.fragmentShader;
    let d = Lp[h];
    if (!d) {
      const f = G_(this, l, e, t);
      d = Lp[h] = f;
    }
    l.vertexShader = d.vertexShader, l.fragmentShader = d.fragmentShader, cr(l.uniforms, this.uniforms), e.timeUniform && (l.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - B_;
      }
    }), this[n] && this[n](l);
  }, o = function() {
    return i(e.chained ? c : c.clone());
  }, i = function(l) {
    const u = Object.create(l, a);
    return Object.defineProperty(u, "baseMaterial", { value: c }), Object.defineProperty(u, "id", { value: k_++ }), u.uuid = z_(), u.uniforms = cr({}, l.uniforms, e.uniforms), u.defines = cr({}, l.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = cr({}, l.extensions, e.extensions), u._listeners = void 0, u;
  }, a = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return c.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(l) {
        this[n] = l;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(l) {
        return c.copy.call(this, l), !c.isShaderMaterial && !c.isDerivedMaterial && (cr(this.extensions, l.extensions), cr(this.defines, l.defines), cr(this.uniforms, sr.clone(l.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const l = new c.constructor();
        return i(l).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._depthMaterial;
        return l || (l = this._depthMaterial = hu(
          c.isDerivedMaterial ? c.getDepthMaterial() : new zb({ depthPacking: Bb }),
          e
        ), l.defines.IS_DEPTH_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._distanceMaterial;
        return l || (l = this._distanceMaterial = hu(
          c.isDerivedMaterial ? c.getDistanceMaterial() : new kb(),
          e
        ), l.defines.IS_DISTANCE_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: l, _distanceMaterial: u } = this;
        l && l.dispose(), u && u.dispose(), c.dispose.call(this);
      }
    }
  };
  return r[t] = o, new o();
}
function G_(c, { vertexShader: e, fragmentShader: t }, r, n) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: i,
    vertexTransform: a,
    fragmentDefs: l,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: p
  } = r;
  if (s = s || "", o = o || "", i = i || "", l = l || "", u = u || "", h = h || "", (a || f) && (e = uu(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = uu(t)), f) {
    let m = f({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (d) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (m.push(g), "")
    ), h = `${d}
${m.join(`
`)}
${h}`;
  }
  if (p) {
    const m = `
uniform float ${p};
`;
    s = m + s, l = m + l;
  }
  return a && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, s = `${s}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${a}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, g, b, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, b)) ? g : `troika_${g}_${n}`), c.map && c.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = Op(e, n, s, o, i), t = Op(t, n, l, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function Op(c, e, t, r, n) {
  return (r || n || t) && (c = c.replace(
    cx,
    `
${t}
void troikaOrigMain${e}() {`
  ), c += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${n}
}`), c;
}
function V_(c, e) {
  return c === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let j_ = 0;
const Fp = /* @__PURE__ */ new Map();
function W_(c) {
  const e = JSON.stringify(c, V_);
  let t = Fp.get(e);
  return t == null && Fp.set(e, t = ++j_), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function H_() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var L = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < L; b++) {
            var U = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), U.push({ val1: S, val2: R });
            }
            u.matrix.push(U);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var L = n.kern.rval[_].glyph2.indexOf(o);
          if (L != -1)
            return n.kern.rval[_].vals[L];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var L = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[L + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var U = h.lookupRec;
              for (w = 0; w < U.length; w += 2) {
                y = U[w];
                var S = i[U[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, L = 0, A = 0, U = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, U);
        var S = U.val;
        if (p += U.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", D = 0; D < R; D++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (L = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (L = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), F = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[F], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var W = l.length, q = (se = 0, S == "o31");
            for (se += W - (R = -3 & W); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function X_() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = R += 1 << S[D - 1];
      var P = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var se = E[D]; se < E[D + 1]; ++se)
          P[se] = se - E[D] << 5 | D;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var D = S.length, P = 0, se = new t(R); P < D; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < D; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], F = R - S[P], I = H[S[P] - 1]++ << F, k = I | (1 << F) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(D), P = 0; P < D; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var D = R / 8 | 0;
      return (S[D] | S[D + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var D = new Error(R || T[S]);
      if (D.code = S, Error.captureStackTrace && Error.captureStackTrace(D, _), !E)
        throw D;
      return D;
    }, L = function(S, R, E) {
      var D = S.length;
      if (!D || E && !E.l && D < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * D));
      var oe, H = function(ge) {
        var We = R.length;
        if (ge > We) {
          var $e = new e(Math.max(2 * We, ge));
          $e.set(R), R = $e;
        }
      }, X = E.f || 0, C = E.p || 0, F = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, W = 8 * D;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(fe = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[fe - 3] << 8, ae = fe + ie;
            if (ae > D) {
              se && _(0);
              break;
            }
            P && H(F + ie), R.set(S.subarray(fe, ae), F), E.b = F += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, O = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < O; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * O;
            var pe = x(Y), ne = (1 << pe) - 1, he = m(Y, pe, 1);
            for (ee = 0; ee < te; ) {
              var fe, K = he[N(S, C, ne)];
              if (C += 15 & K, (fe = K >>> 4) < 16)
                Z[ee++] = fe;
              else {
                var Ae = 0, me = 0;
                for (fe == 16 ? (me = 3 + N(S, C, 3), C += 2, Ae = Z[ee - 1]) : fe == 17 ? (me = 3 + N(S, C, 7), C += 3) : fe == 18 && (me = 11 + N(S, C, 127), C += 7); me--; )
                  Z[ee++] = Ae;
              }
            }
            var be = Z.subarray(0, $), de = Z.subarray($);
            z = x(be), Q = x(de), I = m(be, z, 1), k = m(de, Q, 1);
          } else
            _(1);
          if (C > W) {
            se && _(0);
            break;
          }
        }
        P && H(F + 131072);
        for (var qe = (1 << z) - 1, le = (1 << Q) - 1, Ne = C; ; Ne = C) {
          var ve = (Ae = I[w(S, C) & qe]) >>> 4;
          if ((C += 15 & Ae) > W) {
            se && _(0);
            break;
          }
          if (Ae || _(2), ve < 256)
            R[F++] = ve;
          else {
            if (ve == 256) {
              Ne = C, I = null;
              break;
            }
            var Te = ve - 254;
            if (ve > 264) {
              var Pe = n[ee = ve - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var Je = k[w(S, C) & le], _e = Je >>> 4;
            if (Je || _(3), C += 15 & Je, de = h[_e], _e > 3 && (Pe = s[_e], de += w(S, C) & (1 << Pe) - 1, C += Pe), C > W) {
              se && _(0);
              break;
            }
            P && H(F + 131072);
            for (var Ue = F + Te; F < Ue; F += 4)
              R[F] = R[F - de], R[F + 1] = R[F + 1 - de], R[F + 2] = R[F + 2 - de], R[F + 3] = R[F + 3 - de];
            F = Ue;
          }
        }
        E.l = I, E.p = Ne, E.b = F, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return F == R.length ? R : function(ge, We, $e) {
        (We == null || We < 0) && (We = 0), ($e == null || $e > ge.length) && ($e = ge.length);
        var dt = new (ge instanceof t ? t : ge instanceof r ? r : e)($e - We);
        return dt.set(ge.subarray(We, $e)), dt;
      }(R, 0, F);
    }, A = new e(0), U = typeof TextDecoder < "u" && new TextDecoder();
    try {
      U.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function D() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: D(), reserved: D(), totalSfntSize: P(), majorVersion: D(), minorVersion: D(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), F = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, W = new Uint8Array(12 + 16 * k.length + k.reduce(function($, O) {
        return $ + O.origLength + 4;
      }, 0)), q = W.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(F), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var O, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          O = new Uint8Array(te, 2), L(O, Z);
        } else
          Z = new Uint8Array(te);
        W.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), W.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function $_(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((L) => {
          let [A, U] = L.split("+");
          A = parseInt(A, 36), U = U ? parseInt(U, 36) : 0, u.set(_ += A, w[T]);
          for (let S = U; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, L = -1;
    for (let A = 0; A < N.length; A++) {
      const U = N.codePointAt(A);
      let S = h(U) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[L]++) : S & (n | l) && (_ === f || _ === m) && w[L]-- : T & (s | l) && (_ === f || _ === m) && w[L]--, _ = w[A] = R, T = S, L = A, U > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let L = 0; L < w.length; L++) {
      const A = w.codePointAt(L);
      A > 65535 && L++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: L, featureList: A } = _;
      let U;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (R[E.tab[D]])
              continue;
            R[E.tab[D]] = !0;
            const P = L[E.tab[D]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !U && (U = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!U || !se || g[U[oe]] === E.tag) && c.U._applySubs(T, oe, P, L);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, L = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, L), U = {
      unitsPerEm: L,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, D) {
        let P = 0;
        const se = 1 / U.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, F) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", W = 0;
              for (let O = 0, te = k.length; O < te; O++) {
                const Z = t[k[O]];
                Q += k[O];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[W++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let O = 0, te = z.length; O < te; O += 2) {
                  let Z = z[O], Y = z[O + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), D.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return U;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const q_ = /* @__PURE__ */ ms({
  name: "Typr Font Parser",
  dependencies: [H_, X_, $_],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function J_() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var L = x.weight;
      L === void 0 && (L = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), U = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, D = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var F = m.get(C);
        return F || (F = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, F)), F;
      }
      for (var H = function(C) {
        var F = y.codePointAt(C), I = s(F);
        D[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), F > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[D[I]], W = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in W = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== W) {
                  for (var O in Q[$])
                    if (o(k, Q[$][O])) {
                      z = O;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), D[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, F = I);
        }, F = 0; F < y.length; F++)
          C(F);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, F = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (F && (v(k) || f(F).has(k)))
            S[I] = S[I - 1];
          else {
            F = u[D[I]];
            var z = R[F.id];
            if (!z) {
              var Q = F.typeforms, W = g(Q, T, "sans-serif"), q = g(Q[W], _, "normal"), ie = b((C = Q[W]) === null || C === void 0 ? void 0 : C[q], L);
              z = R[F.id] = A + "/font-files/" + F.id + "/" + W + "." + q + "." + ie + ".woff";
            }
            var ae = U.get(z);
            ae == null && (ae = U.size, U.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(U.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function Y_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(L = 0) {
        for (let A = L, U = o.length; A < U; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const D = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                D[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: D, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[D];
                  if (!se) {
                    s(D, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < U && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let U = 0, S = A[1] - A[0]; U <= S; U++)
              f[A[0] + U] = w[_++] + T;
            _++;
          });
          let L = 0;
          N.forEach((A, U) => {
            s(A, (S) => {
              p[U + T] = S, ++L === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const K_ = /* @__PURE__ */ ms({
  name: "FontResolver",
  dependencies: [
    Y_,
    q_,
    J_
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function Z_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let L, A;
      const U = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], U.push(L = { start: S, end: S, fontObj: _[T[S]] })) : L.end = S;
      N(U);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: L = "left",
    textIndent: A = 0,
    whiteSpace: U = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const F = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - F;
      const z = isFinite(T);
      let Q = null, W = null, q = null, ie = null, ae = null, $ = null, O = null, te = null, Z = 0, Y = 0, ee = U !== "nowrap";
      const pe = /* @__PURE__ */ new Map(), ne = h();
      let he = A, fe = 0, K = new d();
      const Ae = [K];
      k.forEach((le) => {
        const { fontObj: Ne } = le, { ascender: ve, descender: Te, unitsPerEm: Pe, lineGap: Je, capHeight: _e, xHeight: Ue } = Ne;
        let ge = pe.get(Ne);
        if (!ge) {
          const xe = v / Pe, Fe = w === "normal" ? (ve - Te + Je) * xe : w * v, Bt = (Fe - (ve - Te) * xe) / 2, Ee = Math.min(Fe, (ve - Te) * xe), Le = (ve + Te) / 2 * xe + Ee / 2;
          ge = {
            index: pe.size,
            src: Ne.src,
            fontObj: Ne,
            fontSizeMult: xe,
            unitsPerEm: Pe,
            ascender: ve * xe,
            descender: Te * xe,
            capHeight: _e * xe,
            xHeight: Ue * xe,
            lineHeight: Fe,
            baseline: -Bt - ve * xe,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ve + Te) / 2 * xe + Ee / 2,
            caretBottom: Le - Ee
          }, pe.set(Ne, ge);
        }
        const { fontSizeMult: We } = ge, $e = p.slice(le.start, le.end + 1);
        let dt, Qe;
        Ne.forEachGlyph($e, v, N, (xe, Fe, Bt) => {
          Fe += fe, Bt += le.start, dt = Fe, Qe = xe;
          const Ee = p.charAt(Bt), Le = xe.advanceWidth * We, tt = K.count;
          let De;
          if ("isEmpty" in xe || (xe.isWhitespace = !!Ee && new RegExp(n).test(Ee), xe.canBreakAfter = !!Ee && s.test(Ee), xe.isEmpty = xe.xMin === xe.xMax || xe.yMin === xe.yMax || r.test(Ee)), !xe.isWhitespace && !xe.isEmpty && Y++, ee && z && !xe.isWhitespace && Fe + Le + he > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              De = new d(), he = -Fe;
            else
              for (let He = tt; He--; )
                if (He === 0 && S === "break-word") {
                  De = new d(), he = -Fe;
                  break;
                } else if (K.glyphAt(He).glyphObj.canBreakAfter) {
                  De = K.splitAt(He + 1);
                  const vt = De.glyphAt(0).x;
                  he -= vt;
                  for (let at = De.count; at--; )
                    De.glyphAt(at).x -= vt;
                  break;
                }
            De && (K.isSoftWrapped = !0, K = De, Ae.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = xe, we.x = Fe + he, we.width = Le, we.charIndex = Bt, we.fontData = ge, Ee === `
` && (K = new d(), Ae.push(K), he = -(Fe + Le + N * v) + A);
        }), fe = dt + Qe.advanceWidth * We + N * v;
      });
      let me = 0;
      Ae.forEach((le) => {
        let Ne = !0;
        for (let ve = le.count; ve--; ) {
          const Te = le.glyphAt(ve);
          Ne && !Te.glyphObj.isWhitespace && (le.width = Te.x + Te.width, le.width > Z && (Z = le.width), Ne = !1);
          let { lineHeight: Pe, capHeight: Je, xHeight: _e, baseline: Ue } = Te.fontData;
          Pe > le.lineHeight && (le.lineHeight = Pe);
          const ge = Ue - le.baseline;
          ge < 0 && (le.baseline += ge, le.cap += ge, le.ex += ge), le.cap = Math.max(le.cap, le.baseline + Je), le.ex = Math.max(le.ex, le.baseline + _e);
        }
        le.baseline -= me, le.cap -= me, le.ex -= me, me += le.lineHeight;
      });
      let be = 0, de = 0;
      if (R && (typeof R == "number" ? be = -R : typeof R == "string" && (be = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? de = -E : typeof E == "string" && (de = E === "top" ? 0 : E === "top-baseline" ? -Ae[0].baseline : E === "top-cap" ? -Ae[0].cap : E === "top-ex" ? -Ae[0].ex : E === "middle" ? me / 2 : E === "bottom" ? me : E === "bottom-baseline" ? Ae[Ae.length - 1].baseline : l(E) * me)), !D) {
        const le = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), W = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, O = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let Ne = 0, ve = -1, Te = -1, Pe, Je;
        if (Ae.forEach((_e, Ue) => {
          let { count: ge, width: We } = _e;
          if (ge > 0) {
            let $e = 0;
            for (let Ee = ge; Ee-- && _e.glyphAt(Ee).glyphObj.isWhitespace; )
              $e++;
            let dt = 0, Qe = 0;
            if (L === "center")
              dt = (Z - We) / 2;
            else if (L === "right")
              dt = Z - We;
            else if (L === "justify" && _e.isSoftWrapped) {
              let Ee = 0;
              for (let Le = ge - $e; Le--; )
                _e.glyphAt(Le).glyphObj.isWhitespace && Ee++;
              Qe = (Z - We) / Ee;
            }
            if (Qe || dt) {
              let Ee = 0;
              for (let Le = 0; Le < ge; Le++) {
                let tt = _e.glyphAt(Le);
                const De = tt.glyphObj;
                tt.x += dt + Ee, Qe !== 0 && De.isWhitespace && Le < ge - $e && (Ee += Qe, tt.width += Qe);
              }
            }
            const xe = e.getReorderSegments(
              p,
              le,
              _e.glyphAt(0).charIndex,
              _e.glyphAt(_e.count - 1).charIndex
            );
            for (let Ee = 0; Ee < xe.length; Ee++) {
              const [Le, tt] = xe[Ee];
              let De = 1 / 0, we = -1 / 0;
              for (let He = 0; He < ge; He++)
                if (_e.glyphAt(He).charIndex >= Le) {
                  let vt = He, at = He;
                  for (; at < ge; at++) {
                    let ot = _e.glyphAt(at);
                    if (ot.charIndex > tt)
                      break;
                    at < ge - $e && (De = Math.min(De, ot.x), we = Math.max(we, ot.x + ot.width));
                  }
                  for (let ot = vt; ot < at; ot++) {
                    const It = _e.glyphAt(ot);
                    It.x = we - (It.x + It.width - De);
                  }
                  break;
                }
            }
            let Fe;
            const Bt = (Ee) => Fe = Ee;
            for (let Ee = 0; Ee < ge; Ee++) {
              const Le = _e.glyphAt(Ee);
              Fe = Le.glyphObj;
              const tt = Fe.index, De = le.levels[Le.charIndex] & 1;
              if (De) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, Bt);
              }
              if (oe) {
                const { charIndex: we, fontData: He } = Le, vt = Le.x + be, at = Le.x + Le.width + be;
                $[we * 4] = De ? at : vt, $[we * 4 + 1] = De ? vt : at, $[we * 4 + 2] = _e.baseline + He.caretBottom + de, $[we * 4 + 3] = _e.baseline + He.caretTop + de;
                const ot = we - ve;
                ot > 1 && u($, ve, ot), ve = we;
              }
              if (X) {
                const { charIndex: we } = Le;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (Je = X[Te]);
              }
              if (!Fe.isWhitespace && !Fe.isEmpty) {
                const we = Ne++, { fontSizeMult: He, src: vt, index: at } = Le.fontData, ot = ie[vt] || (ie[vt] = {});
                ot[tt] || (ot[tt] = {
                  path: Fe.path,
                  pathBounds: [Fe.xMin, Fe.yMin, Fe.xMax, Fe.yMax]
                });
                const It = Le.x + be, Fn = _e.baseline + de;
                q[we * 2] = It, q[we * 2 + 1] = Fn;
                const un = It + Fe.xMin * He, wn = Fn + Fe.yMin * He, In = It + Fe.xMax * He, hn = Fn + Fe.yMax * He;
                un < O[0] && (O[0] = un), wn < O[1] && (O[1] = wn), In > O[2] && (O[2] = In), hn > O[3] && (O[3] = hn), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const xt = Pe.rect;
                if (un < xt[0] && (xt[0] = un), wn < xt[1] && (xt[1] = wn), In > xt[2] && (xt[2] = In), hn > xt[3] && (xt[3] = hn), Q[we] = tt, W[we] = at, X) {
                  const Wn = we * 3;
                  ae[Wn] = Je >> 16 & 255, ae[Wn + 1] = Je >> 8 & 255, ae[Wn + 2] = Je & 255;
                }
              }
            }
          }
        }), $) {
          const _e = p.length - ve;
          _e > 1 && u($, ve, _e);
        }
      }
      const qe = [];
      pe.forEach(({ index: le, src: Ne, unitsPerEm: ve, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue }) => {
        qe[le] = { src: Ne, unitsPerEm: ve, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: W,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: qe,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: de + Ae[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          be,
          de - me,
          be + Z,
          de
        ],
        visibleBounds: O,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const Tr = () => (self.performance || Date).now(), Ec = /* @__PURE__ */ ix();
let Ip;
function Q_(c, e, t, r, n, s, o, i, a, l, u = !0) {
  return u ? tM(c, e, t, r, n, s, o, i, a, l).then(
    null,
    (h) => (Ip || (console.warn("WebGL SDF generation failed, falling back to JS", h), Ip = !0), Dp(c, e, t, r, n, s, o, i, a, l))
  ) : Dp(c, e, t, r, n, s, o, i, a, l);
}
const Ca = [], eM = 5;
let du = 0;
function lx() {
  const c = Tr();
  for (; Ca.length && Tr() - c < eM; )
    Ca.shift()();
  du = Ca.length ? setTimeout(lx, 0) : 0;
}
const tM = (...c) => new Promise((e, t) => {
  Ca.push(() => {
    const r = Tr();
    try {
      Ec.webgl.generateIntoCanvas(...c), e({ timing: Tr() - r });
    } catch (n) {
      t(n);
    }
  }), du || (du = setTimeout(lx, 0));
}), nM = 4, sM = 2e3, Pp = {};
let rM = 0;
function Dp(c, e, t, r, n, s, o, i, a, l) {
  const u = "TroikaTextSDFGenerator_JS_" + rM++ % nM;
  let h = Pp[u];
  return h || (h = Pp[u] = {
    workerModule: ms({
      name: u,
      workerId: u,
      dependencies: [
        ix,
        Tr
      ],
      init(d, f) {
        const p = d().javascript.generate;
        return function(...m) {
          const g = f();
          return {
            textureData: p(...m),
            timing: f() - g
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(c, e, t, r, n, s).then(({ textureData: d, timing: f }) => {
    const p = Tr(), m = new Uint8Array(d.length * 4);
    for (let g = 0; g < d.length; g++)
      m[g * 4 + l] = d[g];
    return Ec.webglUtils.renderImageData(o, m, i, a, c, e, 1 << 3 - l), f += Tr() - p, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      D_(u);
    }, sM)), { timing: f };
  });
}
function oM(c) {
  c._warm || (Ec.webgl.isSupported(c), c._warm = !0);
}
const iM = Ec.webglUtils.resizeWebGLCanvasWithoutClearing, Kr = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, aM = /* @__PURE__ */ new je();
function Br() {
  return (self.performance || Date).now();
}
const Up = /* @__PURE__ */ Object.create(null);
function cM(c, e) {
  c = uM({}, c);
  const t = Br(), { defaultFontURL: r } = Kr, n = [];
  if (r && n.push({ label: "default", src: zp(r) }), c.font && n.push({ label: "user", src: zp(c.font) }), c.font = n, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || Kr.sdfGlyphSize, c.unicodeFontsURL = c.unicodeFontsURL || Kr.unicodeFontsURL, c.colorRanges != null) {
    let d = {};
    for (let f in c.colorRanges)
      if (c.colorRanges.hasOwnProperty(f)) {
        let p = c.colorRanges[f];
        typeof p != "number" && (p = aM.set(p).getHex()), d[f] = p;
      }
    c.colorRanges = d;
  }
  Object.freeze(c);
  const { textureWidth: s, sdfExponent: o } = Kr, { sdfGlyphSize: i } = c, a = s / i * 4;
  let l = Up[i];
  if (!l) {
    const d = document.createElement("canvas");
    d.width = s, d.height = i * 256 / a, l = Up[i] = {
      glyphCount: 0,
      sdfGlyphSize: i,
      sdfCanvas: d,
      sdfTexture: new Vn(
        d,
        void 0,
        void 0,
        void 0,
        po,
        po
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, lM(l);
  }
  const { sdfTexture: u, sdfCanvas: h } = l;
  dM(c).then((d) => {
    const { glyphIds: f, glyphFontIndices: p, fontData: m, glyphPositions: g, fontSize: b, timings: v } = d, y = [], x = new Float32Array(f.length * 4);
    let N = 0, w = 0;
    const T = Br(), _ = m.map((R) => {
      let E = l.glyphsByFont.get(R.src);
      return E || l.glyphsByFont.set(R.src, E = /* @__PURE__ */ new Map()), E;
    });
    f.forEach((R, E) => {
      const D = p[E], { src: P, unitsPerEm: se } = m[D];
      let oe = _[D].get(R);
      if (!oe) {
        const { path: I, pathBounds: k } = d.glyphData[P][R], z = Math.max(k[2] - k[0], k[3] - k[1]) / i * (Kr.sdfMargin * i + 0.5), Q = l.glyphCount++, W = [
          k[0] - z,
          k[1] - z,
          k[2] + z,
          k[3] + z
        ];
        _[D].set(R, oe = { path: I, atlasIndex: Q, sdfViewBox: W }), y.push(oe);
      }
      const { sdfViewBox: H } = oe, X = g[w++], C = g[w++], F = b / se;
      x[N++] = X + H[0] * F, x[N++] = C + H[1] * F, x[N++] = X + H[2] * F, x[N++] = C + H[3] * F, f[E] = oe.atlasIndex;
    }), v.quads = (v.quads || 0) + (Br() - T);
    const L = Br();
    v.sdf = {};
    const A = h.height, U = Math.ceil(l.glyphCount / a), S = Math.pow(2, Math.ceil(Math.log2(U * i)));
    S > A && (console.info(`Increasing SDF texture size ${A}->${S}`), iM(h, s, S), u.dispose()), Promise.all(y.map(
      (R) => ux(R, l, c.gpuAccelerateSDF).then(({ timing: E }) => {
        v.sdf[R.atlasIndex] = E;
      })
    )).then(() => {
      y.length && !l.contextLost && (hx(l), u.needsUpdate = !0), v.sdfTotal = Br() - L, v.total = Br() - t, e(Object.freeze({
        parameters: c,
        sdfTexture: u,
        sdfGlyphSize: i,
        sdfExponent: o,
        glyphBounds: x,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || oM(h);
  });
}
function ux({ path: c, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: n, contextLost: s }, o) {
  if (s)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: i, sdfExponent: a } = Kr, l = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (i / r) * r, d = Math.floor(u / (i / r)) * r, f = e % 4;
  return Q_(r, r, c, t, l, a, n, h, d, f, o);
}
function lM(c) {
  const e = c.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), c.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), c.contextLost = !1;
    const r = [];
    c.glyphsByFont.forEach((n) => {
      n.forEach((s) => {
        r.push(ux(s, c, !0));
      });
    }), Promise.all(r).then(() => {
      hx(c), c.sdfTexture.needsUpdate = !0;
    });
  });
}
function uM(c, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (c[t] = e[t]);
  return c;
}
let Qi;
function zp(c) {
  return Qi || (Qi = typeof document > "u" ? {} : document.createElement("a")), Qi.href = c, Qi.href;
}
function hx(c) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = c, { width: r, height: n } = e, s = c.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== r * n * 4) && (o = new Uint8Array(r * n * 4), t.image = { width: r, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, r, n, s.RGBA, s.UNSIGNED_BYTE, o);
  }
}
const hM = /* @__PURE__ */ ms({
  name: "Typesetter",
  dependencies: [
    Z_,
    K_,
    ax
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), dM = /* @__PURE__ */ ms({
  name: "Typesetter",
  dependencies: [
    hM
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (let t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), Bp = {};
function fM(c) {
  let e = Bp[c];
  if (!e) {
    const t = new Er(1, 1, c, c), r = t.clone(), n = t.attributes, s = r.attributes, o = new Kn(), i = n.uv.count;
    for (let a = 0; a < i; a++)
      s.position.array[a * 3] *= -1, s.normal.array[a * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((a) => {
      o.setAttribute(
        a,
        new yn(
          [...n[a].array, ...s[a].array],
          n[a].itemSize
        )
      );
    }), o.setIndex([...t.index.array, ...r.index.array.map((a) => a + i)]), o.translate(0.5, 0.5, 0), e = Bp[c] = o;
  }
  return e;
}
const pM = "aTroikaGlyphBounds", kp = "aTroikaGlyphIndex", mM = "aTroikaGlyphColor";
class dx extends km {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Ti(), this.boundingBox = new nr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Su ? t / 2 : 0, e === Eu ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = fM(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, r, n, s) {
    gl(this, pM, e, 4), gl(this, kp, t, 1), gl(this, mM, s, 3), this._blockBounds = r, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: n, floor: s, min: o, max: i, sin: a, cos: l } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, p = e[2] / d, m = s((f + u) / h) !== s((p + u) / h) ? -d : o(a(f) * d, a(p) * d), g = s((f - u) / h) !== s((p - u) / h) ? d : i(a(f) * d, a(p) * d), b = s((f + n) / h) !== s((p + n) / h) ? d * 2 : i(d - l(f) * d, d - l(p) * d);
        r.min.set(m, e[1], t < 0 ? -b : 0), r.max.set(g, e[3], t < 0 ? 0 : b);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(kp).count, r = this._chunkedBounds;
    if (r)
      for (let n = r.length; n--; ) {
        t = r[n].end;
        let s = r[n].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function gl(c, e, t, r) {
  const n = c.getAttribute(e);
  t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (c.setAttribute(e, new Wm(t, r)), delete c._maxInstanceCount, c.dispose()) : n && c.deleteAttribute(e);
}
const gM = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, yM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, vM = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, xM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function bM(c) {
  const e = hu(c, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Tt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new mt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new mt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Tt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new je() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Ts() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: gM,
    vertexTransform: yM,
    fragmentDefs: vM,
    fragmentColorTransform: xM,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(r) && (r = r.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        cx,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const nf = /* @__PURE__ */ new Cn({
  color: 16777215,
  side: Eu,
  transparent: !0
}), Gp = 8421504, Vp = /* @__PURE__ */ new Ge(), ea = /* @__PURE__ */ new ye(), yl = /* @__PURE__ */ new ye(), zo = [], NM = /* @__PURE__ */ new ye(), vl = "+x+y";
function jp(c) {
  return Array.isArray(c) ? c[0] : c;
}
let fx = () => {
  const c = new Jt(
    new Er(1, 1),
    nf
  );
  return fx = () => c, c;
}, px = () => {
  const c = new Jt(
    new Er(1, 1, 32, 1),
    nf
  );
  return px = () => c, c;
};
const wM = { type: "syncstart" }, TM = { type: "synccomplete" }, mx = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], SM = mx.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class gx extends Jt {
  constructor() {
    const e = new dx();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Gp, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = vl, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(wM), cM({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((n) => n && n());
      })), this.dispatchEvent(TM), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, r, n, s, o) {
    this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s), s._hadOwnSide = s.hasOwnProperty("side"), this.geometry.setSide(s._actualSide = s.side), s.side = Hm;
  }
  onAfterRender(e, t, r, n, s, o) {
    s._hadOwnSide ? s.side = s._actualSide : delete s.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = nf.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = bM(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return jp(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return jp(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: i, blockBounds: a } = n;
      r.uTroikaSDFTexture.value = i, r.uTroikaSDFTextureSize.value.set(i.image.width, i.image.height), r.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, r.uTroikaSDFExponent.value = n.sdfExponent, r.uTroikaTotalBounds.value.fromArray(a), r.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let l = 0, u = 0, h = 0, d, f, p, m = 0, g = 0;
      if (t) {
        let { outlineWidth: v, outlineOffsetX: y, outlineOffsetY: x, outlineBlur: N, outlineOpacity: w } = this;
        l = this._parsePercent(v) || 0, u = Math.max(0, this._parsePercent(N) || 0), d = w, m = this._parsePercent(y) || 0, g = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (p = this.strokeColor, r.uTroikaStrokeColor.value.set(p ?? Gp), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      r.uTroikaDistanceOffset.value = l, r.uTroikaPositionOffset.value.set(m, g), r.uTroikaBlurRadius.value = u, r.uTroikaStrokeWidth.value = h, r.uTroikaStrokeOpacity.value = f, r.uTroikaFillOpacity.value = d ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let b = this.clipRect;
      if (b && Array.isArray(b) && b.length === 4)
        r.uTroikaClipRect.value.fromArray(b);
      else {
        const v = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          a[0] - v,
          a[1] - v,
          a[2] + v,
          a[3] + v
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null)
      delete e.color;
    else {
      const i = e.hasOwnProperty("color") ? e.color : e.color = new je();
      (s !== i._input || typeof s == "object") && i.set(i._input = s);
    }
    let o = this.orientation || vl;
    if (o !== e._orientation) {
      let i = r.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let a = o !== vl && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (a) {
        let [, l, u, h, d] = a;
        ea.set(0, 0, 0)[u] = l === "-" ? 1 : -1, yl.set(0, 0, 0)[d] = h === "-" ? -1 : 1, Vp.lookAt(NM, ea.cross(yl), yl), i.setFromMatrix4(Vp);
      } else
        i.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Tt()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Tt()) {
    return ea.copy(e), this.localPositionToTextCoords(this.worldToLocal(ea), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: n } = this;
    if (r) {
      const s = r.blockBounds, o = n ? px() : fx(), i = o.geometry, { position: a, uv: l } = i.attributes;
      for (let u = 0; u < l.count; u++) {
        let h = s[0] + l.getX(u) * (s[2] - s[0]);
        const d = s[1] + l.getY(u) * (s[3] - s[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), a.setXYZ(u, h, d, f);
      }
      i.boundingSphere = this.geometry.boundingSphere, i.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, zo.length = 0, o.raycast(e, zo);
      for (let u = 0; u < zo.length; u++)
        zo[u].object = this, t.push(zo[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, SM.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
mx.forEach((c) => {
  const e = "_private_" + c;
  Object.defineProperty(gx.prototype, c, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const gi = {
  text: "String",
  anchorX: 'number|"left"|"center"|"right"',
  anchorY: 'number|"top"|"top-baseline"|"top-cap"|"top-ex"|"middle"|"bottom-baseline"|"bottom"',
  curveRadius: "number",
  direction: '"auto"|"ltr"|"rtl"',
  font: "string",
  fontSize: "number",
  fontWeight: 'number|"normal" | "bold"',
  fontStyle: '"normal"|"italic"',
  letterSpacing: "number",
  lineHeight: 'number|"normal"',
  maxWidth: "number",
  overflowWrap: '"normal" | "break-word"',
  textAlign: '"left" | "right" | "center" | "justify"',
  textIndent: "number",
  whiteSpace: '"normal"| "nowrap"',
  color: "Color",
  outlineWidth: "number",
  outlineColor: "Color",
  outlineOpacity: "number",
  outlineBlur: "number",
  outlineOffsetX: "number",
  outlineOffsetY: "number",
  strokeWidth: "number",
  strokeColor: "Color",
  strokeOpacity: "number",
  fillOpacity: "number",
  depthOffset: "number",
  clipRect: "number[]",
  orientation: "string",
  glyphGeometryDetail: "number",
  sdfGlyphSize: "number|null",
  gpuAccelerateSDF: "boolean"
};
class sf extends gx {
  constructor() {
    super();
    G(this, "isTextMesh", !0);
    this.type = "TextMesh", this.text = "text", this.font = "/assets/fonts/STFangsong.ttf", this.color = new je(), this.outlineColor = new je(), this.strokeColor = new je();
  }
  serialize(t) {
    for (const [r, n] of Object.entries(gi))
      if (n === "Color") {
        const s = this[r];
        t[r] = (s instanceof je ? s : new je(s)).toArray();
      } else
        t[r] = this[r];
    t.geo = {
      detail: this.geometry.detail,
      curveRadius: this.geometry.curveRadius,
      groups: this.geometry.groups,
      boundingSphere: { center: this.geometry.boundingSphere.center.toArray(), radius: this.geometry.boundingSphere.radius },
      boundingBox: { min: this.geometry.boundingBox.min.toArray(), max: this.geometry.boundingBox.max.toArray() }
    };
  }
  deserialize(t) {
    const r = new dx();
    r.copy(this.geometry), this.geometry = r, t.geo && (r.detail = t.geo.detail, r.curveRadius = t.geo.curveRadius, r.groups = t.geo.groups, r.boundingSphere.set(new ye().fromArray(t.geo.boundingSphere.center), t.geo.boundingSphere.radius), r.boundingBox = new nr(new ye().fromArray(t.geo.boundingBox.min), new ye().fromArray(t.geo.boundingBox.max)));
    for (const [n, s] of Object.entries(gi)) {
      const o = t[n];
      o !== void 0 && (s === "Color" ? this[n] = new je().fromArray(o) : this[n] = o);
    }
    this.sync();
  }
}
Ye("TextMesh", {
  // cls: TextMesh,
  create: () => new sf(),
  members: gi,
  proto: "Mesh",
  group: "Text.Text",
  icon: "text"
});
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function _M() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var L = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < L; b++) {
            var U = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), U.push({ val1: S, val2: R });
            }
            u.matrix.push(U);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var L = n.kern.rval[_].glyph2.indexOf(o);
          if (L != -1)
            return n.kern.rval[_].vals[L];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var L = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[L + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var U = h.lookupRec;
              for (w = 0; w < U.length; w += 2) {
                y = U[w];
                var S = i[U[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, L = 0, A = 0, U = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, U);
        var S = U.val;
        if (p += U.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", D = 0; D < R; D++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (L = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (L = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), F = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[F], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var W = l.length, q = (se = 0, S == "o31");
            for (se += W - (R = -3 & W); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function MM() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = R += 1 << S[D - 1];
      var P = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var se = E[D]; se < E[D + 1]; ++se)
          P[se] = se - E[D] << 5 | D;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var D = S.length, P = 0, se = new t(R); P < D; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < D; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], F = R - S[P], I = H[S[P] - 1]++ << F, k = I | (1 << F) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(D), P = 0; P < D; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var D = R / 8 | 0;
      return (S[D] | S[D + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var D = new Error(R || T[S]);
      if (D.code = S, Error.captureStackTrace && Error.captureStackTrace(D, _), !E)
        throw D;
      return D;
    }, L = function(S, R, E) {
      var D = S.length;
      if (!D || E && !E.l && D < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * D));
      var oe, H = function(ge) {
        var We = R.length;
        if (ge > We) {
          var $e = new e(Math.max(2 * We, ge));
          $e.set(R), R = $e;
        }
      }, X = E.f || 0, C = E.p || 0, F = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, W = 8 * D;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(fe = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[fe - 3] << 8, ae = fe + ie;
            if (ae > D) {
              se && _(0);
              break;
            }
            P && H(F + ie), R.set(S.subarray(fe, ae), F), E.b = F += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, O = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < O; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * O;
            var pe = x(Y), ne = (1 << pe) - 1, he = m(Y, pe, 1);
            for (ee = 0; ee < te; ) {
              var fe, K = he[N(S, C, ne)];
              if (C += 15 & K, (fe = K >>> 4) < 16)
                Z[ee++] = fe;
              else {
                var Ae = 0, me = 0;
                for (fe == 16 ? (me = 3 + N(S, C, 3), C += 2, Ae = Z[ee - 1]) : fe == 17 ? (me = 3 + N(S, C, 7), C += 3) : fe == 18 && (me = 11 + N(S, C, 127), C += 7); me--; )
                  Z[ee++] = Ae;
              }
            }
            var be = Z.subarray(0, $), de = Z.subarray($);
            z = x(be), Q = x(de), I = m(be, z, 1), k = m(de, Q, 1);
          } else
            _(1);
          if (C > W) {
            se && _(0);
            break;
          }
        }
        P && H(F + 131072);
        for (var qe = (1 << z) - 1, le = (1 << Q) - 1, Ne = C; ; Ne = C) {
          var ve = (Ae = I[w(S, C) & qe]) >>> 4;
          if ((C += 15 & Ae) > W) {
            se && _(0);
            break;
          }
          if (Ae || _(2), ve < 256)
            R[F++] = ve;
          else {
            if (ve == 256) {
              Ne = C, I = null;
              break;
            }
            var Te = ve - 254;
            if (ve > 264) {
              var Pe = n[ee = ve - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var Je = k[w(S, C) & le], _e = Je >>> 4;
            if (Je || _(3), C += 15 & Je, de = h[_e], _e > 3 && (Pe = s[_e], de += w(S, C) & (1 << Pe) - 1, C += Pe), C > W) {
              se && _(0);
              break;
            }
            P && H(F + 131072);
            for (var Ue = F + Te; F < Ue; F += 4)
              R[F] = R[F - de], R[F + 1] = R[F + 1 - de], R[F + 2] = R[F + 2 - de], R[F + 3] = R[F + 3 - de];
            F = Ue;
          }
        }
        E.l = I, E.p = Ne, E.b = F, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return F == R.length ? R : function(ge, We, $e) {
        (We == null || We < 0) && (We = 0), ($e == null || $e > ge.length) && ($e = ge.length);
        var dt = new (ge instanceof t ? t : ge instanceof r ? r : e)($e - We);
        return dt.set(ge.subarray(We, $e)), dt;
      }(R, 0, F);
    }, A = new e(0), U = typeof TextDecoder < "u" && new TextDecoder();
    try {
      U.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function D() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: D(), reserved: D(), totalSfntSize: P(), majorVersion: D(), minorVersion: D(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), F = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, W = new Uint8Array(12 + 16 * k.length + k.reduce(function($, O) {
        return $ + O.origLength + 4;
      }, 0)), q = W.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(F), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var O, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          O = new Uint8Array(te, 2), L(O, Z);
        } else
          Z = new Uint8Array(te);
        W.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), W.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function AM(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((L) => {
          let [A, U] = L.split("+");
          A = parseInt(A, 36), U = U ? parseInt(U, 36) : 0, u.set(_ += A, w[T]);
          for (let S = U; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, L = -1;
    for (let A = 0; A < N.length; A++) {
      const U = N.codePointAt(A);
      let S = h(U) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[L]++) : S & (n | l) && (_ === f || _ === m) && w[L]-- : T & (s | l) && (_ === f || _ === m) && w[L]--, _ = w[A] = R, T = S, L = A, U > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let L = 0; L < w.length; L++) {
      const A = w.codePointAt(L);
      A > 65535 && L++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: L, featureList: A } = _;
      let U;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (R[E.tab[D]])
              continue;
            R[E.tab[D]] = !0;
            const P = L[E.tab[D]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !U && (U = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!U || !se || g[U[oe]] === E.tag) && c.U._applySubs(T, oe, P, L);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, L = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, L), U = {
      unitsPerEm: L,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, D) {
        let P = 0;
        const se = 1 / U.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, F) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", W = 0;
              for (let O = 0, te = k.length; O < te; O++) {
                const Z = t[k[O]];
                Q += k[O];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[W++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let O = 0, te = z.length; O < te; O += 2) {
                  let Z = z[O], Y = z[O + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), D.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return U;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const CM = /* @__PURE__ */ ms({
  name: "Typr Font Parser",
  dependencies: [_M, MM, AM],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
}), EM = CM;
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function RM() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var L = x.weight;
      L === void 0 && (L = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), U = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, D = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var F = m.get(C);
        return F || (F = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, F)), F;
      }
      for (var H = function(C) {
        var F = y.codePointAt(C), I = s(F);
        D[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), F > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[D[I]], W = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in W = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== W) {
                  for (var O in Q[$])
                    if (o(k, Q[$][O])) {
                      z = O;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), D[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, F = I);
        }, F = 0; F < y.length; F++)
          C(F);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, F = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (F && (v(k) || f(F).has(k)))
            S[I] = S[I - 1];
          else {
            F = u[D[I]];
            var z = R[F.id];
            if (!z) {
              var Q = F.typeforms, W = g(Q, T, "sans-serif"), q = g(Q[W], _, "normal"), ie = b((C = Q[W]) === null || C === void 0 ? void 0 : C[q], L);
              z = R[F.id] = A + "/font-files/" + F.id + "/" + W + "." + q + "." + ie + ".woff";
            }
            var ae = U.get(z);
            ae == null && (ae = U.size, U.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(U.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function LM(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(L = 0) {
        for (let A = L, U = o.length; A < U; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const D = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                D[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: D, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[D];
                  if (!se) {
                    s(D, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < U && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let U = 0, S = A[1] - A[0]; U <= S; U++)
              f[A[0] + U] = w[_++] + T;
            _++;
          });
          let L = 0;
          N.forEach((A, U) => {
            s(A, (S) => {
              p[U + T] = S, ++L === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const OM = /* @__PURE__ */ ms({
  name: "FontResolver",
  dependencies: [
    LM,
    EM,
    RM
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function FM(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let L, A;
      const U = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], U.push(L = { start: S, end: S, fontObj: _[T[S]] })) : L.end = S;
      N(U);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: L = "left",
    textIndent: A = 0,
    whiteSpace: U = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const F = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - F;
      const z = isFinite(T);
      let Q = null, W = null, q = null, ie = null, ae = null, $ = null, O = null, te = null, Z = 0, Y = 0, ee = U !== "nowrap";
      const pe = /* @__PURE__ */ new Map(), ne = h();
      let he = A, fe = 0, K = new d();
      const Ae = [K];
      k.forEach((le) => {
        const { fontObj: Ne } = le, { ascender: ve, descender: Te, unitsPerEm: Pe, lineGap: Je, capHeight: _e, xHeight: Ue } = Ne;
        let ge = pe.get(Ne);
        if (!ge) {
          const xe = v / Pe, Fe = w === "normal" ? (ve - Te + Je) * xe : w * v, Bt = (Fe - (ve - Te) * xe) / 2, Ee = Math.min(Fe, (ve - Te) * xe), Le = (ve + Te) / 2 * xe + Ee / 2;
          ge = {
            index: pe.size,
            src: Ne.src,
            fontObj: Ne,
            fontSizeMult: xe,
            unitsPerEm: Pe,
            ascender: ve * xe,
            descender: Te * xe,
            capHeight: _e * xe,
            xHeight: Ue * xe,
            lineHeight: Fe,
            baseline: -Bt - ve * xe,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ve + Te) / 2 * xe + Ee / 2,
            caretBottom: Le - Ee
          }, pe.set(Ne, ge);
        }
        const { fontSizeMult: We } = ge, $e = p.slice(le.start, le.end + 1);
        let dt, Qe;
        Ne.forEachGlyph($e, v, N, (xe, Fe, Bt) => {
          Fe += fe, Bt += le.start, dt = Fe, Qe = xe;
          const Ee = p.charAt(Bt), Le = xe.advanceWidth * We, tt = K.count;
          let De;
          if ("isEmpty" in xe || (xe.isWhitespace = !!Ee && new RegExp(n).test(Ee), xe.canBreakAfter = !!Ee && s.test(Ee), xe.isEmpty = xe.xMin === xe.xMax || xe.yMin === xe.yMax || r.test(Ee)), !xe.isWhitespace && !xe.isEmpty && Y++, ee && z && !xe.isWhitespace && Fe + Le + he > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              De = new d(), he = -Fe;
            else
              for (let He = tt; He--; )
                if (He === 0 && S === "break-word") {
                  De = new d(), he = -Fe;
                  break;
                } else if (K.glyphAt(He).glyphObj.canBreakAfter) {
                  De = K.splitAt(He + 1);
                  const vt = De.glyphAt(0).x;
                  he -= vt;
                  for (let at = De.count; at--; )
                    De.glyphAt(at).x -= vt;
                  break;
                }
            De && (K.isSoftWrapped = !0, K = De, Ae.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = xe, we.x = Fe + he, we.width = Le, we.charIndex = Bt, we.fontData = ge, Ee === `
` && (K = new d(), Ae.push(K), he = -(Fe + Le + N * v) + A);
        }), fe = dt + Qe.advanceWidth * We + N * v;
      });
      let me = 0;
      Ae.forEach((le) => {
        let Ne = !0;
        for (let ve = le.count; ve--; ) {
          const Te = le.glyphAt(ve);
          Ne && !Te.glyphObj.isWhitespace && (le.width = Te.x + Te.width, le.width > Z && (Z = le.width), Ne = !1);
          let { lineHeight: Pe, capHeight: Je, xHeight: _e, baseline: Ue } = Te.fontData;
          Pe > le.lineHeight && (le.lineHeight = Pe);
          const ge = Ue - le.baseline;
          ge < 0 && (le.baseline += ge, le.cap += ge, le.ex += ge), le.cap = Math.max(le.cap, le.baseline + Je), le.ex = Math.max(le.ex, le.baseline + _e);
        }
        le.baseline -= me, le.cap -= me, le.ex -= me, me += le.lineHeight;
      });
      let be = 0, de = 0;
      if (R && (typeof R == "number" ? be = -R : typeof R == "string" && (be = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? de = -E : typeof E == "string" && (de = E === "top" ? 0 : E === "top-baseline" ? -Ae[0].baseline : E === "top-cap" ? -Ae[0].cap : E === "top-ex" ? -Ae[0].ex : E === "middle" ? me / 2 : E === "bottom" ? me : E === "bottom-baseline" ? Ae[Ae.length - 1].baseline : l(E) * me)), !D) {
        const le = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), W = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, O = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let Ne = 0, ve = -1, Te = -1, Pe, Je;
        if (Ae.forEach((_e, Ue) => {
          let { count: ge, width: We } = _e;
          if (ge > 0) {
            let $e = 0;
            for (let Ee = ge; Ee-- && _e.glyphAt(Ee).glyphObj.isWhitespace; )
              $e++;
            let dt = 0, Qe = 0;
            if (L === "center")
              dt = (Z - We) / 2;
            else if (L === "right")
              dt = Z - We;
            else if (L === "justify" && _e.isSoftWrapped) {
              let Ee = 0;
              for (let Le = ge - $e; Le--; )
                _e.glyphAt(Le).glyphObj.isWhitespace && Ee++;
              Qe = (Z - We) / Ee;
            }
            if (Qe || dt) {
              let Ee = 0;
              for (let Le = 0; Le < ge; Le++) {
                let tt = _e.glyphAt(Le);
                const De = tt.glyphObj;
                tt.x += dt + Ee, Qe !== 0 && De.isWhitespace && Le < ge - $e && (Ee += Qe, tt.width += Qe);
              }
            }
            const xe = e.getReorderSegments(
              p,
              le,
              _e.glyphAt(0).charIndex,
              _e.glyphAt(_e.count - 1).charIndex
            );
            for (let Ee = 0; Ee < xe.length; Ee++) {
              const [Le, tt] = xe[Ee];
              let De = 1 / 0, we = -1 / 0;
              for (let He = 0; He < ge; He++)
                if (_e.glyphAt(He).charIndex >= Le) {
                  let vt = He, at = He;
                  for (; at < ge; at++) {
                    let ot = _e.glyphAt(at);
                    if (ot.charIndex > tt)
                      break;
                    at < ge - $e && (De = Math.min(De, ot.x), we = Math.max(we, ot.x + ot.width));
                  }
                  for (let ot = vt; ot < at; ot++) {
                    const It = _e.glyphAt(ot);
                    It.x = we - (It.x + It.width - De);
                  }
                  break;
                }
            }
            let Fe;
            const Bt = (Ee) => Fe = Ee;
            for (let Ee = 0; Ee < ge; Ee++) {
              const Le = _e.glyphAt(Ee);
              Fe = Le.glyphObj;
              const tt = Fe.index, De = le.levels[Le.charIndex] & 1;
              if (De) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, Bt);
              }
              if (oe) {
                const { charIndex: we, fontData: He } = Le, vt = Le.x + be, at = Le.x + Le.width + be;
                $[we * 4] = De ? at : vt, $[we * 4 + 1] = De ? vt : at, $[we * 4 + 2] = _e.baseline + He.caretBottom + de, $[we * 4 + 3] = _e.baseline + He.caretTop + de;
                const ot = we - ve;
                ot > 1 && u($, ve, ot), ve = we;
              }
              if (X) {
                const { charIndex: we } = Le;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (Je = X[Te]);
              }
              if (!Fe.isWhitespace && !Fe.isEmpty) {
                const we = Ne++, { fontSizeMult: He, src: vt, index: at } = Le.fontData, ot = ie[vt] || (ie[vt] = {});
                ot[tt] || (ot[tt] = {
                  path: Fe.path,
                  pathBounds: [Fe.xMin, Fe.yMin, Fe.xMax, Fe.yMax]
                });
                const It = Le.x + be, Fn = _e.baseline + de;
                q[we * 2] = It, q[we * 2 + 1] = Fn;
                const un = It + Fe.xMin * He, wn = Fn + Fe.yMin * He, In = It + Fe.xMax * He, hn = Fn + Fe.yMax * He;
                un < O[0] && (O[0] = un), wn < O[1] && (O[1] = wn), In > O[2] && (O[2] = In), hn > O[3] && (O[3] = hn), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const xt = Pe.rect;
                if (un < xt[0] && (xt[0] = un), wn < xt[1] && (xt[1] = wn), In > xt[2] && (xt[2] = In), hn > xt[3] && (xt[3] = hn), Q[we] = tt, W[we] = at, X) {
                  const Wn = we * 3;
                  ae[Wn] = Je >> 16 & 255, ae[Wn + 1] = Je >> 8 & 255, ae[Wn + 2] = Je & 255;
                }
              }
            }
          }
        }), $) {
          const _e = p.length - ve;
          _e > 1 && u($, ve, _e);
        }
      }
      const qe = [];
      pe.forEach(({ index: le, src: Ne, unitsPerEm: ve, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue }) => {
        qe[le] = { src: Ne, unitsPerEm: ve, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: W,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: qe,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: de + Ae[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          be,
          de - me,
          be + Z,
          de
        ],
        visibleBounds: O,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const IM = /* @__PURE__ */ ms({
  name: "Typesetter",
  dependencies: [
    FM,
    OM,
    ax
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), PM = IM, DM = /* @__PURE__ */ ms({
  name: "Typesetter",
  dependencies: [
    PM
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (const t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), UM = new je();
let ta;
function zM(c) {
  return ta || (ta = typeof document > "u" ? {} : document.createElement("a")), ta.href = c, ta.href;
}
const yx = {
  font: "/assets/fonts/STFangsong.ttf",
  lang: "en",
  fontSize: 0.1,
  fontWeight: "normal",
  fontStyle: "normal",
  letterSpacing: 0,
  lineHeight: "normal",
  maxWidth: 1,
  direction: "auto",
  textAlign: "left",
  textIndent: 0,
  whiteSpace: "normal",
  overflowWrap: "normal",
  anchorX: 0,
  anchorY: 0,
  colorRanges: null,
  includeCaretPositions: !0,
  sdfGlyphSize: 64,
  gpuAccelerateSDF: !1
};
async function BM(c) {
  c = { ...yx, ...c };
  const e = [];
  if (c.font && e.push({ label: "user", src: zM(c.font) }), c.font = e, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || 64, c.colorRanges != null) {
    const h = {};
    for (const d in c.colorRanges)
      if (Object.hasOwn(c.colorRanges, d)) {
        let f = c.colorRanges[d];
        typeof f != "number" && (f = UM.set(f).getHex()), h[d] = f;
      }
    c.colorRanges = h;
  }
  Object.freeze(c);
  const t = await DM(c), { glyphIds: r, glyphFontIndices: n, fontData: s, glyphData: o, glyphPositions: i, fontSize: a } = t, l = new Cu();
  let u = 0;
  return r.forEach((h, d) => {
    const f = n[d], { src: p, unitsPerEm: m } = s[f], { path: g } = o[p][h], b = i[u++], v = i[u++], y = a / m, x = g.replace(/([A-Z])/mg, (N, w) => `$${w}`).split("$").filter((N) => N);
    for (const N of x) {
      const w = N[0];
      if (w === "Z")
        continue;
      const T = N.substring(1).split(",").map((_, L) => (L % 2 ? v : b) + Number.parseFloat(_) * y);
      w === "M" ? l.moveTo(...T) : w === "L" ? l.lineTo(...T) : w === "Q" ? l.quadraticCurveTo(...T) : w === "C" && l.bezierCurveTo(...T);
    }
  }), l.toShapes(!1);
}
const kM = Object.fromEntries(Object.entries(gi).map((c) => [`props.${c[0]}`, c[1]]));
class vx extends Or {
  constructor(t, r) {
    super(t, r, {
      ...yx,
      color: new je(),
      strokeColor: new je(),
      outlineColor: new je()
    }, 0, 0);
    G(this, "isText3D", !0);
    this.type = "Text3D";
  }
  async rebuildShapes() {
    this.shapes = await BM(this.props), this.rebuildGeometry();
  }
}
Ye("Text3D", {
  members: kM,
  proto: "Shape",
  group: "Text.3D Text",
  icon: "text",
  create: ({ material: c, geometry: e } = {}) => new vx(e || new Vm(), c)
});
class xx extends Gb {
  constructor() {
    super();
    G(this, "isAudioListener2", !0);
    this.type = "AudioListener2";
  }
  toJSON(t) {
    const r = super.toJSON(t), n = { ...r.object };
    return delete n.children, t.listeners[n.uuid] = n, r;
  }
}
class bx extends Vb {
  constructor(t) {
    super(t);
    G(this, "isPositionalAudio2", !0);
    G(this, "_src", "");
    this.type = "PositionalAudio2";
  }
  get src() {
    return this._src;
  }
  set src(t) {
    this._src !== t && (this._src = t, this.isPlaying && this.stop(), new jb().load(t, (r) => {
      this.setBuffer(r);
    }));
  }
  play(t) {
    return this.isPlaying && this.stop(), super.play(t);
  }
  clone(t) {
    const r = Ar.get(this.listener);
    return new this.constructor(r).copy(this, t);
  }
  serialize(t) {
    t.autoplay = this.autoplay, t.loop = this.loop, t.src = this._src, t.listener = this.listener.uuid;
  }
  deserialize(t) {
    this.autoplay = t.autoplay || !1, this.loop = t.loop || !1, this.src = t.src;
  }
}
Ye("AudioListener2", {
  create: () => new xx(),
  proto: "AudioListener",
  members: {},
  group: "Audio.Audio Listener",
  icon: "ear"
});
Ye("PositionalAudio2", {
  create: ({ listener: c }) => new bx(c),
  proto: "PositionalAudio",
  members: {
    autoplay: "Boolean",
    loop: "Boolean",
    src: "Audio"
  },
  group: "Audio.Positional Audio",
  icon: "audio"
});
function Wp(c, e) {
  if (e === Wb)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), c;
  if (e === Vl || e === Xm) {
    let t = c.getIndex();
    if (t === null) {
      const o = [], i = c.getAttribute("position");
      if (i !== void 0) {
        for (let a = 0; a < i.count; a++)
          o.push(a);
        c.setIndex(o), t = c.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), c;
    }
    const r = t.count - 2, n = [];
    if (e === Vl)
      for (let o = 1; o <= r; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < r; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = c.clone();
    return s.setIndex(n), s.clearGroups(), s;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), c;
}
class rf extends Sr {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new HM(t);
    }), this.register(function(t) {
      return new QM(t);
    }), this.register(function(t) {
      return new eA(t);
    }), this.register(function(t) {
      return new tA(t);
    }), this.register(function(t) {
      return new $M(t);
    }), this.register(function(t) {
      return new qM(t);
    }), this.register(function(t) {
      return new JM(t);
    }), this.register(function(t) {
      return new YM(t);
    }), this.register(function(t) {
      return new WM(t);
    }), this.register(function(t) {
      return new KM(t);
    }), this.register(function(t) {
      return new XM(t);
    }), this.register(function(t) {
      return new ZM(t);
    }), this.register(function(t) {
      return new VM(t);
    }), this.register(function(t) {
      return new nA(t);
    }), this.register(function(t) {
      return new sA(t);
    });
  }
  load(e, t, r, n) {
    const s = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = mo.extractUrlBase(e), this.manager.itemStart(e);
    const i = function(l) {
      n ? n(l) : console.error(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }, a = new Ys(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        s.parse(l, o, function(u) {
          t(u), s.manager.itemEnd(e);
        }, i);
      } catch (u) {
        i(u);
      }
    }, r, i);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, r, n) {
    let s;
    const o = {}, i = {}, a = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (a.decode(new Uint8Array(e, 0, 4)) === Nx) {
        try {
          o[et.KHR_BINARY_GLTF] = new rA(e);
        } catch (h) {
          n && n(h);
          return;
        }
        s = JSON.parse(o[et.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(a.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new yA(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), i[h.name] = h, o[h.name] = !0;
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
        switch (h) {
          case et.KHR_MATERIALS_UNLIT:
            o[h] = new jM();
            break;
          case et.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new oA(s, this.dracoLoader);
            break;
          case et.KHR_TEXTURE_TRANSFORM:
            o[h] = new iA();
            break;
          case et.KHR_MESH_QUANTIZATION:
            o[h] = new aA();
            break;
          default:
            d.indexOf(h) >= 0 && i[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(i), l.parse(r, n);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function(n, s) {
      r.parse(e, t, n, s);
    });
  }
}
function GM() {
  let c = {};
  return {
    get: function(e) {
      return c[e];
    },
    add: function(e, t) {
      c[e] = t;
    },
    remove: function(e) {
      delete c[e];
    },
    removeAll: function() {
      c = {};
    }
  };
}
const et = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class VM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, r = "light:" + e;
    let n = t.cache.get(r);
    if (n)
      return n;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let l;
    const u = new je(16777215);
    a.color !== void 0 && u.setRGB(a.color[0], a.color[1], a.color[2], Rn);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        l = new bi(u), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        l = new ni(u), l.distance = h;
        break;
      case "spot":
        l = new Ni(u), l.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, l.angle = a.spot.outerConeAngle, l.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return l.position.set(0, 0, 0), l.decay = 2, Gs(l, a), a.intensity !== void 0 && (l.intensity = a.intensity), l.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(l), t.cache.add(r, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, r = this.parser, s = r.json.nodes[e], i = (s.extensions && s.extensions[this.name] || {}).light;
    return i === void 0 ? null : this._loadLight(i).then(function(a) {
      return r._getNodeRef(t.cache, i, a);
    });
  }
}
class jM {
  constructor() {
    this.name = et.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Cn;
  }
  extendParams(e, t, r) {
    const n = [];
    e.color = new je(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Rn), e.opacity = o[3];
      }
      s.baseColorTexture !== void 0 && n.push(r.assignTexture(e, "map", s.baseColorTexture, vn));
    }
    return Promise.all(n);
  }
}
class WM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class HM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const i = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Tt(i, i);
    }
    return Promise.all(s);
  }
}
class XM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class $M {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new je(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const i = o.sheenColorFactor;
      t.sheenColor.setRGB(i[0], i[1], i[2], Rn);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, vn)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s);
  }
}
class qM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s);
  }
}
class JM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const i = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new je().setRGB(i[0], i[1], i[2], Rn), Promise.all(s);
  }
}
class YM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name];
    return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
}
class KM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const i = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new je().setRGB(i[0], i[1], i[2], Rn), o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, vn)), Promise.all(s);
  }
}
class ZM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s);
  }
}
class QM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, r = t.json, n = r.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const s = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class eA {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class tA {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class nA {
  constructor(e) {
    this.name = et.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const n = r.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(i) {
        const a = n.byteOffset || 0, l = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(i, a, l);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class sA {
  constructor(e) {
    this.name = et.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const n = t.meshes[r.mesh];
    for (const l of n.primitives)
      if (l.mode !== Un.TRIANGLES && l.mode !== Un.TRIANGLE_STRIP && l.mode !== Un.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const o = r.extensions[this.name].attributes, i = [], a = {};
    for (const l in o)
      i.push(this.parser.getDependency("accessor", o[l]).then((u) => (a[l] = u, a[l])));
    return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then((l) => {
      const u = l.pop(), h = u.isGroup ? u.children : [u], d = l[0].count, f = [];
      for (const p of h) {
        const m = new Ge(), g = new ye(), b = new pr(), v = new ye(1, 1, 1), y = new Hb(p.geometry, p.material, d);
        for (let x = 0; x < d; x++)
          a.TRANSLATION && g.fromBufferAttribute(a.TRANSLATION, x), a.ROTATION && b.fromBufferAttribute(a.ROTATION, x), a.SCALE && v.fromBufferAttribute(a.SCALE, x), y.setMatrixAt(x, m.compose(g, b, v));
        for (const x in a)
          if (x === "_COLOR_0") {
            const N = a[x];
            y.instanceColor = new Wm(N.array, N.itemSize, N.normalized);
          } else
            x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, a[x]);
        xn.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), f.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
}
const Nx = "glTF", Bo = 12, Hp = { JSON: 1313821514, BIN: 5130562 };
class rA {
  constructor(e) {
    this.name = et.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Bo), r = new TextDecoder();
    if (this.header = {
      magic: r.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Nx)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Bo, s = new DataView(e, Bo);
    let o = 0;
    for (; o < n; ) {
      const i = s.getUint32(o, !0);
      o += 4;
      const a = s.getUint32(o, !0);
      if (o += 4, a === Hp.JSON) {
        const l = new Uint8Array(e, Bo + o, i);
        this.content = r.decode(l);
      } else if (a === Hp.BIN) {
        const l = Bo + o;
        this.body = e.slice(l, l + i);
      }
      o += i;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class oA {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = et.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, i = {}, a = {}, l = {};
    for (const u in o) {
      const h = fu[u] || u.toLowerCase();
      i[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = fu[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = r.accessors[e.attributes[u]], f = ho[d.componentType];
        l[h] = f.name, a[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(u, function(d) {
          for (const f in d.attributes) {
            const p = d.attributes[f], m = a[f];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, i, l);
      });
    });
  }
}
class iA {
  constructor() {
    this.name = et.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class aA {
  constructor() {
    this.name = et.KHR_MESH_QUANTIZATION;
  }
}
class wx extends Yb {
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = r[s + o];
    return t;
  }
  interpolate_(e, t, r, n) {
    const s = this.resultBuffer, o = this.sampleValues, i = this.valueSize, a = i * 2, l = i * 3, u = n - t, h = (r - t) / u, d = h * h, f = d * h, p = e * l, m = p - l, g = -2 * f + 3 * d, b = f - d, v = 1 - g, y = b - d + h;
    for (let x = 0; x !== i; x++) {
      const N = o[m + x + i], w = o[m + x + a] * u, T = o[p + x + i], _ = o[p + x] * u;
      s[x] = v * N + y * w + g * T + b * _;
    }
    return s;
  }
}
const cA = new pr();
class lA extends wx {
  interpolate_(e, t, r, n) {
    const s = super.interpolate_(e, t, r, n);
    return cA.fromArray(s).normalize().toArray(s), s;
  }
}
const Un = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, ho = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Xp = {
  9728: Ws,
  9729: po,
  9984: Km,
  9985: Zm,
  9986: Qm,
  9987: To
}, $p = {
  33071: go,
  33648: eg,
  10497: Ks
}, xl = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, fu = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Is = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, uA = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Ym,
  STEP: Jb
}, bl = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function hA(c) {
  return c.DefaultMaterial === void 0 && (c.DefaultMaterial = new jn({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Hm
  })), c.DefaultMaterial;
}
function lr(c, e, t) {
  for (const r in t.extensions)
    c[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]);
}
function Gs(c, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(c.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function dA(c, e, t) {
  let r = !1, n = !1, s = !1;
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (h.POSITION !== void 0 && (r = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (s = !0), r && n && s)
      break;
  }
  if (!r && !n && !s)
    return Promise.resolve(c);
  const o = [], i = [], a = [];
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (r) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : c.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : c.attributes.normal;
      i.push(d);
    }
    if (s) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : c.attributes.color;
      a.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(i),
    Promise.all(a)
  ]).then(function(l) {
    const u = l[0], h = l[1], d = l[2];
    return r && (c.morphAttributes.position = u), n && (c.morphAttributes.normal = h), s && (c.morphAttributes.color = d), c.morphTargetsRelative = !0, c;
  });
}
function fA(c, e) {
  if (c.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, r = e.weights.length; t < r; t++)
      c.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (c.morphTargetInfluences.length === t.length) {
      c.morphTargetDictionary = {};
      for (let r = 0, n = t.length; r < n; r++)
        c.morphTargetDictionary[t[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function pA(c) {
  let e;
  const t = c.extensions && c.extensions[et.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Nl(t.attributes) : e = c.indices + ":" + Nl(c.attributes) + ":" + c.mode, c.targets !== void 0)
    for (let r = 0, n = c.targets.length; r < n; r++)
      e += ":" + Nl(c.targets[r]);
  return e;
}
function Nl(c) {
  let e = "";
  const t = Object.keys(c).sort();
  for (let r = 0, n = t.length; r < n; r++)
    e += t[r] + ":" + c[t[r]] + ";";
  return e;
}
function pu(c) {
  switch (c) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function mA(c) {
  return c.search(/\.jpe?g($|\?)/i) > 0 || c.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : c.search(/\.webp($|\?)/i) > 0 || c.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const gA = new Ge();
class yA {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new GM(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, n = !1, s = -1;
    typeof navigator < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || n && s < 98 ? this.textureLoader = new Ru(this.options.manager) : this.textureLoader = new Xb(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ys(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(o) {
      const i = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: r,
        userData: {}
      };
      return lr(s, i, n), Gs(i, n), Promise.all(r._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(i);
      })).then(function() {
        e(i);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n].joints;
      for (let i = 0, a = o.length; i < a; i++)
        e[o[i]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1)
      return r;
    const n = r.clone(), s = (o, i) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(i, a);
      for (const [l, u] of o.children.entries())
        s(u, i.children[l]);
    };
    return s(r, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const n = e(t[r]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const r = e + ":" + t;
    let n = this.cache.get(r);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(s, o) {
        return r.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[et.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(s, o) {
      r.load(mo.resolveURL(t.uri, n.path), s, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(r) {
      const n = t.byteLength || 0, s = t.byteOffset || 0;
      return r.slice(s, s + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, r = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = xl[n.type], i = ho[n.componentType], a = n.normalized === !0, l = new i(n.count * o);
      return Promise.resolve(new ao(l, o, a));
    }
    const s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(o) {
      const i = o[0], a = xl[n.type], l = ho[n.componentType], u = l.BYTES_PER_ELEMENT, h = u * a, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? r.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, g;
      if (f && f !== h) {
        const b = Math.floor(d / f), v = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + b + ":" + n.count;
        let y = t.cache.get(v);
        y || (m = new l(i, b * f, n.count * f / u), y = new Om(m, f / u), t.cache.add(v, y)), g = new js(y, a, d % f / u, p);
      } else
        i === null ? m = new l(n.count * a) : m = new l(i, d, n.count * a), g = new ao(m, a, p);
      if (n.sparse !== void 0) {
        const b = xl.SCALAR, v = ho[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, x = n.sparse.values.byteOffset || 0, N = new v(o[1], y, n.sparse.count * b), w = new l(o[2], x, n.sparse.count * a);
        i !== null && (g = new ao(g.array.slice(), g.itemSize, g.normalized));
        for (let T = 0, _ = N.length; T < _; T++) {
          const L = N[T];
          if (g.setX(L, w[T * a]), a >= 2 && g.setY(L, w[T * a + 1]), a >= 3 && g.setZ(L, w[T * a + 2]), a >= 4 && g.setW(L, w[T * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, r = this.options, s = t.textures[e].source, o = t.images[s];
    let i = this.textureLoader;
    if (o.uri) {
      const a = r.manager.getHandler(o.uri);
      a !== null && (i = a);
    }
    return this.loadTextureImage(e, s, i);
  }
  loadTextureImage(e, t, r) {
    const n = this, s = this.json, o = s.textures[e], i = s.images[t], a = (i.uri || i.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const l = this.loadImageSource(t, r).then(function(u) {
      u.flipY = !1, u.name = o.name || i.name || "", u.name === "" && typeof i.uri == "string" && i.uri.startsWith("data:image/") === !1 && (u.name = i.uri);
      const d = (s.samplers || {})[o.sampler] || {};
      return u.magFilter = Xp[d.magFilter] || po, u.minFilter = Xp[d.minFilter] || To, u.wrapS = $p[d.wrapS] || Ks, u.wrapT = $p[d.wrapT] || Ks, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = l, l;
  }
  loadImageSource(e, t) {
    const r = this, n = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], i = self.URL || self.webkitURL;
    let a = o.uri || "", l = !1;
    if (o.bufferView !== void 0)
      a = r.getDependency("bufferView", o.bufferView).then(function(h) {
        l = !0;
        const d = new Blob([h], { type: o.mimeType });
        return a = i.createObjectURL(d), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(d, f) {
        let p = d;
        t.isImageBitmapLoader === !0 && (p = function(m) {
          const g = new Vn(m);
          g.needsUpdate = !0, d(g);
        }), t.load(mo.resolveURL(h, s.path), p, void 0, f);
      });
    }).then(function(h) {
      return l === !0 && i.revokeObjectURL(a), h.userData.mimeType = o.mimeType || mA(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, r, n) {
    const s = this;
    return this.getDependency("texture", r.index).then(function(o) {
      if (!o)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[et.KHR_TEXTURE_TRANSFORM]) {
        const i = r.extensions !== void 0 ? r.extensions[et.KHR_TEXTURE_TRANSFORM] : void 0;
        if (i) {
          const a = s.associations.get(o);
          o = s.extensions[et.KHR_TEXTURE_TRANSFORM].extendTexture(o, i), s.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const i = "PointsMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new Mu(), kn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, a.sizeAttenuation = !1, this.cache.add(i, a)), r = a;
    } else if (e.isLine) {
      const i = "LineBasicMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new Au(), kn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, this.cache.add(i, a)), r = a;
    }
    if (n || s || o) {
      let i = "ClonedMaterial:" + r.uuid + ":";
      n && (i += "derivative-tangents:"), s && (i += "vertex-colors:"), o && (i += "flat-shading:");
      let a = this.cache.get(i);
      a || (a = r.clone(), s && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(i, a), this.associations.set(a, this.associations.get(r))), r = a;
    }
    e.material = r;
  }
  getMaterialType() {
    return jn;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, r = this.json, n = this.extensions, s = r.materials[e];
    let o;
    const i = {}, a = s.extensions || {}, l = [];
    if (a[et.KHR_MATERIALS_UNLIT]) {
      const h = n[et.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), l.push(h.extendParams(i, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (i.color = new je(1, 1, 1), i.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        i.color.setRGB(d[0], d[1], d[2], Rn), i.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(i, "map", h.baseColorTexture, vn)), i.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, i.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(i, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(i, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, i);
      })));
    }
    s.doubleSided === !0 && (i.side = Eu);
    const u = s.alphaMode || bl.OPAQUE;
    if (u === bl.BLEND ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === bl.MASK && (i.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && o !== Cn && (l.push(t.assignTexture(i, "normalMap", s.normalTexture)), i.normalScale = new Tt(1, 1), s.normalTexture.scale !== void 0)) {
      const h = s.normalTexture.scale;
      i.normalScale.set(h, h);
    }
    if (s.occlusionTexture !== void 0 && o !== Cn && (l.push(t.assignTexture(i, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (i.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== Cn) {
      const h = s.emissiveFactor;
      i.emissive = new je().setRGB(h[0], h[1], h[2], Rn);
    }
    return s.emissiveTexture !== void 0 && o !== Cn && l.push(t.assignTexture(i, "emissiveMap", s.emissiveTexture, vn)), Promise.all(l).then(function() {
      const h = new o(i);
      return s.name && (h.name = s.name), Gs(h, s), t.associations.set(h, { materials: e }), s.extensions && lr(n, h, s), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = si.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, r = this.extensions, n = this.primitiveCache;
    function s(i) {
      return r[et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i, t).then(function(a) {
        return qp(a, i, t);
      });
    }
    const o = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i], u = pA(l), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        l.extensions && l.extensions[et.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = qp(new Kn(), l, t), n[u] = { primitive: l, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, r = this.json, n = this.extensions, s = r.meshes[e], o = s.primitives, i = [];
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a].material === void 0 ? hA(this.cache) : this.getDependency("material", o[a].material);
      i.push(u);
    }
    return i.push(t.loadGeometries(o)), Promise.all(i).then(function(a) {
      const l = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let f = 0, p = u.length; f < p; f++) {
        const m = u[f], g = o[f];
        let b;
        const v = l[f];
        if (g.mode === Un.TRIANGLES || g.mode === Un.TRIANGLE_STRIP || g.mode === Un.TRIANGLE_FAN || g.mode === void 0)
          b = s.isSkinnedMesh === !0 ? new $m(m, v) : new Jt(m, v), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), g.mode === Un.TRIANGLE_STRIP ? b.geometry = Wp(b.geometry, Xm) : g.mode === Un.TRIANGLE_FAN && (b.geometry = Wp(b.geometry, Vl));
        else if (g.mode === Un.LINES)
          b = new $b(m, v);
        else if (g.mode === Un.LINE_STRIP)
          b = new qm(m, v);
        else if (g.mode === Un.LINE_LOOP)
          b = new qb(m, v);
        else if (g.mode === Un.POINTS)
          b = new Jm(m, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(b.geometry.morphAttributes).length > 0 && fA(b, s), b.name = t.createUniqueName(s.name || "mesh_" + e), Gs(b, s), g.extensions && lr(n, b, g), t.assignFinalMaterial(b), h.push(b);
      }
      for (let f = 0, p = h.length; f < p; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return s.extensions && lr(n, h[0], s), h[0];
      const d = new lo();
      s.extensions && lr(n, d, s), t.associations.set(d, { meshes: e });
      for (let f = 0, p = h.length; f < p; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e], n = r[r.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? t = new _r(Qt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : r.type === "orthographic" && (t = new ec(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Gs(t, r), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], r = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      r.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(n) {
      const s = n.pop(), o = n, i = [], a = [];
      for (let l = 0, u = o.length; l < u; l++) {
        const h = o[l];
        if (h) {
          i.push(h);
          const d = new Ge();
          s !== null && d.fromArray(s.array, l * 16), a.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
      }
      return new Lu(i, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, r = this, n = t.animations[e], s = n.name ? n.name : "animation_" + e, o = [], i = [], a = [], l = [], u = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const f = n.channels[h], p = n.samplers[f.sampler], m = f.target, g = m.node, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, v = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (o.push(this.getDependency("node", g)), i.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", v)), l.push(p), u.push(m));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(i),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u)
    ]).then(function(h) {
      const d = h[0], f = h[1], p = h[2], m = h[3], g = h[4], b = [];
      for (let v = 0, y = d.length; v < y; v++) {
        const x = d[v], N = f[v], w = p[v], T = m[v], _ = g[v];
        if (x === void 0)
          continue;
        x.updateMatrix && x.updateMatrix();
        const L = r._createAnimationTracks(x, N, w, T, _);
        if (L)
          for (let A = 0; A < L.length; A++)
            b.push(L[A]);
      }
      return new Ou(s, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json, r = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : r.getDependency("mesh", n.mesh).then(function(s) {
      const o = r._getNodeRef(r.meshCache, n.mesh, s);
      return n.weights !== void 0 && o.traverse(function(i) {
        if (i.isMesh)
          for (let a = 0, l = n.weights.length; a < l; a++)
            i.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, r = this, n = t.nodes[e], s = r._loadNodeShallow(e), o = [], i = n.children || [];
    for (let l = 0, u = i.length; l < u; l++)
      o.push(r.getDependency("node", i[l]));
    const a = n.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", n.skin);
    return Promise.all([
      s,
      Promise.all(o),
      a
    ]).then(function(l) {
      const u = l[0], h = l[1], d = l[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, gA);
      });
      for (let f = 0, p = h.length; f < p; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, r = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], o = s.name ? n.createUniqueName(s.name) : "", i = [], a = n._invokeOne(function(l) {
      return l.createNodeMesh && l.createNodeMesh(e);
    });
    return a && i.push(a), s.camera !== void 0 && i.push(n.getDependency("camera", s.camera).then(function(l) {
      return n._getNodeRef(n.cameraCache, s.camera, l);
    })), n._invokeAll(function(l) {
      return l.createNodeAttachment && l.createNodeAttachment(e);
    }).forEach(function(l) {
      i.push(l);
    }), this.nodeCache[e] = Promise.all(i).then(function(l) {
      let u;
      if (s.isBone === !0 ? u = new jl() : l.length > 1 ? u = new lo() : l.length === 1 ? u = l[0] : u = new xn(), u !== l[0])
        for (let h = 0, d = l.length; h < d; h++)
          u.add(l[h]);
      if (s.name && (u.userData.name = s.name, u.name = o), Gs(u, s), s.extensions && lr(r, u, s), s.matrix !== void 0) {
        const h = new Ge();
        h.fromArray(s.matrix), u.applyMatrix4(h);
      } else
        s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, r = this.json.scenes[e], n = this, s = new lo();
    r.name && (s.name = n.createUniqueName(r.name)), Gs(s, r), r.extensions && lr(t, s, r);
    const o = r.nodes || [], i = [];
    for (let a = 0, l = o.length; a < l; a++)
      i.push(n.getDependency("node", o[a]));
    return Promise.all(i).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        s.add(a[u]);
      const l = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof kn || d instanceof Vn) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = l(s), s;
    });
  }
  _createAnimationTracks(e, t, r, n, s) {
    const o = [], i = e.name ? e.name : e.uuid, a = [];
    Is[s.path] === Is.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && a.push(d.name ? d.name : d.uuid);
    }) : a.push(i);
    let l;
    switch (Is[s.path]) {
      case Is.weights:
        l = Hl;
        break;
      case Is.rotation:
        l = Xl;
        break;
      case Is.position:
      case Is.scale:
        l = Wl;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            l = Hl;
            break;
          case 2:
          case 3:
          default:
            l = Wl;
            break;
        }
        break;
    }
    const u = n.interpolation !== void 0 ? uA[n.interpolation] : Ym, h = this._getArrayFromAccessor(r);
    for (let d = 0, f = a.length; d < f; d++) {
      const p = new l(
        a[d] + "." + Is[s.path],
        t.array,
        h,
        u
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const r = pu(t.constructor), n = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++)
        n[s] = t[s] * r;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(r) {
      const n = this instanceof Xl ? lA : wx;
      return new n(this.times, this.values, this.getValueSize() / 3, r);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function vA(c, e, t) {
  const r = e.attributes, n = new nr();
  if (r.POSITION !== void 0) {
    const i = t.json.accessors[r.POSITION], a = i.min, l = i.max;
    if (a !== void 0 && l !== void 0) {
      if (n.set(
        new ye(a[0], a[1], a[2]),
        new ye(l[0], l[1], l[2])
      ), i.normalized) {
        const u = pu(ho[i.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const s = e.targets;
  if (s !== void 0) {
    const i = new ye(), a = new ye();
    for (let l = 0, u = s.length; l < u; l++) {
      const h = s[l];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, p = d.max;
        if (f !== void 0 && p !== void 0) {
          if (a.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), a.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), a.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
            const m = pu(ho[d.componentType]);
            a.multiplyScalar(m);
          }
          i.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(i);
  }
  c.boundingBox = n;
  const o = new Ti();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, c.boundingSphere = o;
}
function qp(c, e, t) {
  const r = e.attributes, n = [];
  function s(o, i) {
    return t.getDependency("accessor", o).then(function(a) {
      c.setAttribute(i, a);
    });
  }
  for (const o in r) {
    const i = fu[o] || o.toLowerCase();
    i in c.attributes || n.push(s(r[o], i));
  }
  if (e.indices !== void 0 && !c.index) {
    const o = t.getDependency("accessor", e.indices).then(function(i) {
      c.setIndex(i);
    });
    n.push(o);
  }
  return Zf.workingColorSpace !== Rn && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Zf.workingColorSpace}" not supported.`), Gs(c, e), vA(c, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? dA(c, e.targets, t) : c;
  });
}
const wl = /* @__PURE__ */ new WeakMap();
class xA extends Sr {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, r, n) {
    const s = new Ys(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      this.parse(o, t, n);
    }, r, n);
  }
  parse(e, t, r) {
    this.decodeDracoFile(e, t, null, null, vn).catch(r);
  }
  decodeDracoFile(e, t, r, n, s = Rn) {
    const o = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: s
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const r = JSON.stringify(t);
    if (wl.has(e)) {
      const a = wl.get(e);
      if (a.key === r)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++, o = e.byteLength, i = this._getWorker(s, o).then((a) => (n = a, new Promise((l, u) => {
      n._callbacks[s] = { resolve: l, reject: u }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return i.catch(() => !0).then(() => {
      n && s && this._releaseTask(n, s);
    }), wl.set(e, {
      key: r,
      promise: i
    }), i;
  }
  _createGeometry(e) {
    const t = new Kn();
    e.index && t.setIndex(new ao(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const n = e.attributes[r], s = n.name, o = n.array, i = n.itemSize, a = new ao(o, i);
      s === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(s, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== vn)
      return;
    const r = new je();
    for (let n = 0, s = e.count; n < s; n++)
      r.fromBufferAttribute(e, n).convertSRGBToLinear(), e.setXYZ(n, r.r, r.g, r.b);
  }
  _loadLibrary(e, t) {
    const r = new Ys(this.manager);
    return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((n, s) => {
      r.load(e, n, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((r) => {
      const n = r[0];
      e || (this.decoderConfig.wasmBinary = r[1]);
      const s = bA.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(s) {
          const o = s.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, s) {
          return n._taskLoad > s._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return r._taskCosts[e] = t, r._taskLoad += t, r;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function bA() {
  let c, e;
  onmessage = function(o) {
    const i = o.data;
    switch (i.type) {
      case "init":
        c = i.decoderConfig, e = new Promise(function(u) {
          c.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(c);
        });
        break;
      case "decode":
        const a = i.buffer, l = i.taskConfig;
        e.then((u) => {
          const h = u.draco, d = new h.Decoder();
          try {
            const f = t(h, d, new Int8Array(a), l), p = f.attributes.map((m) => m.array.buffer);
            f.index && p.push(f.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: f }, p);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: i.id, error: f.message });
          } finally {
            h.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, i, a, l) {
    const u = l.attributeIDs, h = l.attributeTypes;
    let d, f;
    const p = i.GetEncodedGeometryType(a);
    if (p === o.TRIANGULAR_MESH)
      d = new o.Mesh(), f = i.DecodeArrayToMesh(a, a.byteLength, d);
    else if (p === o.POINT_CLOUD)
      d = new o.PointCloud(), f = i.DecodeArrayToPointCloud(a, a.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const m = { index: null, attributes: [] };
    for (const g in u) {
      const b = self[h[g]];
      let v, y;
      if (l.useUniqueIDs)
        y = u[g], v = i.GetAttributeByUniqueId(d, y);
      else {
        if (y = i.GetAttributeId(d, o[u[g]]), y === -1)
          continue;
        v = i.GetAttribute(d, y);
      }
      const x = n(o, i, d, g, b, v);
      g === "color" && (x.vertexColorSpace = l.vertexColorSpace), m.attributes.push(x);
    }
    return p === o.TRIANGULAR_MESH && (m.index = r(o, i, d)), o.destroy(d), m;
  }
  function r(o, i, a) {
    const u = a.num_faces() * 3, h = u * 4, d = o._malloc(h);
    i.GetTrianglesUInt32Array(a, h, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function n(o, i, a, l, u, h) {
    const d = h.num_components(), p = a.num_points() * d, m = p * u.BYTES_PER_ELEMENT, g = s(o, u), b = o._malloc(m);
    i.GetAttributeDataArrayForAllPoints(a, h, g, m, b);
    const v = new u(o.HEAPF32.buffer, b, p).slice();
    return o._free(b), {
      name: l,
      array: v,
      itemSize: d
    };
  }
  function s(o, i) {
    switch (i) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Jp = function(c) {
  return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Jp(""));
} catch {
  Jp = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Bn = Uint8Array, Xs = Uint16Array, mu = Uint32Array, Tx = new Bn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Sx = new Bn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), NA = new Bn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _x = function(c, e) {
  for (var t = new Xs(31), r = 0; r < 31; ++r)
    t[r] = e += 1 << c[r - 1];
  for (var n = new mu(t[30]), r = 1; r < 30; ++r)
    for (var s = t[r]; s < t[r + 1]; ++s)
      n[s] = s - t[r] << 5 | r;
  return [t, n];
}, Mx = _x(Tx, 2), Ax = Mx[0], wA = Mx[1];
Ax[28] = 258, wA[258] = 28;
var TA = _x(Sx, 0), SA = TA[0], gu = new Xs(32768);
for (var pt = 0; pt < 32768; ++pt) {
  var Ps = (pt & 43690) >>> 1 | (pt & 21845) << 1;
  Ps = (Ps & 52428) >>> 2 | (Ps & 13107) << 2, Ps = (Ps & 61680) >>> 4 | (Ps & 3855) << 4, gu[pt] = ((Ps & 65280) >>> 8 | (Ps & 255) << 8) >>> 1;
}
var Qo = function(c, e, t) {
  for (var r = c.length, n = 0, s = new Xs(e); n < r; ++n)
    ++s[c[n] - 1];
  var o = new Xs(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + s[n - 1] << 1;
  var i;
  if (t) {
    i = new Xs(1 << e);
    var a = 15 - e;
    for (n = 0; n < r; ++n)
      if (c[n])
        for (var l = n << 4 | c[n], u = e - c[n], h = o[c[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          i[gu[h] >>> a] = l;
  } else
    for (i = new Xs(r), n = 0; n < r; ++n)
      c[n] && (i[n] = gu[o[c[n] - 1]++] >>> 15 - c[n]);
  return i;
}, Ri = new Bn(288);
for (var pt = 0; pt < 144; ++pt)
  Ri[pt] = 8;
for (var pt = 144; pt < 256; ++pt)
  Ri[pt] = 9;
for (var pt = 256; pt < 280; ++pt)
  Ri[pt] = 7;
for (var pt = 280; pt < 288; ++pt)
  Ri[pt] = 8;
var Cx = new Bn(32);
for (var pt = 0; pt < 32; ++pt)
  Cx[pt] = 5;
var _A = /* @__PURE__ */ Qo(Ri, 9, 1), MA = /* @__PURE__ */ Qo(Cx, 5, 1), Tl = function(c) {
  for (var e = c[0], t = 1; t < c.length; ++t)
    c[t] > e && (e = c[t]);
  return e;
}, $n = function(c, e, t) {
  var r = e / 8 | 0;
  return (c[r] | c[r + 1] << 8) >> (e & 7) & t;
}, Sl = function(c, e) {
  var t = e / 8 | 0;
  return (c[t] | c[t + 1] << 8 | c[t + 2] << 16) >> (e & 7);
}, AA = function(c) {
  return (c / 8 | 0) + (c & 7 && 1);
}, CA = function(c, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > c.length) && (t = c.length);
  var r = new (c instanceof Xs ? Xs : c instanceof mu ? mu : Bn)(t - e);
  return r.set(c.subarray(e, t)), r;
}, EA = function(c, e, t) {
  var r = c.length;
  if (!r || t && !t.l && r < 5)
    return e || new Bn(0);
  var n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new Bn(r * 3));
  var o = function(Q) {
    var W = e.length;
    if (Q > W) {
      var q = new Bn(Math.max(W * 2, Q));
      q.set(e), e = q;
    }
  }, i = t.f || 0, a = t.p || 0, l = t.b || 0, u = t.l, h = t.d, d = t.m, f = t.n, p = r * 8;
  do {
    if (!u) {
      t.f = i = $n(c, a, 1);
      var m = $n(c, a + 1, 3);
      if (a += 3, m)
        if (m == 1)
          u = _A, h = MA, d = 9, f = 5;
        else if (m == 2) {
          var y = $n(c, a, 31) + 257, x = $n(c, a + 10, 15) + 4, N = y + $n(c, a + 5, 31) + 1;
          a += 14;
          for (var w = new Bn(N), T = new Bn(19), _ = 0; _ < x; ++_)
            T[NA[_]] = $n(c, a + _ * 3, 7);
          a += x * 3;
          for (var L = Tl(T), A = (1 << L) - 1, U = Qo(T, L, 1), _ = 0; _ < N; ) {
            var S = U[$n(c, a, A)];
            a += S & 15;
            var g = S >>> 4;
            if (g < 16)
              w[_++] = g;
            else {
              var R = 0, E = 0;
              for (g == 16 ? (E = 3 + $n(c, a, 3), a += 2, R = w[_ - 1]) : g == 17 ? (E = 3 + $n(c, a, 7), a += 3) : g == 18 && (E = 11 + $n(c, a, 127), a += 7); E--; )
                w[_++] = R;
            }
          }
          var D = w.subarray(0, y), P = w.subarray(y);
          d = Tl(D), f = Tl(P), u = Qo(D, d, 1), h = Qo(P, f, 1);
        } else
          throw "invalid block type";
      else {
        var g = AA(a) + 4, b = c[g - 4] | c[g - 3] << 8, v = g + b;
        if (v > r) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + b), e.set(c.subarray(g, v), l), t.b = l += b, t.p = a = v * 8;
        continue;
      }
      if (a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(l + 131072);
    for (var se = (1 << d) - 1, oe = (1 << f) - 1, H = a; ; H = a) {
      var R = u[Sl(c, a) & se], X = R >>> 4;
      if (a += R & 15, a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!R)
        throw "invalid length/literal";
      if (X < 256)
        e[l++] = X;
      else if (X == 256) {
        H = a, u = null;
        break;
      } else {
        var C = X - 254;
        if (X > 264) {
          var _ = X - 257, F = Tx[_];
          C = $n(c, a, (1 << F) - 1) + Ax[_], a += F;
        }
        var I = h[Sl(c, a) & oe], k = I >>> 4;
        if (!I)
          throw "invalid distance";
        a += I & 15;
        var P = SA[k];
        if (k > 3) {
          var F = Sx[k];
          P += Sl(c, a) & (1 << F) - 1, a += F;
        }
        if (a > p) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + 131072);
        for (var z = l + C; l < z; l += 4)
          e[l] = e[l - P], e[l + 1] = e[l + 1 - P], e[l + 2] = e[l + 2 - P], e[l + 3] = e[l + 3 - P];
        l = z;
      }
    }
    t.l = u, t.p = H, t.b = l, u && (i = 1, t.m = d, t.d = h, t.n = f);
  } while (!i);
  return l == e.length ? e : CA(e, 0, l);
}, RA = /* @__PURE__ */ new Bn(0), LA = function(c) {
  if ((c[0] & 15) != 8 || c[0] >>> 4 > 7 || (c[0] << 8 | c[1]) % 31)
    throw "invalid zlib data";
  if (c[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function OA(c, e) {
  return EA((LA(c), c.subarray(2, -4)), e);
}
var FA = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), IA = 0;
try {
  FA.decode(RA, { stream: !0 }), IA = 1;
} catch {
}
function Ex(c, e, t) {
  const r = t.length - c - 1;
  if (e >= t[r])
    return r - 1;
  if (e <= t[c])
    return c;
  let n = c, s = r, o = Math.floor((n + s) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? s = o : n = o, o = Math.floor((n + s) / 2);
  return o;
}
function PA(c, e, t, r) {
  const n = [], s = [], o = [];
  n[0] = 1;
  for (let i = 1; i <= t; ++i) {
    s[i] = e - r[c + 1 - i], o[i] = r[c + i] - e;
    let a = 0;
    for (let l = 0; l < i; ++l) {
      const u = o[l + 1], h = s[i - l], d = n[l] / (u + h);
      n[l] = a + u * d, a = h * d;
    }
    n[i] = a;
  }
  return n;
}
function DA(c, e, t, r) {
  const n = Ex(c, r, e), s = PA(n, r, c, e), o = new mt(0, 0, 0, 0);
  for (let i = 0; i <= c; ++i) {
    const a = t[n - c + i], l = s[i], u = a.w * l;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * l;
  }
  return o;
}
function UA(c, e, t, r, n) {
  const s = [];
  for (let h = 0; h <= t; ++h)
    s[h] = 0;
  const o = [];
  for (let h = 0; h <= r; ++h)
    o[h] = s.slice(0);
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = s.slice(0);
  i[0][0] = 1;
  const a = s.slice(0), l = s.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[c + 1 - h], l[h] = n[c + h] - e;
    let d = 0;
    for (let f = 0; f < h; ++f) {
      const p = l[f + 1], m = a[h - f];
      i[h][f] = p + m;
      const g = i[f][h - 1] / i[h][f];
      i[f][h] = d + p * g, d = m * g;
    }
    i[h][h] = d;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = i[h][t];
  for (let h = 0; h <= t; ++h) {
    let d = 0, f = 1;
    const p = [];
    for (let m = 0; m <= t; ++m)
      p[m] = s.slice(0);
    p[0][0] = 1;
    for (let m = 1; m <= r; ++m) {
      let g = 0;
      const b = h - m, v = t - m;
      h >= m && (p[f][0] = p[d][0] / i[v + 1][b], g = p[f][0] * i[b][v]);
      const y = b >= -1 ? 1 : -b, x = h - 1 <= v ? m - 1 : t - h;
      for (let w = y; w <= x; ++w)
        p[f][w] = (p[d][w] - p[d][w - 1]) / i[v + 1][b + w], g += p[f][w] * i[b + w][v];
      h <= v && (p[f][m] = -p[d][m - 1] / i[v + 1][h], g += p[f][m] * i[h][v]), o[m][h] = g;
      const N = d;
      d = f, f = N;
    }
  }
  let u = t;
  for (let h = 1; h <= r; ++h) {
    for (let d = 0; d <= t; ++d)
      o[h][d] *= u;
    u *= t - h;
  }
  return o;
}
function zA(c, e, t, r, n) {
  const s = n < c ? n : c, o = [], i = Ex(c, r, e), a = UA(i, r, c, s, e), l = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), d = h.w;
    h.x *= d, h.y *= d, h.z *= d, l[u] = h;
  }
  for (let u = 0; u <= s; ++u) {
    const h = l[i - c].clone().multiplyScalar(a[u][0]);
    for (let d = 1; d <= c; ++d)
      h.add(l[i - c + d].clone().multiplyScalar(a[u][d]));
    o[u] = h;
  }
  for (let u = s + 1; u <= n + 1; ++u)
    o[u] = new mt(0, 0, 0);
  return o;
}
function BA(c, e) {
  let t = 1;
  for (let n = 2; n <= c; ++n)
    t *= n;
  let r = 1;
  for (let n = 2; n <= e; ++n)
    r *= n;
  for (let n = 2; n <= c - e; ++n)
    r *= n;
  return t / r;
}
function kA(c) {
  const e = c.length, t = [], r = [];
  for (let s = 0; s < e; ++s) {
    const o = c[s];
    t[s] = new ye(o.x, o.y, o.z), r[s] = o.w;
  }
  const n = [];
  for (let s = 0; s < e; ++s) {
    const o = t[s].clone();
    for (let i = 1; i <= s; ++i)
      o.sub(n[s - i].clone().multiplyScalar(BA(s, i) * r[i]));
    n[s] = o.divideScalar(r[0]);
  }
  return n;
}
function GA(c, e, t, r, n) {
  const s = zA(c, e, t, r, n);
  return kA(s);
}
class VA extends Kb {
  constructor(e, t, r, n, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = s || this.knots.length - 1;
    for (let o = 0; o < r.length; ++o) {
      const i = r[o];
      this.controlPoints[o] = new mt(i.x, i.y, i.z, i.w);
    }
  }
  getPoint(e, t = new ye()) {
    const r = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = DA(this.degree, this.knots, this.controlPoints, n);
    return s.w !== 1 && s.divideScalar(s.w), r.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new ye()) {
    const r = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = GA(this.degree, this.knots, this.controlPoints, n, 1);
    return r.copy(s[1]).normalize(), r;
  }
}
let Ke, _t, mn;
class jA extends Sr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, n) {
    const s = this, o = s.path === "" ? mo.extractUrlBase(e) : s.path, i = new Ys(this.manager);
    i.setPath(s.path), i.setResponseType("arraybuffer"), i.setRequestHeader(s.requestHeader), i.setWithCredentials(s.withCredentials), i.load(e, function(a) {
      try {
        t(s.parse(a, o));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, r, n);
  }
  parse(e, t) {
    if (JA(e))
      Ke = new qA().parse(e);
    else {
      const n = Fx(e);
      if (!YA(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Kp(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Kp(n));
      Ke = new $A().parse(n);
    }
    const r = new Ru(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new WA(r, this.manager).parse(Ke);
  }
}
class WA {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    _t = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), r = this.parseMaterials(t), n = this.parseDeformers(), s = new HA().parse(n);
    return this.parseScene(n, s, r), mn;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ke && Ke.Connections.connections.forEach(function(r) {
      const n = r[0], s = r[1], o = r[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const i = { ID: s, relationship: o };
      e.get(n).parents.push(i), e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(s).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ke.Objects) {
      const r = Ke.Objects.Video;
      for (const n in r) {
        const s = r[n], o = parseInt(n);
        if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
          const i = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, a = typeof s.Content == "string" && s.Content !== "";
          if (i || a) {
            const l = this.parseImage(r[n]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const r in e) {
      const n = e[r];
      t[n] !== void 0 ? e[r] = t[n] : e[r] = e[r].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, r = e.RelativeFilename || e.Filename, n = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (n) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", r), s = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: s }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ke.Objects) {
      const r = Ke.Objects.Texture;
      for (const n in r) {
        const s = this.parseTexture(r[n], e);
        t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const r = this.loadTexture(e, t);
    r.ID = e.id, r.name = e.attrName;
    const n = e.WrapModeU, s = e.WrapModeV, o = n !== void 0 ? n.value : 0, i = s !== void 0 ? s.value : 0;
    if (r.wrapS = o === 0 ? Ks : go, r.wrapT = i === 0 ? Ks : go, "Scaling" in e) {
      const a = e.Scaling.value;
      r.repeat.x = a[0], r.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      r.offset.x = a[0], r.offset.y = a[1];
    }
    return r;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let r;
    const n = this.textureLoader.path, s = _t.get(e.id).children;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (r = t[s[0].ID], (r.indexOf("blob:") === 0 || r.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const i = e.FileName.slice(-3).toLowerCase();
    if (i === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Vn()) : (a.setPath(this.textureLoader.path), o = a.load(r));
    } else
      i === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Vn()) : o = this.textureLoader.load(r);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ke.Objects) {
      const r = Ke.Objects.Material;
      for (const n in r) {
        const s = this.parseMaterial(r[n], e);
        s !== null && t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const r = e.id, n = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !_t.has(r))
      return null;
    const o = this.parseParameters(e, t, r);
    let i;
    switch (s.toLowerCase()) {
      case "phong":
        i = new wa();
        break;
      case "lambert":
        i = new Bm();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), i = new wa();
        break;
    }
    return i.setValues(o), i.name = n, i;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, r) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new je().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new je().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new je().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new je().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new je().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new je().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return _t.get(r).children.forEach(function(o) {
      const i = o.relationship;
      switch (i) {
        case "Bump":
          n.bumpMap = s.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = s.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = s.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = vn);
          break;
        case "DisplacementColor":
          n.displacementMap = s.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = s.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = vn);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = s.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = s.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = tg, n.envMap.colorSpace = vn);
          break;
        case "SpecularColor":
          n.specularMap = s.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = vn);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = s.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", i);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ke.Objects && t in Ke.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = _t.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ke.Objects) {
      const r = Ke.Objects.Deformer;
      for (const n in r) {
        const s = r[n], o = _t.get(parseInt(n));
        if (s.attrType === "Skin") {
          const i = this.parseSkeleton(o, r);
          i.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), i.geometryID = o.parents[0].ID, e[n] = i;
        } else if (s.attrType === "BlendShape") {
          const i = {
            id: n
          };
          i.rawTargets = this.parseMorphTargets(o, r), i.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = i;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const r = [];
    return e.children.forEach(function(n) {
      const s = t[n.ID];
      if (s.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new Ge().fromArray(s.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), r.push(o);
    }), {
      rawBones: r,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const r = [];
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n], o = t[s.ID], i = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      i.geoID = _t.get(parseInt(s.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, r.push(i);
    }
    return r;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, r) {
    mn = new lo();
    const n = this.parseModels(e.skeletons, t, r), s = Ke.Objects.Model, o = this;
    n.forEach(function(a) {
      const l = s[a.ID];
      o.setLookAtProperties(a, l), _t.get(a.ID).parents.forEach(function(h) {
        const d = n.get(h.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && mn.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), mn.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const l = Lx(a.userData.transformData);
        a.applyMatrix4(l), a.updateWorldMatrix();
      }
    });
    const i = new XA().parse();
    mn.children.length === 1 && mn.children[0].isGroup && (mn.children[0].animations = i, mn = mn.children[0]), mn.animations = i;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, r) {
    const n = /* @__PURE__ */ new Map(), s = Ke.Objects.Model;
    for (const o in s) {
      const i = parseInt(o), a = s[o], l = _t.get(i);
      let u = this.buildSkeleton(l, e, i, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(l);
            break;
          case "Light":
            u = this.createLight(l);
            break;
          case "Mesh":
            u = this.createMesh(l, t, r);
            break;
          case "NurbsCurve":
            u = this.createCurve(l, t);
            break;
          case "LimbNode":
          case "Root":
            u = new jl();
            break;
          case "Null":
          default:
            u = new lo();
            break;
        }
        u.name = a.attrName ? si.sanitizeNodeName(a.attrName) : "", u.userData.originalName = a.attrName, u.ID = i;
      }
      this.getTransformData(u, a), n.set(i, u);
    }
    return n;
  }
  buildSkeleton(e, t, r, n) {
    let s = null;
    return e.parents.forEach(function(o) {
      for (const i in t) {
        const a = t[i];
        a.rawBones.forEach(function(l, u) {
          if (l.ID === o.ID) {
            const h = s;
            s = new jl(), s.matrixWorld.copy(l.transformLink), s.name = n ? si.sanitizeNodeName(n) : "", s.userData.originalName = n, s.ID = r, a.bones[u] = s, h !== null && s.add(h);
          }
        });
      }
    }), s;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ke.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new xn();
    else {
      let n = 0;
      r.CameraProjectionType !== void 0 && r.CameraProjectionType.value === 1 && (n = 1);
      let s = 1;
      r.NearPlane !== void 0 && (s = r.NearPlane.value / 1e3);
      let o = 1e3;
      r.FarPlane !== void 0 && (o = r.FarPlane.value / 1e3);
      let i = window.innerWidth, a = window.innerHeight;
      r.AspectWidth !== void 0 && r.AspectHeight !== void 0 && (i = r.AspectWidth.value, a = r.AspectHeight.value);
      const l = i / a;
      let u = 45;
      r.FieldOfView !== void 0 && (u = r.FieldOfView.value);
      const h = r.FocalLength ? r.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new _r(u, l, s, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new ec(-i / 2, i / 2, a / 2, -a / 2, s, o);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new xn();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ke.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new xn();
    else {
      let n;
      r.LightType === void 0 ? n = 0 : n = r.LightType.value;
      let s = 16777215;
      r.Color !== void 0 && (s = new je().fromArray(r.Color.value).convertSRGBToLinear());
      let o = r.Intensity === void 0 ? 1 : r.Intensity.value / 100;
      r.CastLightOnObject !== void 0 && r.CastLightOnObject.value === 0 && (o = 0);
      let i = 0;
      r.FarAttenuationEnd !== void 0 && (r.EnableFarAttenuation !== void 0 && r.EnableFarAttenuation.value === 0 ? i = 0 : i = r.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new ni(s, o, i, a);
          break;
        case 1:
          t = new bi(s, o);
          break;
        case 2:
          let l = Math.PI / 3;
          r.InnerAngle !== void 0 && (l = Qt.degToRad(r.InnerAngle.value));
          let u = 0;
          r.OuterAngle !== void 0 && (u = Qt.degToRad(r.OuterAngle.value), u = Math.max(u, 1)), t = new Ni(s, o, i, l, u, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), t = new ni(s, o);
          break;
      }
      r.CastShadows !== void 0 && r.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, r) {
    let n, s = null, o = null;
    const i = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (s = t.get(a.ID)), r.has(a.ID) && i.push(r.get(a.ID));
    }), i.length > 1 ? o = i : i.length > 0 ? o = i[0] : (o = new wa({
      name: Sr.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), i.push(o)), "color" in s.attributes && i.forEach(function(a) {
      a.vertexColors = !0;
    }), s.FBX_Deformer ? (n = new $m(s, o), n.normalizeSkinWeights()) : n = new Jt(s, o), n;
  }
  createCurve(e, t) {
    const r = e.children.reduce(function(s, o) {
      return t.has(o.ID) && (s = t.get(o.ID)), s;
    }, null), n = new Au({
      name: Sr.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new qm(r, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const r = {};
    "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? r.eulerOrder = Ox(t.RotationOrder.value) : r.eulerOrder = "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && _t.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const s = Ke.Objects.Model[n.ID];
        if ("Lcl_Translation" in s) {
          const o = s.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), mn.add(e.target)) : e.lookAt(new ye().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, r) {
    const n = this.parsePoseNodes();
    for (const s in e) {
      const o = e[s];
      _t.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const l = a.ID;
          _t.get(l).parents.forEach(function(h) {
            r.has(h.ID) && r.get(h.ID).bind(new Lu(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ke.Objects) {
      const t = Ke.Objects.Pose;
      for (const r in t)
        if (t[r].attrType === "BindPose" && t[r].NbPoseNodes > 0) {
          const n = t[r].PoseNode;
          Array.isArray(n) ? n.forEach(function(s) {
            e[s.Node] = new Ge().fromArray(s.Matrix.a);
          }) : e[n.Node] = new Ge().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ke && "AmbientColor" in Ke.GlobalSettings) {
      const e = Ke.GlobalSettings.AmbientColor.value, t = e[0], r = e[1], n = e[2];
      if (t !== 0 || r !== 0 || n !== 0) {
        const s = new je(t, r, n).convertSRGBToLinear();
        mn.add(new _u(s, 1));
      }
    }
  }
}
class HA {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ke.Objects) {
      const r = Ke.Objects.Geometry;
      for (const n in r) {
        const s = _t.get(parseInt(n)), o = this.parseGeometry(s, r[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, r) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, r);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, r) {
    const n = r.skeletons, s = [], o = e.parents.map(function(h) {
      return Ke.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const i = e.children.reduce(function(h, d) {
      return n[d.ID] !== void 0 && (h = n[d.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      r.morphTargets[h.ID] !== void 0 && s.push(r.morphTargets[h.ID]);
    });
    const a = o[0], l = {};
    "RotationOrder" in a && (l.eulerOrder = Ox(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
    const u = Lx(l);
    return this.genGeometry(t, i, s, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, r, n) {
    const s = new Kn();
    e.attrName && (s.name = e.attrName);
    const o = this.parseGeoNode(e, t), i = this.genBuffers(o), a = new yn(i.vertex, 3);
    if (a.applyMatrix4(n), s.setAttribute("position", a), i.colors.length > 0 && s.setAttribute("color", new yn(i.colors, 3)), t && (s.setAttribute("skinIndex", new Zb(i.weightsIndices, 4)), s.setAttribute("skinWeight", new yn(i.vertexWeights, 4)), s.FBX_Deformer = t), i.normal.length > 0) {
      const l = new Ts().getNormalMatrix(n), u = new yn(i.normal, 3);
      u.applyNormalMatrix(l), s.setAttribute("normal", u);
    }
    if (i.uvs.forEach(function(l, u) {
      const h = u === 0 ? "uv" : `uv${u}`;
      s.setAttribute(h, new yn(i.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let l = i.materialIndex[0], u = 0;
      if (i.materialIndex.forEach(function(h, d) {
        h !== l && (s.addGroup(u, d - u, l), l = h, u = d);
      }), s.groups.length > 0) {
        const h = s.groups[s.groups.length - 1], d = h.start + h.count;
        d !== i.materialIndex.length && s.addGroup(d, i.materialIndex.length - d, l);
      }
      s.groups.length === 0 && s.addGroup(0, i.materialIndex.length, i.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, r, n), s;
  }
  parseGeoNode(e, t) {
    const r = {};
    if (r.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], r.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      r.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && r.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return r.weightTable = {}, t !== null && (r.skeleton = t, t.rawBones.forEach(function(n, s) {
      n.indices.forEach(function(o, i) {
        r.weightTable[o] === void 0 && (r.weightTable[o] = []), r.weightTable[o].push({
          id: s,
          weight: n.weights[i]
        });
      });
    })), r;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let r = 0, n = 0, s = !1, o = [], i = [], a = [], l = [], u = [], h = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, p) {
      let m, g = !1;
      f < 0 && (f = f ^ -1, g = !0);
      let b = [], v = [];
      if (o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = na(p, r, f, e.color);
        a.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          v.push(y.weight), b.push(y.id);
        }), v.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const y = [0, 0, 0, 0], x = [0, 0, 0, 0];
          v.forEach(function(N, w) {
            let T = N, _ = b[w];
            x.forEach(function(L, A, U) {
              if (T > L) {
                U[A] = T, T = L;
                const S = y[A];
                y[A] = _, _ = S;
              }
            });
          }), b = y, v = x;
        }
        for (; v.length < 4; )
          v.push(0), b.push(0);
        for (let y = 0; y < 4; ++y)
          u.push(v[y]), h.push(b[y]);
      }
      if (e.normal) {
        const y = na(p, r, f, e.normal);
        i.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = na(p, r, f, e.material)[0], m < 0 && (d.negativeMaterialIndices = !0, m = 0)), e.uv && e.uv.forEach(function(y, x) {
        const N = na(p, r, f, y);
        l[x] === void 0 && (l[x] = []), l[x].push(N[0]), l[x].push(N[1]);
      }), n++, g && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, o, m, i, a, l, u, h, n), r++, n = 0, o = [], i = [], a = [], l = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, r, n, s, o, i, a, l, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[r[h * 3]]), e.vertex.push(t.vertexPositions[r[h * 3 + 1]]), e.vertex.push(t.vertexPositions[r[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[(h - 1) * 4]), e.weightsIndices.push(l[(h - 1) * 4 + 1]), e.weightsIndices.push(l[(h - 1) * 4 + 2]), e.weightsIndices.push(l[(h - 1) * 4 + 3]), e.weightsIndices.push(l[h * 4]), e.weightsIndices.push(l[h * 4 + 1]), e.weightsIndices.push(l[h * 4 + 2]), e.weightsIndices.push(l[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(i[f][0]), e.uvs[f].push(i[f][1]), e.uvs[f].push(i[f][(h - 1) * 2]), e.uvs[f].push(i[f][(h - 1) * 2 + 1]), e.uvs[f].push(i[f][h * 2]), e.uvs[f].push(i[f][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, r, n) {
    if (r.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    r.forEach(function(o) {
      o.rawTargets.forEach(function(i) {
        const a = Ke.Objects.Geometry[i.geoID];
        a !== void 0 && s.genMorphGeometry(e, t, a, n, i.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, r, n, s) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], i = r.Vertices !== void 0 ? r.Vertices.a : [], a = r.Indexes !== void 0 ? r.Indexes.a : [], l = e.attributes.position.count * 3, u = new Float32Array(l);
    for (let p = 0; p < a.length; p++) {
      const m = a[p] * 3;
      u[m] = i[p * 3], u[m + 1] = i[p * 3 + 1], u[m + 2] = i[p * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, d = this.genBuffers(h), f = new yn(d.vertex, 3);
    f.name = s || r.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Normals.a;
    let s = [];
    return r === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.UV.a;
    let s = [];
    return r === "IndexToDirect" && (s = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Colors.a;
    let s = [];
    r === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let o = 0, i = new je(); o < n.length; o += 4)
      i.fromArray(n, o).convertSRGBToLinear().toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: r
      };
    const n = e.Materials.a, s = [];
    for (let o = 0; o < n.length; ++o)
      s.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Kn();
    const r = t - 1, n = e.KnotVector.a, s = [], o = e.Points.a;
    for (let h = 0, d = o.length; h < d; h += 4)
      s.push(new mt().fromArray(o, h));
    let i, a;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      i = r, a = n.length - 1 - i;
      for (let h = 0; h < r; ++h)
        s.push(s[h]);
    }
    const u = new VA(r, n, s, i, a).getPoints(s.length * 12);
    return new Kn().setFromPoints(u);
  }
}
class XA {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const r in t) {
        const n = t[r], s = this.addClip(n);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (Ke.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ke.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const r in e) {
      const n = e[r];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(s.id, s);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ke.Objects.AnimationCurve;
    for (const r in t) {
      const n = {
        id: t[r].id,
        times: t[r].KeyTime.a.map(KA),
        values: t[r].KeyValueFloat.a
      }, s = _t.get(n.id);
      if (s !== void 0) {
        const o = s.parents[0].ID, i = s.parents[0].relationship;
        i.match(/X/) ? e.get(o).curves.x = n : i.match(/Y/) ? e.get(o).curves.y = n : i.match(/Z/) ? e.get(o).curves.z = n : i.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ke.Objects.AnimationLayer, r = /* @__PURE__ */ new Map();
    for (const n in t) {
      const s = [], o = _t.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, l) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (s[l] === void 0) {
              const h = _t.get(a.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const d = Ke.Objects.Model[h.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const f = {
                  modelName: d.attrName ? si.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                mn.traverse(function(p) {
                  p.ID === d.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new Ge()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), s[l] = f;
              }
            }
            s[l] && (s[l][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const h = _t.get(a.ID).parents.filter(function(b) {
                return b.relationship !== void 0;
              })[0].ID, d = _t.get(h).parents[0].ID, f = _t.get(d).parents[0].ID, p = _t.get(f).parents[0].ID, m = Ke.Objects.Model[p], g = {
                modelName: m.attrName ? si.sanitizeNodeName(m.attrName) : "",
                morphName: Ke.Objects.Deformer[h].attrName
              };
              s[l] = g;
            }
            s[l][u.attr] = u;
          }
        }
      }), r.set(parseInt(n), s));
    }
    return r;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ke.Objects.AnimationStack, r = {};
    for (const n in t) {
      const s = _t.get(parseInt(n)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(s[0].ID);
      r[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return r;
  }
  addClip(e) {
    let t = [];
    const r = this;
    return e.layer.forEach(function(n) {
      t = t.concat(r.generateTracks(n));
    }), new Ou(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let r = new ye(), n = new pr(), s = new ye();
    if (e.transform && e.transform.decompose(r, n, s), r = r.toArray(), n = new Ss().setFromQuaternion(n, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, r, n) {
    const s = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(s, t, r);
    return new Wl(e + "." + n, s, o);
  }
  generateRotationTrack(e, t, r, n, s, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Qt.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Qt.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Qt.degToRad));
    const i = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(i, t, r);
    n !== void 0 && (n = n.map(Qt.degToRad), n.push(o), n = new Ss().fromArray(n), n = new pr().setFromEuler(n)), s !== void 0 && (s = s.map(Qt.degToRad), s.push(o), s = new Ss().fromArray(s), s = new pr().setFromEuler(s).invert());
    const l = new pr(), u = new Ss(), h = [];
    for (let d = 0; d < a.length; d += 3)
      u.set(a[d], a[d + 1], a[d + 2], o), l.setFromEuler(u), n !== void 0 && l.premultiply(n), s !== void 0 && l.multiply(s), l.toArray(h, d / 3 * 4);
    return new Xl(e + ".quaternion", i, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, r = t.values.map(function(s) {
      return s / 100;
    }), n = mn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Hl(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, r);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(r, n) {
      return r - n;
    }), t.length > 1) {
      let r = 1, n = t[0];
      for (let s = 1; s < t.length; s++) {
        const o = t[s];
        o !== n && (t[r] = o, n = o, r++);
      }
      t = t.slice(0, r);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, r) {
    const n = r, s = [];
    let o = -1, i = -1, a = -1;
    return e.forEach(function(l) {
      if (t.x && (o = t.x.times.indexOf(l)), t.y && (i = t.y.times.indexOf(l)), t.z && (a = t.z.times.indexOf(l)), o !== -1) {
        const u = t.x.values[o];
        s.push(u), n[0] = u;
      } else
        s.push(n[0]);
      if (i !== -1) {
        const u = t.y.values[i];
        s.push(u), n[1] = u;
      } else
        s.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        s.push(u), n[2] = u;
      } else
        s.push(n[2]);
    }), s;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const r = e.values[t - 1], n = e.values[t] - r, s = Math.abs(n);
      if (s >= 180) {
        const o = s / 180, i = n / o;
        let a = r + i;
        const l = e.times[t - 1], h = (e.times[t] - l) / o;
        let d = l + h;
        const f = [], p = [];
        for (; d < e.times[t]; )
          f.push(d), d += h, p.push(a), a += i;
        e.times = Zp(e.times, t, f), e.values = Zp(e.values, t, p);
      }
    }
  }
}
class $A {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new Rx(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, r = e.split(/[\r\n]+/);
    return r.forEach(function(n, s) {
      const o = n.match(/^[\s\t]*;/), i = n.match(/^[\s\t]*$/);
      if (o || i)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : l ? t.parseNodeProperty(n, l, r[++s]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const r = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: r }, o = this.parseNodeAttr(n), i = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(r, s) : r in i ? (r === "PoseNode" ? i.PoseNode.push(s) : i[r].id !== void 0 && (i[r] = {}, i[r][i[r].id] = i[r]), o.id !== "" && (i[r][o.id] = s)) : typeof o.id == "number" ? (i[r] = {}, i[r][o.id] = s) : r !== "Properties70" && (r === "PoseNode" ? i[r] = [s] : i[r] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let r = "", n = "";
    return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: r, type: n };
  }
  parseNodeProperty(e, t, r) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, s);
      return;
    }
    if (n === "C") {
      const a = s.split(",").slice(1), l = parseInt(a[0]), u = parseInt(a[1]);
      let h = s.split(",").slice(3);
      h = h.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", s = [l, u], QA(s, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = s), n in o && Array.isArray(o[n]) ? o[n].push(s) : n !== "a" ? o[n] = s : o.a = s, this.setCurrentProp(o, n), n === "a" && s.slice(-1) !== "," && (o.a = Ml(s));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Ml(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, r) {
    const n = r.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = n[0], o = n[1], i = n[2], a = n[3];
    let l = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        l = parseFloat(l);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        l = Ml(l);
        break;
    }
    this.getPrevNode()[s] = {
      type: o,
      type2: i,
      flag: a,
      value: l
    }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class qA {
  parse(e) {
    const t = new Yp(e);
    t.skip(23);
    const r = t.getUint32();
    if (r < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
    const n = new Rx();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, r);
      s !== null && n.add(s.name, s);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const r = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), i = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let d = 0; d < s; d++)
      a.push(this.parseProperty(e));
    const l = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (r.singleProperty = s === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(i, r, d);
    }
    return r.propertyList = a, typeof l == "number" && (r.id = l), u !== "" && (r.attrName = u), h !== "" && (r.attrType = h), i !== "" && (r.name = i), r;
  }
  parseSubNode(e, t, r) {
    if (r.singleProperty === !0) {
      const n = r.propertyList[0];
      Array.isArray(n) ? (t[r.name] = r, r.a = n) : t[r.name] = n;
    } else if (e === "Connections" && r.name === "C") {
      const n = [];
      r.propertyList.forEach(function(s, o) {
        o !== 0 && n.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (r.name === "Properties70")
      Object.keys(r).forEach(function(s) {
        t[s] = r[s];
      });
    else if (e === "Properties70" && r.name === "P") {
      let n = r.propertyList[0], s = r.propertyList[1];
      const o = r.propertyList[2], i = r.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? a = [
        r.propertyList[4],
        r.propertyList[5],
        r.propertyList[6]
      ] : a = r.propertyList[4], t[n] = {
        type: s,
        type2: o,
        flag: i,
        value: a
      };
    } else
      t[r.name] === void 0 ? typeof r.id == "number" ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : r.name === "PoseNode" ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : t[r.name][r.id] === void 0 && (t[r.name][r.id] = r);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let r;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return r = e.getUint32(), e.getArrayBuffer(r);
      case "S":
        return r = e.getUint32(), e.getString(r);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), s = e.getUint32(), o = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const i = OA(new Uint8Array(e.getArrayBuffer(o))), a = new Yp(i.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Yp {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let r = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = r.indexOf(0);
    return n >= 0 && (r = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(r);
  }
}
class Rx {
  add(e, t) {
    this[e] = t;
  }
}
function JA(c) {
  const e = "Kaydara FBX Binary  \0";
  return c.byteLength >= e.length && e === Fx(c, 0, e.length);
}
function YA(c) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function r(n) {
    const s = c[n - 1];
    return c = c.slice(t + n), t++, s;
  }
  for (let n = 0; n < e.length; ++n)
    if (r(1) === e[n])
      return !1;
  return !0;
}
function Kp(c) {
  const e = /FBXVersion: (\d+)/, t = c.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function KA(c) {
  return c / 46186158e3;
}
const ZA = [];
function na(c, e, t, r) {
  let n;
  switch (r.mappingType) {
    case "ByPolygonVertex":
      n = c;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = r.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
  }
  r.referenceType === "IndexToDirect" && (n = r.indices[n]);
  const s = n * r.dataSize, o = s + r.dataSize;
  return eC(ZA, r.buffer, s, o);
}
const _l = new Ss(), kr = new ye();
function Lx(c) {
  const e = new Ge(), t = new Ge(), r = new Ge(), n = new Ge(), s = new Ge(), o = new Ge(), i = new Ge(), a = new Ge(), l = new Ge(), u = new Ge(), h = new Ge(), d = new Ge(), f = c.inheritType ? c.inheritType : 0;
  if (c.translation && e.setPosition(kr.fromArray(c.translation)), c.preRotation) {
    const A = c.preRotation.map(Qt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), t.makeRotationFromEuler(_l.fromArray(A));
  }
  if (c.rotation) {
    const A = c.rotation.map(Qt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), r.makeRotationFromEuler(_l.fromArray(A));
  }
  if (c.postRotation) {
    const A = c.postRotation.map(Qt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), n.makeRotationFromEuler(_l.fromArray(A)), n.invert();
  }
  c.scale && s.scale(kr.fromArray(c.scale)), c.scalingOffset && i.setPosition(kr.fromArray(c.scalingOffset)), c.scalingPivot && o.setPosition(kr.fromArray(c.scalingPivot)), c.rotationOffset && a.setPosition(kr.fromArray(c.rotationOffset)), c.rotationPivot && l.setPosition(kr.fromArray(c.rotationPivot)), c.parentMatrixWorld && (h.copy(c.parentMatrix), u.copy(c.parentMatrixWorld));
  const p = t.clone().multiply(r).multiply(n), m = new Ge();
  m.extractRotation(u);
  const g = new Ge();
  g.copyPosition(u);
  const b = g.clone().invert().multiply(u), v = m.clone().invert().multiply(b), y = s, x = new Ge();
  if (f === 0)
    x.copy(m).multiply(p).multiply(v).multiply(y);
  else if (f === 1)
    x.copy(m).multiply(v).multiply(p).multiply(y);
  else {
    const U = new Ge().scale(new ye().setFromMatrixScale(h)).clone().invert(), S = v.clone().multiply(U);
    x.copy(m).multiply(p).multiply(S).multiply(y);
  }
  const N = l.clone().invert(), w = o.clone().invert();
  let T = e.clone().multiply(a).multiply(l).multiply(t).multiply(r).multiply(n).multiply(N).multiply(i).multiply(o).multiply(s).multiply(w);
  const _ = new Ge().copyPosition(T), L = u.clone().multiply(_);
  return d.copyPosition(L), T = d.clone().multiply(x), T.premultiply(u.invert()), T;
}
function Ox(c) {
  c = c || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return c === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[c];
}
function Ml(c) {
  return c.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Fx(c, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = c.byteLength), new TextDecoder().decode(new Uint8Array(c, e, t));
}
function QA(c, e) {
  for (let t = 0, r = c.length, n = e.length; t < n; t++, r++)
    c[r] = e[t];
}
function eC(c, e, t, r) {
  for (let n = t, s = 0; n < r; n++, s++)
    c[s] = e[n];
  return c;
}
function Zp(c, e, t) {
  return c.slice(0, e).concat(t).concat(c.slice(e));
}
const Ix = new xA();
Ix.setDecoderPath("/draco/");
class Rc extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t || new tc(0.1), r || new Cn({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isModel3D", !0);
    G(this, "_model", "");
    G(this, "_modelRoot", null);
    G(this, "_modeMatrix");
    G(this, "_object");
    G(this, "_isLoading", !1);
    G(this, "_castShadowModel", !1);
    G(this, "_receiveShadowModel", !1);
    G(this, "_objectOrgSize", new ye());
    this.type = "Model3D", this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this.onBeforeRender = () => {
      (this._castShadowModel !== this.castShadow || this._receiveShadowModel !== this.receiveShadow) && this.updateModelShadow();
    }, this.geometry.boundingBox || this.geometry.computeBoundingBox();
  }
  get model() {
    return this._model;
  }
  set model(t) {
    this._model !== t && (this._object && this._object.removeFromParent(), this._model && (this._modeMatrix = void 0), this._model = t, this.loadModel());
  }
  async loadModel() {
    if (this._object && (this._object.removeFromParent(), this._object = void 0), !this._model)
      return;
    this._isLoading = !0;
    let t;
    if (/.glb$/i.test(this._model))
      t = new rf(), t.setDRACOLoader(Ix);
    else if (/.fbx$/i.test(this._model))
      t = new jA();
    else
      throw ze.panic(`Model[${this._model}] is not supported!`);
    const r = await t.loadAsync(this._model);
    r instanceof lo ? this._object = r : this._object = r.scene, this._modelRoot = r, this._object.__isHidden = !0, this._isLoading = !1, this.material.visible = !1, this.add(this._object), this.objectAutoSize(), this.updateModelShadow();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.resizeObject();
  }
  resizeObject() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0);
    const r = this.geometry.boundingBox.getSize(new ye()).divide(this._objectOrgSize), n = Math.min(r.x, r.y, r.z);
    this._object.scale.set(n, n, n);
  }
  objectAutoSize() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    if (this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0), this._modeMatrix)
      return this._object.applyMatrix4(this._modeMatrix);
    const t = this.geometry.boundingBox.getSize(new ye()).multiply(this.scale), r = this.getWorldPosition(new ye()), n = new nr().setFromObject(this._object, !0), s = n.getCenter(new ye()), o = n.getSize(this._objectOrgSize), i = t.divide(o), a = Math.min(i.x, i.y, i.z);
    this._object.position.copy(r.sub(s).multiply(i)), this._object.scale.set(a, a, a);
  }
  updateModelShadow() {
    this._object && (this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this._object.traverse((t) => {
      t.castShadow = this._castShadowModel, t.receiveShadow = this._receiveShadowModel;
    }));
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), r.geometry = s(t.geometries, this.geometry), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        o !== this._object && r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    super.serialize(t), t.model = this._model, t.objectOrgSize = this._objectOrgSize.toArray(), this._object && (t.modeMatrix = this._object.matrix.toArray());
  }
  deserialize(t) {
    super.deserialize(t), t.objectOrgSize && this._objectOrgSize.fromArray(t.objectOrgSize), t.modeMatrix && (this._modeMatrix = new Ge().fromArray(t.modeMatrix), this._object && this._object.applyMatrix4(this._modeMatrix)), this.model = t.model;
  }
}
Ye("Model3D", {
  create: ({ material: c, geometry: e } = {}) => new Rc(e, c),
  members: {
    model: "String"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class Px extends Rc {
  constructor(e, t, r = 0, n = 0) {
    super(e || new Za(1, 1, 1), t, r, n), this.type = "StaticMesh";
  }
  rebuildBody() {
    if (!this._object)
      return;
    const e = this.world;
    if (this.physicalBody && (this.world && this.world.removeMesh(this), $s.destroyBody(this.physicalBody)), this._bodyType !== Cc.Ghost) {
      const t = $s.createShape(this._object);
      this.physicalBody = $s.createBody(this, this._mass, t), this.physicalBody.setUserIndex(this.id), e && e.addMesh(this, this.physicalBody);
    } else
      this.physicalBody = null;
  }
}
Ye("StaticMesh", {
  create: ({ material: c, geometry: e } = {}) => new Px(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    model: "String"
  },
  proto: "Entity",
  group: "Objects.Static Mesh",
  icon: "mesh"
});
class Dx extends Rc {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Gm(), r || new Cn({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isCharacter", !0);
    G(this, "actions", {});
    G(this, "_mixer");
    G(this, "_clips", []);
    G(this, "_objectOrgSize", new ye());
    this.type = "Character";
  }
  async loadModel() {
    if (await super.loadModel(), !this._object || !this._modelRoot)
      return;
    const t = this._object.getObjectByProperty("isMesh", !0);
    t && (t.onBeforeRender = () => {
      this._mixer && this._mixer.update(sn.delta);
    }), this._mixer = new Qb(this._object), this._mixer.addEventListener("finished", ({ action: r }) => {
      const n = Object.entries(this.actions).find((s) => s[1].action === r);
      n && (ze.notice(`action ${n[0]} finished!`), n[1].isPending = !1, n[1].resolve && (n[1].resolve(!0), n[1].resolve = void 0));
    }), this._clips = this._modelRoot.animations || [];
    for (const r of this._clips)
      this.actions[r.name] = { isPending: !1, action: this._mixer.clipAction(r), resolve: void 0 };
  }
  async act(t, r) {
    const n = this.actions[t];
    if (n) {
      if (n.isPending)
        return !0;
    } else
      return !1;
    n.isPending = !0;
    const s = n.action;
    return s.clampWhenFinished = !0, s.reset().setLoop(r ? eN : tN, r ? 1 / 0 : 1).setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(1).play(), new Promise((o) => {
      n.resolve = o;
    });
  }
  stop(t) {
    const r = t ? [t] : Object.keys(this.actions);
    for (const n of r) {
      const s = this.actions[n];
      if (s) {
        if (!s.isPending)
          continue;
      } else
        continue;
      s.isPending = !1, s.resolve && (s.resolve(!1), s.resolve = void 0), s.action.stop();
    }
  }
}
Ye("Character", {
  create: ({ material: c, geometry: e } = {}) => new Dx(e, c),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Model3D",
  group: "Objects.Character",
  icon: "human"
});
const kt = new ye(), tC = new ye();
class Ux extends Jm {
  constructor(t, r) {
    super(t || new Kn(), r);
    G(this, "isParticles", !0);
    G(this, "mass", 0);
    /** Resistance Coefficient */
    G(this, "airResCoe", 25e-4);
    G(this, "growSpeed", 1);
    G(this, "spaceSize", new ye(1, 1, 1));
    G(this, "bornSpaceSize", new ye(1, 1, 1));
    G(this, "bornPoint", new ye(0, 0, 0));
    G(this, "_count", 100);
    G(this, "_countFired", 0);
    G(this, "_positions", null);
    G(this, "_velocities", null);
    G(this, "_bornTime", 0);
    this.type = "Particles", this.rebuildBuffer(), this.onBeforeRender = () => {
      this.update();
    };
  }
  get count() {
    return this._count;
  }
  set count(t) {
    t <= 0 && (t = 100), this._count !== t && (this._count = t, this.rebuildBuffer());
  }
  rebuildBuffer() {
    this._countFired = 0, this.geometry.setDrawRange(0, 0);
    const t = new Float32Array(this._count * 3), r = new Float32Array(this._count * 3), n = new yn(t, 3), s = new yn(r, 3);
    n.setUsage(Tu), this.geometry.setAttribute("position", n), this._positions = n, this._velocities = s;
  }
  update() {
    for (let t = 0; t < this._countFired; t++) {
      const r = this._positions.getX(t), n = this._positions.getY(t), s = this._positions.getZ(t);
      if (this.isOutofSpace(r, n, s))
        this._positions.setXYZ(t, ...this.randBornPoint()), this._velocities.setXYZ(t, 0, 0, 0);
      else {
        const [o, i] = sn.calcObjectPosition(
          kt.set(r, n, s),
          tC.set(this._velocities.getX(t), this._velocities.getY(t), this._velocities.getZ(t)),
          this.mass,
          this.airResCoe
        );
        this._positions.setXYZ(t, ...o.toArray()), this._velocities.setXYZ(t, ...i.toArray());
      }
    }
    this.grow(), this._positions.needsUpdate = !0;
  }
  grow() {
    if (this._countFired >= this._count)
      return;
    const t = this._bornTime === 0 ? 1 : (sn.now - this._bornTime) / 1e3;
    this._bornTime || (this._bornTime = sn.now);
    const r = Math.floor(t * this.growSpeed), n = Math.min(r, this._count) - this._countFired;
    if (n <= 0)
      return;
    const s = this._countFired;
    this._countFired += n;
    for (let o = s; o < this._countFired; o++)
      this._positions.setXYZ(o, ...this.randBornPoint()), this._velocities.setXYZ(o, 0, 0, 0);
    this.geometry.setDrawRange(0, this._countFired);
  }
  isOutofSpace(t, r, n) {
    return t > this.spaceSize.x || t < -this.spaceSize.x || r > this.spaceSize.y || r < -this.spaceSize.y || n > this.spaceSize.z || n < -this.spaceSize.z;
  }
  randBornPoint() {
    return kt.copy(this.bornPoint), kt.x += this.bornSpaceSize.x * (Math.random() - 0.5) * 2, kt.y += this.bornSpaceSize.y * (Math.random() - 0.5) * 2, kt.z += this.bornSpaceSize.z * (Math.random() - 0.5) * 2, kt.x > this.spaceSize.x ? kt.x = this.spaceSize.x - 1e-5 : kt.x < -this.spaceSize.x && (kt.x = -this.spaceSize.x + 1e-5), kt.y > this.spaceSize.y ? kt.y = this.spaceSize.y - 1e-5 : kt.y < -this.spaceSize.y && (kt.y = -this.spaceSize.y + 1e-5), kt.z > this.spaceSize.z ? kt.z = this.spaceSize.z - 1e-5 : kt.z < -this.spaceSize.z && (kt.z = -this.spaceSize.z + 1e-5), kt.toArray();
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    t.mass = this.mass, t.spaceSize = this.spaceSize.toArray(), t.bornSpaceSize = this.bornSpaceSize.toArray(), t.bornPoint = this.bornPoint.toArray(), t.count = this.count, t.growSpeed = this.growSpeed, t.airResCoe = this.airResCoe;
  }
  deserialize(t) {
    t.mass !== void 0 && (this.mass = t.mass), t.spaceSize && this.spaceSize.fromArray(t.spaceSize), t.bornSpaceSize && this.bornSpaceSize.fromArray(t.bornSpaceSize), t.bornPoint && this.bornPoint.fromArray(t.bornPoint), t.count > 0 && (this.count = t.count), t.growSpeed > 0 && (this.growSpeed = t.growSpeed), t.airResCoe !== void 0 && (this.airResCoe = t.airResCoe);
  }
}
Ye("Particles", {
  members: {
    mass: "Number",
    airResCoe: "Number",
    count: "Number",
    spaceSize: "Vector3",
    bornPoint: "Vector3",
    bornSpaceSize: "Vector3",
    growSpeed: "Number"
  },
  proto: "Points",
  group: "Particles.Particles",
  icon: "box",
  create: () => new Ux()
});
class Lc extends Jt {
  constructor(e, t = {}) {
    super(e), this.isRefractor = !0, this.type = "Refractor", this.camera = new _r();
    const r = this, n = t.color !== void 0 ? new je(t.color) : new je(8355711), s = t.textureWidth || 512, o = t.textureHeight || 512, i = t.clipBias || 0, a = t.shader || Lc.RefractorShader, l = t.multisample !== void 0 ? t.multisample : 4, u = this.camera;
    u.matrixAutoUpdate = !1, u.userData.refractor = !0;
    const h = new $l(), d = new Ge(), f = new Fu(s, o, { samples: l, type: ng });
    this.material = new fs({
      name: a.name !== void 0 ? a.name : "unspecified",
      uniforms: sr.clone(a.uniforms),
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      transparent: !0
      // ensures, refractors are drawn from farthest to closest
    }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = d;
    const p = function() {
      const y = new ye(), x = new ye(), N = new Ge(), w = new ye(), T = new ye();
      return function(L) {
        return y.setFromMatrixPosition(r.matrixWorld), x.setFromMatrixPosition(L.matrixWorld), w.subVectors(y, x), N.extractRotation(r.matrixWorld), T.set(0, 0, 1), T.applyMatrix4(N), w.dot(T) < 0;
      };
    }(), m = function() {
      const y = new ye(), x = new ye(), N = new pr(), w = new ye();
      return function() {
        r.matrixWorld.decompose(x, N, w), y.set(0, 0, 1).applyQuaternion(N).normalize(), y.negate(), h.setFromNormalAndCoplanarPoint(y, x);
      };
    }(), g = function() {
      const y = new $l(), x = new mt(), N = new mt();
      return function(T) {
        u.matrixWorld.copy(T.matrixWorld), u.matrixWorldInverse.copy(u.matrixWorld).invert(), u.projectionMatrix.copy(T.projectionMatrix), u.far = T.far, y.copy(h), y.applyMatrix4(u.matrixWorldInverse), x.set(y.normal.x, y.normal.y, y.normal.z, y.constant);
        const _ = u.projectionMatrix;
        N.x = (Math.sign(x.x) + _.elements[8]) / _.elements[0], N.y = (Math.sign(x.y) + _.elements[9]) / _.elements[5], N.z = -1, N.w = (1 + _.elements[10]) / _.elements[14], x.multiplyScalar(2 / x.dot(N)), _.elements[2] = x.x, _.elements[6] = x.y, _.elements[10] = x.z + 1 - i, _.elements[14] = x.w;
      };
    }();
    function b(y) {
      d.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), d.multiply(y.projectionMatrix), d.multiply(y.matrixWorldInverse), d.multiply(r.matrixWorld);
    }
    function v(y, x, N) {
      r.visible = !1;
      const w = y.getRenderTarget(), T = y.xr.enabled, _ = y.shadowMap.autoUpdate;
      y.xr.enabled = !1, y.shadowMap.autoUpdate = !1, y.setRenderTarget(f), y.autoClear === !1 && y.clear(), y.render(x, u), y.xr.enabled = T, y.shadowMap.autoUpdate = _, y.setRenderTarget(w);
      const L = N.viewport;
      L !== void 0 && y.state.viewport(L), r.visible = !0;
    }
    this.onBeforeRender = function(y, x, N) {
      N.userData.refractor !== !0 && p(N) && (m(), b(N), g(N), v(y, x, N));
    }, this.getRenderTarget = function() {
      return f;
    }, this.dispose = function() {
      f.dispose(), r.material.dispose();
    };
  }
}
Lc.RefractorShader = {
  name: "RefractorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const sa = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
class of extends Jt {
  constructor(t, r) {
    super(t || new Er(1, 1), r || new fs({
      name: sa.name,
      uniforms: sr.clone(sa.uniforms),
      fragmentShader: sa.fragmentShader,
      vertexShader: sa.vertexShader
    }));
    G(this, "isReflector", !0);
    G(this, "props", {
      color: new je(8355711),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      multisample: 4
    });
    G(this, "renderTarget");
    G(this, "camera", new _r());
    this.type = "Reflector";
    const n = new $l(), s = new ye(), o = new ye(), i = new ye(), a = new Ge(), l = new ye(0, 0, -1), u = new mt(), h = new ye(), d = new ye(), f = new mt(), p = new Ge(), m = this.camera;
    this.renderTarget = new Fu(this.props.textureWidth, this.props.textureHeight, { samples: this.props.multisample, type: ng }), r ? this.props.color = this.material.uniforms.color.value : this.material.uniforms.color.value = this.props.color, this.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.material.uniforms.textureMatrix.value = p, this.onBeforeRender = (g, b, v) => {
      if (o.setFromMatrixPosition(this.matrixWorld), i.setFromMatrixPosition(v.matrixWorld), a.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(a), h.subVectors(o, i), h.dot(s) > 0)
        return;
      h.reflect(s).negate(), h.add(o), a.extractRotation(v.matrixWorld), l.set(0, 0, -1), l.applyMatrix4(a), l.add(i), d.subVectors(o, l), d.reflect(s).negate(), d.add(o), m.position.copy(h), m.up.set(0, 1, 0), m.up.applyMatrix4(a), m.up.reflect(s), m.lookAt(d), m.far = v instanceof _r ? v.far : 1e3, m.updateMatrixWorld(), m.projectionMatrix.copy(v.projectionMatrix), p.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), p.multiply(m.projectionMatrix), p.multiply(m.matrixWorldInverse), p.multiply(this.matrixWorld), n.setFromNormalAndCoplanarPoint(s, o), n.applyMatrix4(m.matrixWorldInverse), u.set(n.normal.x, n.normal.y, n.normal.z, n.constant);
      const y = m.projectionMatrix;
      f.x = (Math.sign(u.x) + y.elements[8]) / y.elements[0], f.y = (Math.sign(u.y) + y.elements[9]) / y.elements[5], f.z = -1, f.w = (1 + y.elements[10]) / y.elements[14], u.multiplyScalar(2 / u.dot(f)), y.elements[2] = u.x, y.elements[6] = u.y, y.elements[10] = u.z + 1 - this.props.clipBias, y.elements[14] = u.w, this.visible = !1;
      const x = g.getRenderTarget(), N = g.xr.enabled, w = g.shadowMap.autoUpdate;
      g.xr.enabled = !1, g.shadowMap.autoUpdate = !1, g.setRenderTarget(this.renderTarget), g.state.buffers.depth.setMask(!0), g.autoClear === !1 && g.clear(), g.render(b, m), g.xr.enabled = N, g.shadowMap.autoUpdate = w, g.setRenderTarget(x);
      const T = v.viewport;
      T !== void 0 && g.state.viewport(T), this.visible = !0;
    };
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t);
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  dispose() {
    this.renderTarget.dispose(), this.material.dispose();
  }
  clone(t) {
    const r = super.clone(t), n = er(this.props);
    return tr(r.props, n), r;
  }
  serialize(t) {
    t.props = er(this.props);
  }
  deserialize(t) {
    t.props && tr(this.props, t.props);
  }
}
Ye("Reflector", {
  members: {
    castShadow: "Boolean",
    receiveShadow: "Boolean",
    color: "Color",
    textureWidth: "Number",
    textureHeight: "Number",
    clipBias: "Number"
  },
  proto: "Object3D",
  group: "Objects.Reflector",
  icon: "plane",
  create: ({ geometry: c, material: e } = {}) => new of(c, e)
});
const Ea = 0.15, ra = Ea * 0.5, io = class io extends Nn {
  constructor(t, r) {
    super(t || new Er(10, 10), r || new fs({
      uniforms: sr.merge([
        co.fog,
        io.WaterShader.uniforms
      ]),
      vertexShader: io.WaterShader.vertexShader,
      fragmentShader: io.WaterShader.fragmentShader,
      transparent: !0,
      fog: !0
    }), 0, 0);
    G(this, "isWaterPlane", !0);
    G(this, "props", {
      color: new je(),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      flowDirection: new Tt(1, 0),
      flowSpeed: 0.03,
      reflectivity: 0.02,
      scale: 1
    });
    G(this, "textureMatrix", new Ge());
    G(this, "reflector");
    G(this, "refractor");
    G(this, "refractorClipBias");
    this.type = "WaterPlane", t || (this.rotation.x = -Math.PI / 2);
    const n = new of(t);
    n.textureWidth = this.props.textureWidth, n.textureHeight = this.props.textureHeight, n.clipBias = this.props.clipBias;
    const s = new Lc(t, {
      textureWidth: this.props.textureWidth,
      textureHeight: this.props.textureHeight,
      clipBias: 0
    });
    if (this.refractorClipBias = s.camera.projectionMatrix.elements[10], n.matrixAutoUpdate = !1, s.matrixAutoUpdate = !1, this.reflector = n, this.refractor = s, r)
      this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.props.flowDirection = this.material.uniforms.flowDirection.value, this.props.color = this.material.uniforms.color.value, this.props.reflectivity = this.material.uniforms.reflectivity.value, this.textureMatrix = this.material.uniforms.textureMatrix.value, this.props.scale = this.material.uniforms.config.value.w;
    else {
      this.material.uniforms.flowDirection = {
        type: "v2",
        value: this.props.flowDirection
      };
      const o = new Vn(), i = new Vn();
      o.wrapS = o.wrapT = Ks, i.wrapS = i.wrapT = Ks, this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = o, this.material.uniforms.tNormalMap1.value = i, this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = ra, this.material.uniforms.config.value.z = ra, this.material.uniforms.config.value.w = this.props.scale;
    }
    this.onBeforeRender = function(o, i, a) {
      this.updateTextureMatrix(a), this.updateFlow(), this.visible = !1, n.matrixWorld.copy(this.matrixWorld), s.matrixWorld.copy(this.matrixWorld), n.onBeforeRender(o, i, a, null, null, null), s.onBeforeRender(o, i, a, null, null, null), this.visible = !0;
    };
  }
  get normalMap0() {
    return this.material.uniforms.tNormalMap0.value;
  }
  set normalMap0(t) {
    const r = this.material.uniforms.tNormalMap0.value;
    r !== t && (this.material.uniforms.tNormalMap0.value = t, r.dispose());
  }
  get normalMap1() {
    return this.material.uniforms.tNormalMap1.value;
  }
  set normalMap1(t) {
    const r = this.material.uniforms.tNormalMap1.value;
    r !== t && (this.material.uniforms.tNormalMap1.value = t, r.dispose());
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t, this.reflector.clipBias = t);
  }
  get flowDirection() {
    return this.props.flowDirection;
  }
  set flowDirection(t) {
    this.props.flowDirection !== t && (this.props.flowDirection = t, this.material.uniforms.flowDirection.value = t);
  }
  get flowSpeed() {
    return this.props.flowSpeed;
  }
  set flowSpeed(t) {
    this.props.flowSpeed !== t && (this.props.flowSpeed = t);
  }
  get reflectivity() {
    return this.props.reflectivity;
  }
  set reflectivity(t) {
    this.props.reflectivity !== t && (this.props.reflectivity = t, this.material.uniforms.reflectivity.value = this.props.reflectivity);
  }
  get waterScale() {
    return this.props.scale;
  }
  set waterScale(t) {
    this.props.scale !== t && (this.props.scale = t, this.material.uniforms.config.value.w = this.props.scale);
  }
  appleProps() {
    this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.flowDirection.value = this.props.flowDirection, this.material.uniforms.config.value.w = this.props.scale, this.reflector.textureWidth = this.props.textureWidth, this.reflector.textureHeight = this.props.textureHeight, this.reflector.clipBias = this.props.clipBias, this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight);
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Vt], s = er(n), o = r.props[Vt];
    return tr(o, s), o.appleProps(), r;
  }
  serialize(t) {
    super.serialize(t), t.props = er(this.props);
  }
  deserialize(t) {
    super.deserialize(t), t.props && (tr(this.props, t.props), this.appleProps());
  }
  dispose() {
    this.reflector.dispose(), this.refractor.dispose();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.reflector.geometry = this.geometry, this.refractor.geometry = this.geometry;
  }
  updateTextureMatrix(t) {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(t.projectionMatrix), this.textureMatrix.multiply(t.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld);
  }
  updateFlow() {
    const t = this.material.uniforms.config;
    t.value.x += this.props.flowSpeed * sn.delta, t.value.y = t.value.x + ra, t.value.x >= Ea ? (t.value.x = 0, t.value.y = ra) : t.value.y >= Ea && (t.value.y = t.value.y - Ea);
  }
};
G(io, "WaterShader", {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new mt()
    }
  },
  vertexShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_vertex>
      #include <logdepthbuf_pars_vertex>
  
      uniform mat4 textureMatrix;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        vUv = uv;
        vCoord = textureMatrix * vec4( position, 1.0 );
  
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vToEye = cameraPosition - worldPosition.xyz;
  
        vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
        gl_Position = projectionMatrix * mvPosition;
  
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
  
      }`
  ),
  fragmentShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_fragment>
      #include <logdepthbuf_pars_fragment>
  
      uniform sampler2D tReflectionMap;
      uniform sampler2D tRefractionMap;
      uniform sampler2D tNormalMap0;
      uniform sampler2D tNormalMap1;
  
      #ifdef USE_FLOWMAP
        uniform sampler2D tFlowMap;
      #else
        uniform vec2 flowDirection;
      #endif
  
      uniform vec3 color;
      uniform float reflectivity;
      uniform vec4 config;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        #include <logdepthbuf_fragment>
  
        float flowMapOffset0 = config.x;
        float flowMapOffset1 = config.y;
        float halfCycle = config.z;
        float scale = config.w;
  
        vec3 toEye = normalize( vToEye );
  
        // determine flow direction
        vec2 flow;
        #ifdef USE_FLOWMAP
          flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
        #else
          flow = flowDirection;
        #endif
        flow.x *= - 1.0;
  
        // sample normal maps (distort uvs with flowdata)
        vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
        vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );
  
        // linear interpolate to get the final normal color
        float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
        vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );
  
        // calculate normal vector
        vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
  
        // calculate the fresnel term to blend reflection and refraction maps
        float theta = max( dot( toEye, normal ), 0.0 );
        float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );
  
        // calculate final uv coords
        vec3 coord = vCoord.xyz / vCoord.w;
        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;
  
        vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
        vec4 refractColor = texture2D( tRefractionMap, uv );
  
        // multiply water color with the mix of both textures
        gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );
  
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
  
      }`
  )
});
let yu = io;
const Al = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new ye() },
    up: { value: new ye(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
}, nC = new xn();
class zx extends Jt {
  constructor(t, r) {
    super(t || new Za(1, 1, 1), r || new fs({
      name: "SkyShader",
      fragmentShader: Al.fragmentShader,
      vertexShader: Al.vertexShader,
      uniforms: sr.clone(Al.uniforms),
      side: Su,
      depthWrite: !1
    }));
    G(this, "isSkyBox", !0);
    G(this, "_renderTarget");
    G(this, "_pmremGenerator");
    G(this, "_sceneTmp", new Qa());
    G(this, "_sceneRoot");
    G(this, "_sun");
    G(this, "_sunPosition");
    this.type = "SkyBox", t || this.scale.multiplyScalar(1e3), r || (this.material.uniforms.turbidity.value = 10, this.material.uniforms.rayleigh.value = 2, this.material.uniforms.mieCoefficient.value = 5e-3, this.material.uniforms.mieDirectionalG.value = 0.8, this.material.uniforms.sunPosition.value.copy(this.calSunPosition(2, 180))), this._sunPosition = this.material.uniforms.sunPosition.value, this.onBeforeRender = async (n, s, o) => {
      this._sceneRoot = s, this._sun && typeof this._sun == "string" && (this._sun = s.getObjectByProperty("uuid", this._sun)), this._renderTarget || (this._renderTarget = 1, this._pmremGenerator = new nN(n), this.updateRenderTarget()), this._sun && !this._sun.position.equals(this._sunPosition) && this.updateSunPotision();
    };
  }
  get turbidity() {
    return this.material.uniforms.turbidity.value;
  }
  set turbidity(t) {
    this.material.uniforms.turbidity.value = t;
  }
  get rayleigh() {
    return this.material.uniforms.rayleigh.value;
  }
  set rayleigh(t) {
    this.material.uniforms.rayleigh.value = t;
  }
  get mieCoefficient() {
    return this.material.uniforms.mieCoefficient.value;
  }
  set mieCoefficient(t) {
    this.material.uniforms.mieCoefficient.value = t;
  }
  get mieDirectionalG() {
    return this.material.uniforms.mieDirectionalG.value;
  }
  set mieDirectionalG(t) {
    this.material.uniforms.mieDirectionalG.value = t;
  }
  get sunPosition() {
    return this.material.uniforms.sunPosition.value;
  }
  set sunPosition(t) {
    this.material.uniforms.sunPosition.value.copy(t);
  }
  get sun() {
    return nC;
  }
  set sun(t) {
    t instanceof bi && (this._sun = t, this.updateSunPotision());
  }
  calSunPosition(t, r) {
    const n = Qt.degToRad(90 - t), s = Qt.degToRad(r), o = new ye();
    return o.setFromSphericalCoords(1, n, s), o;
  }
  updateSunPotision() {
    typeof this._sun == "object" && (this.material.uniforms.sunPosition.value.copy(this._sun.position), this.updateRenderTarget());
  }
  updateRenderTarget() {
    if (this._renderTarget !== void 0 && typeof this._renderTarget == "object" && this._renderTarget.dispose(), !this._pmremGenerator)
      return;
    const t = this.parent, r = t ? t.children.indexOf(this) : -1;
    t && t.children.splice(r, 1), this._sceneTmp.children.push(this), this._renderTarget = this._pmremGenerator.fromScene(this._sceneTmp), t && (r !== -1 ? t.children.splice(r, 0, this) : t.children.push(this)), this._sceneRoot && (this._sceneRoot.background = this._renderTarget.texture, this._sceneRoot.environment = this._renderTarget.texture);
  }
  serialize(t) {
    t.scale = this.scale.toArray(), t.turbidity = this.turbidity, t.rayleigh = this.rayleigh, t.mieCoefficient = this.mieCoefficient, t.mieDirectionalG = this.mieDirectionalG, t.sunPosition = this.sunPosition.toArray(), this._sun && (t.sun = this._sun.uuid || this._sun);
  }
  deserialize(t) {
    this.scale.fromArray(t.scale), this.turbidity = t.turbidity, this.rayleigh = t.rayleigh, this.mieCoefficient = t.mieCoefficient, this.mieDirectionalG = t.mieDirectionalG, this.sunPosition.fromArray(t.sunPosition), t.sun && (this._sun = t.sun), this.updateRenderTarget();
  }
}
Ye(
  "SkyBox",
  {
    members: {
      scale: "Vector3",
      turbidity: "Number",
      rayleigh: "Number",
      mieCoefficient: "Number",
      mieDirectionalG: "Number",
      sun: "Object3D"
    },
    proto: "Object3D",
    group: "Objects.Sky Box",
    icon: "box",
    create: ({ geometry: c, material: e } = {}) => new zx(c, e)
  }
);
Kn.prototype.computeBoundsTree = gN;
Kn.prototype.disposeBoundsTree = yN;
Jt.prototype.raycast = vN;
class nn extends Oe {
  constructor(t, r, n) {
    super("void");
    G(this, "isObjectNode", !0);
    G(this, "typesExtended", { in: {}, out: {} });
    G(this, "isObject3DNode");
    G(this, "eventDispatcher", null);
    G(this, "_object", null);
    G(this, "_objectRaw", null);
    this._inst = t, this.objectType = r, n && (this.object = n), this.updateType = "none", this.isObject3DNode = fi(r, "Object3D"), this.initTypes();
  }
  get object() {
    return this._object;
  }
  set object(t) {
    if (typeof t != "object" || !a_(t, this.objectType))
      throw ze.panic(`type is not compitable, expected type is ${this.objectType}!`);
    this._objectRaw = t, this._object = new Proxy(t, {
      get(r, n, s) {
        if (n === Vt)
          return r;
        if (typeof n != "string")
          return Reflect.get(r, n, s);
        const o = n.split(".");
        if (o.length > 1) {
          let i = Reflect.get(r, o[0], s);
          for (let a = 1; a < o.length; a++)
            i = i[o[a]];
          return i;
        }
        return Reflect.get(r, n, s);
      },
      set: (r, n, s, o) => {
        if (typeof n != "string")
          return Reflect.set(r, n, s, o);
        if (Reflect.get(r, n, o) === s)
          return !0;
        let a = !0;
        const l = n.split(".");
        if (l.length > 1) {
          let u = Reflect.get(r, l[0], o);
          const h = l.pop();
          for (let d = 1; d < l.length; d++)
            u = u[l[d]];
          if (u[h] === s)
            return !0;
          u[h] = s;
        } else
          a = Reflect.set(r, n, s, r);
        if (this.eventDispatcher) {
          const u = !!this.typesExtended.in[n];
          this.eventDispatcher.dispatchEvent({ type: u ? "nodeEventInputChanged" : "nodeEventOutputChanged", source: null, node: this, fields: [n] });
        }
        return a;
      }
    }), (t instanceof xn || t instanceof M.Material) && (this.objectType = t.type, this.initTypes()), Object.defineProperty(this, "_object", {
      writable: !1
    });
  }
  getObjectsExtended() {
    return { in: this.object, out: this.object };
  }
  fill(t, r) {
    this._object && typeof this._object == "string" && (this.object = r[this._object] || t.getObjectByProperty("uuid", this._object));
  }
  dispose() {
    this._object && this._object instanceof Vn && this._object.dispose();
  }
  toJSON(t) {
    const r = super.toJSON(t);
    if (this._object instanceof Vn) {
      const n = this._object.toJSON(t);
      t.textures[this._object.uuid] = n;
    }
    return r;
  }
  serialize(t) {
    if (!this._object)
      throw ze.panic("object has not been set before serialize!");
    super.serialize(t), t._inst = this._inst, t.object = this._object.uuid, t.objectType = this.objectType;
  }
  deserialize(t) {
    if (!fi(t.objectType, this.objectType))
      throw ze.panic(`type is not compitable, expected type is ${this.objectType}!`);
    super.deserialize(t), this._object = t.object, this.initTypes();
  }
  createDefault(t) {
    if (this.isObject3DNode)
      this.object = t, this.objectType = t.type, this.initTypes();
    else {
      const r = M[this.objectType];
      if (!r)
        throw ze.panic(`class[${this.objectType}] not found in THREE!`);
      this.object = new r();
    }
  }
  initTypes() {
    const t = Xa(this.objectType);
    if (!t)
      throw ze.panic(`class[${this.objectType}] not found!`);
    _s(this.typesExtended.in), Object.assign(this.typesExtended.in, t.in), _s(this.typesExtended.out), Object.assign(this.typesExtended.out, t.out);
  }
}
Ls(
  "ObjectNode",
  nn,
  {
    // @ts-expect-error
    object: "Object3D | Texture"
  },
  "",
  {
    object3DRef: { clsName: "ObjectNode", func: () => new nn("object3DRef", "Object3D"), group: "Objects.Object", icon: "box" },
    texture: { clsName: "ObjectNode", func: () => new nn("texture", "Texture"), group: "Inputs.Primitives.Texture", icon: "photo" }
    // cubeTexture: { clsName: 'CubeTexture', func: () => new ObjectNode('cubeTexture', 'CubeTexture'), group: 'Inputs.Primitives.Cube Texture', icon: 'photo' },
  }
);
const Bx = {
  Boolean: {
    fromJson: (c) => new Boolean(c),
    toJson: (c) => c
  },
  Number: {
    fromJson: (c) => c ?? 0,
    toJson: (c) => c
  },
  String: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Url: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Script: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Color: {
    fromJson: (c) => new je().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector2: {
    fromJson: (c) => new Tt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector3: {
    fromJson: (c) => new ye().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector4: {
    fromJson: (c) => new mt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Euler: {
    fromJson: (c) => new Ss().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  // uniformNode for gpu
  bool: {
    label: "bool UniformNode",
    fromJson: function(c) {
      const e = new nt(!1, "bool");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  float: {
    label: "float UniformNode",
    fromJson: function(c) {
      const e = new nt(0, "float");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  color: {
    label: "color UniformNode",
    fromJson: function(c) {
      const e = new nt(new je(), "color");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec2: {
    label: "vec2 UniformNode",
    fromJson: function(c) {
      const e = new nt(new Tt());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec3: {
    label: "vec3 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ye());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec4: {
    label: "vec4 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ye());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  int: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "int");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ts());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  code: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  uint: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "uint");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  void: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  property: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  sampler: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  cubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  ivec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Tt(), "ivec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Tt(), "uvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Tt(), "bvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "ivec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "uvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "bvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new mt(), "ivec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new mt(), "uvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new mt(), "bvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ts(), "imat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ts(), "umat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ts(), "bmat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "imat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "umat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "bmat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix3: {
    label: void 0,
    fromJson: (c) => new Ts(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix4: {
    label: void 0,
    fromJson: (c) => new Ge(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Audio: {
    label: void 0,
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Image: {
    label: void 0,
    fromJson: function(c) {
      const e = document.createElement("img");
      return c != null && c.src && (e.src = c.src), e;
    },
    toJson: function(c) {
      return { src: c.src };
    }
  },
  Texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  CubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Material: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Object3D: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  }
};
function oa(c, e) {
  return Bx[c].fromJson(e);
}
function Qp(c, e) {
  return Bx[c].toJson(e);
}
const kx = globalThis.AsyncFunction || (async (c) => c).constructor;
class wo extends nn {
  constructor(t, r, n = !0) {
    super(t, "Object3D", r);
    G(this, "isScriptNode", !0);
    G(this, "inputs");
    G(this, "outputs");
    G(this, "enabled", !1);
    G(this, "_parametersProps", ["params", "out", "THREE", "TSL", "world", "window", "document"]);
    G(this, "_parameters", [null, null, M, D1, sn, null, null]);
    G(this, "_code", "");
    // eslint-disable-next-line @typescript-eslint/ban-types
    G(this, "_main");
    this.editable = n, this.inputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this.outputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventOutputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this._parameters[0] = this.inputs, this._parameters[1] = this.outputs, this._main = this.compile();
  }
  get code() {
    return this._code;
  }
  set code(t) {
    this._code = t;
    try {
      this._main = this.compile();
    } catch (r) {
      console.warn(r);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this._code && this.object && await this._main.call(this._objectRaw, ...this._parameters);
  }
  getObjectsExtended() {
    return { in: this.inputs, out: this.outputs };
  }
  initTypes() {
  }
  addInput(t, r) {
    if (this.typesExtended.in[t])
      return;
    this.typesExtended.in[t] = { types: [r], direct: "in", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = oa(r);
    return this.inputs[t] = n, n;
  }
  removeInput(t) {
    return this.typesExtended.in[t] ? (delete this.typesExtended.in[t], delete this.inputs[t], !0) : !1;
  }
  addOutput(t, r) {
    if (this.typesExtended.out[t])
      return;
    this.typesExtended.out[t] = { types: [r], direct: "out", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = oa(r);
    return this.outputs[t] = n, n;
  }
  removeOutput(t) {
    return this.typesExtended.out[t] ? (delete this.typesExtended.out[t], delete this.outputs[t], !0) : !1;
  }
  serialize(t) {
    var r;
    super.serialize(t), t.object = (r = this.object) == null ? void 0 : r.uuid, t.types = { ...this.typesExtended }, t.enabled = this.enabled, t.inputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.in))
      t.inputs[n] = Qp(s.types[0], this.inputs[n]);
    t.outputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.out))
      t.outputs[n] = Qp(s.types[0], this.outputs[n]);
    t.code = this._code;
  }
  deserialize(t) {
    var r, n;
    super.deserialize(t), (r = t.types) != null && r.in && (_s(this.typesExtended.in), Object.assign(this.typesExtended.in, t.types.in));
    for (const [s, o] of Object.entries(this.typesExtended.in)) {
      const i = t.inputs ? t.inputs[s] : void 0;
      this.inputs[s] = oa(o.types[0], i);
    }
    (n = t.types) != null && n.out && (_s(this.typesExtended.out), Object.assign(this.typesExtended.out, t.types.out));
    for (const [s, o] of Object.entries(this.typesExtended.out)) {
      const i = t.outputs ? t.outputs[s] : void 0;
      this.outputs[s] = oa(o.types[0], i);
    }
    t.code !== void 0 && (this.code = t.code), this.enabled = t.enabled;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new kx(this._parametersProps, this._code);
  }
}
Ls(
  "ScriptNode",
  wo,
  {
    enabled: "Boolean",
    code: "Script"
  },
  "ObjectNode"
);
class Mn extends wo {
  constructor() {
    super(...arguments);
    G(this, "isScriptBlockNode", !0);
    G(this, "_prev");
    G(this, "_next");
  }
  get prev() {
    return this._prev;
  }
  set prev(t) {
    this._prev = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this.object && (this._code ? await this._main.call(this._objectRaw, ...this._parameters) : !0) !== !1 && this._next && await this._next.exec(t);
  }
  fill(t, r) {
    super.fill(t, r), this.prev && typeof this.prev == "string" && (this.prev = r[this.prev]), this.next && typeof this.next == "string" && (this.next = r[this.next]);
  }
  serialize(t) {
    var r, n;
    super.serialize(t), t.prev = (r = this.prev) == null ? void 0 : r.uuid, t.next = (n = this.next) == null ? void 0 : n.uuid;
  }
  deserialize(t) {
    super.deserialize(t), this.prev = t.prev, this.next = t.next;
  }
}
Ls("ScriptBlockNode", Mn, {}, "ScriptNode", {
  scriptBlock: { clsName: "UpdateNode", func: () => new Mn("scriptBlock"), group: "Scripts.Script Block", icon: "brand-javascript" }
});
class fr extends Mn {
  constructor(t, r, n, s) {
    super(t, n);
    G(this, "isEventListenerNode", !0);
    G(this, "_event", "onBorn");
    G(this, "_eventSource");
    G(this, "_listener");
    r && (this._event = r), this._eventSource = s || this.object;
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t, this._eventSource || (this._eventSource = t), this.resetEventlisten(this._event);
  }
  get event() {
    return this._event;
  }
  set event(t) {
    this.resetEventlisten(t), this._event = t;
  }
  serialize(t) {
    super.serialize(t), t.event = this.event;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event;
  }
  resetEventlisten(t) {
    this.object === null || typeof this.object != "object" || (this._listener && this._eventSource.removeEventListener(this.event, this._listener), this._listener = (r) => {
      this.exec(r);
    }, this._eventSource.addEventListener(t, this._listener));
  }
  dispose() {
    super.dispose(), this._listener && typeof this.object == "object" && this._eventSource.removeEventListener(this.event, this._listener);
  }
}
Ls("EventListenerNode", fr, {
  event: "String"
}, "ScriptBlockNode", {
  eventOnBorn: { clsName: "EventListenerNode", func: () => new fr("eventOnBorn", "onBorn"), group: "Scripts.On Born", icon: "loader" },
  eventOnDead: { clsName: "EventListenerNode", func: () => new fr("eventOnDead", "onDead"), group: "Scripts.On Dead", icon: "bell-off" },
  eventOnCollisionEnter: { clsName: "EventListenerNode", func: () => new fr("eventOnCollisionEnter", "onCollisionEnter"), group: "Scripts.On Collision Enter", icon: "arrows-shuffle" },
  eventOnCollisionLeave: { clsName: "EventListenerNode", func: () => new fr("eventOnCollisionLeave", "onCollisionLeave"), group: "Scripts.On Collision Leave", icon: "arrow-bounce" },
  eventCustom: { clsName: "EventListenerNode", func: () => new fr("eventCustom", "onCustomEvent"), group: "Scripts.On Custom Event", icon: "calendar-event" }
});
class em extends wo {
  constructor(t, r) {
    super(t, r);
    G(this, "isUpdateNode", !0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdate(t, r, n, s) {
    if (this.enabled && this._code && this.object)
      try {
        this._main.call(this._objectRaw, ...this._parameters, n, s);
      } catch (o) {
        console.error(o);
      }
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new Function(...this._parametersProps, "delta", "now", this._code);
  }
}
Ls("UpdateNode", em, {}, "ScriptNode", {
  update: { clsName: "UpdateNode", func: () => new em("update"), group: "Scripts.On Update", icon: "refresh" }
});
class tm extends Mn {
  constructor(t, r) {
    super(t, r);
    G(this, "isKeyboardNode", !0);
    G(this, "event", "keydown");
    G(this, "key", "");
    G(this, "_listenerKeyDown");
    G(this, "_listenerKeyUp");
    G(this, "_listenerBorn");
    G(this, "_listenerDead");
    G(this, "_isActived", !1);
    this._listenerKeyDown = (s) => {
      this.exec(s);
    }, this._listenerKeyUp = (s) => {
      this.exec(s);
    }, this._listenerBorn = () => {
      this._isActived = !0;
    }, this._listenerDead = () => {
      this._isActived = !1;
    };
    const n = ["_listenerKeyDown", "_listenerKeyUp"];
    window.addEventListener("keydown", this._listenerKeyDown), window.addEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), n.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const s of n)
      Object.defineProperty(this, s, {
        writable: !1
      });
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t;
    const r = [];
    this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), r.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const n of r)
      Object.defineProperty(this, n, {
        writable: !1
      });
  }
  async exec(t) {
    if (this._isActived && !(t.type !== this.event || t.key !== this.key))
      return super.exec(t);
  }
  serialize(t) {
    super.serialize(t), t.event = this.event, t.key = this.key;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event, this.key = t.key;
  }
  dispose() {
    super.dispose(), window.removeEventListener("keydown", this._listenerKeyDown), window.removeEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.removeEventListener("onBorn", this._listenerBorn), this.object.removeEventListener("onDead", this._listenerDead));
  }
}
Ls("KeyboardNode", tm, {
  event: '"keydown"|"keyup"',
  key: '"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"'
}, "ScriptBlockNode", {
  keyboardEvent: { clsName: "KeyboardNode", func: () => new tm("keyboardEvent"), group: "Scripts.On Keyboard", icon: "keyboard" }
});
const sC = {
  lineBasicMaterial: { clsName: "LineBasicMaterial", func: () => new M.LineBasicMaterial(), group: "Material.Line Basic Material", icon: "brand-medium" },
  // lineBasicNodeMaterial: { clsName: 'LineBasicNodeMaterial', func: () => new Nodes.LineBasicNodeMaterial(), group: 'Material.Line Basic Material Node', icon: 'brand-medium' },
  meshBasicMaterial: { clsName: "MeshBasicMaterial", func: () => new M.MeshBasicMaterial(), group: "Material.Mesh Basic Material", icon: "brand-medium" },
  // meshBasicNodeMaterial: { clsName: 'MeshBasicNodeMaterial', func: () => new Nodes.MeshBasicNodeMaterial(), group: 'Material.Mesh Basic Material Node', icon: 'brand-medium' },
  meshPhysicalMaterial: { clsName: "MeshPhysicalMaterial", func: () => new M.MeshPhysicalMaterial({}), group: "Material.Mesh Physical Material", icon: "brand-medium" },
  // meshPhysicalNodeMaterial: { clsName: 'MeshPhysicalNodeMaterial', func: () => new Nodes.MeshPhysicalNodeMaterial({}), group: 'Material.Mesh Physical Material Node', icon: 'brand-medium' },
  meshStandardMaterial: { clsName: "MeshStandardMaterial", func: () => new M.MeshStandardMaterial(), group: "Material.Mesh Standard Material", icon: "brand-medium" },
  // meshStandardNodeMaterial: { clsName: 'MeshStandardNodeMaterial', func: () => new Nodes.MeshStandardNodeMaterial(), group: 'Material.Mesh Standard Material Node', icon: 'brand-medium' },
  pointsMaterial: { clsName: "PointsMaterial", func: () => new M.PointsMaterial(), group: "Material.Points Material", icon: "brand-medium" },
  // pointsNodeMaterial: { clsName: 'PointsNodeMaterial', func: () => new Nodes.PointsNodeMaterial(), group: 'Material.Points Material Node', icon: 'brand-medium' },
  spriteMaterial: { clsName: "SpriteMaterial", func: () => new M.SpriteMaterial(), group: "Material.Sprite Material", icon: "brand-medium" },
  // spriteNodeMaterial: { clsName: 'SpriteNodeMaterial', func: () => new Nodes.SpriteNodeMaterial(), group: 'Material.Sprite Material Node', icon: 'brand-medium' },
  pongMaterial: { clsName: "MeshPhongMaterial", func: () => new M.MeshPhongMaterial(), group: "Material.Phong Material", icon: "brand-medium" },
  toonMaterial: { clsName: "MeshToonMaterial", func: () => new M.MeshToonMaterial({ color: 16777215, refractionRatio: 0.98 }), group: "Material.Toon Material", icon: "brand-medium" },
  normalMaterial: { clsName: "MeshNormalMaterial", func: () => new M.MeshNormalMaterial(), group: "Material.Normal Material", icon: "brand-medium" },
  matcapMaterial: { clsName: "MeshMatcapMaterial", func: () => new M.MeshMatcapMaterial(), group: "Material.Matcap Material", icon: "brand-medium" },
  lambertMaterial: { clsName: "MeshLambertMaterial", func: () => new M.MeshLambertMaterial(), group: "Material.Lambert Material", icon: "brand-medium" },
  depthMaterial: { clsName: "MeshDepthMaterial", func: () => new M.MeshDepthMaterial(), group: "Material.Depth Material", icon: "brand-medium" }
};
for (const [c, e] of Object.entries(sC))
  Ac(c, e);
function Ra(c, e) {
  return c instanceof nn ? c : new Proxy(c, {
    get(t, r, n) {
      if (r === Vt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      if (Reflect.has(t, `${r}Node`)) {
        const o = Reflect.get(t, `${r}Node`, n);
        if (o !== null)
          return o;
      }
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      let o = r;
      Reflect.has(t, `${r}Node`) && n && n.isNode && (o = `${r}Node`);
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else {
        if (Reflect.get(t, o, s) === n)
          return !0;
        i = Reflect.set(t, o, n, s);
      }
      return i && e.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: c, fields: [r] }), i;
    }
  });
}
class af extends Mn {
  constructor(t, r, n, s) {
    super(t, s, !1);
    G(this, "isEffectNode", !0);
    _s(this.typesExtended.in), _s(this.inputs);
    for (const [o, i] of Object.entries(r.in || {}))
      this.addInput(o, i);
    _s(this.typesExtended.out), _s(this.outputs);
    for (const [o, i] of Object.entries(r.out || {}))
      this.addOutput(o, i);
    n && (this.code = n);
  }
  serialize(t) {
    super.serialize(t), delete t.code, delete t.types;
  }
}
Ls("EffectNode", af, {}, "ScriptBlockNode");
function cf(c, e, t, r) {
  return Ac(c, {
    clsName: "EffectNode",
    func: () => new af(c, t, r),
    group: `Effects.${e}`,
    icon: "polygon"
  });
}
cf(
  "FallingPoints",
  "Falling Points",
  {
    in: {
      speed: "Number",
      size: "Number",
      maxCount: "Number"
    }
  },
  `const worldPosition = this.getWorldPosition(new THREE.Vector3());
const initialPosition = world.combineBuffer(this, 'position', params.maxCount || 1000);
const geometry = new THREE.BufferGeometry();

this.traverse(function (child) {
  if (child.isMesh) {
    child.material.visible = false;
  }
} );

geometry.setAttribute( 'position', initialPosition.clone() );
geometry.attributes.position.setUsage( THREE.DynamicDrawUsage );

const size = params.size || 0.02;
const mesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size, color: 0xffffff } ) );
const positions = geometry.attributes.position;
const count = positions.count;
const speed = params.speed || 5;
const minY = -worldPosition.y;
let resolve;
const promise = new Promise((rslv) => resolve = rslv);

mesh.onBeforeRender = () => {
  const delta = world.delta;
  let verticesDown = 0;

  for ( let i = 0; i < count; i ++ ) {
    const px = positions.getX( i );
    const py = positions.getY( i );
    const pz = positions.getZ( i );

    if ( py > minY ) {
      positions.setXYZ(
        i,
        px + 1.5 * ( 0.50 - Math.random() ) * speed * delta,
        py + 3.0 * ( 0.25 - Math.random() ) * speed * delta,
        pz + 1.5 * ( 0.50 - Math.random() ) * speed * delta
      );
    } else {
      verticesDown += 1;
    }
  }

  // all vertices down
  if ( verticesDown >= count ) {
    resolve();
  }
  positions.needsUpdate = true;
};
this.add(mesh);
await promise;
this.removeFromParent();
`
);
class Gx extends xn {
  constructor(t, r, n) {
    super();
    G(this, "isEffect", !0);
    G(this, "props");
    this.geometry = t, this.material = r, this.type = "Effect", this.props = Qd({ ...n }, (s, o) => {
      this.onPropsChanged([s], [o]);
    }), this.addEventListener("added", async () => {
      await this.onAttached();
    }), this.addEventListener("removed", async () => {
      await this.onDetached();
    });
  }
  async onAttached() {
    await this.build();
  }
  onPropsChanged(t, r) {
  }
  onDetached() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  async build() {
  }
  dispose() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  clone(t) {
    const r = super.clone(t), n = er(this.props), s = r.props[Vt];
    return tr(s, n), r;
  }
  serialize(t) {
    t.props = er(this.props);
  }
  deserialize(t) {
    if (t.props) {
      const r = this.props[Vt];
      tr(r, t.props), this.build();
    }
  }
}
Ye(
  "Effect",
  {
    members: {},
    proto: "Object3D",
    group: "",
    icon: "",
    create: () => new Gx()
  }
);
const vu = {};
function Vx(c, e) {
  if (vu[c])
    throw ze.panic(`Class[${c}] aready exists`);
  return vu[c] = e, Ye(c, e);
}
function rC(c, e) {
  const t = vu[c];
  if (!t)
    throw ze.panic(`Class[${c}] not found!`);
  return t.create(e);
}
sn.createEffect = rC;
class oC extends Gx {
  constructor() {
    super(void 0, void 0, { maxCount: 1e3, texture: "", lerpPosition: 0, intensity: 0.04, size: 4 });
    G(this, "isEffectBurning", !0);
    this.type = "EffectBurning";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPropsChanged(t, r) {
    const n = this.parent;
    if (!n || !(n instanceof Jt))
      return;
    t.includes("maxCount") && (this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.build());
    let s = !1;
    if (t.includes("lerpPosition"))
      if (this.material) {
        const o = Mt("targetPosition", "vec3"), i = Ft(this.props.lerpPosition), a = bn(rn, o, i);
        this.material.positionNode = a, this.material.uniformsNeedUpdate = !0;
      } else
        s = !0;
    t.includes("texture") && (s = !0), s && (this.material && (this.material.dispose(), this.material = void 0), this.build());
  }
  async buildMaterial() {
    if (!this.props.texture)
      return;
    const t = Mt("targetPosition", "vec3"), r = Mt("particleSize", "float"), n = Ft(this.props.lerpPosition), s = bn(rn, t, n), o = await new Ru().loadAsync(this.props.texture);
    o.colorSpace = vn;
    const i = Mt("particleSpeed", "float"), a = Mt("particleIntensity", "float"), l = id(1), u = lv(
      rt(6, 6),
      // count
      xv,
      // uv
      l.mul(i)
      // current frame
    ), d = En(o, u).mul(a), f = new Kd({
      depthWrite: !1,
      transparent: !0,
      sizeAttenuation: !0,
      blending: sN
    });
    f.colorNode = d, f.sizeNode = r, f.positionNode = s, this.material && this.material.dispose(), this.material = f;
  }
  buildGeometry() {
    const t = this.parent;
    if (!t || !(t instanceof Jt))
      return;
    const r = new Kn(), n = [], s = [], o = [], i = sn.combineBuffer(t, "position", this.props.maxCount || 1e3), a = i.count;
    for (let l = 0; l < a; l++)
      n.push(20 + Math.random() * 50), s.push(Math.random() * this.props.intensity), o.push(this.props.size + Math.random() * this.props.size);
    r.setAttribute("position", i), r.setAttribute("targetPosition", i), r.setAttribute("particleSpeed", new yn(n, 1)), r.setAttribute("particleIntensity", new yn(s, 1)), r.setAttribute("particleSize", new yn(o, 1)), this.geometry && this.geometry.dispose(), this.geometry = r;
  }
  async build() {
    this.geometry || this.buildGeometry(), this.material || await this.buildMaterial(), this.geometry && this.material && (this.isPoints = !0, this.visible = !0);
  }
  toJSON(t) {
    const r = this.isPoints;
    delete this.isPoints;
    const n = super.toJSON(t);
    return this.isPoints = r, n;
  }
}
Vx(
  "EffectBurning",
  {
    members: {
      "props.maxCount": "Number",
      "props.texture": "Url",
      "props.lerpPosition": "Number",
      "props.intensity": "Number",
      "props.size": "Number"
    },
    proto: "Effect",
    group: "Effects.Burning Effect",
    icon: "fireworks",
    create: () => new oC()
  }
);
cf(
  "Burning",
  "Burning Body",
  {
    in: {
      texture: "Url",
      lerpPosition: "Number",
      time: "Number",
      maxCount: "Number"
    }
  },
  `const effect = world.createEffect('EffectBurning');
effect.props.maxCount = params.maxCount || 1000;
effect.props.lerpPosition = params.lerpPosition;
effect.props.texture = params.texture;
this.add(effect);

// waits
if (params.time) {
  await world.wait(params.time);
  effect.removeFromParent();
}
`
);
class iC extends Oe {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const ft = iC, La = new Qh();
La.camera = new _r();
const nm = {
  LineBasicNodeMaterial: ls.basic,
  MeshBasicNodeMaterial: ls.basic,
  PointsNodeMaterial: ls.points,
  MeshStandardNodeMaterial: ls.standard,
  MeshPhysicalNodeMaterial: ls.physical,
  MeshPhongNodeMaterial: ls.phong
}, aC = {
  [ke.ATAN2]: "atan"
}, cC = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function ys(c) {
  return `#include <${c}>`;
}
function ko(c) {
  return `${c}Shader`;
}
class sm extends q0 {
  constructor(e, t, r, n = null) {
    super(e, t, new R1(), null, n), this.shader = r, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow();
  }
  getMethod(e) {
    return aC[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), nm[t] !== void 0) {
      const r = nm[t], n = this.shader;
      n.vertexShader = r.vertexShader, n.fragmentShader = r.fragmentShader, n.uniforms = sr.merge([r.uniforms, co.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new ft({
      node: ps,
      nodeType: "vec3",
      source: ys("clipping_planes_fragment"),
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new ft({
      node: e.colorNode,
      nodeType: "vec4",
      source: ys("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new ft({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new ft({
      node: e.opacityNode,
      nodeType: "float",
      source: ys("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new ft({
      node: e.normalNode,
      nodeType: "vec3",
      source: ys("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new ft({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: ys("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new ft({
      node: e.metalnessNode,
      nodeType: "float",
      source: ys("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new ft({
      node: e.roughnessNode,
      nodeType: "float",
      source: ys("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new ft({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new ft({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new ft({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new ft({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new ft({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new ft({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new ft({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new ft({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new ft({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new ft({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new ft({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new ft({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new ft({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new ft({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new ft({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new ft({
      node: e.positionNode,
      nodeType: "vec3",
      source: ys("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new ft({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  getTexture(e, t, r) {
    return e.isTextureCube ? `textureCube( ${t}, ${r} )` : `texture2D( ${t}, ${r} )`;
  }
  getTextureBias(e, t, r, n) {
    return this.material.extensions !== void 0 && (this.material.extensions.shaderTextureLOD = !0), `textureLod( ${t}, ${r}, ${n} )`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let r = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let s = null;
      n.type === "texture" ? s = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? s = `samplerCube ${n.name}; ` : s = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? s = "uniform " + cC[o] + " " + s : s = "uniform " + s, r += s;
    }
    return r;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const r = this.attributes;
      for (const n of r)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const r = this.varyings;
    if (e === "vertex")
      for (const n of r)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of r)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, r, n = this) {
    const s = ko(e);
    let o = n[s];
    const i = o.indexOf(t);
    if (i !== -1) {
      const a = o.substring(0, i + t.length), l = o.substring(i + t.length);
      o = `${a}
${r}
${l}`;
    }
    n[s] = o;
  }
  replaceCode(e, t, r, n = this) {
    const s = ko(e);
    n[s] = n[s].replaceAll(t, r);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of Qr) {
      const r = this.getUniforms(t), n = this.getAttributes(t), s = this.getVaryings(t), o = this.getVars(t), i = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${r}

// attributes
${n}

// varyings
${s}

// vars
${o}

// codes
${i}

// </node_builder>

${this.shader[ko(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const r of t) {
      const n = ys(r), s = jm[r], o = ko(e);
      this.shader[o] = this.shader[o].replaceAll(n, s);
    }
  }
  _sortSlotsToFlow() {
    for (const e of Qr) {
      const t = this.shader[ko(e)], r = this.slots[e].sort((n, s) => t.indexOf(n.source) > t.indexOf(s.source) ? 1 : -1);
      for (const n of r)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of Qr) {
      for (const t of this.slots[e]) {
        const r = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, s = t.source, o = r.code + `
	` + t.target.replace("%RESULT%", r.result);
        n === "append" ? this.addCode(e, s, o) : n === "replace" ? this.replaceCode(e, s, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of Qr)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    La.object = this.object, La.renderer = this.renderer;
    for (const e of this.updateNodes)
      La.updateNode(e);
  }
}
const xu = /* @__PURE__ */ new WeakMap(), Zr = new Qh();
kn.prototype.onBuild = function(c, e, t) {
  if (Array.isArray(c.material))
    for (const r of c.material)
      r.isNodeMaterial === !0 && xu.set(r, new sm(c, t, e, r).build());
  else
    c.material.isNodeMaterial === !0 && xu.set(c.material, new sm(c, t, e).build());
};
kn.prototype.onBeforeRender = function(c, e, t, r, n) {
  const s = xu.get(this);
  if (s !== void 0) {
    Zr.material = this, Zr.camera = t, Zr.object = n, Zr.renderer = c;
    const o = s.updateNodes;
    if (o.length > 0) {
      c.state.useProgram(null);
      for (const i of o)
        Zr.updateNode(i);
    }
  }
};
class lC {
  constructor(e, t, r) {
    this.variables = [], this.currentTextureIndex = 0;
    let n = ep;
    const s = new Qa(), o = new rN();
    o.position.z = 1;
    const i = {
      passThruTexture: { value: null }
    }, a = h(f(), i), l = new Jt(new Er(2, 2), a);
    s.add(l), this.setDataType = function(p) {
      return n = p, this;
    }, this.addVariable = function(p, m, g) {
      const b = this.createShaderMaterial(m), v = {
        name: p,
        initialValueTexture: g,
        material: b,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: Ws,
        magFilter: Ws
      };
      return this.variables.push(v), v;
    }, this.setVariableDependencies = function(p, m) {
      p.dependencies = m;
    }, this.init = function() {
      if (r.capabilities.isWebGL2 === !1 && r.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (r.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let p = 0; p < this.variables.length; p++) {
        const m = this.variables[p];
        m.renderTargets[0] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), m.renderTargets[1] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), this.renderTexture(m.initialValueTexture, m.renderTargets[0]), this.renderTexture(m.initialValueTexture, m.renderTargets[1]);
        const g = m.material, b = g.uniforms;
        if (m.dependencies !== null)
          for (let v = 0; v < m.dependencies.length; v++) {
            const y = m.dependencies[v];
            if (y.name !== m.name) {
              let x = !1;
              for (let N = 0; N < this.variables.length; N++)
                if (y.name === this.variables[N].name) {
                  x = !0;
                  break;
                }
              if (!x)
                return "Variable dependency not found. Variable=" + m.name + ", dependency=" + y.name;
            }
            b[y.name] = { value: null }, g.fragmentShader = `
uniform sampler2D ` + y.name + `;
` + g.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const p = this.currentTextureIndex, m = this.currentTextureIndex === 0 ? 1 : 0;
      for (let g = 0, b = this.variables.length; g < b; g++) {
        const v = this.variables[g];
        if (v.dependencies !== null) {
          const y = v.material.uniforms;
          for (let x = 0, N = v.dependencies.length; x < N; x++) {
            const w = v.dependencies[x];
            y[w.name].value = w.renderTargets[p].texture;
          }
        }
        this.doRenderTarget(v.material, v.renderTargets[m]);
      }
      this.currentTextureIndex = m;
    }, this.getCurrentRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.geometry.dispose(), l.material.dispose();
      const p = this.variables;
      for (let m = 0; m < p.length; m++) {
        const g = p[m];
        g.initialValueTexture && g.initialValueTexture.dispose();
        const b = g.renderTargets;
        for (let v = 0; v < b.length; v++)
          b[v].dispose();
      }
    };
    function u(p) {
      p.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function h(p, m) {
      m = m || {};
      const g = new fs({
        name: "GPUComputationShader",
        uniforms: m,
        vertexShader: d(),
        fragmentShader: p
      });
      return u(g), g;
    }
    this.createShaderMaterial = h, this.createRenderTarget = function(p, m, g, b, v, y) {
      return p = p || e, m = m || t, g = g || go, b = b || go, v = v || Ws, y = y || Ws, new Fu(p, m, {
        wrapS: g,
        wrapT: b,
        minFilter: v,
        magFilter: y,
        format: Qf,
        type: n,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const p = new Float32Array(e * t * 4), m = new Ta(p, e, t, Qf, ep);
      return m.needsUpdate = !0, m;
    }, this.renderTexture = function(p, m) {
      i.passThruTexture.value = p, this.doRenderTarget(a, m), i.passThruTexture.value = null;
    }, this.doRenderTarget = function(p, m) {
      const g = r.getRenderTarget(), b = r.xr.enabled, v = r.shadowMap.autoUpdate;
      r.xr.enabled = !1, r.shadowMap.autoUpdate = !1, l.material = p, r.setRenderTarget(m), r.render(s, o), l.material = a, r.xr.enabled = b, r.shadowMap.autoUpdate = v, r.setRenderTarget(g);
    };
    function d() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function f() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const wt = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function jx(c) {
  const e = await fetch(c);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function uC(c) {
  if (!c)
    throw new Error("No basePath supplied");
  return await jx(`${c}/profilesList.json`);
}
async function hC(c, e, t = null, r = !0) {
  if (!c)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await uC(e);
  let s;
  if (c.profiles.some((a) => {
    const l = n[a];
    return l && (s = {
      profileId: a,
      profilePath: `${e}/${l.path}`,
      deprecated: !!l.deprecated
    }), !!s;
  }), !s) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    s = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await jx(s.profilePath);
  let i;
  if (r) {
    let a;
    if (c.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[c.handedness], !a)
      throw new Error(
        `No matching handedness, ${c.handedness}, in profile ${s.profileId}`
      );
    a.assetPath && (i = s.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: i };
}
const dC = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: wt.ComponentState.DEFAULT
};
function fC(c = 0, e = 0) {
  let t = c, r = e;
  if (Math.sqrt(c * c + e * e) > 1) {
    const o = Math.atan2(e, c);
    t = Math.cos(o), r = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: r * 0.5 + 0.5
  };
}
class pC {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === wt.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(dC);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: r,
    state: n
  }) {
    const { normalizedXAxis: s, normalizedYAxis: o } = fC(e, t);
    switch (this.componentProperty) {
      case wt.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? s : 0.5;
        break;
      case wt.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case wt.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? r : 0;
        break;
      case wt.ComponentProperty.STATE:
        this.valueNodeProperty === wt.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class mC {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((r) => {
      const n = new pC(t.visualResponses[r]);
      this.visualResponses[r] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: wt.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = wt.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = wt.ComponentState.PRESSED : (t.touched || this.values.button > wt.ButtonTouchThreshold) && (this.values.state = wt.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === wt.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > wt.AxisTouchThreshold && (this.values.state = wt.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === wt.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > wt.AxisTouchThreshold && (this.values.state = wt.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class gC {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, r) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = r, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const s = this.layoutDescription.components[n];
      this.components[n] = new mC(n, s);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const yC = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", vC = "generic-trigger";
class xC extends xn {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((r) => {
        const { valueNode: n, minNode: s, maxNode: o, value: i, valueNodeProperty: a } = r;
        n && (a === wt.VisualResponseProperty.VISIBILITY ? n.visible = i : a === wt.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          s.quaternion,
          o.quaternion,
          i
        ), n.position.lerpVectors(
          s.position,
          o.position,
          i
        )));
      });
    }));
  }
}
function bC(c, e) {
  Object.values(c.components).forEach((t) => {
    const { type: r, touchPointNodeName: n, visualResponses: s } = t;
    if (r === wt.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new tc(1e-3), i = new Cn({ color: 255 }), a = new Jt(o, i);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(s).forEach((o) => {
      const { valueNodeName: i, minNodeName: a, maxNodeName: l, valueNodeProperty: u } = o;
      if (u === wt.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(l), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${l} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(i), o.valueNode || console.warn(`Could not find ${i} in the model`);
    });
  });
}
function rm(c, e) {
  bC(c.motionController, e), c.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = c.envMap, t.material.needsUpdate = !0);
  }), c.add(e);
}
class NC {
  constructor(e = null) {
    this.gltfLoader = e, this.path = yC, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new rf());
  }
  createControllerModel(e) {
    const t = new xC();
    let r = null;
    return e.addEventListener("connected", (n) => {
      const s = n.data;
      s.targetRayMode !== "tracked-pointer" || !s.gamepad || hC(s, this.path, vC).then(({ profile: o, assetPath: i }) => {
        t.motionController = new gC(
          s,
          o,
          i
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          r = a.scene.clone(), rm(t, r);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (l) => {
              this._assetCache[t.motionController.assetUrl] = l, r = l.scene.clone(), rm(t, r);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(r), r = null;
    }), t;
  }
}
const wC = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class TC {
  constructor(e, t, r, n, s = null) {
    this.controller = t, this.handModel = e, this.bones = [], s === null && (s = new rf(), s.setPath(r || wC)), s.load(`${n}.glb`, (o) => {
      const i = o.scene.children[0];
      this.handModel.add(i);
      const a = i.getObjectByProperty("type", "SkinnedMesh");
      a.frustumCulled = !1, a.castShadow = !0, a.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((u) => {
        const h = i.getObjectByName(u);
        h !== void 0 ? h.jointName = u : console.warn(`Couldn't find ${u} in ${n} hand mesh`), this.bones.push(h);
      });
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const r = this.bones[t];
      if (r) {
        const n = e[r.jointName];
        if (n.visible) {
          const s = n.position;
          r.position.copy(s), r.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const SC = 0.01, _C = "index-finger-tip";
class om extends xn {
  constructor(e, t = null) {
    super(), this.controller = e, this.motionController = null, this.envMap = null, this.loader = t, this.mesh = null, e.addEventListener("connected", (r) => {
      const n = r.data;
      n.hand && !this.motionController && (this.xrInputSource = n, this.motionController = new TC(this, e, this.path, n.handedness, this.loader));
    }), e.addEventListener("disconnected", () => {
      this.clear(), this.motionController = null;
    });
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && this.motionController.updateMesh();
  }
  getPointerPosition() {
    const e = this.controller.joints[_C];
    return e ? e.position : null;
  }
  intersectBoxObject(e) {
    const t = this.getPointerPosition();
    if (t) {
      const r = new Ti(t, SC), n = new nr().setFromObject(e);
      return r.intersectsBox(n);
    } else
      return !1;
  }
  checkButton(e) {
    this.intersectBoxObject(e) ? e.onPress() : e.onClear(), e.isPressed() && e.whilePressed();
  }
}
const MC = 0.05, im = 0.02, ia = 0.01, am = 0.02, cm = 1, Gr = 0.4, AC = 2e-3, Go = 0.01, aa = 3e-3, lm = 0.035, ut = 16, Pn = 12, Cl = 110, CC = /* @__PURE__ */ new M.Vector3(0, 1, 0), EC = /* @__PURE__ */ new M.Vector3(0, 0, 1), RC = 0.02, LC = 1.5;
class um extends M.Object3D {
  constructor(e, t) {
    super(), this.hand = e, this.controller = t, this.motionController = null, this.envMap = null, this.mesh = null, this.pointerGeometry = null, this.pointerMesh = null, this.pointerObject = null, this.pinched = !1, this.attached = !1, this.cursorObject = null, this.raycaster = null, this._onConnected = this._onConnected.bind(this), this._onDisconnected = this._onDisconnected.bind(this), this.hand.addEventListener("connected", this._onConnected), this.hand.addEventListener("disconnected", this._onDisconnected);
  }
  _onConnected(e) {
    const t = e.data;
    t.hand && (this.visible = !0, this.xrInputSource = t, this.createPointer());
  }
  _onDisconnected() {
    this.visible = !1, this.xrInputSource = null, this.pointerGeometry && this.pointerGeometry.dispose(), this.pointerMesh && this.pointerMesh.material && this.pointerMesh.material.dispose(), this.clear();
  }
  _drawVerticesRing(e, t, r) {
    const n = t.clone();
    for (let s = 0; s < ut; s++) {
      n.applyAxisAngle(EC, Math.PI * 2 / ut);
      const o = r * ut + s;
      e[3 * o] = n.x, e[3 * o + 1] = n.y, e[3 * o + 2] = n.z;
    }
  }
  _updatePointerVertices(e) {
    const t = this.pointerGeometry.attributes.position.array, r = new M.Vector3(
      AC,
      0,
      -1 * (lm - e)
    );
    this._drawVerticesRing(t, r, 0);
    const n = new M.Vector3(
      Math.sin(Math.PI * Cl / 180) * e,
      Math.cos(Math.PI * Cl / 180) * e,
      0
    );
    for (let l = 0; l < Pn; l++)
      this._drawVerticesRing(t, n, l + 1), n.applyAxisAngle(
        CC,
        Math.PI * Cl / 180 / (Pn * -2)
      );
    const s = ut * (1 + Pn), o = ut * (1 + Pn) + 1, i = new M.Vector3(
      0,
      0,
      -1 * (lm - e)
    );
    t[s * 3] = i.x, t[s * 3 + 1] = i.y, t[s * 3 + 2] = i.z;
    const a = new M.Vector3(0, 0, e);
    t[o * 3] = a.x, t[o * 3 + 1] = a.y, t[o * 3 + 2] = a.z, this.pointerGeometry.setAttribute(
      "position",
      new M.Float32BufferAttribute(t, 3)
    );
  }
  createPointer() {
    let e, t;
    const r = new Array(
      ((Pn + 1) * ut + 2) * 3
    ).fill(0), n = [];
    for (this.pointerGeometry = new M.BufferGeometry(), this.pointerGeometry.setAttribute(
      "position",
      new M.Float32BufferAttribute(r, 3)
    ), this._updatePointerVertices(Go), e = 0; e < Pn; e++) {
      for (t = 0; t < ut - 1; t++)
        n.push(
          e * ut + t,
          e * ut + t + 1,
          (e + 1) * ut + t
        ), n.push(
          e * ut + t + 1,
          (e + 1) * ut + t + 1,
          (e + 1) * ut + t
        );
      n.push(
        (e + 1) * ut - 1,
        e * ut,
        (e + 2) * ut - 1
      ), n.push(
        e * ut,
        (e + 1) * ut,
        (e + 2) * ut - 1
      );
    }
    const s = ut * (1 + Pn), o = ut * (1 + Pn) + 1;
    for (e = 0; e < ut - 1; e++)
      n.push(s, e + 1, e), n.push(
        o,
        e + ut * Pn,
        e + ut * Pn + 1
      );
    n.push(s, 0, ut - 1), n.push(
      o,
      ut * (Pn + 1) - 1,
      ut * Pn
    );
    const i = new M.MeshBasicMaterial();
    i.transparent = !0, i.opacity = Gr, this.pointerGeometry.setIndex(n), this.pointerMesh = new M.Mesh(this.pointerGeometry, i), this.pointerMesh.position.set(0, 0, -1 * Go), this.pointerObject = new M.Object3D(), this.pointerObject.add(this.pointerMesh), this.raycaster = new M.Raycaster();
    const a = new M.SphereGeometry(RC, 10, 10), l = new M.MeshBasicMaterial();
    l.transparent = !0, l.opacity = Gr, this.cursorObject = new M.Mesh(a, l), this.pointerObject.add(this.cursorObject), this.add(this.pointerObject);
  }
  _updateRaycaster() {
    if (this.raycaster) {
      const e = this.pointerObject.matrixWorld, t = new M.Matrix4();
      t.identity().extractRotation(e), this.raycaster.ray.origin.setFromMatrixPosition(e), this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(t);
    }
  }
  _updatePointer() {
    this.pointerObject.visible = this.controller.visible;
    const e = this.hand.joints["index-finger-tip"], t = this.hand.joints["thumb-tip"], r = e.position.distanceTo(t.position), n = e.position.clone().add(t.position).multiplyScalar(0.5);
    this.pointerObject.position.copy(n), this.pointerObject.quaternion.copy(this.controller.quaternion), this.pinched = r <= im;
    const s = (r - ia) / (MC - ia), o = (r - ia) / (im - ia);
    if (s > 1)
      this._updatePointerVertices(Go), this.pointerMesh.position.set(0, 0, -1 * Go), this.pointerMesh.material.opacity = Gr;
    else if (s > 0) {
      const i = (Go - aa) * s + aa;
      this._updatePointerVertices(i), o < 1 ? (this.pointerMesh.position.set(
        0,
        0,
        -1 * i - (1 - o) * am
      ), this.pointerMesh.material.opacity = Gr + (1 - o) * (cm - Gr)) : (this.pointerMesh.position.set(0, 0, -1 * i), this.pointerMesh.material.opacity = Gr);
    } else
      this._updatePointerVertices(aa), this.pointerMesh.position.set(
        0,
        0,
        -1 * aa - am
      ), this.pointerMesh.material.opacity = cm;
    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.pointerGeometry && (this._updatePointer(), this._updateRaycaster());
  }
  isPinched() {
    return this.pinched;
  }
  setAttached(e) {
    this.attached = e;
  }
  isAttached() {
    return this.attached;
  }
  intersectObject(e, t = !0) {
    if (this.raycaster)
      return this.raycaster.intersectObject(e, t);
  }
  intersectObjects(e, t = !0) {
    if (this.raycaster)
      return this.raycaster.intersectObjects(e, t);
  }
  checkIntersections(e, t = !1) {
    if (this.raycaster && !this.attached) {
      const r = this.raycaster.intersectObjects(e, t), n = new M.Vector3(0, 0, -1);
      if (r.length > 0) {
        const o = r[0].distance;
        this.cursorObject.position.copy(n.multiplyScalar(o));
      } else
        this.cursorObject.position.copy(n.multiplyScalar(LC));
    }
  }
  setCursor(e) {
    const t = new M.Vector3(0, 0, -1);
    this.raycaster && !this.attached && this.cursorObject.position.copy(t.multiplyScalar(e));
  }
  dispose() {
    this._onDisconnected(), this.hand.removeEventListener("connected", this._onConnected), this.hand.removeEventListener("disconnected", this._onDisconnected);
  }
}
class OC extends ef {
  constructor() {
    super(), this.name;
    const e = new ec(-5, 5, 5, -5);
    e.near = 1e-4, e.far = 1e3, e.position.set(0, 0, 4), this.add(e);
    const t = new Jt(new tc(0.5), new Cn({ color: 8947967, wireframe: !0 }));
    t.onBeforeRender = () => {
      t.rotation.y -= 4e-3;
    }, this.add(t);
    const r = new sf();
    r.text = "Loading...", r.color = 8947865, r.anchorX = "center", r.fontSize = 0.16, r.position.set(0, -0.6, 0), this.add(r);
  }
}
const Zt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], FC = Math.PI / 180;
function lf() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Zt[c & 255] + Zt[c >> 8 & 255] + Zt[c >> 16 & 255] + Zt[c >> 24 & 255] + "-" + Zt[e & 255] + Zt[e >> 8 & 255] + "-" + Zt[e >> 16 & 15 | 64] + Zt[e >> 24 & 255] + "-" + Zt[t & 63 | 128] + Zt[t >> 8 & 255] + "-" + Zt[t >> 16 & 255] + Zt[t >> 24 & 255] + Zt[r & 255] + Zt[r >> 8 & 255] + Zt[r >> 16 & 255] + Zt[r >> 24 & 255]).toLowerCase();
}
function zn(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function Vo(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return c / 4294967295;
    case Uint16Array:
      return c / 65535;
    case Uint8Array:
      return c / 255;
    case Int32Array:
      return Math.max(c / 2147483647, -1);
    case Int16Array:
      return Math.max(c / 32767, -1);
    case Int8Array:
      return Math.max(c / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function pn(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return Math.round(c * 4294967295);
    case Uint16Array:
      return Math.round(c * 65535);
    case Uint8Array:
      return Math.round(c * 255);
    case Int32Array:
      return Math.round(c * 2147483647);
    case Int16Array:
      return Math.round(c * 32767);
    case Int8Array:
      return Math.round(c * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class Li {
  constructor(e = 0, t = 0, r = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = n;
  }
  static slerpFlat(e, t, r, n, s, o, i) {
    let a = r[n + 0], l = r[n + 1], u = r[n + 2], h = r[n + 3];
    const d = s[o + 0], f = s[o + 1], p = s[o + 2], m = s[o + 3];
    if (i === 0) {
      e[t + 0] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (i === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
      return;
    }
    if (h !== m || a !== d || l !== f || u !== p) {
      let g = 1 - i;
      const b = a * d + l * f + u * p + h * m, v = b >= 0 ? 1 : -1, y = 1 - b * b;
      if (y > Number.EPSILON) {
        const N = Math.sqrt(y), w = Math.atan2(N, b * v);
        g = Math.sin(g * w) / N, i = Math.sin(i * w) / N;
      }
      const x = i * v;
      if (a = a * g + d * x, l = l * g + f * x, u = u * g + p * x, h = h * g + m * x, g === 1 - i) {
        const N = 1 / Math.sqrt(a * a + l * l + u * u + h * h);
        a *= N, l *= N, u *= N, h *= N;
      }
    }
    e[t] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, r, n, s, o) {
    const i = r[n], a = r[n + 1], l = r[n + 2], u = r[n + 3], h = s[o], d = s[o + 1], f = s[o + 2], p = s[o + 3];
    return e[t] = i * p + u * h + a * f - l * d, e[t + 1] = a * p + u * d + l * h - i * f, e[t + 2] = l * p + u * f + i * d - a * h, e[t + 3] = u * p - i * h - a * d - l * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._order, i = Math.cos, a = Math.sin, l = i(r / 2), u = i(n / 2), h = i(s / 2), d = a(r / 2), f = a(n / 2), p = a(s / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "YZX":
        this._x = d * u * h + l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "XZY":
        this._x = d * u * h - l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], n = t[4], s = t[8], o = t[1], i = t[5], a = t[9], l = t[2], u = t[6], h = t[10], d = r + i + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - a) * f, this._y = (s - l) * f, this._z = (o - n) * f;
    } else if (r > i && r > h) {
      const f = 2 * Math.sqrt(1 + r - i - h);
      this._w = (u - a) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (s + l) / f;
    } else if (i > h) {
      const f = 2 * Math.sqrt(1 + i - r - h);
      this._w = (s - l) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (a + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - r - i);
      this._w = (o - n) / f, this._x = (s + l) / f, this._y = (a + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(zn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const n = Math.min(1, t / r);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._w, i = t._x, a = t._y, l = t._z, u = t._w;
    return this._x = r * u + o * i + n * l - s * a, this._y = n * u + o * a + s * i - r * l, this._z = s * u + o * l + r * a - n * i, this._w = o * u - r * i - n * a - s * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, n = this._y, s = this._z, o = this._w;
    let i = o * e._w + r * e._x + n * e._y + s * e._z;
    if (i < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, i = -i) : this.copy(e), i >= 1)
      return this._w = o, this._x = r, this._y = n, this._z = s, this;
    const a = 1 - i * i;
    if (a <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * r + t * this._x, this._y = f * n + t * this._y, this._z = f * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(a), u = Math.atan2(l, i), h = Math.sin((1 - t) * u) / l, d = Math.sin(t * u) / l;
    return this._w = o * h + this._w * d, this._x = r * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class j {
  constructor(e = 0, t = 0, r = 0) {
    j.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(hm.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(hm.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * n, this.y = s[1] * t + s[4] * r + s[7] * n, this.z = s[2] * t + s[5] * r + s[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * r + s[11] * n + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * n + s[12]) * o, this.y = (s[1] * t + s[5] * r + s[9] * n + s[13]) * o, this.z = (s[2] * t + s[6] * r + s[10] * n + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, n = this.z, s = e.x, o = e.y, i = e.z, a = e.w, l = 2 * (o * n - i * r), u = 2 * (i * t - s * n), h = 2 * (s * r - o * t);
    return this.x = t + a * l + o * h - i * u, this.y = r + a * u + i * l - s * h, this.z = n + a * h + s * u - o * l, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * n, this.y = s[1] * t + s[5] * r + s[9] * n, this.z = s[2] * t + s[6] * r + s[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, n = e.y, s = e.z, o = t.x, i = t.y, a = t.z;
    return this.x = n * a - s * i, this.y = s * o - r * a, this.z = r * i - n * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return El.copy(this).projectOnVector(e), this.sub(El);
  }
  reflect(e) {
    return this.sub(El.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(zn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const El = /* @__PURE__ */ new j(), hm = /* @__PURE__ */ new Li();
class Re {
  constructor(e = 0, t = 0) {
    Re.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(zn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * r - o * n + e.x, this.y = s * n + o * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Oi {
  constructor(e = new j(1 / 0, 1 / 0, 1 / 0), t = new j(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(qn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(qn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = qn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const s = r.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, i = s.count; o < i; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, qn) : qn.fromBufferAttribute(s, o), qn.applyMatrix4(e.matrixWorld), this.expandByPoint(qn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), ca.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(), ca.copy(r.boundingBox)), ca.applyMatrix4(e.matrixWorld), this.union(ca);
    }
    const n = e.children;
    for (let s = 0, o = n.length; s < o; s++)
      this.expandByObject(n[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, qn), qn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(jo), la.subVectors(this.max, jo), Vr.subVectors(e.a, jo), jr.subVectors(e.b, jo), Wr.subVectors(e.c, jo), Ds.subVectors(jr, Vr), Us.subVectors(Wr, jr), ur.subVectors(Vr, Wr);
    let t = [
      0,
      -Ds.z,
      Ds.y,
      0,
      -Us.z,
      Us.y,
      0,
      -ur.z,
      ur.y,
      Ds.z,
      0,
      -Ds.x,
      Us.z,
      0,
      -Us.x,
      ur.z,
      0,
      -ur.x,
      -Ds.y,
      Ds.x,
      0,
      -Us.y,
      Us.x,
      0,
      -ur.y,
      ur.x,
      0
    ];
    return !Rl(t, Vr, jr, Wr, la) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Rl(t, Vr, jr, Wr, la)) ? !1 : (ua.crossVectors(Ds, Us), t = [ua.x, ua.y, ua.z], Rl(t, Vr, jr, Wr, la));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, qn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(qn).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (vs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), vs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), vs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), vs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), vs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), vs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), vs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), vs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(vs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const vs = [
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j()
], qn = /* @__PURE__ */ new j(), ca = /* @__PURE__ */ new Oi(), Vr = /* @__PURE__ */ new j(), jr = /* @__PURE__ */ new j(), Wr = /* @__PURE__ */ new j(), Ds = /* @__PURE__ */ new j(), Us = /* @__PURE__ */ new j(), ur = /* @__PURE__ */ new j(), jo = /* @__PURE__ */ new j(), la = /* @__PURE__ */ new j(), ua = /* @__PURE__ */ new j(), hr = /* @__PURE__ */ new j();
function Rl(c, e, t, r, n) {
  for (let s = 0, o = c.length - 3; s <= o; s += 3) {
    hr.fromArray(c, s);
    const i = n.x * Math.abs(hr.x) + n.y * Math.abs(hr.y) + n.z * Math.abs(hr.z), a = e.dot(hr), l = t.dot(hr), u = r.dot(hr);
    if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > i)
      return !1;
  }
  return !0;
}
class Wx {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const n = r.slice(0);
      for (let s = 0, o = n.length; s < o; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const IC = 1015, dm = 35044, ha = 2e3, fm = 2001, Et = /* @__PURE__ */ new j(), da = /* @__PURE__ */ new Re();
class fo {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = dm, this.updateRange = { offset: 0, count: -1 }, this.gpuType = IC, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        da.fromBufferAttribute(this, t), da.applyMatrix3(e), this.setXY(t, da.x, da.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Et.fromBufferAttribute(this, t), Et.applyMatrix3(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Et.fromBufferAttribute(this, t), Et.applyMatrix4(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Et.fromBufferAttribute(this, t), Et.applyNormalMatrix(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Et.fromBufferAttribute(this, t), Et.transformDirection(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = Vo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = pn(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Vo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = pn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Vo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = pn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Vo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = pn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Vo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = pn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = pn(t, this.array), r = pn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, n) {
    return e *= this.itemSize, this.normalized && (t = pn(t, this.array), r = pn(r, this.array), n = pn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, r, n, s) {
    return e *= this.itemSize, this.normalized && (t = pn(t, this.array), r = pn(r, this.array), n = pn(n, this.array), s = pn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== dm && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class PC extends fo {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class DC extends fo {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class Xe extends fo {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
const UC = /* @__PURE__ */ new Oi(), Wo = /* @__PURE__ */ new j(), Ll = /* @__PURE__ */ new j();
class zC {
  constructor(e = new j(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : UC.setFromPoints(e).getCenter(r);
    let n = 0;
    for (let s = 0, o = e.length; s < o; s++)
      n = Math.max(n, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Wo.subVectors(e, this.center);
    const t = Wo.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), n = (r - this.radius) * 0.5;
      this.center.addScaledVector(Wo, n / r), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Ll.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Wo.copy(e.center).add(Ll)), this.expandByPoint(Wo.copy(e.center).sub(Ll))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qn {
  constructor(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    Qn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g);
  }
  set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    const b = this.elements;
    return b[0] = e, b[4] = t, b[8] = r, b[12] = n, b[1] = s, b[5] = o, b[9] = i, b[13] = a, b[2] = l, b[6] = u, b[10] = h, b[14] = d, b[3] = f, b[7] = p, b[11] = m, b[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Qn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, n = 1 / Hr.setFromMatrixColumn(e, 0).length(), s = 1 / Hr.setFromMatrixColumn(e, 1).length(), o = 1 / Hr.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z, o = Math.cos(r), i = Math.sin(r), a = Math.cos(n), l = Math.sin(n), u = Math.cos(s), h = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = -a * h, t[8] = l, t[1] = f + p * l, t[5] = d - m * l, t[9] = -i * a, t[2] = m - d * l, t[6] = p + f * l, t[10] = o * a;
    } else if (e.order === "YXZ") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d + m * i, t[4] = p * i - f, t[8] = o * l, t[1] = o * h, t[5] = o * u, t[9] = -i, t[2] = f * i - p, t[6] = m + d * i, t[10] = o * a;
    } else if (e.order === "ZXY") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d - m * i, t[4] = -o * h, t[8] = p + f * i, t[1] = f + p * i, t[5] = o * u, t[9] = m - d * i, t[2] = -o * l, t[6] = i, t[10] = o * a;
    } else if (e.order === "ZYX") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = p * l - f, t[8] = d * l + m, t[1] = a * h, t[5] = m * l + d, t[9] = f * l - p, t[2] = -l, t[6] = i * a, t[10] = o * a;
    } else if (e.order === "YZX") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = m - d * h, t[8] = p * h + f, t[1] = h, t[5] = o * u, t[9] = -i * u, t[2] = -l * u, t[6] = f * h + p, t[10] = d - m * h;
    } else if (e.order === "XZY") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = -h, t[8] = l * u, t[1] = d * h + m, t[5] = o * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = i * u, t[10] = m * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(BC, e, kC);
  }
  lookAt(e, t, r) {
    const n = this.elements;
    return Sn.subVectors(e, t), Sn.lengthSq() === 0 && (Sn.z = 1), Sn.normalize(), zs.crossVectors(r, Sn), zs.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Sn.x += 1e-4 : Sn.z += 1e-4, Sn.normalize(), zs.crossVectors(r, Sn)), zs.normalize(), fa.crossVectors(Sn, zs), n[0] = zs.x, n[4] = fa.x, n[8] = Sn.x, n[1] = zs.y, n[5] = fa.y, n[9] = Sn.y, n[2] = zs.z, n[6] = fa.z, n[10] = Sn.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[4], a = r[8], l = r[12], u = r[1], h = r[5], d = r[9], f = r[13], p = r[2], m = r[6], g = r[10], b = r[14], v = r[3], y = r[7], x = r[11], N = r[15], w = n[0], T = n[4], _ = n[8], L = n[12], A = n[1], U = n[5], S = n[9], R = n[13], E = n[2], D = n[6], P = n[10], se = n[14], oe = n[3], H = n[7], X = n[11], C = n[15];
    return s[0] = o * w + i * A + a * E + l * oe, s[4] = o * T + i * U + a * D + l * H, s[8] = o * _ + i * S + a * P + l * X, s[12] = o * L + i * R + a * se + l * C, s[1] = u * w + h * A + d * E + f * oe, s[5] = u * T + h * U + d * D + f * H, s[9] = u * _ + h * S + d * P + f * X, s[13] = u * L + h * R + d * se + f * C, s[2] = p * w + m * A + g * E + b * oe, s[6] = p * T + m * U + g * D + b * H, s[10] = p * _ + m * S + g * P + b * X, s[14] = p * L + m * R + g * se + b * C, s[3] = v * w + y * A + x * E + N * oe, s[7] = v * T + y * U + x * D + N * H, s[11] = v * _ + y * S + x * P + N * X, s[15] = v * L + y * R + x * se + N * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], n = e[8], s = e[12], o = e[1], i = e[5], a = e[9], l = e[13], u = e[2], h = e[6], d = e[10], f = e[14], p = e[3], m = e[7], g = e[11], b = e[15];
    return p * (+s * a * h - n * l * h - s * i * d + r * l * d + n * i * f - r * a * f) + m * (+t * a * f - t * l * d + s * o * d - n * o * f + n * l * u - s * a * u) + g * (+t * l * h - t * i * f - s * o * h + r * o * f + s * i * u - r * l * u) + b * (-n * i * u - t * a * h + t * i * d + n * o * h - r * o * d + r * a * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = e[9], d = e[10], f = e[11], p = e[12], m = e[13], g = e[14], b = e[15], v = h * g * l - m * d * l + m * a * f - i * g * f - h * a * b + i * d * b, y = p * d * l - u * g * l - p * a * f + o * g * f + u * a * b - o * d * b, x = u * m * l - p * h * l + p * i * f - o * m * f - u * i * b + o * h * b, N = p * h * a - u * m * a - p * i * d + o * m * d + u * i * g - o * h * g, w = t * v + r * y + n * x + s * N;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / w;
    return e[0] = v * T, e[1] = (m * d * s - h * g * s - m * n * f + r * g * f + h * n * b - r * d * b) * T, e[2] = (i * g * s - m * a * s + m * n * l - r * g * l - i * n * b + r * a * b) * T, e[3] = (h * a * s - i * d * s - h * n * l + r * d * l + i * n * f - r * a * f) * T, e[4] = y * T, e[5] = (u * g * s - p * d * s + p * n * f - t * g * f - u * n * b + t * d * b) * T, e[6] = (p * a * s - o * g * s - p * n * l + t * g * l + o * n * b - t * a * b) * T, e[7] = (o * d * s - u * a * s + u * n * l - t * d * l - o * n * f + t * a * f) * T, e[8] = x * T, e[9] = (p * h * s - u * m * s - p * r * f + t * m * f + u * r * b - t * h * b) * T, e[10] = (o * m * s - p * i * s + p * r * l - t * m * l - o * r * b + t * i * b) * T, e[11] = (u * i * s - o * h * s - u * r * l + t * h * l + o * r * f - t * i * f) * T, e[12] = N * T, e[13] = (u * m * n - p * h * n + p * r * d - t * m * d - u * r * g + t * h * g) * T, e[14] = (p * i * n - o * m * n - p * r * a + t * m * a + o * r * g - t * i * g) * T, e[15] = (o * h * n - u * i * n + u * r * a - t * h * a - o * r * d + t * i * d) * T, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= s, t[1] *= r, t[5] *= n, t[9] *= s, t[2] *= r, t[6] *= n, t[10] *= s, t[3] *= r, t[7] *= n, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = 1 - r, o = e.x, i = e.y, a = e.z, l = s * o, u = s * i;
    return this.set(
      l * o + r,
      l * i - n * a,
      l * a + n * i,
      0,
      l * i + n * a,
      u * i + r,
      u * a - n * o,
      0,
      l * a - n * i,
      u * a + n * o,
      s * a * a + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, n, s, o) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const n = this.elements, s = t._x, o = t._y, i = t._z, a = t._w, l = s + s, u = o + o, h = i + i, d = s * l, f = s * u, p = s * h, m = o * u, g = o * h, b = i * h, v = a * l, y = a * u, x = a * h, N = r.x, w = r.y, T = r.z;
    return n[0] = (1 - (m + b)) * N, n[1] = (f + x) * N, n[2] = (p - y) * N, n[3] = 0, n[4] = (f - x) * w, n[5] = (1 - (d + b)) * w, n[6] = (g + v) * w, n[7] = 0, n[8] = (p + y) * T, n[9] = (g - v) * T, n[10] = (1 - (d + m)) * T, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, r) {
    const n = this.elements;
    let s = Hr.set(n[0], n[1], n[2]).length();
    const o = Hr.set(n[4], n[5], n[6]).length(), i = Hr.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], Jn.copy(this);
    const l = 1 / s, u = 1 / o, h = 1 / i;
    return Jn.elements[0] *= l, Jn.elements[1] *= l, Jn.elements[2] *= l, Jn.elements[4] *= u, Jn.elements[5] *= u, Jn.elements[6] *= u, Jn.elements[8] *= h, Jn.elements[9] *= h, Jn.elements[10] *= h, t.setFromRotationMatrix(Jn), r.x = s, r.y = o, r.z = i, this;
  }
  makePerspective(e, t, r, n, s, o, i = ha) {
    const a = this.elements, l = 2 * s / (t - e), u = 2 * s / (r - n), h = (t + e) / (t - e), d = (r + n) / (r - n);
    let f, p;
    if (i === ha)
      f = -(o + s) / (o - s), p = -2 * o * s / (o - s);
    else if (i === fm)
      f = -o / (o - s), p = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + i);
    return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = u, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, r, n, s, o, i = ha) {
    const a = this.elements, l = 1 / (t - e), u = 1 / (r - n), h = 1 / (o - s), d = (t + e) * l, f = (r + n) * u;
    let p, m;
    if (i === ha)
      p = (o + s) * h, m = -2 * h;
    else if (i === fm)
      p = s * h, m = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + i);
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = m, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const Hr = /* @__PURE__ */ new j(), Jn = /* @__PURE__ */ new Qn(), BC = /* @__PURE__ */ new j(0, 0, 0), kC = /* @__PURE__ */ new j(1, 1, 1), zs = /* @__PURE__ */ new j(), fa = /* @__PURE__ */ new j(), Sn = /* @__PURE__ */ new j(), pm = /* @__PURE__ */ new Qn(), mm = /* @__PURE__ */ new Li();
class Oc {
  constructor(e = 0, t = 0, r = 0, n = Oc.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, n = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const n = e.elements, s = n[0], o = n[4], i = n[8], a = n[1], l = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(zn(i, -1, 1)), Math.abs(i) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-zn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(i, f), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(zn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, s));
        break;
      case "ZYX":
        this._y = Math.asin(-zn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(a, s)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(zn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(i, f));
        break;
      case "XZY":
        this._z = Math.asin(-zn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(i, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return pm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(pm, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return mm.setFromEuler(this), this.setFromQuaternion(mm, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Oc.DEFAULT_ORDER = "XYZ";
class GC {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class Fi {
  constructor(e, t, r, n, s, o, i, a, l) {
    Fi.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l);
  }
  set(e, t, r, n, s, o, i, a, l) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = i, u[3] = t, u[4] = s, u[5] = a, u[6] = r, u[7] = o, u[8] = l, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[3], a = r[6], l = r[1], u = r[4], h = r[7], d = r[2], f = r[5], p = r[8], m = n[0], g = n[3], b = n[6], v = n[1], y = n[4], x = n[7], N = n[2], w = n[5], T = n[8];
    return s[0] = o * m + i * v + a * N, s[3] = o * g + i * y + a * w, s[6] = o * b + i * x + a * T, s[1] = l * m + u * v + h * N, s[4] = l * g + u * y + h * w, s[7] = l * b + u * x + h * T, s[2] = d * m + f * v + p * N, s[5] = d * g + f * y + p * w, s[8] = d * b + f * x + p * T, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8];
    return t * o * u - t * i * l - r * s * u + r * i * a + n * s * l - n * o * a;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = u * o - i * l, d = i * a - u * s, f = l * s - o * a, p = t * h + r * d + n * f;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return e[0] = h * m, e[1] = (n * l - u * r) * m, e[2] = (i * r - n * o) * m, e[3] = d * m, e[4] = (u * t - n * a) * m, e[5] = (n * s - i * t) * m, e[6] = f * m, e[7] = (r * a - l * t) * m, e[8] = (o * t - r * s) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, n, s, o, i) {
    const a = Math.cos(s), l = Math.sin(s);
    return this.set(
      r * a,
      r * l,
      -r * (a * o + l * i) + o + e,
      -n * l,
      n * a,
      -n * (-l * o + a * i) + i + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Ol.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Ol.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Ol.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ol = /* @__PURE__ */ new Fi();
let VC = 0;
const gm = /* @__PURE__ */ new j(), Xr = /* @__PURE__ */ new Li(), xs = /* @__PURE__ */ new Qn(), pa = /* @__PURE__ */ new j(), Ho = /* @__PURE__ */ new j(), jC = /* @__PURE__ */ new j(), WC = /* @__PURE__ */ new Li(), ym = /* @__PURE__ */ new j(1, 0, 0), vm = /* @__PURE__ */ new j(0, 1, 0), xm = /* @__PURE__ */ new j(0, 0, 1), HC = { type: "added" }, XC = { type: "removed" };
class qs extends Wx {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: VC++ }), this.uuid = lf(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qs.DEFAULT_UP.clone();
    const e = new j(), t = new Oc(), r = new Li(), n = new j(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Qn()
      },
      normalMatrix: {
        value: new Fi()
      }
    }), this.matrix = new Qn(), this.matrixWorld = new Qn(), this.matrixAutoUpdate = qs.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = qs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new GC(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Xr.setFromAxisAngle(e, t), this.quaternion.multiply(Xr), this;
  }
  rotateOnWorldAxis(e, t) {
    return Xr.setFromAxisAngle(e, t), this.quaternion.premultiply(Xr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(ym, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(vm, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(xm, e);
  }
  translateOnAxis(e, t) {
    return gm.copy(e).applyQuaternion(this.quaternion), this.position.add(gm.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(ym, e);
  }
  translateY(e) {
    return this.translateOnAxis(vm, e);
  }
  translateZ(e) {
    return this.translateOnAxis(xm, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(xs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? pa.copy(e) : pa.set(e, t, r);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), Ho.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xs.lookAt(Ho, pa, this.up) : xs.lookAt(pa, Ho, this.up), this.quaternion.setFromRotationMatrix(xs), n && (xs.extractRotation(n.matrixWorld), Xr.setFromRotationMatrix(xs), this.quaternion.premultiply(Xr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(HC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(XC)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), xs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), xs.multiply(e.parent.matrixWorld)), e.applyMatrix4(xs), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, n = this.children.length; r < n; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const o = this.children[n].getObjectsByProperty(e, t);
      o.length > 0 && (r = r.concat(o));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ho, e, jC), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ho, WC, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let s = 0, o = n.length; s < o; s++) {
        const i = n[s];
        i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function s(i, a) {
      return i[a.uuid] === void 0 && (i[a.uuid] = a.toJSON(e)), a.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const i = this.geometry.parameters;
      if (i !== void 0 && i.shapes !== void 0) {
        const a = i.shapes;
        if (Array.isArray(a))
          for (let l = 0, u = a.length; l < u; l++) {
            const h = a[l];
            s(e.shapes, h);
          }
        else
          s(e.shapes, a);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const i = [];
        for (let a = 0, l = this.material.length; a < l; a++)
          i.push(s(e.materials, this.material[a]));
        n.material = i;
      } else
        n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let i = 0; i < this.children.length; i++)
        n.children.push(this.children[i].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const a = this.animations[i];
        n.animations.push(s(e.animations, a));
      }
    }
    if (t) {
      const i = o(e.geometries), a = o(e.materials), l = o(e.textures), u = o(e.images), h = o(e.shapes), d = o(e.skeletons), f = o(e.animations), p = o(e.nodes);
      i.length > 0 && (r.geometries = i), a.length > 0 && (r.materials = a), l.length > 0 && (r.textures = l), u.length > 0 && (r.images = u), h.length > 0 && (r.shapes = h), d.length > 0 && (r.skeletons = d), f.length > 0 && (r.animations = f), p.length > 0 && (r.nodes = p);
    }
    return r.object = n, r;
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
}
qs.DEFAULT_UP = /* @__PURE__ */ new j(0, 1, 0);
qs.DEFAULT_MATRIX_AUTO_UPDATE = !0;
qs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
function $C(c) {
  if (c.length === 0)
    return 1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] < e && (e = c[t]);
  return e;
}
function qC(c) {
  if (c.length === 0)
    return -1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] > e && (e = c[t]);
  return e;
}
function Hx(c) {
  for (let e = c.length - 1; e >= 0; --e)
    if (c[e] >= 65535)
      return !0;
  return !1;
}
const JC = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function YC(c, e) {
  return new JC[c](e);
}
function Xx(c) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", c);
}
function KC() {
  const c = Xx("canvas");
  return c.style.display = "block", c;
}
const bm = {};
function ZC(c) {
  c in bm || (bm[c] = !0, console.warn(c));
}
const QC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayMax: qC,
  arrayMin: $C,
  arrayNeedsUint32: Hx,
  createCanvasElement: KC,
  createElementNS: Xx,
  getTypedArray: YC,
  warnOnce: ZC
}, Symbol.toStringTag, { value: "Module" }));
let eE = 0;
const Dn = /* @__PURE__ */ new Qn(), Fl = /* @__PURE__ */ new qs(), $r = /* @__PURE__ */ new j(), _n = /* @__PURE__ */ new Oi(), Xo = /* @__PURE__ */ new Oi(), Gt = /* @__PURE__ */ new j();
class Kt extends Wx {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: eE++ }), this.uuid = lf(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Hx(e) ? DC : PC)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Fi().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Dn.makeRotationFromQuaternion(e), this.applyMatrix4(Dn), this;
  }
  rotateX(e) {
    return Dn.makeRotationX(e), this.applyMatrix4(Dn), this;
  }
  rotateY(e) {
    return Dn.makeRotationY(e), this.applyMatrix4(Dn), this;
  }
  rotateZ(e) {
    return Dn.makeRotationZ(e), this.applyMatrix4(Dn), this;
  }
  translate(e, t, r) {
    return Dn.makeTranslation(e, t, r), this.applyMatrix4(Dn), this;
  }
  scale(e, t, r) {
    return Dn.makeScale(e, t, r), this.applyMatrix4(Dn), this;
  }
  lookAt(e) {
    return Fl.lookAt(e), Fl.updateMatrix(), this.applyMatrix4(Fl.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter($r).negate(), this.translate($r.x, $r.y, $r.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, n = e.length; r < n; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Xe(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Oi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new j(-1 / 0, -1 / 0, -1 / 0),
        new j(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, n = t.length; r < n; r++) {
          const s = t[r];
          _n.setFromBufferAttribute(s), this.morphTargetsRelative ? (Gt.addVectors(this.boundingBox.min, _n.min), this.boundingBox.expandByPoint(Gt), Gt.addVectors(this.boundingBox.max, _n.max), this.boundingBox.expandByPoint(Gt)) : (this.boundingBox.expandByPoint(_n.min), this.boundingBox.expandByPoint(_n.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new zC());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new j(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (_n.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s];
          Xo.setFromBufferAttribute(i), this.morphTargetsRelative ? (Gt.addVectors(_n.min, Xo.min), _n.expandByPoint(Gt), Gt.addVectors(_n.max, Xo.max), _n.expandByPoint(Gt)) : (_n.expandByPoint(Xo.min), _n.expandByPoint(Xo.max));
        }
      _n.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Gt.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Gt));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s], a = this.morphTargetsRelative;
          for (let l = 0, u = i.count; l < u; l++)
            Gt.fromBufferAttribute(i, l), a && ($r.fromBufferAttribute(e, l), Gt.add($r)), n = Math.max(n, r.distanceToSquared(Gt));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, n = t.position.array, s = t.normal.array, o = t.uv.array, i = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new fo(new Float32Array(4 * i), 4));
    const a = this.getAttribute("tangent").array, l = [], u = [];
    for (let A = 0; A < i; A++)
      l[A] = new j(), u[A] = new j();
    const h = new j(), d = new j(), f = new j(), p = new Re(), m = new Re(), g = new Re(), b = new j(), v = new j();
    function y(A, U, S) {
      h.fromArray(n, A * 3), d.fromArray(n, U * 3), f.fromArray(n, S * 3), p.fromArray(o, A * 2), m.fromArray(o, U * 2), g.fromArray(o, S * 2), d.sub(h), f.sub(h), m.sub(p), g.sub(p);
      const R = 1 / (m.x * g.y - g.x * m.y);
      isFinite(R) && (b.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(R), v.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(R), l[A].add(b), l[U].add(b), l[S].add(b), u[A].add(v), u[U].add(v), u[S].add(v));
    }
    let x = this.groups;
    x.length === 0 && (x = [{
      start: 0,
      count: r.length
    }]);
    for (let A = 0, U = x.length; A < U; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let D = R, P = R + E; D < P; D += 3)
        y(
          r[D + 0],
          r[D + 1],
          r[D + 2]
        );
    }
    const N = new j(), w = new j(), T = new j(), _ = new j();
    function L(A) {
      T.fromArray(s, A * 3), _.copy(T);
      const U = l[A];
      N.copy(U), N.sub(T.multiplyScalar(T.dot(U))).normalize(), w.crossVectors(_, U);
      const R = w.dot(u[A]) < 0 ? -1 : 1;
      a[A * 4] = N.x, a[A * 4 + 1] = N.y, a[A * 4 + 2] = N.z, a[A * 4 + 3] = R;
    }
    for (let A = 0, U = x.length; A < U; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let D = R, P = R + E; D < P; D += 3)
        L(r[D + 0]), L(r[D + 1]), L(r[D + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new fo(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let d = 0, f = r.count; d < f; d++)
          r.setXYZ(d, 0, 0, 0);
      const n = new j(), s = new j(), o = new j(), i = new j(), a = new j(), l = new j(), u = new j(), h = new j();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0), m = e.getX(d + 1), g = e.getX(d + 2);
          n.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), i.fromBufferAttribute(r, p), a.fromBufferAttribute(r, m), l.fromBufferAttribute(r, g), i.add(u), a.add(u), l.add(u), r.setXYZ(p, i.x, i.y, i.z), r.setXYZ(m, a.x, a.y, a.z), r.setXYZ(g, l.x, l.y, l.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), r.setXYZ(d + 0, u.x, u.y, u.z), r.setXYZ(d + 1, u.x, u.y, u.z), r.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Gt.fromBufferAttribute(e, t), Gt.normalize(), e.setXYZ(t, Gt.x, Gt.y, Gt.z);
  }
  toNonIndexed() {
    function e(i, a) {
      const l = i.array, u = i.itemSize, h = i.normalized, d = new l.constructor(a.length * u);
      let f = 0, p = 0;
      for (let m = 0, g = a.length; m < g; m++) {
        i.isInterleavedBufferAttribute ? f = a[m] * i.data.stride + i.offset : f = a[m] * u;
        for (let b = 0; b < u; b++)
          d[p++] = l[f++];
      }
      return new fo(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Kt(), r = this.index.array, n = this.attributes;
    for (const i in n) {
      const a = n[i], l = e(a, r);
      t.setAttribute(i, l);
    }
    const s = this.morphAttributes;
    for (const i in s) {
      const a = [], l = s[i];
      for (let u = 0, h = l.length; u < h; u++) {
        const d = l[u], f = e(d, r);
        a.push(f);
      }
      t.morphAttributes[i] = a;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let i = 0, a = o.length; i < a; i++) {
      const l = o[i];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const a = this.parameters;
      for (const l in a)
        a[l] !== void 0 && (e[l] = a[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const a in r) {
      const l = r[a];
      e.data.attributes[a] = l.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const a in this.morphAttributes) {
      const l = this.morphAttributes[a], u = [];
      for (let h = 0, d = l.length; h < d; h++) {
        const f = l[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[a] = u, s = !0);
    }
    s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const i = this.boundingSphere;
    return i !== null && (e.data.boundingSphere = {
      center: i.center.toArray(),
      radius: i.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const n = e.attributes;
    for (const l in n) {
      const u = n[l];
      this.setAttribute(l, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const u = [], h = s[l];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const i = e.boundingBox;
    i !== null && (this.boundingBox = i.clone());
    const a = e.boundingSphere;
    return a !== null && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class uf extends Kt {
  constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: n,
      heightSegments: s,
      depthSegments: o
    };
    const i = this;
    n = Math.floor(n), s = Math.floor(s), o = Math.floor(o);
    const a = [], l = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, r, t, e, o, s, 0), p("z", "y", "x", 1, -1, r, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, r, t, n, o, 2), p("x", "z", "y", 1, -1, e, r, -t, n, o, 3), p("x", "y", "z", 1, -1, e, t, r, n, s, 4), p("x", "y", "z", -1, -1, e, t, -r, n, s, 5), this.setIndex(a), this.setAttribute("position", new Xe(l, 3)), this.setAttribute("normal", new Xe(u, 3)), this.setAttribute("uv", new Xe(h, 2));
    function p(m, g, b, v, y, x, N, w, T, _, L) {
      const A = x / T, U = N / _, S = x / 2, R = N / 2, E = w / 2, D = T + 1, P = _ + 1;
      let se = 0, oe = 0;
      const H = new j();
      for (let X = 0; X < P; X++) {
        const C = X * U - R;
        for (let F = 0; F < D; F++) {
          const I = F * A - S;
          H[m] = I * v, H[g] = C * y, H[b] = E, l.push(H.x, H.y, H.z), H[m] = 0, H[g] = 0, H[b] = w > 0 ? 1 : -1, u.push(H.x, H.y, H.z), h.push(F / T), h.push(1 - X / _), se += 1;
        }
      }
      for (let X = 0; X < _; X++)
        for (let C = 0; C < T; C++) {
          const F = d + C + D * X, I = d + C + D * (X + 1), k = d + (C + 1) + D * (X + 1), z = d + (C + 1) + D * X;
          a.push(F, I, z), a.push(I, k, z), oe += 6;
        }
      i.addGroup(f, oe, L), f += oe, d += se;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uf(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class gs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, n = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      r = this.getPoint(o / e), s += r.distanceTo(n), t.push(s), n = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let n = 0;
    const s = r.length;
    let o;
    t ? o = t : o = e * r[s - 1];
    let i = 0, a = s - 1, l;
    for (; i <= a; )
      if (n = Math.floor(i + (a - i) / 2), l = r[n] - o, l < 0)
        i = n + 1;
      else if (l > 0)
        a = n - 1;
      else {
        a = n;
        break;
      }
    if (n = a, r[n] === o)
      return n / (s - 1);
    const u = r[n], d = r[n + 1] - u, f = (o - u) / d;
    return (n + f) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const o = this.getPoint(n), i = this.getPoint(s), a = t || (o.isVector2 ? new Re() : new j());
    return a.copy(i).sub(o).normalize(), a;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new j(), n = [], s = [], o = [], i = new j(), a = new Qn();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      n[f] = this.getTangentAt(p, new j());
    }
    s[0] = new j(), o[0] = new j();
    let l = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= l && (l = u, r.set(1, 0, 0)), h <= l && (l = h, r.set(0, 1, 0)), d <= l && r.set(0, 0, 1), i.crossVectors(n[0], r).normalize(), s[0].crossVectors(n[0], i), o[0].crossVectors(n[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), i.crossVectors(n[f - 1], n[f]), i.length() > Number.EPSILON) {
        i.normalize();
        const p = Math.acos(zn(n[f - 1].dot(n[f]), -1, 1));
        s[f].applyMatrix4(a.makeRotationAxis(i, p));
      }
      o[f].crossVectors(n[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(zn(s[0].dot(s[e]), -1, 1));
      f /= e, n[0].dot(i.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        s[p].applyMatrix4(a.makeRotationAxis(n[p], f * p)), o[p].crossVectors(n[p], s[p]);
    }
    return {
      tangents: n,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class hf extends gs {
  constructor(e = 0, t = 0, r = 1, n = 1, s = 0, o = Math.PI * 2, i = !1, a = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = i, this.aRotation = a;
  }
  getPoint(e, t) {
    const r = t || new Re(), n = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += n;
    for (; s > n; )
      s -= n;
    s < Number.EPSILON && (o ? s = 0 : s = n), this.aClockwise === !0 && !o && (s === n ? s = -n : s = s - n);
    const i = this.aStartAngle + e * s;
    let a = this.aX + this.xRadius * Math.cos(i), l = this.aY + this.yRadius * Math.sin(i);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = a - this.aX, f = l - this.aY;
      a = d * u - f * h + this.aX, l = d * h + f * u + this.aY;
    }
    return r.set(a, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class tE extends hf {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, r, n, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function df() {
  let c = 0, e = 0, t = 0, r = 0;
  function n(s, o, i, a) {
    c = s, e = i, t = -3 * s + 3 * o - 2 * i - a, r = 2 * s - 2 * o + i + a;
  }
  return {
    initCatmullRom: function(s, o, i, a, l) {
      n(o, i, l * (i - s), l * (a - o));
    },
    initNonuniformCatmullRom: function(s, o, i, a, l, u, h) {
      let d = (o - s) / l - (i - s) / (l + u) + (i - o) / u, f = (i - o) / u - (a - o) / (u + h) + (a - i) / h;
      d *= u, f *= u, n(o, i, d, f);
    },
    calc: function(s) {
      const o = s * s, i = o * s;
      return c + e * s + t * o + r * i;
    }
  };
}
const ma = /* @__PURE__ */ new j(), Il = /* @__PURE__ */ new df(), Pl = /* @__PURE__ */ new df(), Dl = /* @__PURE__ */ new df();
class nE extends gs {
  constructor(e = [], t = !1, r = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.points, s = n.length, o = (s - (this.closed ? 0 : 1)) * e;
    let i = Math.floor(o), a = o - i;
    this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / s) + 1) * s : a === 0 && i === s - 1 && (i = s - 2, a = 1);
    let l, u;
    this.closed || i > 0 ? l = n[(i - 1) % s] : (ma.subVectors(n[0], n[1]).add(n[0]), l = ma);
    const h = n[i % s], d = n[(i + 1) % s];
    if (this.closed || i + 2 < s ? u = n[(i + 2) % s] : (ma.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), u = ma), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(l.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), g = Math.pow(d.distanceToSquared(u), f);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Il.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, p, m, g), Pl.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, p, m, g), Dl.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, p, m, g);
    } else
      this.curveType === "catmullrom" && (Il.initCatmullRom(l.x, h.x, d.x, u.x, this.tension), Pl.initCatmullRom(l.y, h.y, d.y, u.y, this.tension), Dl.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
    return r.set(
      Il.calc(a),
      Pl.calc(a),
      Dl.calc(a)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new j().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Nm(c, e, t, r, n) {
  const s = (r - e) * 0.5, o = (n - t) * 0.5, i = c * c, a = c * i;
  return (2 * t - 2 * r + s + o) * a + (-3 * t + 3 * r - 2 * s - o) * i + s * c + t;
}
function sE(c, e) {
  const t = 1 - c;
  return t * t * e;
}
function rE(c, e) {
  return 2 * (1 - c) * c * e;
}
function oE(c, e) {
  return c * c * e;
}
function ei(c, e, t, r) {
  return sE(c, e) + rE(c, t) + oE(c, r);
}
function iE(c, e) {
  const t = 1 - c;
  return t * t * t * e;
}
function aE(c, e) {
  const t = 1 - c;
  return 3 * t * t * c * e;
}
function cE(c, e) {
  return 3 * (1 - c) * c * c * e;
}
function lE(c, e) {
  return c * c * c * e;
}
function ti(c, e, t, r, n) {
  return iE(c, e) + aE(c, t) + cE(c, r) + lE(c, n);
}
class $x extends gs {
  constructor(e = new Re(), t = new Re(), r = new Re(), n = new Re()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      ti(e, n.x, s.x, o.x, i.x),
      ti(e, n.y, s.y, o.y, i.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class uE extends gs {
  constructor(e = new j(), t = new j(), r = new j(), n = new j()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      ti(e, n.x, s.x, o.x, i.x),
      ti(e, n.y, s.y, o.y, i.y),
      ti(e, n.z, s.z, o.z, i.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class qx extends gs {
  constructor(e = new Re(), t = new Re()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Re()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Re()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class hE extends gs {
  constructor(e = new j(), t = new j()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new j()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new j()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Jx extends gs {
  constructor(e = new Re(), t = new Re(), r = new Re()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      ei(e, n.x, s.x, o.x),
      ei(e, n.y, s.y, o.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Yx extends gs {
  constructor(e = new j(), t = new j(), r = new j()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      ei(e, n.x, s.x, o.x),
      ei(e, n.y, s.y, o.y),
      ei(e, n.z, s.z, o.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Kx extends gs {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.points, s = (n.length - 1) * e, o = Math.floor(s), i = s - o, a = n[o === 0 ? o : o - 1], l = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return r.set(
      Nm(i, a.x, l.x, u.x, h.x),
      Nm(i, a.y, l.y, u.y, h.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new Re().fromArray(n));
    }
    return this;
  }
}
const Ja = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: tE,
  CatmullRomCurve3: nE,
  CubicBezierCurve: $x,
  CubicBezierCurve3: uE,
  EllipseCurve: hf,
  LineCurve: qx,
  LineCurve3: hE,
  QuadraticBezierCurve: Jx,
  QuadraticBezierCurve3: Yx,
  SplineCurve: Kx
}, Symbol.toStringTag, { value: "Module" }));
class dE extends gs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Ja[r](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= r) {
        const o = n[s] - r, i = this.curves[s], a = i.getLength(), l = a === 0 ? 0 : 1 - o / a;
        return i.getPointAt(l, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let n = 0, s = this.curves; n < s.length; n++) {
      const o = s[n], i = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, a = o.getPoints(i);
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        r && r.equals(u) || (t.push(u), r = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(new Ja[n.type]().fromJSON(n));
    }
    return this;
  }
}
class bu extends dE {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Re(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new qx(this.currentPoint.clone(), new Re(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, n) {
    const s = new Jx(
      this.currentPoint.clone(),
      new Re(e, t),
      new Re(r, n)
    );
    return this.curves.push(s), this.currentPoint.set(r, n), this;
  }
  bezierCurveTo(e, t, r, n, s, o) {
    const i = new $x(
      this.currentPoint.clone(),
      new Re(e, t),
      new Re(r, n),
      new Re(s, o)
    );
    return this.curves.push(i), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new Kx(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, n, s, o) {
    const i = this.currentPoint.x, a = this.currentPoint.y;
    return this.absarc(
      e + i,
      t + a,
      r,
      n,
      s,
      o
    ), this;
  }
  absarc(e, t, r, n, s, o) {
    return this.absellipse(e, t, r, r, n, s, o), this;
  }
  ellipse(e, t, r, n, s, o, i, a) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, t + u, r, n, s, o, i, a), this;
  }
  absellipse(e, t, r, n, s, o, i, a) {
    const l = new hf(e, t, r, n, s, o, i, a);
    if (this.curves.length > 0) {
      const h = l.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Fc extends Kt {
  constructor(e = [new Re(0, -0.5), new Re(0.5, 0), new Re(0, 0.5)], t = 12, r = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: n
    }, t = Math.floor(t), n = zn(n, 0, Math.PI * 2);
    const s = [], o = [], i = [], a = [], l = [], u = 1 / t, h = new j(), d = new Re(), f = new j(), p = new j(), m = new j();
    let g = 0, b = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, m.copy(f), f.normalize(), a.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          a.push(m.x, m.y, m.z);
          break;
        default:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), a.push(f.x, f.y, f.z), m.copy(p);
      }
    for (let v = 0; v <= t; v++) {
      const y = r + v * u * n, x = Math.sin(y), N = Math.cos(y);
      for (let w = 0; w <= e.length - 1; w++) {
        h.x = e[w].x * x, h.y = e[w].y, h.z = e[w].x * N, o.push(h.x, h.y, h.z), d.x = v / t, d.y = w / (e.length - 1), i.push(d.x, d.y);
        const T = a[3 * w + 0] * x, _ = a[3 * w + 1], L = a[3 * w + 0] * N;
        l.push(T, _, L);
      }
    }
    for (let v = 0; v < t; v++)
      for (let y = 0; y < e.length - 1; y++) {
        const x = y + v * e.length, N = x, w = x + e.length, T = x + e.length + 1, _ = x + 1;
        s.push(N, w, _), s.push(T, _, w);
      }
    this.setIndex(s), this.setAttribute("position", new Xe(o, 3)), this.setAttribute("uv", new Xe(i, 2)), this.setAttribute("normal", new Xe(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fc(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class ff extends Fc {
  constructor(e = 1, t = 1, r = 4, n = 8) {
    const s = new bu();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new ff(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class pf extends Kt {
  constructor(e = 1, t = 32, r = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: n
    }, t = Math.max(3, t);
    const s = [], o = [], i = [], a = [], l = new j(), u = new Re();
    o.push(0, 0, 0), i.push(0, 0, 1), a.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = r + h / t * n;
      l.x = e * Math.cos(f), l.y = e * Math.sin(f), o.push(l.x, l.y, l.z), i.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, a.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      s.push(h, h + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Xe(o, 3)), this.setAttribute("normal", new Xe(i, 3)), this.setAttribute("uv", new Xe(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pf(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ic extends Kt {
  constructor(e = 1, t = 1, r = 1, n = 32, s = 1, o = !1, i = 0, a = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: n,
      heightSegments: s,
      openEnded: o,
      thetaStart: i,
      thetaLength: a
    };
    const l = this;
    n = Math.floor(n), s = Math.floor(s);
    const u = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], g = r / 2;
    let b = 0;
    v(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new Xe(h, 3)), this.setAttribute("normal", new Xe(d, 3)), this.setAttribute("uv", new Xe(f, 2));
    function v() {
      const x = new j(), N = new j();
      let w = 0;
      const T = (t - e) / r;
      for (let _ = 0; _ <= s; _++) {
        const L = [], A = _ / s, U = A * (t - e) + e;
        for (let S = 0; S <= n; S++) {
          const R = S / n, E = R * a + i, D = Math.sin(E), P = Math.cos(E);
          N.x = U * D, N.y = -A * r + g, N.z = U * P, h.push(N.x, N.y, N.z), x.set(D, T, P).normalize(), d.push(x.x, x.y, x.z), f.push(R, 1 - A), L.push(p++);
        }
        m.push(L);
      }
      for (let _ = 0; _ < n; _++)
        for (let L = 0; L < s; L++) {
          const A = m[L][_], U = m[L + 1][_], S = m[L + 1][_ + 1], R = m[L][_ + 1];
          u.push(A, U, R), u.push(U, S, R), w += 6;
        }
      l.addGroup(b, w, 0), b += w;
    }
    function y(x) {
      const N = p, w = new Re(), T = new j();
      let _ = 0;
      const L = x === !0 ? e : t, A = x === !0 ? 1 : -1;
      for (let S = 1; S <= n; S++)
        h.push(0, g * A, 0), d.push(0, A, 0), f.push(0.5, 0.5), p++;
      const U = p;
      for (let S = 0; S <= n; S++) {
        const E = S / n * a + i, D = Math.cos(E), P = Math.sin(E);
        T.x = L * P, T.y = g * A, T.z = L * D, h.push(T.x, T.y, T.z), d.push(0, A, 0), w.x = D * 0.5 + 0.5, w.y = P * 0.5 * A + 0.5, f.push(w.x, w.y), p++;
      }
      for (let S = 0; S < n; S++) {
        const R = N + S, E = U + S;
        x === !0 ? u.push(E, E + 1, R) : u.push(E + 1, E, R), _ += 3;
      }
      l.addGroup(b, _, x === !0 ? 1 : 2), b += _;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ic(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class mf extends Ic {
  constructor(e = 1, t = 1, r = 32, n = 1, s = !1, o = 0, i = Math.PI * 2) {
    super(0, e, t, r, n, s, o, i), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: n,
      openEnded: s,
      thetaStart: o,
      thetaLength: i
    };
  }
  static fromJSON(e) {
    return new mf(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Fr extends Kt {
  constructor(e = [], t = [], r = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: n
    };
    const s = [], o = [];
    i(n), l(r), u(), this.setAttribute("position", new Xe(s, 3)), this.setAttribute("normal", new Xe(s.slice(), 3)), this.setAttribute("uv", new Xe(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function i(v) {
      const y = new j(), x = new j(), N = new j();
      for (let w = 0; w < t.length; w += 3)
        f(t[w + 0], y), f(t[w + 1], x), f(t[w + 2], N), a(y, x, N, v);
    }
    function a(v, y, x, N) {
      const w = N + 1, T = [];
      for (let _ = 0; _ <= w; _++) {
        T[_] = [];
        const L = v.clone().lerp(x, _ / w), A = y.clone().lerp(x, _ / w), U = w - _;
        for (let S = 0; S <= U; S++)
          S === 0 && _ === w ? T[_][S] = L : T[_][S] = L.clone().lerp(A, S / U);
      }
      for (let _ = 0; _ < w; _++)
        for (let L = 0; L < 2 * (w - _) - 1; L++) {
          const A = Math.floor(L / 2);
          L % 2 === 0 ? (d(T[_][A + 1]), d(T[_ + 1][A]), d(T[_][A])) : (d(T[_][A + 1]), d(T[_ + 1][A + 1]), d(T[_ + 1][A]));
        }
    }
    function l(v) {
      const y = new j();
      for (let x = 0; x < s.length; x += 3)
        y.x = s[x + 0], y.y = s[x + 1], y.z = s[x + 2], y.normalize().multiplyScalar(v), s[x + 0] = y.x, s[x + 1] = y.y, s[x + 2] = y.z;
    }
    function u() {
      const v = new j();
      for (let y = 0; y < s.length; y += 3) {
        v.x = s[y + 0], v.y = s[y + 1], v.z = s[y + 2];
        const x = g(v) / 2 / Math.PI + 0.5, N = b(v) / Math.PI + 0.5;
        o.push(x, 1 - N);
      }
      p(), h();
    }
    function h() {
      for (let v = 0; v < o.length; v += 6) {
        const y = o[v + 0], x = o[v + 2], N = o[v + 4], w = Math.max(y, x, N), T = Math.min(y, x, N);
        w > 0.9 && T < 0.1 && (y < 0.2 && (o[v + 0] += 1), x < 0.2 && (o[v + 2] += 1), N < 0.2 && (o[v + 4] += 1));
      }
    }
    function d(v) {
      s.push(v.x, v.y, v.z);
    }
    function f(v, y) {
      const x = v * 3;
      y.x = e[x + 0], y.y = e[x + 1], y.z = e[x + 2];
    }
    function p() {
      const v = new j(), y = new j(), x = new j(), N = new j(), w = new Re(), T = new Re(), _ = new Re();
      for (let L = 0, A = 0; L < s.length; L += 9, A += 6) {
        v.set(s[L + 0], s[L + 1], s[L + 2]), y.set(s[L + 3], s[L + 4], s[L + 5]), x.set(s[L + 6], s[L + 7], s[L + 8]), w.set(o[A + 0], o[A + 1]), T.set(o[A + 2], o[A + 3]), _.set(o[A + 4], o[A + 5]), N.copy(v).add(y).add(x).divideScalar(3);
        const U = g(N);
        m(w, A + 0, v, U), m(T, A + 2, y, U), m(_, A + 4, x, U);
      }
    }
    function m(v, y, x, N) {
      N < 0 && v.x === 1 && (o[y] = v.x - 1), x.x === 0 && x.z === 0 && (o[y] = N / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function b(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fr(e.vertices, e.indices, e.radius, e.details);
  }
}
class gf extends Fr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = 1 / r, s = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      // (±1/φ, ±φ, 0)
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      0,
      // (±φ, 0, ±1/φ)
      -r,
      0,
      -n,
      r,
      0,
      -n,
      -r,
      0,
      n,
      r,
      0,
      n
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new gf(e.radius, e.detail);
  }
}
const Yn = /* @__PURE__ */ new j(), bs = /* @__PURE__ */ new j(), Ul = /* @__PURE__ */ new j(), Ns = /* @__PURE__ */ new j(), qr = /* @__PURE__ */ new j(), Jr = /* @__PURE__ */ new j(), wm = /* @__PURE__ */ new j(), zl = /* @__PURE__ */ new j(), Bl = /* @__PURE__ */ new j(), kl = /* @__PURE__ */ new j();
let ga = !1;
class Vs {
  constructor(e = new j(), t = new j(), r = new j()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, n) {
    n.subVectors(r, t), Yn.subVectors(e, t), n.cross(Yn);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, n, s) {
    Yn.subVectors(n, t), bs.subVectors(r, t), Ul.subVectors(e, t);
    const o = Yn.dot(Yn), i = Yn.dot(bs), a = Yn.dot(Ul), l = bs.dot(bs), u = bs.dot(Ul), h = o * l - i * i;
    if (h === 0)
      return s.set(-2, -1, -1);
    const d = 1 / h, f = (l * a - i * u) * d, p = (o * u - i * a) * d;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, r, n) {
    return this.getBarycoord(e, t, r, n, Ns), Ns.x >= 0 && Ns.y >= 0 && Ns.x + Ns.y <= 1;
  }
  static getUV(e, t, r, n, s, o, i, a) {
    return ga === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ga = !0), this.getInterpolation(e, t, r, n, s, o, i, a);
  }
  static getInterpolation(e, t, r, n, s, o, i, a) {
    return this.getBarycoord(e, t, r, n, Ns), a.setScalar(0), a.addScaledVector(s, Ns.x), a.addScaledVector(o, Ns.y), a.addScaledVector(i, Ns.z), a;
  }
  static isFrontFacing(e, t, r, n) {
    return Yn.subVectors(r, t), bs.subVectors(e, t), Yn.cross(bs).dot(n) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, r, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Yn.subVectors(this.c, this.b), bs.subVectors(this.a, this.b), Yn.cross(bs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Vs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Vs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, n, s) {
    return ga === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ga = !0), Vs.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  getInterpolation(e, t, r, n, s) {
    return Vs.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  containsPoint(e) {
    return Vs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Vs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, n = this.b, s = this.c;
    let o, i;
    qr.subVectors(n, r), Jr.subVectors(s, r), zl.subVectors(e, r);
    const a = qr.dot(zl), l = Jr.dot(zl);
    if (a <= 0 && l <= 0)
      return t.copy(r);
    Bl.subVectors(e, n);
    const u = qr.dot(Bl), h = Jr.dot(Bl);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = a * h - u * l;
    if (d <= 0 && a >= 0 && u <= 0)
      return o = a / (a - u), t.copy(r).addScaledVector(qr, o);
    kl.subVectors(e, s);
    const f = qr.dot(kl), p = Jr.dot(kl);
    if (p >= 0 && f <= p)
      return t.copy(s);
    const m = f * l - a * p;
    if (m <= 0 && l >= 0 && p <= 0)
      return i = l / (l - p), t.copy(r).addScaledVector(Jr, i);
    const g = u * p - f * h;
    if (g <= 0 && h - u >= 0 && f - p >= 0)
      return wm.subVectors(s, n), i = (h - u) / (h - u + (f - p)), t.copy(n).addScaledVector(wm, i);
    const b = 1 / (g + m + d);
    return o = m * b, i = d * b, t.copy(r).addScaledVector(qr, o).addScaledVector(Jr, i);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ya = /* @__PURE__ */ new j(), va = /* @__PURE__ */ new j(), Gl = /* @__PURE__ */ new j(), xa = /* @__PURE__ */ new Vs();
class fE extends Kt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), s = Math.cos(FC * t), o = e.getIndex(), i = e.getAttribute("position"), a = o ? o.count : i.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
      for (let p = 0; p < a; p += 3) {
        o ? (l[0] = o.getX(p), l[1] = o.getX(p + 1), l[2] = o.getX(p + 2)) : (l[0] = p, l[1] = p + 1, l[2] = p + 2);
        const { a: m, b: g, c: b } = xa;
        if (m.fromBufferAttribute(i, l[0]), g.fromBufferAttribute(i, l[1]), b.fromBufferAttribute(i, l[2]), xa.getNormal(Gl), h[0] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, h[1] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, h[2] = `${Math.round(b.x * n)},${Math.round(b.y * n)},${Math.round(b.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let v = 0; v < 3; v++) {
            const y = (v + 1) % 3, x = h[v], N = h[y], w = xa[u[v]], T = xa[u[y]], _ = `${x}_${N}`, L = `${N}_${x}`;
            L in d && d[L] ? (Gl.dot(d[L].normal) <= s && (f.push(w.x, w.y, w.z), f.push(T.x, T.y, T.z)), d[L] = null) : _ in d || (d[_] = {
              index0: l[v],
              index1: l[y],
              normal: Gl.clone()
            });
          }
      }
      for (const p in d)
        if (d[p]) {
          const { index0: m, index1: g } = d[p];
          ya.fromBufferAttribute(i, m), va.fromBufferAttribute(i, g), f.push(ya.x, ya.y, ya.z), f.push(va.x, va.y, va.z);
        }
      this.setAttribute("position", new Xe(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Zx extends bu {
  constructor(e) {
    super(e), this.uuid = lf(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(new bu().fromJSON(n));
    }
    return this;
  }
}
const pE = {
  triangulate: function(c, e, t = 2) {
    const r = e && e.length, n = r ? e[0] * t : c.length;
    let s = Qx(c, 0, n, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let i, a, l, u, h, d, f;
    if (r && (s = xE(c, e, s, t)), c.length > 80 * t) {
      i = l = c[0], a = u = c[1];
      for (let p = t; p < n; p += t)
        h = c[p], d = c[p + 1], h < i && (i = h), d < a && (a = d), h > l && (l = h), d > u && (u = d);
      f = Math.max(l - i, u - a), f = f !== 0 ? 32767 / f : 0;
    }
    return yi(s, o, t, i, a, f, 0), o;
  }
};
function Qx(c, e, t, r, n) {
  let s, o;
  if (n === RE(c, e, t, r) > 0)
    for (s = e; s < t; s += r)
      o = Tm(s, c[s], c[s + 1], o);
  else
    for (s = t - r; s >= e; s -= r)
      o = Tm(s, c[s], c[s + 1], o);
  return o && Pc(o, o.next) && (xi(o), o = o.next), o;
}
function Cr(c, e) {
  if (!c)
    return c;
  e || (e = c);
  let t = c, r;
  do
    if (r = !1, !t.steiner && (Pc(t, t.next) || bt(t.prev, t, t.next) === 0)) {
      if (xi(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function yi(c, e, t, r, n, s, o) {
  if (!c)
    return;
  !o && s && SE(c, r, n, s);
  let i = c, a, l;
  for (; c.prev !== c.next; ) {
    if (a = c.prev, l = c.next, s ? gE(c, r, n, s) : mE(c)) {
      e.push(a.i / t | 0), e.push(c.i / t | 0), e.push(l.i / t | 0), xi(c), c = l.next, i = l.next;
      continue;
    }
    if (c = l, c === i) {
      o ? o === 1 ? (c = yE(Cr(c), e, t), yi(c, e, t, r, n, s, 2)) : o === 2 && vE(c, e, t, r, n, s) : yi(Cr(c), e, t, r, n, s, 1);
      break;
    }
  }
}
function mE(c) {
  const e = c.prev, t = c, r = c.next;
  if (bt(e, t, r) >= 0)
    return !1;
  const n = e.x, s = t.x, o = r.x, i = e.y, a = t.y, l = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, h = i < a ? i < l ? i : l : a < l ? a : l, d = n > s ? n > o ? n : o : s > o ? s : o, f = i > a ? i > l ? i : l : a > l ? a : l;
  let p = r.next;
  for (; p !== e; ) {
    if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && oo(n, i, s, a, o, l, p.x, p.y) && bt(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function gE(c, e, t, r) {
  const n = c.prev, s = c, o = c.next;
  if (bt(n, s, o) >= 0)
    return !1;
  const i = n.x, a = s.x, l = o.x, u = n.y, h = s.y, d = o.y, f = i < a ? i < l ? i : l : a < l ? a : l, p = u < h ? u < d ? u : d : h < d ? h : d, m = i > a ? i > l ? i : l : a > l ? a : l, g = u > h ? u > d ? u : d : h > d ? h : d, b = Nu(f, p, e, t, r), v = Nu(m, g, e, t, r);
  let y = c.prevZ, x = c.nextZ;
  for (; y && y.z >= b && x && x.z <= v; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && oo(i, u, a, h, l, d, y.x, y.y) && bt(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && oo(i, u, a, h, l, d, x.x, x.y) && bt(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= b; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && oo(i, u, a, h, l, d, y.x, y.y) && bt(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= v; ) {
    if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && oo(i, u, a, h, l, d, x.x, x.y) && bt(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function yE(c, e, t) {
  let r = c;
  do {
    const n = r.prev, s = r.next.next;
    !Pc(n, s) && eb(n, r, r.next, s) && vi(n, s) && vi(s, n) && (e.push(n.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), xi(r), xi(r.next), r = c = s), r = r.next;
  } while (r !== c);
  return Cr(r);
}
function vE(c, e, t, r, n, s) {
  let o = c;
  do {
    let i = o.next.next;
    for (; i !== o.prev; ) {
      if (o.i !== i.i && AE(o, i)) {
        let a = tb(o, i);
        o = Cr(o, o.next), a = Cr(a, a.next), yi(o, e, t, r, n, s, 0), yi(a, e, t, r, n, s, 0);
        return;
      }
      i = i.next;
    }
    o = o.next;
  } while (o !== c);
}
function xE(c, e, t, r) {
  const n = [];
  let s, o, i, a, l;
  for (s = 0, o = e.length; s < o; s++)
    i = e[s] * r, a = s < o - 1 ? e[s + 1] * r : c.length, l = Qx(c, i, a, r, !1), l === l.next && (l.steiner = !0), n.push(ME(l));
  for (n.sort(bE), s = 0; s < n.length; s++)
    t = NE(n[s], t);
  return t;
}
function bE(c, e) {
  return c.x - e.x;
}
function NE(c, e) {
  const t = wE(c, e);
  if (!t)
    return e;
  const r = tb(t, c);
  return Cr(r, r.next), Cr(t, t.next);
}
function wE(c, e) {
  let t = e, r = -1 / 0, n;
  const s = c.x, o = c.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= s && d > r && (r = d, n = t.x < t.next.x ? t : t.next, d === s))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n)
    return null;
  const i = n, a = n.x, l = n.y;
  let u = 1 / 0, h;
  t = n;
  do
    s >= t.x && t.x >= a && s !== t.x && oo(o < l ? s : r, o, a, l, o < l ? r : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), vi(t, c) && (h < u || h === u && (t.x > n.x || t.x === n.x && TE(n, t))) && (n = t, u = h)), t = t.next;
  while (t !== i);
  return n;
}
function TE(c, e) {
  return bt(c.prev, c, e.prev) < 0 && bt(e.next, c, c.next) < 0;
}
function SE(c, e, t, r) {
  let n = c;
  do
    n.z === 0 && (n.z = Nu(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== c);
  n.prevZ.nextZ = null, n.prevZ = null, _E(n);
}
function _E(c) {
  let e, t, r, n, s, o, i, a, l = 1;
  do {
    for (t = c, c = null, s = null, o = 0; t; ) {
      for (o++, r = t, i = 0, e = 0; e < l && (i++, r = r.nextZ, !!r); e++)
        ;
      for (a = l; i > 0 || a > 0 && r; )
        i !== 0 && (a === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, i--) : (n = r, r = r.nextZ, a--), s ? s.nextZ = n : c = n, n.prevZ = s, s = n;
      t = r;
    }
    s.nextZ = null, l *= 2;
  } while (o > 1);
  return c;
}
function Nu(c, e, t, r, n) {
  return c = (c - t) * n | 0, e = (e - r) * n | 0, c = (c | c << 8) & 16711935, c = (c | c << 4) & 252645135, c = (c | c << 2) & 858993459, c = (c | c << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, c | e << 1;
}
function ME(c) {
  let e = c, t = c;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== c);
  return t;
}
function oo(c, e, t, r, n, s, o, i) {
  return (n - o) * (e - i) >= (c - o) * (s - i) && (c - o) * (r - i) >= (t - o) * (e - i) && (t - o) * (s - i) >= (n - o) * (r - i);
}
function AE(c, e) {
  return c.next.i !== e.i && c.prev.i !== e.i && !CE(c, e) && // dones't intersect other edges
  (vi(c, e) && vi(e, c) && EE(c, e) && // locally visible
  (bt(c.prev, c, e.prev) || bt(c, e.prev, e)) || // does not create opposite-facing sectors
  Pc(c, e) && bt(c.prev, c, c.next) > 0 && bt(e.prev, e, e.next) > 0);
}
function bt(c, e, t) {
  return (e.y - c.y) * (t.x - e.x) - (e.x - c.x) * (t.y - e.y);
}
function Pc(c, e) {
  return c.x === e.x && c.y === e.y;
}
function eb(c, e, t, r) {
  const n = Na(bt(c, e, t)), s = Na(bt(c, e, r)), o = Na(bt(t, r, c)), i = Na(bt(t, r, e));
  return !!(n !== s && o !== i || n === 0 && ba(c, t, e) || s === 0 && ba(c, r, e) || o === 0 && ba(t, c, r) || i === 0 && ba(t, e, r));
}
function ba(c, e, t) {
  return e.x <= Math.max(c.x, t.x) && e.x >= Math.min(c.x, t.x) && e.y <= Math.max(c.y, t.y) && e.y >= Math.min(c.y, t.y);
}
function Na(c) {
  return c > 0 ? 1 : c < 0 ? -1 : 0;
}
function CE(c, e) {
  let t = c;
  do {
    if (t.i !== c.i && t.next.i !== c.i && t.i !== e.i && t.next.i !== e.i && eb(t, t.next, c, e))
      return !0;
    t = t.next;
  } while (t !== c);
  return !1;
}
function vi(c, e) {
  return bt(c.prev, c, c.next) < 0 ? bt(c, e, c.next) >= 0 && bt(c, c.prev, e) >= 0 : bt(c, e, c.prev) < 0 || bt(c, c.next, e) < 0;
}
function EE(c, e) {
  let t = c, r = !1;
  const n = (c.x + e.x) / 2, s = (c.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== c);
  return r;
}
function tb(c, e) {
  const t = new wu(c.i, c.x, c.y), r = new wu(e.i, e.x, e.y), n = c.next, s = e.prev;
  return c.next = e, e.prev = c, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function Tm(c, e, t, r) {
  const n = new wu(c, e, t);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function xi(c) {
  c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
}
function wu(c, e, t) {
  this.i = c, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function RE(c, e, t, r) {
  let n = 0;
  for (let s = e, o = t - r; s < t; s += r)
    n += (c[o] - c[s]) * (c[s + 1] + c[o + 1]), o = s;
  return n;
}
class Js {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let n = t - 1, s = 0; s < t; n = s++)
      r += e[n].x * e[s].y - e[s].x * e[n].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Js.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], n = [], s = [];
    Sm(e), _m(r, e);
    let o = e.length;
    t.forEach(Sm);
    for (let a = 0; a < t.length; a++)
      n.push(o), o += t[a].length, _m(r, t[a]);
    const i = pE.triangulate(r, n);
    for (let a = 0; a < i.length; a += 3)
      s.push(i.slice(a, a + 3));
    return s;
  }
}
function Sm(c) {
  const e = c.length;
  e > 2 && c[e - 1].equals(c[0]) && c.pop();
}
function _m(c, e) {
  for (let t = 0; t < e.length; t++)
    c.push(e[t].x), c.push(e[t].y);
}
class yf extends Kt {
  constructor(e = new Zx([new Re(0.5, 0.5), new Re(-0.5, 0.5), new Re(-0.5, -0.5), new Re(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, n = [], s = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i];
      o(l);
    }
    this.setAttribute("position", new Xe(n, 3)), this.setAttribute("uv", new Xe(s, 2)), this.computeVertexNormals();
    function o(i) {
      const a = [], l = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, p = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const b = t.extrudePath, v = t.UVGenerator !== void 0 ? t.UVGenerator : LE;
      let y, x = !1, N, w, T, _;
      b && (y = b.getSpacedPoints(u), x = !0, d = !1, N = b.computeFrenetFrames(u, !1), w = new j(), T = new j(), _ = new j()), d || (g = 0, f = 0, p = 0, m = 0);
      const L = i.extractPoints(l);
      let A = L.shape;
      const U = L.holes;
      if (!Js.isClockWise(A)) {
        A = A.reverse();
        for (let O = 0, te = U.length; O < te; O++) {
          const Z = U[O];
          Js.isClockWise(Z) && (U[O] = Z.reverse());
        }
      }
      const R = Js.triangulateShape(A, U), E = A;
      for (let O = 0, te = U.length; O < te; O++) {
        const Z = U[O];
        A = A.concat(Z);
      }
      function D(O, te, Z) {
        return te || console.error("THREE.ExtrudeGeometry: vec does not exist"), O.clone().addScaledVector(te, Z);
      }
      const P = A.length, se = R.length;
      function oe(O, te, Z) {
        let Y, ee, pe;
        const ne = O.x - te.x, he = O.y - te.y, fe = Z.x - O.x, K = Z.y - O.y, Ae = ne * ne + he * he, me = ne * K - he * fe;
        if (Math.abs(me) > Number.EPSILON) {
          const be = Math.sqrt(Ae), de = Math.sqrt(fe * fe + K * K), qe = te.x - he / be, le = te.y + ne / be, Ne = Z.x - K / de, ve = Z.y + fe / de, Te = ((Ne - qe) * K - (ve - le) * fe) / (ne * K - he * fe);
          Y = qe + ne * Te - O.x, ee = le + he * Te - O.y;
          const Pe = Y * Y + ee * ee;
          if (Pe <= 2)
            return new Re(Y, ee);
          pe = Math.sqrt(Pe / 2);
        } else {
          let be = !1;
          ne > Number.EPSILON ? fe > Number.EPSILON && (be = !0) : ne < -Number.EPSILON ? fe < -Number.EPSILON && (be = !0) : Math.sign(he) === Math.sign(K) && (be = !0), be ? (Y = -he, ee = ne, pe = Math.sqrt(Ae)) : (Y = ne, ee = he, pe = Math.sqrt(Ae / 2));
        }
        return new Re(Y / pe, ee / pe);
      }
      const H = [];
      for (let O = 0, te = E.length, Z = te - 1, Y = O + 1; O < te; O++, Z++, Y++)
        Z === te && (Z = 0), Y === te && (Y = 0), H[O] = oe(E[O], E[Z], E[Y]);
      const X = [];
      let C, F = H.concat();
      for (let O = 0, te = U.length; O < te; O++) {
        const Z = U[O];
        C = [];
        for (let Y = 0, ee = Z.length, pe = ee - 1, ne = Y + 1; Y < ee; Y++, pe++, ne++)
          pe === ee && (pe = 0), ne === ee && (ne = 0), C[Y] = oe(Z[Y], Z[pe], Z[ne]);
        X.push(C), F = F.concat(C);
      }
      for (let O = 0; O < g; O++) {
        const te = O / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, pe = E.length; ee < pe; ee++) {
          const ne = D(E[ee], H[ee], Y);
          W(ne.x, ne.y, -Z);
        }
        for (let ee = 0, pe = U.length; ee < pe; ee++) {
          const ne = U[ee];
          C = X[ee];
          for (let he = 0, fe = ne.length; he < fe; he++) {
            const K = D(ne[he], C[he], Y);
            W(K.x, K.y, -Z);
          }
        }
      }
      const I = p + m;
      for (let O = 0; O < P; O++) {
        const te = d ? D(A[O], F[O], I) : A[O];
        x ? (T.copy(N.normals[0]).multiplyScalar(te.x), w.copy(N.binormals[0]).multiplyScalar(te.y), _.copy(y[0]).add(T).add(w), W(_.x, _.y, _.z)) : W(te.x, te.y, 0);
      }
      for (let O = 1; O <= u; O++)
        for (let te = 0; te < P; te++) {
          const Z = d ? D(A[te], F[te], I) : A[te];
          x ? (T.copy(N.normals[O]).multiplyScalar(Z.x), w.copy(N.binormals[O]).multiplyScalar(Z.y), _.copy(y[O]).add(T).add(w), W(_.x, _.y, _.z)) : W(Z.x, Z.y, h / u * O);
        }
      for (let O = g - 1; O >= 0; O--) {
        const te = O / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, pe = E.length; ee < pe; ee++) {
          const ne = D(E[ee], H[ee], Y);
          W(ne.x, ne.y, h + Z);
        }
        for (let ee = 0, pe = U.length; ee < pe; ee++) {
          const ne = U[ee];
          C = X[ee];
          for (let he = 0, fe = ne.length; he < fe; he++) {
            const K = D(ne[he], C[he], Y);
            x ? W(K.x, K.y + y[u - 1].y, y[u - 1].x + Z) : W(K.x, K.y, h + Z);
          }
        }
      }
      k(), z();
      function k() {
        const O = n.length / 3;
        if (d) {
          let te = 0, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[2] + Z, ee[1] + Z, ee[0] + Z);
          }
          te = u + g * 2, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[0] + Z, ee[1] + Z, ee[2] + Z);
          }
        } else {
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[2], Z[1], Z[0]);
          }
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[0] + P * u, Z[1] + P * u, Z[2] + P * u);
          }
        }
        r.addGroup(O, n.length / 3 - O, 0);
      }
      function z() {
        const O = n.length / 3;
        let te = 0;
        Q(E, te), te += E.length;
        for (let Z = 0, Y = U.length; Z < Y; Z++) {
          const ee = U[Z];
          Q(ee, te), te += ee.length;
        }
        r.addGroup(O, n.length / 3 - O, 1);
      }
      function Q(O, te) {
        let Z = O.length;
        for (; --Z >= 0; ) {
          const Y = Z;
          let ee = Z - 1;
          ee < 0 && (ee = O.length - 1);
          for (let pe = 0, ne = u + g * 2; pe < ne; pe++) {
            const he = P * pe, fe = P * (pe + 1), K = te + Y + he, Ae = te + ee + he, me = te + ee + fe, be = te + Y + fe;
            ie(K, Ae, me, be);
          }
        }
      }
      function W(O, te, Z) {
        a.push(O), a.push(te), a.push(Z);
      }
      function q(O, te, Z) {
        ae(O), ae(te), ae(Z);
        const Y = n.length / 3, ee = v.generateTopUV(r, n, Y - 3, Y - 2, Y - 1);
        $(ee[0]), $(ee[1]), $(ee[2]);
      }
      function ie(O, te, Z, Y) {
        ae(O), ae(te), ae(Y), ae(te), ae(Z), ae(Y);
        const ee = n.length / 3, pe = v.generateSideWallUV(r, n, ee - 6, ee - 3, ee - 2, ee - 1);
        $(pe[0]), $(pe[1]), $(pe[3]), $(pe[1]), $(pe[2]), $(pe[3]);
      }
      function ae(O) {
        n.push(a[O * 3 + 0]), n.push(a[O * 3 + 1]), n.push(a[O * 3 + 2]);
      }
      function $(O) {
        s.push(O.x), s.push(O.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return OE(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const i = t[e.shapes[s]];
      r.push(i);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Ja[n.type]().fromJSON(n)), new yf(r, e.options);
  }
}
const LE = {
  generateTopUV: function(c, e, t, r, n) {
    const s = e[t * 3], o = e[t * 3 + 1], i = e[r * 3], a = e[r * 3 + 1], l = e[n * 3], u = e[n * 3 + 1];
    return [
      new Re(s, o),
      new Re(i, a),
      new Re(l, u)
    ];
  },
  generateSideWallUV: function(c, e, t, r, n, s) {
    const o = e[t * 3], i = e[t * 3 + 1], a = e[t * 3 + 2], l = e[r * 3], u = e[r * 3 + 1], h = e[r * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], p = e[n * 3 + 2], m = e[s * 3], g = e[s * 3 + 1], b = e[s * 3 + 2];
    return Math.abs(i - u) < Math.abs(o - l) ? [
      new Re(o, 1 - a),
      new Re(l, 1 - h),
      new Re(d, 1 - p),
      new Re(m, 1 - b)
    ] : [
      new Re(i, 1 - a),
      new Re(u, 1 - h),
      new Re(f, 1 - p),
      new Re(g, 1 - b)
    ];
  }
};
function OE(c, e, t) {
  if (t.shapes = [], Array.isArray(c))
    for (let r = 0, n = c.length; r < n; r++) {
      const s = c[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(c.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class vf extends Fr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new vf(e.radius, e.detail);
  }
}
class xf extends Fr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new xf(e.radius, e.detail);
  }
}
class bf extends Kt {
  constructor(e = 1, t = 1, r = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: n
    };
    const s = e / 2, o = t / 2, i = Math.floor(r), a = Math.floor(n), l = i + 1, u = a + 1, h = e / i, d = t / a, f = [], p = [], m = [], g = [];
    for (let b = 0; b < u; b++) {
      const v = b * d - o;
      for (let y = 0; y < l; y++) {
        const x = y * h - s;
        p.push(x, -v, 0), m.push(0, 0, 1), g.push(y / i), g.push(1 - b / a);
      }
    }
    for (let b = 0; b < a; b++)
      for (let v = 0; v < i; v++) {
        const y = v + l * b, x = v + l * (b + 1), N = v + 1 + l * (b + 1), w = v + 1 + l * b;
        f.push(y, x, w), f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new Xe(p, 3)), this.setAttribute("normal", new Xe(m, 3)), this.setAttribute("uv", new Xe(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new bf(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Nf extends Kt {
  constructor(e = 0.5, t = 1, r = 32, n = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: n,
      thetaStart: s,
      thetaLength: o
    }, r = Math.max(3, r), n = Math.max(1, n);
    const i = [], a = [], l = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new j(), p = new Re();
    for (let m = 0; m <= n; m++) {
      for (let g = 0; g <= r; g++) {
        const b = s + g / r * o;
        f.x = h * Math.cos(b), f.y = h * Math.sin(b), a.push(f.x, f.y, f.z), l.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, u.push(p.x, p.y);
      }
      h += d;
    }
    for (let m = 0; m < n; m++) {
      const g = m * (r + 1);
      for (let b = 0; b < r; b++) {
        const v = b + g, y = v, x = v + r + 1, N = v + r + 2, w = v + 1;
        i.push(y, x, w), i.push(x, N, w);
      }
    }
    this.setIndex(i), this.setAttribute("position", new Xe(a, 3)), this.setAttribute("normal", new Xe(l, 3)), this.setAttribute("uv", new Xe(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Nf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class wf extends Kt {
  constructor(e = new Zx([new Re(0, 0.5), new Re(-0.5, -0.5), new Re(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], n = [], s = [], o = [];
    let i = 0, a = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(i, a, u), i += a, a = 0;
    this.setIndex(r), this.setAttribute("position", new Xe(n, 3)), this.setAttribute("normal", new Xe(s, 3)), this.setAttribute("uv", new Xe(o, 2));
    function l(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      Js.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        Js.isClockWise(v) === !0 && (p[g] = v.reverse());
      }
      const m = Js.triangulateShape(f, p);
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        f = f.concat(v);
      }
      for (let g = 0, b = f.length; g < b; g++) {
        const v = f[g];
        n.push(v.x, v.y, 0), s.push(0, 0, 1), o.push(v.x, v.y);
      }
      for (let g = 0, b = m.length; g < b; g++) {
        const v = m[g], y = v[0] + h, x = v[1] + h, N = v[2] + h;
        r.push(y, x, N), a += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return FE(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let n = 0, s = e.shapes.length; n < s; n++) {
      const o = t[e.shapes[n]];
      r.push(o);
    }
    return new wf(r, e.curveSegments);
  }
}
function FE(c, e) {
  if (e.shapes = [], Array.isArray(c))
    for (let t = 0, r = c.length; t < r; t++) {
      const n = c[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(c.uuid);
  return e;
}
class Tf extends Kt {
  constructor(e = 1, t = 32, r = 16, n = 0, s = Math.PI * 2, o = 0, i = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: n,
      phiLength: s,
      thetaStart: o,
      thetaLength: i
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const a = Math.min(o + i, Math.PI);
    let l = 0;
    const u = [], h = new j(), d = new j(), f = [], p = [], m = [], g = [];
    for (let b = 0; b <= r; b++) {
      const v = [], y = b / r;
      let x = 0;
      b === 0 && o === 0 ? x = 0.5 / t : b === r && a === Math.PI && (x = -0.5 / t);
      for (let N = 0; N <= t; N++) {
        const w = N / t;
        h.x = -e * Math.cos(n + w * s) * Math.sin(o + y * i), h.y = e * Math.cos(o + y * i), h.z = e * Math.sin(n + w * s) * Math.sin(o + y * i), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), g.push(w + x, 1 - y), v.push(l++);
      }
      u.push(v);
    }
    for (let b = 0; b < r; b++)
      for (let v = 0; v < t; v++) {
        const y = u[b][v + 1], x = u[b][v], N = u[b + 1][v], w = u[b + 1][v + 1];
        (b !== 0 || o > 0) && f.push(y, x, w), (b !== r - 1 || a < Math.PI) && f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new Xe(p, 3)), this.setAttribute("normal", new Xe(m, 3)), this.setAttribute("uv", new Xe(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Tf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Sf extends Fr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Sf(e.radius, e.detail);
  }
}
class _f extends Kt {
  constructor(e = 1, t = 0.4, r = 12, n = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: n,
      arc: s
    }, r = Math.floor(r), n = Math.floor(n);
    const o = [], i = [], a = [], l = [], u = new j(), h = new j(), d = new j();
    for (let f = 0; f <= r; f++)
      for (let p = 0; p <= n; p++) {
        const m = p / n * s, g = f / r * Math.PI * 2;
        h.x = (e + t * Math.cos(g)) * Math.cos(m), h.y = (e + t * Math.cos(g)) * Math.sin(m), h.z = t * Math.sin(g), i.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), d.subVectors(h, u).normalize(), a.push(d.x, d.y, d.z), l.push(p / n), l.push(f / r);
      }
    for (let f = 1; f <= r; f++)
      for (let p = 1; p <= n; p++) {
        const m = (n + 1) * f + p - 1, g = (n + 1) * (f - 1) + p - 1, b = (n + 1) * (f - 1) + p, v = (n + 1) * f + p;
        o.push(m, g, v), o.push(g, b, v);
      }
    this.setIndex(o), this.setAttribute("position", new Xe(i, 3)), this.setAttribute("normal", new Xe(a, 3)), this.setAttribute("uv", new Xe(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _f(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Mf extends Kt {
  constructor(e = 1, t = 0.4, r = 64, n = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: n,
      p: s,
      q: o
    }, r = Math.floor(r), n = Math.floor(n);
    const i = [], a = [], l = [], u = [], h = new j(), d = new j(), f = new j(), p = new j(), m = new j(), g = new j(), b = new j();
    for (let y = 0; y <= r; ++y) {
      const x = y / r * s * Math.PI * 2;
      v(x, s, o, e, f), v(x + 0.01, s, o, e, p), g.subVectors(p, f), b.addVectors(p, f), m.crossVectors(g, b), b.crossVectors(m, g), m.normalize(), b.normalize();
      for (let N = 0; N <= n; ++N) {
        const w = N / n * Math.PI * 2, T = -t * Math.cos(w), _ = t * Math.sin(w);
        h.x = f.x + (T * b.x + _ * m.x), h.y = f.y + (T * b.y + _ * m.y), h.z = f.z + (T * b.z + _ * m.z), a.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), l.push(d.x, d.y, d.z), u.push(y / r), u.push(N / n);
      }
    }
    for (let y = 1; y <= r; y++)
      for (let x = 1; x <= n; x++) {
        const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
        i.push(N, w, _), i.push(w, T, _);
      }
    this.setIndex(i), this.setAttribute("position", new Xe(a, 3)), this.setAttribute("normal", new Xe(l, 3)), this.setAttribute("uv", new Xe(u, 2));
    function v(y, x, N, w, T) {
      const _ = Math.cos(y), L = Math.sin(y), A = N / x * y, U = Math.cos(A);
      T.x = w * (2 + U) * 0.5 * _, T.y = w * (2 + U) * L * 0.5, T.z = w * Math.sin(A) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Af extends Kt {
  constructor(e = new Yx(new j(-1, -1, 0), new j(-1, 1, 0), new j(1, 1, 0)), t = 64, r = 1, n = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: n,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const i = new j(), a = new j(), l = new Re();
    let u = new j();
    const h = [], d = [], f = [], p = [];
    m(), this.setIndex(p), this.setAttribute("position", new Xe(h, 3)), this.setAttribute("normal", new Xe(d, 3)), this.setAttribute("uv", new Xe(f, 2));
    function m() {
      for (let y = 0; y < t; y++)
        g(y);
      g(s === !1 ? t : 0), v(), b();
    }
    function g(y) {
      u = e.getPointAt(y / t, u);
      const x = o.normals[y], N = o.binormals[y];
      for (let w = 0; w <= n; w++) {
        const T = w / n * Math.PI * 2, _ = Math.sin(T), L = -Math.cos(T);
        a.x = L * x.x + _ * N.x, a.y = L * x.y + _ * N.y, a.z = L * x.z + _ * N.z, a.normalize(), d.push(a.x, a.y, a.z), i.x = u.x + r * a.x, i.y = u.y + r * a.y, i.z = u.z + r * a.z, h.push(i.x, i.y, i.z);
      }
    }
    function b() {
      for (let y = 1; y <= t; y++)
        for (let x = 1; x <= n; x++) {
          const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
          p.push(N, w, _), p.push(w, T, _);
        }
    }
    function v() {
      for (let y = 0; y <= t; y++)
        for (let x = 0; x <= n; x++)
          l.x = y / t, l.y = x / n, f.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Af(
      new Ja[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class IE extends Kt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), n = new j(), s = new j();
      if (e.index !== null) {
        const o = e.attributes.position, i = e.index;
        let a = e.groups;
        a.length === 0 && (a = [{ start: 0, count: i.count, materialIndex: 0 }]);
        for (let l = 0, u = a.length; l < u; ++l) {
          const h = a[l], d = h.start, f = h.count;
          for (let p = d, m = d + f; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const b = i.getX(p + g), v = i.getX(p + (g + 1) % 3);
              n.fromBufferAttribute(o, b), s.fromBufferAttribute(o, v), Mm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let i = 0, a = o.count / 3; i < a; i++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * i + l, h = 3 * i + (l + 1) % 3;
            n.fromBufferAttribute(o, u), s.fromBufferAttribute(o, h), Mm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Xe(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function Mm(c, e, t) {
  const r = `${c.x},${c.y},${c.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${c.x},${c.y},${c.z}`;
  return t.has(r) === !0 || t.has(n) === !0 ? !1 : (t.add(r), t.add(n), !0);
}
const Am = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BoxGeometry: uf,
  CapsuleGeometry: ff,
  CircleGeometry: pf,
  ConeGeometry: mf,
  CylinderGeometry: Ic,
  DodecahedronGeometry: gf,
  EdgesGeometry: fE,
  ExtrudeGeometry: yf,
  IcosahedronGeometry: vf,
  LatheGeometry: Fc,
  OctahedronGeometry: xf,
  PlaneGeometry: bf,
  PolyhedronGeometry: Fr,
  RingGeometry: Nf,
  ShapeGeometry: wf,
  SphereGeometry: Tf,
  TetrahedronGeometry: Sf,
  TorusGeometry: _f,
  TorusKnotGeometry: Mf,
  TubeGeometry: Af,
  WireframeGeometry: IE
}, Symbol.toStringTag, { value: "Module" }));
class Ya extends Ka {
  constructor(t) {
    super();
    G(this, "nodes", []);
    G(this, "isLocked", !1);
    this.object = t, t.graph || (t.graph = this), this.addEventListener("nodeEventOutputChanged", ({ node: r, fields: n }) => {
      for (const s of n)
        this.applyNodePins(r._parentGraphNode, s, "out");
    });
  }
  newGraphNode(t, r) {
    const n = new Proxy({ x: 0, y: 0 }, {
      set: (o, i, a, l) => {
        if (a === Reflect.get(o, i))
          return !0;
        const u = Reflect.set(o, i, a, l);
        return u && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s] }), u;
      }
    }), s = {
      name: r,
      scoped: Ra(t, this),
      anchor: n,
      bounds: {},
      outs: {}
    };
    return t._parentGraphNode = s, s;
  }
  add(t) {
    if (this.nodes.indexOf(t) !== -1)
      throw ze.panic(`Graph Node[${t.scoped.uuid}] aready exists`);
    t.scoped instanceof nn && (t.scoped.eventDispatcher = this), this.nodes.push(t), this.dispatchEvent({ type: "graphAdded", soure: this, nodes: [t] });
  }
  remove(t) {
    const r = this.nodes.indexOf(t);
    if (r === -1)
      return !1;
    this.nodes.splice(r, 1), t.scoped instanceof nn && (t.scoped.eventDispatcher = null);
    for (const n of Object.keys(t.bounds))
      this.disconnect({ node: t, field: n }, !0);
    for (const n of Object.values(t.outs))
      for (const s of [...n])
        this.disconnect({ node: s.node, field: s.field }, !0);
    t.scoped.dispose && t.scoped.dispose(), this.dispatchEvent({ type: "graphRemoved", soure: this, nodes: [t] });
  }
  get(t) {
    return this.nodes.find((r) => r.scoped.uuid === t);
  }
  update(t, r, n, s) {
    for (const o of this.nodes)
      o.scoped.onUpdate && o.scoped.onUpdate(t, r, n, s);
  }
  connect(t, r, n) {
    if (!t.field && t.node.scoped instanceof Mn || !t.field && r.node.scoped instanceof Mn) {
      if (t.node.scoped instanceof Mn != r.node.scoped instanceof Mn) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      if (!(t.node.scoped instanceof Mn) || !(r.node.scoped instanceof Mn)) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      if (t.node.scoped.next === r.node.scoped) {
        if (n)
          return 3;
      } else if (t.node.scoped.next || r.node.scoped.prev) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      return n || (t.node.scoped.next = r.node.scoped, r.node.scoped.prev = t.node.scoped, this.dispatchEvent({ type: "graphModified", soure: this, nodes: [t.node, r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node })), 3;
    }
    if (!r.field) {
      if (n)
        return 0;
      throw ze.panic("not supported");
    }
    const s = r.node.bounds[r.field];
    if (s) {
      if (s.node === t.node && s.field === t.field)
        return s.type;
      if (n)
        return 0;
      throw ze.panic(`field[${r.field}] has been bound`);
    }
    const o = t.node.scoped instanceof nn ? t.node.scoped.objectType : bp(t.node.name), i = bp(r.node.name), { out: a } = t.node.scoped.typesExtended || Xa(o), { in: l } = r.node.scoped.typesExtended || Xa(i), u = t.field ? a[t.field] : { types: [o] }, h = r.field ? l[r.field] : { types: [i] };
    if (t.field) {
      if (!i_(u.types, h.types)) {
        if (n)
          return 0;
        throw ze.panic("type mismatched");
      }
    } else if (!c_(o, h.types)) {
      if (n)
        return 0;
      throw ze.panic("type mismatched");
    }
    const f = u.types.findIndex((g) => Mc(g)) !== -1 ? 1 : 2;
    if (n)
      return f;
    r.node.bounds[r.field] = { node: t.node, type: f, field: t.field };
    const p = t.field || "$";
    return (t.node.outs[p] || (t.node.outs[p] = [])).push({ node: r.node, type: f, field: r.field }), this.applyNodeBounds(r.node), this.dispatchEvent({ type: "graphModified", soure: this, nodes: [r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node }), f;
  }
  disconnect(t, r) {
    if (!t.field && t.node.scoped instanceof Mn) {
      if (!t.node.scoped.prev)
        throw ze.panic("state error");
      t.node.scoped.prev.next = void 0, t.node.scoped.prev = void 0;
      return;
    }
    if (!t.field)
      throw ze.panic("not allowed");
    const n = t.node.bounds[t.field];
    if (n === void 0)
      return;
    const s = n.node, o = n.field || "$", i = s.outs[o];
    if (!i)
      throw ze.panic(`bound list not found for node[field=${t.field}]`);
    const a = t.node.scoped, l = i.findIndex((f) => f.node === t.node && f.field === t.field);
    if (l === -1)
      return;
    delete t.node.bounds[t.field], i.splice(l, 1);
    const u = a instanceof nn ? a.getObjectsExtended().in : a, h = u[t.field];
    if (h instanceof kn)
      u[t.field] = new Cn();
    else {
      const f = `${t.field}Node`;
      Object.hasOwn(u, f) ? u[f] = null : h && (h.isNode || h.isMaterial) && (u[t.field] = null), u instanceof kn && (u.needsUpdate = !0, u instanceof fs && (u.uniformsNeedUpdate = !0));
    }
    r || (this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s, t.node] }), this.dispatchEvent({ type: "graphDisconnected", soure: this, from: s, to: t.node }));
  }
  clear() {
    for (const t of this.nodes)
      t.scoped.dispose && t.scoped.dispose();
    this.nodes.length = 0;
  }
  clone(t, r) {
    const n = r.get(this.object);
    if (!n)
      throw ze.panic(`object[${this.object.uuid}] is not found in list being transfered`);
    const s = {};
    for (const i of this.nodes) {
      const a = i.scoped;
      let l;
      const u = {};
      if (a instanceof nn) {
        l = cu(i.name), a.serialize(u), l.deserialize(u), a.object instanceof Vn && (s[a.object.uuid] = a.object);
        const h = a.object[Vt], d = r.get(h);
        d && (s[h.uuid] = d);
      } else
        a.clone ? l = a.clone(!0) : l = cu(i.name, a);
      s[l.uuid] = l, s[a.uuid] = l;
    }
    const o = new Ya(n);
    for (const i of Object.values(this.nodes)) {
      let a = s[i.scoped.uuid];
      a instanceof nn ? (a.fill(t, s), a.eventDispatcher = o) : a[Vt] || (a = Ra(Me(a), o));
      const l = new Proxy({ ...i.anchor }, {
        set: (h, d, f, p) => {
          if (f === Reflect.get(h, d))
            return !0;
          const m = Reflect.set(h, d, f, p);
          return m && o.dispatchEvent({ type: "graphModified", soure: o, nodes: [u] }), m;
        }
      }), u = {
        name: i.name,
        scoped: a,
        anchor: l,
        bounds: {},
        outs: {}
      };
      a._parentGraphNode = u;
      for (const [h, d] of Object.entries(i.bounds)) {
        const { node: f, type: p, field: m } = d, g = s[f.scoped.uuid];
        if (!g)
          throw ze.panic(`node[${f.scoped.uuid}] not found`);
        u.bounds[h] = { type: p, node: g, field: m };
      }
      for (const [h, d] of Object.entries(i.outs || {})) {
        const f = u.outs[h] || (u.outs[h] = []);
        for (const p of d) {
          const { node: m, type: g, field: b } = p, v = s[m.scoped.uuid];
          if (!v)
            throw ze.panic(`node[${m.scoped.uuid}] not found`);
          f.push({ node: v, type: g, field: b });
        }
      }
      o.nodes.push(u);
    }
    for (const i of o.nodes) {
      for (const a of Object.values(i.bounds)) {
        const l = o.nodes.find((u) => u.scoped.uuid === a.node.uuid);
        l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
      }
      for (const a of Object.values(i.outs))
        for (const l of a) {
          const u = o.nodes.find((h) => h.scoped.uuid === l.node.uuid);
          u || console.error(`node[${l.node.uuid}] not found!`), l.node = u;
        }
    }
    for (const i of o.nodes)
      o.applyNodeBounds(i);
    return o;
  }
  serialize(t) {
    const r = {
      isGraph: !0,
      nodes: []
    };
    for (const n of this.nodes) {
      t.nodes[n.scoped.uuid] || (t.nodes[n.scoped.uuid] = n.scoped.toJSON(t));
      const s = {};
      Object.entries(n.outs).forEach(([i, a]) => {
        s[i] = a.map((l) => ({ n: l.node.scoped.uuid, f: l.field, t: l.type }));
      });
      const o = {
        name: n.name,
        node: n.scoped.uuid,
        anchor: { ...n.anchor },
        bounds: Object.fromEntries(Object.entries(n.bounds).map((i) => [i[0], { t: i[1].type, n: i[1].node.scoped.uuid, f: i[1].field }])),
        outs: s
      };
      r.nodes.push(o);
    }
    return r;
  }
  deserialize(t, r, n) {
    if (!t || !t.isGraph)
      return;
    if (!Array.isArray(t.nodes))
      throw ze.panic("not node info found");
    this.clear();
    const s = { ...r, ...n };
    for (const o of t.nodes) {
      let i = r[o.node];
      if (!i)
        throw ze.panic(`node[${o.node}] not found`);
      i instanceof nn ? (i.fill(this.object, s), i.eventDispatcher = this) : i = Ra(Me(i), this);
      const a = new Proxy(o.anchor, {
        set: (u, h, d, f) => {
          if (d === Reflect.get(u, h))
            return !0;
          const p = Reflect.set(u, h, d, f);
          return p && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [l] }), p;
        }
      }), l = {
        name: o.name,
        scoped: i,
        anchor: a,
        bounds: {},
        outs: {}
      };
      i._parentGraphNode = l;
      for (const [u, h] of Object.entries(o.bounds)) {
        const { n: d, t: f, f: p } = h, m = r[d];
        if (!m)
          throw ze.panic(`node[${d}] not found`);
        l.bounds[u] = { type: f, node: m, field: p };
      }
      for (const [u, h] of Object.entries(o.outs || {})) {
        const d = l.outs[u] || (l.outs[u] = []);
        for (const f of h) {
          const { n: p, t: m, f: g } = f, b = r[p];
          if (!b)
            throw ze.panic(`node[${p}] not found`);
          d.push({ node: b, type: m, field: g });
        }
      }
      this.nodes.push(l);
    }
    for (const o of this.nodes) {
      for (const i of Object.values(o.bounds)) {
        const a = this.nodes.find((l) => l.scoped.uuid === i.node.uuid);
        a || console.error(`node[${i.node.uuid}] not found!`), i.node = a;
      }
      for (const i of Object.values(o.outs))
        for (const a of i) {
          const l = this.nodes.find((u) => u.scoped.uuid === a.node.uuid);
          l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
        }
    }
    for (const o of this.nodes)
      this.applyNodeBounds(o);
  }
  applyNodeBounds(t, r) {
    for (const [n, s] of Object.entries(t.bounds)) {
      if (r && !r.includes(n))
        continue;
      const { node: o, type: i, field: a } = s, l = o.outs[a || "$"];
      if (!l)
        throw ze.panic(`bound list not found for node[field=${n}]`);
      if (!l.find((m) => m.node === t && m.field === n))
        throw ze.panic(`bound slot not found for node[field=${n}]`);
      const h = o.scoped instanceof nn ? o.scoped.getObjectsExtended().out : o.scoped;
      let d = a ? h[a] : h;
      const f = t.scoped instanceof nn ? t.scoped.getObjectsExtended().in : t.scoped, p = f[n];
      if (typeof d == "object" && (d = d[Vt] || d), d !== p) {
        if (i === 1) {
          typeof p == "object" && p.dispose && p.dispose(), f[n] = d;
          continue;
        }
        typeof d == "object" ? !p || p === null ? f[n] = d : typeof p.copy == "function" ? p.copy(d) : typeof d.clone == "function" ? f[n] = d.clone() : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d) : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d);
      }
    }
    t.scoped instanceof kn && (t.scoped.needsUpdate = !0, t.scoped instanceof fs && (t.scoped.uniformsNeedUpdate = !0));
  }
  applyNodePins(t, r, n) {
    if (n === "in")
      t.scoped instanceof kn ? (t.scoped.needsUpdate = !0, t.scoped instanceof fs && (t.scoped.uniformsNeedUpdate = !0)) : t.scoped instanceof nn && t.scoped.object instanceof Vn && (t.scoped.object.needsUpdate = !0);
    else {
      const s = t.outs[r];
      if (!s)
        return;
      for (const o of s)
        o.type === 1 ? this.applyNodePins(o.node, o.field, "in") : this.applyNodeBounds(o.node, [o.field]);
    }
  }
  addType(t, r, n, s) {
    return r ? /^[a-z][a-z0-9_]*$/i.test(r) ? t.scoped instanceof wo ? (s === "in" ? t.scoped.addInput : t.scoped.addOutput).call(t.scoped, r, n) ? !0 : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: `Failed to create field[${r}] as type[${n}]!` }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "It is not a ScriptNode!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Illegal name!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Empty name!" }), !1);
  }
  removeType(t, r, n) {
    if (!(t.scoped instanceof wo) || !(n === "in" ? t.scoped.removeInput : t.scoped.removeOutput).call(t.scoped, r))
      return !1;
    if (n === "in")
      this.disconnect({ node: t, field: r, io: n });
    else {
      const o = t.outs[r];
      if (o)
        for (const i of [...o])
          this.disconnect({ node: i.node, field: i.field });
    }
    return !0;
  }
}
const { getTypedArray: Cm } = QC, { createNodeFromType: PE } = D1;
class DE extends Sr {
  constructor(t) {
    super(t);
    G(this, "_textures");
    G(this, "_listeners", {});
    G(this, "_nodes");
    G(this, "_nodesJSON");
  }
  load(t, r, n, s) {
    const o = this, i = this.path === "" ? mo.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new Ys(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(l) {
      let u = null;
      try {
        u = JSON.parse(l);
      } catch (d) {
        s !== void 0 && s(d), console.error("THREE:ObjectLoader: Can't parse " + t + ".", d.message);
        return;
      }
      const h = u.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + t)), console.error("THREE.ObjectLoader: Can't load " + t);
        return;
      }
      o.parse(u, r);
    }, n, s);
  }
  async loadAsync(t, r) {
    const n = this, s = this.path === "" ? mo.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new Ys(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const i = await o.loadAsync(t, r), a = JSON.parse(i), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + t);
    return await n.parseAsync(a);
  }
  parse(t, r) {
    this._nodesJSON = t.nodes;
    const n = this.parseAnimations(t.animations), s = this.parseShapes(t.shapes), o = this.parseGeometries(t.geometries, s), i = this.parseImages(t.images, function() {
      r !== void 0 && r(u);
    }), a = this.parseTextures(t.textures, i), l = this.parseMaterials(t.materials, a);
    if (t.listeners)
      for (const d of t.listeners) {
        const f = this.parseObject(d, o, l, a, n);
        this._listeners[f.uuid] = f;
      }
    const u = this.parseObject(t.object, o, l, a, n), h = this.parseSkeletons(t.skeletons, u);
    if (this.bindSkeletons(u, h), r !== void 0) {
      let d = !1;
      for (const f in i)
        if (i[f].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && r(u);
    }
    this._nodesJSON = null, u.traverse((d) => {
      d.userData.graph && new Ya(d).deserialize(d.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const d of Object.values(this._nodes || {}))
      d.fill && d.fill(u, this._nodes || {}, this._textures || {});
    return u;
  }
  async parseAsync(t) {
    this._nodesJSON = t.nodes;
    const r = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes), s = this.parseGeometries(t.geometries, n), o = await this.parseImagesAsync(t.images), i = this.parseTextures(t.textures, o), a = this.parseMaterials(t.materials, i);
    if (t.listeners)
      for (const h of t.listeners) {
        const d = this.parseObject(h, s, a, i, r);
        this._listeners[d.uuid] = d;
      }
    const l = this.parseObject(t.object, s, a, i, r), u = this.parseSkeletons(t.skeletons, l);
    this.bindSkeletons(l, u), this._nodesJSON = null, l.traverse((h) => {
      h.userData.graph && new Ya(h).deserialize(h.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const h of Object.values(this._nodes || {}))
      h.fill && h.fill(l, this._nodes || {}, this._textures || {});
    return l;
  }
  parseShapes(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0, s = t.length; n < s; n++) {
        const o = new So().fromJSON(t[n]);
        r[o.uuid] = o;
      }
    return r;
  }
  parseSkeletons(t, r) {
    const n = {}, s = {};
    if (r.traverse(function(o) {
      o.isBone && (s[o.uuid] = o);
    }), t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = new Lu();
        a.fromJSON(t[o], s), n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(t, r) {
    const n = {};
    if (t !== void 0) {
      const s = new oN();
      for (let o = 0, i = t.length; o < i; o++) {
        let a;
        const l = t[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = s.parse(l);
            break;
          default:
            l.type in Am ? a = Am[l.type].fromJSON(l, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(t, r) {
    const n = {};
    if (this._textures = r, t !== void 0) {
      const s = this.parseNodes(this._nodesJSON, r);
      this._nodes = s;
      const o = new ja();
      o.setTextures(r), o.setNodes(s);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = s[l.uuid];
        u ? n[l.uuid] = u : n[l.uuid] = o.parse(l);
      }
    } else
      this._nodesJSON && (this._nodes = this.parseNodes(this._nodesJSON, r));
    return n;
  }
  parseAnimations(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0; n < t.length; n++) {
        const s = t[n], o = Ou.parse(s);
        r[o.uuid] = o;
      }
    return r;
  }
  parseImages(t, r) {
    const n = this, s = {};
    let o;
    function i(l) {
      return n.manager.itemStart(l), o.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
        return i(h);
      } else
        return l.data ? {
          data: Cm(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      const l = new iN(r);
      o = new tp(l), o.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = t.length; u < h; u++) {
        const d = t[u], f = d.url;
        if (Array.isArray(f)) {
          const p = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const b = f[m], v = a(b);
            v !== null && (v instanceof HTMLImageElement ? p.push(v) : p.push(new Ta(v.data, v.width, v.height)));
          }
          s[d.uuid] = new $i(p);
        } else {
          const p = a(d.url);
          s[d.uuid] = new $i(p);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(t) {
    const r = this, n = {};
    let s;
    async function o(i) {
      if (typeof i == "string" && i) {
        const a = i, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : r.resourcePath + a;
        return await s.loadAsync(l);
      } else
        return i.data ? {
          data: Cm(i.type, i.data),
          width: i.width,
          height: i.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      s = new tp(this.manager), s.setCrossOrigin(this.crossOrigin);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, f = u.length; d < f; d++) {
            const p = u[d], m = await o(p);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new Ta(m.data, m.width, m.height)));
          }
          n[l.uuid] = new $i(h);
        } else {
          const h = await o(l.url);
          n[l.uuid] = new $i(h);
        }
      }
    }
    return n;
  }
  parseTextures(t, r) {
    function n(o, i) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), i[o]);
    }
    const s = {};
    if (t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = t[o];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), r[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = r[a.image], u = l.data;
        let h;
        Array.isArray(u) ? (h = new aN(), u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new Ta() : h = new Vn(), u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = n(a.mapping, UE)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = n(a.wrap[0], Em), h.wrapT = n(a.wrap[1], Em)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, Rm)), a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, Rm)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), s[a.uuid] = h;
      }
    return s;
  }
  parseObject(t, r, n, s, o) {
    var m;
    function i(g) {
      return r[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", g), r[g];
    }
    function a(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const b = [];
          for (let v = 0, y = g.length; v < y; v++) {
            const x = g[v];
            n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), b.push(n[x]);
          }
          return b;
        }
        return n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), n[g];
      }
    }
    function l(g) {
      return s[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", g), s[g];
    }
    if (this._listeners[t.uuid]) {
      const g = this._listeners[t.uuid];
      if (t.children !== void 0) {
        const b = t.children;
        for (let v = 0; v < b.length; v++)
          g.add(this.parseObject(b[v], r, n, s, o));
      }
      return g;
    }
    const u = t.geometry ? i(t.geometry) : void 0, h = t.material ? a(t.material) : void 0;
    (u || h) && (t = { ...t, geometry: u, material: h });
    const d = ((m = t.userData) == null ? void 0 : m.extend) || t.type;
    if (d === "PositionalAudio2" && t.listener) {
      const g = this._listeners[t.listener];
      t = { ...t, listener: g };
    }
    if (!b_(d) && /^\[.*\]$/.test(t.name)) {
      const g = new xn();
      return g.uuid = t.uuid, t.name !== void 0 && (g.name = t.name), g;
    }
    const f = x_(d, t);
    switch (G1(d)) {
      case "Scene":
        t.background !== void 0 && (Number.isInteger(t.background) ? f.background = new je(t.background) : f.background = l(t.background)), t.environment !== void 0 && (f.environment = l(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? f.fog = new cN(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (f.fog = new lN(t.fog.color, t.fog.density)), t.fog.name !== "" && (f.fog.name = t.fog.name)), t.backgroundBlurriness !== void 0 && (f.backgroundBlurriness = t.backgroundBlurriness), t.backgroundIntensity !== void 0 && (f.backgroundIntensity = t.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        t.focus !== void 0 && (f.focus = t.focus), t.zoom !== void 0 && (f.zoom = t.zoom), t.filmGauge !== void 0 && (f.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (f.filmOffset = t.filmOffset), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        t.zoom !== void 0 && (f.zoom = t.zoom), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "SkinnedMesh":
        t.bindMode !== void 0 && (f.bindMode = t.bindMode), t.bindMatrix !== void 0 && f.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (f.skeleton = t.skeleton);
        break;
    }
    if (f.uuid = t.uuid, t.name !== void 0 && (f.name = t.name), t.matrix !== void 0 ? (f.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (f.matrixAutoUpdate = t.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (t.position !== void 0 && f.position.fromArray(t.position), t.rotation !== void 0 && f.rotation.fromArray(t.rotation), t.quaternion !== void 0 && f.quaternion.fromArray(t.quaternion), t.scale !== void 0 && f.scale.fromArray(t.scale)), t.up !== void 0 && f.up.fromArray(t.up), t.castShadow !== void 0 && (f.castShadow = t.castShadow), t.receiveShadow !== void 0 && (f.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (f.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (f.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (f.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && f.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (f.shadow.camera = this.parseObject(t.shadow.camera, r, n, s, o))), t.visible !== void 0 && (f.visible = t.visible), t.frustumCulled !== void 0 && (f.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (f.renderOrder = t.renderOrder), t.userData !== void 0 && (f.userData = t.userData), t.layers !== void 0 && (f.layers.mask = t.layers), t.children !== void 0) {
      const g = t.children;
      for (let b = 0; b < g.length; b++)
        f.add(this.parseObject(g[b], r, n, s, o));
    }
    if (t.animations !== void 0) {
      const g = t.animations;
      for (let b = 0; b < g.length; b++) {
        const v = g[b];
        f.animations.push(o[v]);
      }
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (f.autoUpdate = t.autoUpdate);
      const g = t.levels;
      for (let b = 0; b < g.length; b++) {
        const v = g[b], y = f.getObjectByProperty("uuid", v.object);
        y !== void 0 && f.addLevel(y, v.distance, v.hysteresis);
      }
    }
    return f.deserialize && f.deserialize(t), f;
  }
  bindSkeletons(t, r) {
    Object.keys(r).length !== 0 && t.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const s = r[n.skeleton];
        s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix);
      }
    });
  }
  parseNodes(t, r) {
    if (t !== void 0) {
      const n = {}, s = new ja();
      for (const i of t) {
        const { uuid: a, type: l, _inst: u } = i;
        if (/Material$/.test(l)) {
          const f = s.parse(i);
          f.uuid = a, n[a] = f;
          continue;
        }
        const d = u ? cu(u) : PE(l);
        n[a] = d, n[a].uuid = a;
      }
      const o = { nodes: n, textures: r };
      for (const i of t) {
        i.meta = o;
        const a = n[i.uuid];
        a.isMaterial || (a.deserialize(i), delete i.meta);
      }
      return n;
    }
    return {};
  }
}
const UE = {
  UVMapping: uN,
  CubeReflectionMapping: hN,
  CubeRefractionMapping: dN,
  EquirectangularReflectionMapping: tg,
  EquirectangularRefractionMapping: fN,
  CubeUVReflectionMapping: pN
}, Em = {
  RepeatWrapping: Ks,
  ClampToEdgeWrapping: go,
  MirroredRepeatWrapping: eg
}, Rm = {
  NearestFilter: Ws,
  NearestMipmapNearestFilter: Km,
  NearestMipmapLinearFilter: Qm,
  LinearFilter: po,
  LinearMipmapNearestFilter: Zm,
  LinearMipmapLinearFilter: To
};
async function zE(c) {
  window.import || (window.import = new Function("path", "return import(path)"));
  try {
    return await window.import(c);
  } catch (e) {
    console.error(e);
  }
}
const Lm = {
  resolution: "auto",
  toneMapping: Pm,
  toneMappingExposure: 1,
  shadowMap: {
    enabled: !0,
    type: mN
  },
  vrEnable: !1
};
class BE extends M.EventDispatcher {
  constructor(t) {
    super();
    G(this, "renderer");
    G(this, "clock");
    G(this, "size", { width: 2048, height: 2048 });
    G(this, "uuid", M.MathUtils.generateUUID());
    G(this, "defaultScene", new OC());
    G(this, "currentScene");
    G(this, "currentCamera");
    G(this, "defaultCamera");
    // vr
    G(this, "vrSession");
    /** left, right */
    G(this, "hands", []);
    G(this, "handsConllisionMap", /* @__PURE__ */ new Set());
    G(this, "handPointers", []);
    G(this, "dragState", { state: { left: "none", right: "none" }, draging: {}, positions: { left: new ye(), right: new ye() } });
    G(this, "working", !1);
    // for app
    G(this, "settings", { ...Lm });
    G(this, "scenes", []);
    G(this, "spawns");
    this.context = t, Object.assign(sn, {
      navigateTo: this.navigateTo.bind(this),
      setCamera: this.setCamera.bind(this),
      spawn: this.createObjectFromSpawn.bind(this)
    }), this.renderer = new M.WebGLRenderer({
      canvas: this.context,
      antialias: !0
    }), this.renderer.outputColorSpace = M.SRGBColorSpace, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.autoUpdate = !0, this.renderer.shadowMap.type = M.PCFSoftShadowMap, this.renderer.autoClear = !1, this.renderer.toneMapping = M.ACESFilmicToneMapping, this.renderer.setClearColor(16777215), sn.gpuComputeRender = new lC(S_, __, this.renderer), this.clock = new M.Clock(), this.currentScene = this.defaultScene, this.defaultCamera = new M.PerspectiveCamera(50, 1, 1e-3, 1e3), this.defaultCamera.name = "Perspective", this.defaultCamera.position.set(4, 3, 8), this.defaultCamera.lookAt(0, 0, 0);
    const r = this.currentScene.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.currentCamera = r, this.resize(this.size.width, this.size.height, 1);
  }
  resize(t, r, n) {
    if (!this.context)
      return;
    const s = Math.max(n, 1), o = t / r;
    this.size.width = t * s, this.size.height = r * s, this.renderer.setSize(this.size.width, this.size.height, !1), this.currentCamera && (this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = o, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / o, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix()));
  }
  navigateTo(t) {
    const r = this.scenes.find((s) => s.uuid === t || s.name === t);
    if (!r) {
      console.error(`Scene[${t}] not found`);
      return;
    }
    if (this.currentScene === r)
      return;
    this.currentScene && this.currentScene.deactive(), this.currentScene = r, this.currentScene.active();
    const n = r.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.setCamera(n), this.settings.vrEnable && (this.currentScene.getObjectByName("vr-controller0") || this.setupVr(r), this.vrSession || this.startVR());
  }
  createObjectFromSpawn(t) {
    if (!this.spawns)
      return;
    const r = this.spawns.children.find((n) => n.name === t);
    if (r)
      return B1(r, !0, this.spawns);
  }
  setCamera(t) {
    if (this.currentCamera !== t && (this.currentCamera = t, this.currentCamera)) {
      const r = this.size.width / this.size.height;
      this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = r, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / r, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix());
    }
  }
  async load(t) {
    const r = new DE(), s = await (await fetch(t)).json();
    if (s.project.plugins)
      try {
        const l = await Promise.all(s.project.plugins.map((u) => zE(u)));
        for (const u in l) {
          l[u].pluginInstall(
            Ye,
            Vx,
            Ls,
            Ac
          );
          const d = s.project.plugins[u].split("/").pop();
          ze.notice(`Plugin ${d} has been installed successfully!`);
        }
      } catch (l) {
        console.error(l);
      }
    const o = await r.parseAsync(s), { project: i } = s;
    i.world && (_s(this.settings), Object.assign(this.settings, { ...Lm, ...i.world })), this.settings.resolution || (this.settings.resolution = "auto"), this.settings.vrEnable && (this.renderer.xr.enabled = !0), this.scenes.length = 0;
    for (const l of o.children)
      l.name === "[Spawns]" ? this.spawns = l : this.scenes.push(l);
    const a = this.scenes.find((l) => l.name === "index") || this.scenes[0] || this.defaultScene;
    this.navigateTo(a.uuid);
  }
  setupVr(t) {
    const r = this.renderer.xr.getController(0);
    r.name = "vr-controller0", t.add(r);
    const n = this.renderer.xr.getController(1);
    t.add(n);
    const s = new NC(), o = this.renderer.xr.getControllerGrip(0);
    o.add(s.createControllerModel(o)), t.add(o);
    const i = this.renderer.xr.getHand(0);
    this.hands[0] || (this.hands[0] = new om(i), this.hands[0].name = "left"), i.add(this.hands[0]);
    const a = new um(i, r);
    a.name = "left", this.handPointers[0] = a, i.add(a), t.add(i);
    const l = this.renderer.xr.getControllerGrip(1);
    l.add(s.createControllerModel(l)), t.add(l);
    const u = this.renderer.xr.getHand(1);
    this.hands[1] || (this.hands[1] = new om(u), this.hands[1].name = "right"), u.add(this.hands[1]);
    const h = new um(u, n);
    h.name = "right", this.handPointers[1] = h, u.add(h), t.add(u);
  }
  async startVR() {
    if (!navigator.xr || !await navigator.xr.isSessionSupported("immersive-vr"))
      return ze.error("Your browser is not currently supported VR!"), !1;
    if (this.vrSession)
      return ze.warn("VR has already been started!"), !1;
    let r;
    const n = new Promise((i) => r = i), s = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
    this.vrSession = await navigator.xr.requestSession("immersive-vr", s), await this.renderer.xr.setSession(this.vrSession);
    const o = () => {
      this.vrSession && (this.vrSession.removeEventListener("end", o), this.vrSession = null, this.currentCamera = this.defaultCamera, ze.debug("VR has been exited successfully!")), r(!0);
    };
    return this.vrSession.addEventListener("end", o), this.currentCamera = this.defaultCamera, n;
  }
  stopVR() {
    this.vrSession && this.vrSession.end();
  }
  updateVR() {
    this.renderer.xr.updateCamera(this.currentCamera);
    for (const t of this.hands)
      if (t)
        for (const r of this.currentScene.children) {
          if (!(r instanceof M.Mesh))
            continue;
          const n = `${t.name}:${r.uuid}`;
          t.intersectBoxObject(r) ? this.handsConllisionMap.has(n) || (this.handsConllisionMap.add(n), r.dispatchEvent({ type: "onCollisionEnter", target: t })) : this.handsConllisionMap.has(n) && (this.handsConllisionMap.delete(n), r.dispatchEvent({ type: "onCollisionLeave", target: t }));
        }
    this.updateDragState();
  }
  updateDragState() {
    for (const t of this.handPointers) {
      if (!t)
        continue;
      const r = t.name, n = this.dragState.draging[r];
      if (this.dragState.state[r] === "pinched") {
        if (!t.pinched) {
          const a = t.children[0].position.clone().sub(this.dragState.positions[r]);
          this.dragState.draging[r] = void 0, this.dragState.state[r] = "none", this.currentScene.add(n), t.setAttached(!1), n.position.add(a), n.scale.set(1, 1, 1), n.dispatchEvent({ type: "onDrop", target: t });
        }
        continue;
      } else if (!t.pinched)
        continue;
      let o = 1e4, i;
      for (const a of this.currentScene.children) {
        if (a.bodyType === Cc.Ghost)
          continue;
        const l = t.intersectObject(a, !1);
        !l || !l.length || l[0].distance < o && (o = l[0].distance, i = a);
      }
      i && (i.scale.set(1.2, 1.2, 1.2), t.setAttached(!0), this.dragState.draging[r] = i, this.dragState.state[r] = "pinched", this.dragState.positions[r].copy(t.children[0].position).sub(i.position), t.children[0].attach(i), i.dispatchEvent({ type: "onDragStart", target: t }));
    }
  }
  render(t, r) {
    sn.delta = t, sn.now = r, this.currentScene.update(this.renderer, this.currentCamera, t, r), Zr.update(), this.renderer.xr.enabled && this.updateVR(), this.renderer.render(this.currentScene, this.currentCamera);
  }
  async run() {
    if (this.working)
      throw ze.panic("already working");
    this.working = !0, this.clock.start();
    const t = (r, n) => {
      if (!this.working) {
        this.renderer.setAnimationLoop(null);
        return;
      }
      const s = this.clock.getDelta(), o = this.clock.oldTime;
      this.render(s, o);
    };
    this.renderer.setAnimationLoop(t);
  }
  dispose() {
    this.clock.stop(), this.renderer.dispose();
  }
}
const kE = "[Spawns]", GE = "__isHidden", VE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AsyncFunction: kx,
  AudioListener2: xx,
  BezierLine: H1,
  BezierLineMaterial: mi,
  Box: X1,
  BuiltinObjectKeyHidden: GE,
  BuiltinSceneSpawns: kE,
  Capsule: $1,
  Character: Dx,
  Cone: q1,
  Cylinder: J1,
  EffectNode: af,
  EventDispatcher: Ka,
  EventListenerNode: fr,
  Model3D: Rc,
  Particles: Ux,
  PhysicalScene: ef,
  Plane: Q1,
  PositionalAudio2: bx,
  Reflector: of,
  ScriptBlockNode: Mn,
  ScriptNode: wo,
  ShapeArc: rx,
  ShapeCircle: sx,
  ShapeRounded: nx,
  ShapeSquare: tx,
  ShapeTriangle: ex,
  SkyBox: zx,
  Sphere: Y1,
  StaticMesh: Px,
  Text3D: vx,
  TextMesh: sf,
  Torus: K1,
  TorusKnot: Z1,
  U3JsRuntime: BE,
  WaterPlane: yu,
  addEffectNode: cf,
  clone: B1,
  cloneTracingBegin: U1,
  cloneTracingEnd: z1,
  logger: ze,
  nodeProxy: Ra,
  objectsTransferred: Ar,
  textMembers: gi
}, Symbol.toStringTag, { value: "Module" }));
window.U3JS || (window.U3JS = VE);
export {
  kx as AsyncFunction,
  xx as AudioListener2,
  H1 as BezierLine,
  mi as BezierLineMaterial,
  X1 as Box,
  GE as BuiltinObjectKeyHidden,
  kE as BuiltinSceneSpawns,
  $1 as Capsule,
  Dx as Character,
  q1 as Cone,
  J1 as Cylinder,
  af as EffectNode,
  KE as EventDispatcher,
  fr as EventListenerNode,
  Rc as Model3D,
  Ux as Particles,
  ef as PhysicalScene,
  Q1 as Plane,
  bx as PositionalAudio2,
  of as Reflector,
  Mn as ScriptBlockNode,
  wo as ScriptNode,
  rx as ShapeArc,
  sx as ShapeCircle,
  nx as ShapeRounded,
  tx as ShapeSquare,
  ex as ShapeTriangle,
  zx as SkyBox,
  Y1 as Sphere,
  Px as StaticMesh,
  vx as Text3D,
  sf as TextMesh,
  K1 as Torus,
  Z1 as TorusKnot,
  BE as U3JsRuntime,
  yu as WaterPlane,
  cf as addEffectNode,
  B1 as clone,
  U1 as cloneTracingBegin,
  z1 as cloneTracingEnd,
  ze as logger,
  Ra as nodeProxy,
  Ar as objectsTransferred,
  gi as textMembers
};
