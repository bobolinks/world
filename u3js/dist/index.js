var ax = Object.defineProperty;
var cx = (c, e, t) => e in c ? ax(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var G = (c, e, t) => (cx(c, typeof e != "symbol" ? e + "" : e, t), t);
import * as M from "three";
import { Object3D as En, Color as Ve, Vector2 as wt, Vector3 as ye, Vector4 as pt, Matrix3 as ws, Matrix4 as Ge, EventDispatcher as pu, MathUtils as Zt, LinearSRGBColorSpace as Rn, SRGBColorSpace as vn, TangentSpaceNormalMap as If, ObjectSpaceNormalMap as lx, StaticDrawUsage as ux, InterleavedBuffer as hm, InterleavedBufferAttribute as Ws, DynamicDrawUsage as mu, InstancedInterleavedBuffer as Na, DepthTexture as dm, NearestFilter as Hs, LessCompare as hx, ShaderMaterial as hs, NoColorSpace as fm, Material as kn, WebGLCubeRenderTarget as dx, BoxGeometry as Wa, BackSide as gu, NoBlending as fx, Mesh as qt, Scene as Ha, LinearMipmapLinearFilter as xo, LinearFilter as fo, CubeCamera as px, RenderTarget as mx, sRGBEncoding as gx, LinearEncoding as yx, Float16BufferAttribute as vx, REVISION as xx, NoToneMapping as Pf, LinearToneMapping as bx, ReinhardToneMapping as Nx, CineonToneMapping as wx, ACESFilmicToneMapping as pm, FramebufferTexture as mm, UnsignedIntType as Tx, DepthFormat as Sx, PointLight as Zo, DirectionalLight as pi, SpotLight as mi, AmbientLight as yu, HemisphereLight as gm, Loader as xr, FileLoader as Ks, LineBasicMaterial as vu, LineDashedMaterial as ym, MeshNormalMaterial as _x, MeshBasicMaterial as An, MeshLambertMaterial as vm, MeshPhongMaterial as ha, MeshStandardMaterial as jn, MeshPhysicalMaterial as Es, PointsMaterial as xm, SpriteMaterial as Mx, MaterialLoader as gi, ObjectLoader as Ax, BufferAttribute as ro, BufferGeometry as Kn, Box3 as sr, InstancedBufferGeometry as bm, Float32BufferAttribute as yn, WireframeGeometry as Cx, Sphere as yi, UniformsLib as oo, ShaderLib as cs, UniformsUtils as rr, Line3 as Ex, CubicBezierCurve3 as Rx, PerspectiveCamera as br, OrthographicCamera as Xa, CapsuleGeometry as Nm, ConeGeometry as Fx, CylinderGeometry as Lx, SphereGeometry as $a, TorusGeometry as Ox, TorusKnotGeometry as Ix, ExtrudeGeometry as wm, PlaneGeometry as Sr, ShapePath as xu, Shape as bo, Path as Px, MeshDepthMaterial as Ux, RGBADepthPacking as Dx, MeshDistanceMaterial as zx, ShaderChunk as Tm, DoubleSide as bu, InstancedBufferAttribute as Bx, FrontSide as Sm, Texture as Vn, AudioListener as kx, PositionalAudio as Gx, AudioLoader as Vx, TrianglesDrawMode as jx, TriangleFanDrawMode as Il, TriangleStripDrawMode as _m, LoaderUtils as po, Quaternion as fr, InstancedMesh as Wx, TextureLoader as Nu, ImageBitmapLoader as Hx, RepeatWrapping as Zs, PropertyBinding as Qo, SkinnedMesh as Mm, LineSegments as Xx, Line as Am, LineLoop as $x, Points as Cm, Group as io, Skeleton as wu, AnimationClip as Tu, Bone as Pl, InterpolateLinear as Em, ColorManagement as Uf, NearestMipmapNearestFilter as Rm, LinearMipmapNearestFilter as Fm, NearestMipmapLinearFilter as Lm, ClampToEdgeWrapping as mo, MirroredRepeatWrapping as Om, InterpolateDiscrete as qx, VectorKeyframeTrack as Ul, NumberKeyframeTrack as Dl, QuaternionKeyframeTrack as zl, Interpolant as Jx, Curve as Yx, EquirectangularReflectionMapping as Im, Uint16BufferAttribute as Kx, Euler as Ss, AnimationMixer as Zx, LoopRepeat as Qx, LoopOnce as eb, Plane as Bl, WebGLRenderTarget as Su, HalfFloatType as Pm, PMREMGenerator as tb, AdditiveBlending as nb, Camera as sb, RGBAFormat as Df, DataTexture as da, FloatType as zf, BufferGeometryLoader as rb, LoadingManager as ob, ImageLoader as Bf, Source as Bi, CubeTexture as ib, Fog as ab, FogExp2 as cb, UVMapping as lb, CubeReflectionMapping as ub, CubeRefractionMapping as hb, EquirectangularRefractionMapping as db, CubeUVReflectionMapping as fb, PCFSoftShadowMap as pb } from "three";
import { EventDispatcher as gE } from "three";
import { computeBoundsTree as mb, disposeBoundsTree as gb, acceleratedRaycast as yb } from "three-mesh-bvh";
const go = /* @__PURE__ */ new WeakMap(), wa = /* @__PURE__ */ new Set(), vb = En.prototype.clone;
En.prototype.clone = function(c) {
  const e = vb.call(this, c);
  return go.set(this, e), e;
};
function xb() {
  for (const c of wa)
    go.delete(c);
  wa.clear();
}
function bb() {
  for (const c of wa)
    go.delete(c);
  wa.clear();
}
function Nb(c, e, t) {
  xb();
  const r = c.clone(e);
  return c.traverse((n) => {
    if (!n.graph)
      return;
    const s = go.get(n);
    s && (s.graph = n.graph.clone(t || c, go));
  }), bb(), r;
}
const kl = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, ut = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, wb = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
}, Jr = ["fragment", "vertex"], Um = ["setup", "analyze", "generate"], Dm = [...Jr, "compute"], qa = ["x", "y", "z", "w"];
function Ja(c) {
  let e = "{";
  c.isNode === !0 && (e += `uuid:"${c.uuid}"`);
  for (const { property: t, index: r, childNode: n } of ei(c)) {
    let s = Ja(n);
    s.includes(",") || (s = s.slice(s.indexOf('"'), s.indexOf("}"))), e += `,${t}${r !== void 0 ? "/" + r : ""}:${s}`;
  }
  return e += "}", e;
}
function* ei(c, e = !1) {
  for (const t in c) {
    if (t.startsWith("_") === !0)
      continue;
    const r = c[t];
    if (Array.isArray(r) === !0)
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
    else if (r && r.isNode === !0)
      yield { property: t, childNode: r };
    else if (typeof r == "object")
      for (const n in r) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
  }
}
function Xs(c) {
  if (c == null)
    return null;
  const e = typeof c;
  return c.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : c.isVector2 === !0 ? "vec2" : c.isVector3 === !0 ? "vec3" : c.isVector4 === !0 ? "vec4" : c.isMatrix3 === !0 ? "mat3" : c.isMatrix4 === !0 ? "mat4" : c.isColor === !0 ? "color" : c instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function _u(c, ...e) {
  const t = c ? c.slice(-4) : void 0;
  return (t === "vec2" || t === "vec3" || t === "vec4") && e.length === 1 && (e = t === "vec2" ? [e[0], e[0]] : [e[0], e[0], e[0]]), c === "color" ? new Ve(...e) : t === "vec2" ? new wt(...e) : t === "vec3" ? new ye(...e) : t === "vec4" ? new pt(...e) : t === "mat3" ? new ws(...e) : t === "mat4" ? new Ge(...e) : c === "bool" ? e[0] || !1 : c === "float" || c === "int" || c === "uint" ? e[0] || 0 : c === "string" ? e[0] || "" : c === "ArrayBuffer" ? Au(e[0]) : null;
}
function Mu(c) {
  let e = "";
  const t = new Uint8Array(c);
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Au(c) {
  return Uint8Array.from(atob(c), (e) => e.charCodeAt(0)).buffer;
}
const Tb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: Mu,
  base64ToArrayBuffer: Au,
  getCacheKey: Ja,
  getNodeChildren: ei,
  getValueFromType: _u,
  getValueType: Xs
}, Symbol.toStringTag, { value: "Module" })), Gl = /* @__PURE__ */ new Map();
let Sb = 0, _b = class extends pu {
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = ut.NONE, this.updateBeforeType = ut.NONE, this.uuid = Zt.generateUUID(), this.isNode = !0, Object.defineProperty(this, "id", { value: Sb++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    const e = this;
    for (const { property: t, index: r, childNode: n } of ei(this))
      yield { childNode: n, replaceNode(s) {
        r === void 0 ? e[t] = s : e[t][r] = s;
      } };
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e, t = null) {
    e(this, t);
    for (const { childNode: r, replaceNode: n } of this.getChildren())
      r.traverse(e, n);
  }
  getCacheKey() {
    return Ja(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    for (const { childNode: r } of this.getChildren())
      t["_node" + r.id] = r;
    return null;
  }
  construct(e) {
    return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."), this.setup(e);
  }
  analyze(e) {
    const t = e.getDataFromNode(this);
    if (t.dependenciesCount = t.dependenciesCount === void 0 ? 1 : t.dependenciesCount + 1, t.dependenciesCount === 1) {
      const r = e.getNodeProperties(this);
      for (const n of Object.values(r))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    if (r && r.isNode === !0)
      return r.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const r = this.getShared(e);
    if (this !== r)
      return r.build(e, t);
    e.addNode(this), e.addChain(this);
    let n = null;
    const s = e.getBuildStage();
    if (s === "setup") {
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0 || e.context.tempRead === !1) {
        const i = e.stack.nodes.length;
        o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length !== i && (o.outputNode = e.stack);
        for (const a of Object.values(o))
          a && a.isNode === !0 && a.build(e);
      }
    } else if (s === "analyze")
      this.analyze(e);
    else if (s === "generate")
      if (this.generate.length === 1) {
        const i = this.getNodeType(e), a = e.getDataFromNode(this);
        n = a.snippet, n === void 0 && (n = this.generate(e) || "", a.snippet = n), n = e.format(n, i, t);
      } else
        n = this.generate(e, t) || "";
    return e.removeChain(this), n;
  }
  getSerializeChildren() {
    return ei(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(), r = {};
    for (const { property: n, index: s, childNode: o } of t)
      s !== void 0 ? (r[n] === void 0 && (r[n] = Number.isInteger(s) ? [] : {}), r[n][s] = o.toJSON(e.meta).uuid) : r[n] = o.toJSON(e.meta).uuid;
    Object.keys(r).length > 0 && (e.inputNodes = r);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const r in e.inputNodes)
        if (Array.isArray(e.inputNodes[r])) {
          const n = [];
          for (const s of e.inputNodes[r])
            n.push(t[s]);
          this[r] = n;
        } else if (typeof e.inputNodes[r] == "object") {
          const n = {};
          for (const s in e.inputNodes[r]) {
            const o = e.inputNodes[r][s];
            n[s] = t[o];
          }
          this[r] = n;
        } else {
          const n = e.inputNodes[r];
          this[r] = t[n];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: r } = this, n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let s = e.nodes[t];
    s === void 0 && (s = {
      uuid: t,
      type: r,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, n !== !0 && (e.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
    if (n) {
      const i = o(e.textures), a = o(e.images), l = o(e.nodes);
      i.length > 0 && (s.textures = i), a.length > 0 && (s.images = a), l.length > 0 && (s.nodes = l);
    }
    return s;
  }
};
const Le = _b;
function re(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node class ${c} is not a class`);
  if (Gl.has(c))
    throw new Error(`Redefinition of node class ${c}`);
  Gl.set(c, e), e.type = c;
}
function Vl(c) {
  const e = Gl.get(c);
  if (e !== void 0)
    return new e();
}
class zm extends Le {
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Xs(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Xs(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = Mu(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? _u(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Cu = zm;
re("InputNode", zm);
class Bm extends Le {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node.build(e), r = this.indexNode.build(e, "uint");
    return `${t}[ ${r} ]`;
  }
}
const Ya = Bm;
re("ArrayElementNode", Bm);
class km extends Le {
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let r = null;
    for (const n of this.convertTo.split("|"))
      (r === null || e.getTypeLength(t) === e.getTypeLength(n)) && (r = n);
    return r;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const r = this.node, n = this.getNodeType(e), s = r.build(e, n);
    return e.format(s, n, t);
  }
}
const Ka = km;
re("ConvertNode", km);
class Gm extends Le {
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).dependenciesCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, t)), s = e.getDataFromNode(this);
      if (e.context.tempRead !== !1 && s.propertyName !== void 0)
        return e.format(s.propertyName, n, t);
      if (e.context.tempWrite !== !1 && n !== "void" && t !== "void" && this.hasDependencies(e)) {
        const o = super.build(e, n), i = e.getVarFromNode(this, n), a = e.getPropertyName(i);
        return e.addLineFlowCode(`${a} = ${o}`), s.snippet = o, s.propertyName = a, e.format(s.propertyName, n, t);
      }
    }
    return super.build(e, t);
  }
}
const Mt = Gm;
re("TempNode", Gm);
class Vm extends Mt {
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, r) => t + e.getTypeLength(r.getNodeType(e)), 0));
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.nodes, s = [];
    for (const i of n) {
      const a = i.build(e);
      s.push(a);
    }
    const o = `${e.getType(r)}( ${s.join(", ")} )`;
    return e.format(o, r, t);
  }
}
const jm = Vm;
re("JoinNode", Vm);
const Mb = qa.join("");
class Wm extends Le {
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(qa.indexOf(t) + 1, e);
    return e;
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length);
  }
  generate(e, t) {
    const r = this.node, n = e.getTypeLength(r.getNodeType(e));
    let s = null;
    if (n > 1) {
      let o = null;
      this.getVectorLength() >= n && (o = e.getTypeFromLength(this.getVectorLength()));
      const a = r.build(e, o);
      this.components.length === n && this.components === Mb.slice(0, this.components.length) ? s = e.format(a, o, t) : s = e.format(`${a}.${this.components}`, this.getNodeType(e), t);
    } else
      s = r.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
const Ta = Wm;
re("SplitNode", Wm);
class Hm extends Mt {
  constructor(e, t, r) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = r;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: r, targetNode: n } = this, s = this.getNodeType(e), o = e.getTypeFromLength(r.length), i = n.build(e, o), a = t.build(e, s), l = e.getTypeLength(s), u = [];
    for (let h = 0; h < l; h++) {
      const d = qa[h];
      d === r[0] ? (u.push(i), h += r.length - 1) : u.push(a + "." + d);
    }
    return `${e.getType(s)}( ${u.join(", ")} )`;
  }
}
const Xm = Hm;
re("SetNode", Hm);
class $m extends Cu {
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.getConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const r = this.getNodeType(e);
    return e.format(this.generateConst(e), r, t);
  }
}
const Ln = $m;
re("ConstNode", $m);
const Yr = /* @__PURE__ */ new Map();
function W(c, e) {
  if (Yr.has(c))
    throw new Error(`Redefinition of node element ${c}`);
  if (typeof e != "function")
    throw new Error(`Node element ${c} is not a function`);
  Yr.set(c, e);
}
const kf = (c) => c.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), qm = {
  setup(c, e) {
    const t = e.shift();
    return c(ec(t), ...e);
  },
  get: function(c, e, t) {
    if (typeof e == "string" && c[e] === void 0)
      if (Yr.has(e)) {
        const r = Yr.get(e);
        return (...n) => r(t, ...n);
      } else {
        if (e === "self")
          return c;
        if (e.endsWith("Assign") && Yr.has(e.slice(0, e.length - 6))) {
          const r = Yr.get(e.slice(0, e.length - 6));
          return (...n) => t.assign(r(t, ...n));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = kf(e), Ae(new Ta(c, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = kf(e.slice(3).toLowerCase()), e = e.split("").sort().join(""), (r) => Ae(new Xm(c, e, r));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), Ae(new Ta(c, e));
          if (/^\d+$/.test(e) === !0)
            return Ae(new Ya(c, new Ln(Number(e), "uint")));
        }
      }
    return c[e];
  }
}, qc = /* @__PURE__ */ new WeakMap(), Ab = function(c, e = null) {
  const t = Xs(c);
  if (t === "node") {
    let r = qc.get(c);
    return r === void 0 && (r = new Proxy(c, qm), qc.set(c, r), qc.set(r, r)), r;
  } else {
    if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string")
      return Ae(jl(c, e));
    if (t === "shader")
      return Ze(c);
  }
  return c;
}, Cb = function(c, e = null) {
  for (const t in c)
    c[t] = Ae(c[t], e);
  return c;
}, Eb = function(c, e = null) {
  const t = c.length;
  for (let r = 0; r < t; r++)
    c[r] = Ae(c[r], e);
  return c;
}, Rb = function(c, e = null, t = null, r = null) {
  const n = (s) => Ae(r !== null ? Object.assign(s, r) : s);
  return e === null ? (...s) => n(new c(...mr(s))) : t !== null ? (t = Ae(t), (...s) => n(new c(e, ...mr(s), t))) : (...s) => n(new c(e, ...mr(s)));
}, Fb = function(c, ...e) {
  return Ae(new c(...mr(e)));
};
class Lb extends Le {
  constructor(e, t) {
    super(), this.shaderNode = e, this.inputNodes = t;
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  call(e) {
    const { shaderNode: t, inputNodes: r } = this, n = t.jsFunc, s = r !== null ? n(ec(r), e.stack, e) : n(e.stack, e);
    return Ae(s);
  }
  setup(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    return r === null ? this.call(e).build(e, t) : super.generate(e, t);
  }
}
class Ob extends Le {
  constructor(e) {
    super(), this.jsFunc = e;
  }
  call(e = null) {
    return Ae(new Lb(this, e));
  }
  setup() {
    return this.call();
  }
}
const Ib = [!1, !0], Pb = [0, 1, 2, 3], Ub = [-1, -2], Jm = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], Eu = /* @__PURE__ */ new Map();
for (const c of Ib)
  Eu.set(c, new Ln(c));
const Ru = /* @__PURE__ */ new Map();
for (const c of Pb)
  Ru.set(c, new Ln(c, "uint"));
const Fu = new Map([...Ru].map((c) => new Ln(c.value, "int")));
for (const c of Ub)
  Fu.set(c, new Ln(c, "int"));
const Za = new Map([...Fu].map((c) => new Ln(c.value)));
for (const c of Jm)
  Za.set(c, new Ln(c));
for (const c of Jm)
  Za.set(-c, new Ln(-c));
const Qa = { bool: Eu, uint: Ru, ints: Fu, float: Za }, Gf = new Map([...Eu, ...Za]), jl = (c, e) => Gf.has(c) ? Gf.get(c) : c.isNode === !0 ? c : new Ln(c, e), Db = (c) => {
  try {
    return c.getNodeType();
  } catch {
    return;
  }
}, mt = function(c, e = null) {
  return (...t) => {
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(c) && t.every((n) => typeof n != "object")) && (t = [_u(c, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return Ae(e.get(t[0]));
    if (t.length === 1) {
      const n = jl(t[0], c);
      return Db(n) === c ? Ae(n) : Ae(new Ka(n, c));
    }
    const r = t.map((n) => jl(n));
    return Ae(new jm(r, c));
  };
}, Ym = (c) => c != null ? c.nodeType || c.convertTo || (typeof c == "string" ? c : null) : null;
function Ms(c) {
  return new Proxy(new Ob(c), qm);
}
const Ae = (c, e = null) => (
  /* new */
  Ab(c, e)
), ec = (c, e = null) => new Cb(c, e), mr = (c, e = null) => new Eb(c, e), J = (...c) => new Rb(...c), le = (...c) => new Fb(...c), zb = (c) => (console.warn("TSL: shader() is deprecated. Use tslFn() instead."), new Ms(c)), Ze = (c) => {
  const e = new Ms(c);
  return (t) => e.call(t);
};
re("ShaderNode", Ms);
const Km = new mt("color"), Me = new mt("float", Qa.float), Sa = new mt("int", Qa.int), Zm = new mt("uint", Qa.uint), Qm = new mt("bool", Qa.bool), st = new mt("vec2"), eg = new mt("ivec2"), tg = new mt("uvec2"), ng = new mt("bvec2"), Fe = new mt("vec3"), sg = new mt("ivec3"), rg = new mt("uvec3"), og = new mt("bvec3"), ot = new mt("vec4"), ig = new mt("ivec4"), ag = new mt("uvec4"), cg = new mt("bvec4"), As = new mt("mat3"), lg = new mt("imat3"), ug = new mt("umat3"), hg = new mt("bmat3"), Lu = new mt("mat4"), dg = new mt("imat4"), fg = new mt("umat4"), pg = new mt("bmat4"), mg = (c = "") => Ae(new Ln(c, "string")), gg = (c) => Ae(new Ln(c, "ArrayBuffer"));
W("color", Km);
W("float", Me);
W("int", Sa);
W("uint", Zm);
W("bool", Qm);
W("vec2", st);
W("ivec2", eg);
W("uvec2", tg);
W("bvec2", ng);
W("vec3", Fe);
W("ivec3", sg);
W("uvec3", rg);
W("bvec3", og);
W("vec4", ot);
W("ivec4", ig);
W("uvec4", ag);
W("bvec4", cg);
W("mat3", As);
W("imat3", lg);
W("umat3", ug);
W("bmat3", hg);
W("mat4", Lu);
W("imat4", dg);
W("umat4", fg);
W("bmat4", pg);
W("string", mg);
W("arrayBuffer", gg);
const yg = J(Ya), vg = (c, e) => Ae(new Ka(Ae(c), e)), Bb = (c, e) => Ae(new Ta(Ae(c), e));
W("element", yg);
W("convert", vg);
class Ou extends Cu {
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.getUniformHash(e);
    let s = e.getNodeFromHash(n);
    s === void 0 && (e.setHashNode(this, n), s = this);
    const o = s.getInputType(e), i = e.getUniformFromNode(s, o, e.shaderStage, e.context.label), a = e.getPropertyName(i);
    return e.context.label !== void 0 && delete e.context.label, e.format(a, r, t);
  }
}
const nt = Ou, Ft = (c, e) => {
  const t = Ym(e || c), r = c && c.isNode === !0 ? c.node && c.node.value || c.value : c;
  return Ae(new Ou(r, t));
};
re("UniformNode", Ou);
class xg extends nt {
  constructor(e = []) {
    super(), this.isArrayUniformNode = !0, this.nodes = e;
  }
  getNodeType(e) {
    return this.nodes[0].getNodeType(e);
  }
}
const bg = xg;
re("ArrayUniformNode", xg);
class Iu extends Le {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: r } = this, n = this.getNodeType(e), s = e.getVaryingFromNode(this, n);
    s.needsInterpolation || (s.needsInterpolation = e.shaderStage === "fragment"), t !== null && (s.name = t);
    const o = e.getPropertyName(s, kl.VERTEX);
    return e.flowNodeFromShaderStage(kl.VERTEX, r, n, o), e.getPropertyName(s);
  }
}
const Ng = Iu, ct = J(Iu);
W("varying", ct);
re("VaryingNode", Iu);
class Pu extends Le {
  constructor(e, t = null) {
    super(t), this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (t === null) {
      const r = this.getAttributeName(e);
      if (e.hasGeometryAttribute(r)) {
        const n = e.geometry.getAttribute(r);
        t = e.getTypeFromAttribute(n);
      } else
        t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), r = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t), o = e.getTypeFromAttribute(s), i = e.getAttribute(t, o);
      return e.shaderStage === "vertex" ? e.format(i.name, o, r) : ct(this).build(e, r);
    } else
      return console.warn(`AttributeNode: Attribute "${t}" not found.`), e.getConst(r);
  }
}
const Uu = Pu, Ot = (c, e) => Ae(new Pu(c, e));
re("AttributeNode", Pu);
class Du extends Le {
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const wg = Du, tc = J(Du);
W("bypass", tc);
re("BypassNode", Du);
let kb = 0;
class Gb {
  constructor() {
    this.id = kb++, this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
}
const nc = Gb;
class zu extends Le {
  constructor(e, t = new nc()) {
    super(), this.isCacheNode = !0, this.node = e, this.cache = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const r = e.getCache();
    e.setCache(this.cache);
    const n = this.node.build(e, ...t);
    return e.setCache(r), n;
  }
}
const Tg = zu, _a = J(zu);
W("cache", _a);
re("CacheNode", zu);
class Bu extends Le {
  constructor(e, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.context = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const r = this.node.build(e);
    return e.setContext(t), r;
  }
  generate(e, t) {
    const r = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const n = this.node.build(e, t);
    return e.setContext(r), n;
  }
}
const ku = Bu, Zn = J(Bu), sc = (c, e) => Zn(c, { label: e });
W("context", Zn);
W("label", sc);
re("ContextNode", Bu);
class es extends Le {
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), r = this.scope;
    let n;
    if (r === es.VERTEX)
      n = e.getVertexIndex();
    else if (r === es.INSTANCE)
      n = e.getInstanceIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + r);
    let s;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? s = n : s = ct(this).build(e, t), s;
  }
}
es.VERTEX = "vertex";
es.INSTANCE = "instance";
const Vb = es, jb = le(es, es.VERTEX), Sg = le(es, es.INSTANCE);
re("IndexNode", es);
class Wb {
  init() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
}
const Gu = Wb;
class Hb {
  constructor(e, t, r = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = r;
  }
}
const Ma = Hb;
class Xb {
  constructor(e, t, r, n = void 0) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = r.getSelf(), this.needsUpdate = n;
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
}
const Vu = Xb;
class $b {
  constructor(e, t) {
    this.isNodeVar = !0, this.name = e, this.type = t;
  }
}
const rc = $b;
class qb extends rc {
  constructor(e, t) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
const ju = qb;
class Jb {
  constructor(e, t, r = "") {
    this.name = e, this.type = t, this.code = r, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
const Wu = Jb;
class Yb {
  constructor() {
    this.keywords = [], this.nodes = [], this.keywordsCallback = {};
  }
  getNode(e) {
    let t = this.nodes[e];
    return t === void 0 && this.keywordsCallback[e] !== void 0 && (t = this.keywordsCallback[e](e), this.nodes[e] = t), t;
  }
  addKeyword(e, t) {
    return this.keywords.push(e), this.keywordsCallback[e] = t, this;
  }
  parse(e) {
    const t = this.keywords, r = new RegExp(`\\b${t.join("\\b|\\b")}\\b`, "g"), n = e.match(r), s = [];
    if (n !== null)
      for (const o of n) {
        const i = this.getNode(o);
        i !== void 0 && s.indexOf(i) === -1 && s.push(i);
      }
    return s;
  }
  include(e, t) {
    const r = this.parse(t);
    for (const n of r)
      n.build(e);
  }
}
const Hu = Yb;
class Vt extends Le {
  constructor(e, t = null) {
    super(e), this.name = t;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    const t = e.getVarFromNode(this, this.getNodeType(e)), r = this.name;
    return r !== null && (t.name = r), e.getPropertyName(t);
  }
}
const _g = Vt, Ts = (c, e) => Ae(new Vt(c, e)), $t = le(Vt, "vec4", "DiffuseColor"), ao = le(Vt, "float", "Roughness"), Mg = le(Vt, "float", "Metalness"), Wl = le(Vt, "float", "Clearcoat"), Aa = le(Vt, "float", "ClearcoatRoughness"), Kr = le(Vt, "vec3", "Sheen"), Xu = le(Vt, "float", "SheenRoughness"), $u = le(Vt, "float", "Iridescence"), Ag = le(Vt, "float", "IridescenceIOR"), Cg = le(Vt, "float", "IridescenceThickness"), ls = le(Vt, "color", "SpecularColor"), Ca = le(Vt, "float", "Shininess"), Eg = le(Vt, "vec4", "Output"), co = le(Vt, "float", "dashSize"), Ea = le(Vt, "float", "gapSize");
re("PropertyNode", Vt);
class qu extends Uu {
  constructor(e = 0) {
    super(null, "vec2"), this.isUVNode = !0, this.index = e;
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const Rg = qu, vt = (...c) => Ae(new qu(...c));
re("UVNode", qu);
class Fg extends Le {
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const r = this.textureNode.build(e, "property"), n = this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${r}, ${n} )`, this.getNodeType(e), t);
  }
}
const Lg = J(Fg);
W("textureSize", Lg);
re("TextureSizeNode", Fg);
class bt extends Mt {
  constructor(e, t, r, ...n) {
    if (super(), this.op = e, n.length > 0) {
      let s = r;
      for (let o = 0; o < n.length; o++)
        s = new bt(e, s, n[o]);
      r = s;
    }
    this.aNode = t, this.bNode = r;
  }
  hasDependencies(e) {
    return this.op !== "=" ? super.hasDependencies(e) : !1;
  }
  getNodeType(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = n.getNodeType(e), i = s.getNodeType(e);
    if (o === "void" || i === "void")
      return "void";
    if (r === "=" || r === "%")
      return o;
    if (r === "&" || r === "|" || r === "^" || r === ">>" || r === "<<")
      return e.getIntegerType(o);
    if (r === "==" || r === "&&" || r === "||" || r === "^^")
      return "bool";
    if (r === "<" || r === ">" || r === "<=" || r === ">=") {
      const a = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(o), e.getTypeLength(i));
      return a > 1 ? `bvec${a}` : "bool";
    } else
      return o === "float" && e.isMatrix(i) ? i : e.isMatrix(o) && e.isVector(i) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(i) ? e.getVectorFromMatrix(i) : e.getTypeLength(i) > e.getTypeLength(o) ? i : o;
  }
  generate(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = this.getNodeType(e, t);
    let i = null, a = null;
    o !== "void" ? (i = n.getNodeType(e), a = s.getNodeType(e), r === "=" ? a = i : r === "<" || r === ">" || r === "<=" || r === ">=" || r === "==" ? e.isVector(i) ? a = i : i = a = "float" : r === ">>" || r === "<<" ? (i = o, a = e.changeComponentType(a, "uint")) : e.isMatrix(i) && e.isVector(a) ? a = e.getVectorFromMatrix(i) : e.isVector(i) && e.isMatrix(a) ? i = e.getVectorFromMatrix(a) : i = a = o) : i = a = o;
    const l = n.build(e, i), u = s.build(e, a), h = e.getTypeLength(t);
    if (t !== "void")
      return r === "=" ? (e.addLineFlowCode(`${l} ${this.op} ${u}`), l) : r === "<" && h > 1 ? e.format(`${e.getMethod("lessThan")}( ${l}, ${u} )`, o, t) : r === "<=" && h > 1 ? e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${u} )`, o, t) : r === ">" && h > 1 ? e.format(`${e.getMethod("greaterThan")}( ${l}, ${u} )`, o, t) : r === ">=" && h > 1 ? e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${u} )`, o, t) : e.format(`( ${l} ${this.op} ${u} )`, o, t);
    if (i !== "void")
      return e.format(`${l} ${this.op} ${u}`, o, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Og = bt, xn = J(bt, "+"), Ra = J(bt, "-"), Qt = J(bt, "*"), yo = J(bt, "/"), Ig = J(bt, "%"), Pg = J(bt, "=="), Ju = J(bt, "="), Ug = J(bt, "<"), Dg = J(bt, ">"), zg = J(bt, "<="), Bg = J(bt, ">="), kg = J(bt, "&&"), Gg = J(bt, "||"), Vg = J(bt, "^^"), jg = J(bt, "&"), Wg = J(bt, "|"), Hg = J(bt, "^"), Xg = J(bt, "<<"), $g = J(bt, ">>");
W("add", xn);
W("sub", Ra);
W("mul", Qt);
W("div", yo);
W("remainder", Ig);
W("equal", Pg);
W("assign", Ju);
W("lessThan", Ug);
W("greaterThan", Dg);
W("lessThanEqual", zg);
W("greaterThanEqual", Bg);
W("and", kg);
W("or", Gg);
W("xor", Vg);
W("bitAnd", jg);
W("bitOr", Wg);
W("bitXor", Hg);
W("shiftLeft", Xg);
W("shiftRight", $g);
re("OperatorNode", bt);
class B extends Mt {
  constructor(e, t, r = null, n = null) {
    super(), this.method = e, this.aNode = t, this.bNode = r, this.cNode = n;
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e), r = this.bNode ? this.bNode.getNodeType(e) : null, n = this.cNode ? this.cNode.getNodeType(e) : null, s = e.isMatrix(t) ? 0 : e.getTypeLength(t), o = e.isMatrix(r) ? 0 : e.getTypeLength(r), i = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return s > o && s > i ? t : o > i ? r : i > s ? n : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === B.LENGTH || t === B.DISTANCE || t === B.DOT ? "float" : t === B.CROSS ? "vec3" : this.getInputType(e);
  }
  generate(e, t) {
    const r = this.method, n = this.getNodeType(e), s = this.getInputType(e), o = this.aNode, i = this.bNode, a = this.cNode, l = e.renderer.isWebGLRenderer === !0;
    if (r === B.TRANSFORM_DIRECTION) {
      let u = o, h = i;
      e.isMatrix(u.getNodeType(e)) ? h = ot(Fe(h), 0) : u = ot(Fe(u), 0);
      const d = Qt(u, h).xyz;
      return Fn(d).build(e, t);
    } else {
      if (r === B.NEGATE)
        return e.format("( - " + o.build(e, s) + " )", n, t);
      if (r === B.ONE_MINUS)
        return Ra(1, o).build(e, t);
      if (r === B.RECIPROCAL)
        return yo(1, o).build(e, t);
      if (r === B.DIFFERENCE)
        return ti(Ra(o, i)).build(e, t);
      {
        const u = [];
        return r === B.CROSS ? u.push(
          o.build(e, n),
          i.build(e, n)
        ) : r === B.STEP ? u.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : s),
          i.build(e, s)
        ) : l && (r === B.MIN || r === B.MAX) || r === B.MOD ? u.push(
          o.build(e, s),
          i.build(e, e.getTypeLength(i.getNodeType(e)) === 1 ? "float" : s)
        ) : r === B.REFRACT ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, "float")
        ) : r === B.MIX ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : s)
        ) : (u.push(o.build(e, s)), i !== null && u.push(i.build(e, s)), a !== null && u.push(a.build(e, s))), e.format(`${e.getMethod(r)}( ${u.join(", ")} )`, n, t);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
B.RADIANS = "radians";
B.DEGREES = "degrees";
B.EXP = "exp";
B.EXP2 = "exp2";
B.LOG = "log";
B.LOG2 = "log2";
B.SQRT = "sqrt";
B.INVERSE_SQRT = "inversesqrt";
B.FLOOR = "floor";
B.CEIL = "ceil";
B.NORMALIZE = "normalize";
B.FRACT = "fract";
B.SIN = "sin";
B.COS = "cos";
B.TAN = "tan";
B.ASIN = "asin";
B.ACOS = "acos";
B.ATAN = "atan";
B.ABS = "abs";
B.SIGN = "sign";
B.LENGTH = "length";
B.NEGATE = "negate";
B.ONE_MINUS = "oneMinus";
B.DFDX = "dFdx";
B.DFDY = "dFdy";
B.ROUND = "round";
B.RECIPROCAL = "reciprocal";
B.TRUNC = "trunc";
B.FWIDTH = "fwidth";
B.ATAN2 = "atan2";
B.MIN = "min";
B.MAX = "max";
B.MOD = "mod";
B.STEP = "step";
B.REFLECT = "reflect";
B.DISTANCE = "distance";
B.DIFFERENCE = "difference";
B.DOT = "dot";
B.CROSS = "cross";
B.POW = "pow";
B.TRANSFORM_DIRECTION = "transformDirection";
B.MIX = "mix";
B.CLAMP = "clamp";
B.REFRACT = "refract";
B.SMOOTHSTEP = "smoothstep";
B.FACEFORWARD = "faceforward";
const ke = B, Yu = Me(1e-6), Kb = Me(1e6), qg = J(B, B.RADIANS), Jg = J(B, B.DEGREES), Yg = J(B, B.EXP), Kg = J(B, B.EXP2), Zg = J(B, B.LOG), Qg = J(B, B.LOG2), ey = J(B, B.SQRT), ty = J(B, B.INVERSE_SQRT), oc = J(B, B.FLOOR), Ku = J(B, B.CEIL), Fn = J(B, B.NORMALIZE), ic = J(B, B.FRACT), ny = J(B, B.SIN), sy = J(B, B.COS), ry = J(B, B.TAN), oy = J(B, B.ASIN), iy = J(B, B.ACOS), ay = J(B, B.ATAN), ti = J(B, B.ABS), cy = J(B, B.SIGN), ly = J(B, B.LENGTH), uy = J(B, B.NEGATE), hy = J(B, B.ONE_MINUS), Zu = J(B, B.DFDX), Qu = J(B, B.DFDY), dy = J(B, B.ROUND), fy = J(B, B.RECIPROCAL), py = J(B, B.TRUNC), my = J(B, B.FWIDTH), gy = J(B, B.ATAN2), yy = J(B, B.MIN), vy = J(B, B.MAX), eh = J(B, B.MOD), xy = J(B, B.STEP), by = J(B, B.REFLECT), Ny = J(B, B.DISTANCE), wy = J(B, B.DIFFERENCE), js = J(B, B.DOT), Ty = J(B, B.CROSS), th = J(B, B.POW), Sy = J(B, B.POW, 2), _y = J(B, B.POW, 3), My = J(B, B.POW, 4), Ay = J(B, B.TRANSFORM_DIRECTION), on = J(B, B.MIX), ni = (c, e = 0, t = 1) => Ae(new B(B.CLAMP, Ae(c), Ae(e), Ae(t))), Cy = (c) => ni(c), Ey = J(B, B.REFRACT), Qs = J(B, B.SMOOTHSTEP), Ry = J(B, B.FACEFORWARD), Zb = (c, e, t) => on(e, t, c), Qb = (c, e, t) => Qs(e, t, c);
W("radians", qg);
W("degrees", Jg);
W("exp", Yg);
W("exp2", Kg);
W("log", Zg);
W("log2", Qg);
W("sqrt", ey);
W("inverseSqrt", ty);
W("floor", oc);
W("ceil", Ku);
W("normalize", Fn);
W("fract", ic);
W("sin", ny);
W("cos", sy);
W("tan", ry);
W("asin", oy);
W("acos", iy);
W("atan", ay);
W("abs", ti);
W("sign", cy);
W("length", ly);
W("negate", uy);
W("oneMinus", hy);
W("dFdx", Zu);
W("dFdy", Qu);
W("round", dy);
W("reciprocal", fy);
W("trunc", py);
W("fwidth", my);
W("atan2", gy);
W("min", yy);
W("max", vy);
W("mod", eh);
W("step", xy);
W("reflect", by);
W("distance", Ny);
W("dot", js);
W("cross", Ty);
W("pow", th);
W("pow2", Sy);
W("pow3", _y);
W("pow4", My);
W("transformDirection", Ay);
W("mix", Zb);
W("clamp", ni);
W("refract", Ey);
W("smoothstep", Qb);
W("faceForward", Ry);
W("difference", wy);
W("saturate", Cy);
re("MathNode", B);
const eN = Ze((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.mul(0.9478672986).add(0.0521327014).pow(2.4), n = t.mul(0.0773993808), s = t.lessThanEqual(0.04045), o = on(r, n, s);
  return ot(o, e.a);
}), tN = Ze((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.pow(0.41666).mul(1.055).sub(0.055), n = t.mul(12.92), s = t.lessThanEqual(31308e-7), o = on(r, n, s);
  return ot(o, e.a);
}), Vf = (c) => {
  let e = null;
  return c === Rn ? e = "Linear" : c === vn && (e = "sRGB"), e;
}, Fy = (c, e) => Vf(c) + "To" + Vf(e);
class an extends Mt {
  constructor(e, t) {
    super("vec4"), this.method = e, this.node = t;
  }
  setup() {
    const { method: e, node: t } = this;
    return e === an.LINEAR_TO_LINEAR ? t : nN[e]({ value: t });
  }
}
an.LINEAR_TO_LINEAR = "LinearToLinear";
an.LINEAR_TO_sRGB = "LinearTosRGB";
an.sRGB_TO_LINEAR = "sRGBToLinear";
const nN = {
  [an.LINEAR_TO_sRGB]: tN,
  [an.sRGB_TO_LINEAR]: eN
}, jo = an, Ly = (c, e) => Ae(new an(Fy(Rn, e), Ae(c))), ac = (c, e) => Ae(new an(Fy(e, Rn), Ae(c))), Oy = J(an, an.LINEAR_TO_sRGB), Iy = J(an, an.sRGB_TO_LINEAR);
W("linearTosRGB", Oy);
W("sRGBToLinear", Iy);
W("linearToColorSpace", Ly);
W("colorSpaceToLinear", ac);
re("ColorSpaceNode", an);
class nh extends Le {
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.snippet;
    if (r === "void")
      e.addLineFlowCode(n);
    else
      return e.format(`( ${n} )`, r, t);
  }
}
const Py = nh, No = J(nh);
re("ExpressionNode", nh);
class sh extends nt {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = r, this.compareNode = n, this.updateMatrix = !1, this.updateType = ut.NONE, this.setUpdateMatrix(t === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return vt(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    const t = this.value;
    return Ft(t.matrix).mul(Fe(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? ut.FRAME : ut.NONE, this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let r = this.uvNode;
    r === null && e.context.getUVNode && (r = e.context.getUVNode(this)), r || (r = this.getDefaultUV()), this.updateMatrix === !0 && (r = this.getTransformedUV(r));
    let n = this.levelNode;
    n === null && e.context.getSamplerLevelNode && (n = e.context.getSamplerLevelNode(this)), t.uvNode = r, t.levelNode = n ? e.context.getMIPLevelAlgorithmNode(this, n) : null;
  }
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.compareNode, o = this.value;
    if (!o || o.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const i = super.generate(e, "property");
    if (t === "sampler")
      return i + "_sampler";
    if (e.isReference(t))
      return i;
    {
      const a = this.getNodeType(e), l = e.getDataFromNode(this);
      let u = l.propertyName;
      if (u === void 0) {
        const d = r.build(e, "vec2"), f = e.getVarFromNode(this, a);
        u = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(o, i, d, m);
        } else if (s !== null) {
          const m = s.build(e, "float");
          p = e.getTextureCompare(o, i, d, m);
        } else
          p = e.getTexture(o, i, d);
        e.addLineFlowCode(`${u} = ${p}`), e.context.tempWrite !== !1 && (l.snippet = p, l.propertyName = u);
      }
      let h = u;
      return e.needsColorSpaceToLinear(this.value) && (h = ac(No(h, a), this.value.colorSpace).setup(e).build(e, a)), e.format(h, a, t);
    }
  }
  uv(e) {
    const t = this.clone();
    return t.uvNode = e, Ae(t);
  }
  level(e) {
    const t = this.clone();
    return t.levelNode = e, Zn(t, {
      getMIPLevelAlgorithmNode: (r, n) => n
    });
  }
  size(e) {
    return Lg(this, e);
  }
  compare(e) {
    const t = this.clone();
    return t.compareNode = Ae(e), Ae(t);
  }
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value];
  }
  update() {
    const e = this.value;
    e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
}
const vi = sh, en = J(sh), sN = (c) => (c.isNode === !0 ? c : en(c)).convert("sampler");
W("texture", en);
re("TextureNode", sh);
class rh extends Le {
  constructor(e, t, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = r, this.reference = null, this.node = null, this.updateType = ut.OBJECT, this.setNodeType(t);
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setNodeType(e) {
    let t = null;
    e === "texture" ? t = en(null) : t = Ft(e), this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  update() {
    this.node.value = this.reference[this.property];
  }
  setup() {
    return this.node;
  }
}
const cc = rh, Cs = (c, e, t) => Ae(new rh(c, e, t));
re("ReferenceNode", rh);
class oh extends cc {
  constructor(e, t, r = null) {
    super(e, t, r), this.material = r, this.updateType = ut.RENDER;
  }
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
  setup(e) {
    const t = this.material !== null ? this.material : e.material;
    return this.node.value = t[this.property], super.setup(e);
  }
}
const Uy = oh, lo = (c, e, t) => Ae(new oh(c, e, t));
re("MaterialReferenceNode", oh);
const jf = /* @__PURE__ */ new Map();
class Ne extends Le {
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, t) {
    let r = jf.get(e);
    return r === void 0 && (r = lo(e, t), jf.set(e, r)), r;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e, "texture");
  }
  setup(e) {
    const t = e.context.material, r = this.scope;
    let n = null;
    if (r === Ne.ALPHA_TEST || r === Ne.SHININESS || r === Ne.REFLECTIVITY || r === Ne.ROTATION || r === Ne.IRIDESCENCE || r === Ne.IRIDESCENCE_IOR)
      n = this.getFloat(r);
    else if (r === Ne.SPECULAR_COLOR)
      n = this.getColor("specular");
    else if (r === Ne.COLOR) {
      const s = this.getColor("color");
      t.map && t.map.isTexture === !0 ? n = s.mul(this.getTexture("map")) : n = s;
    } else if (r === Ne.OPACITY) {
      const s = this.getFloat("opacity");
      t.alphaMap && t.alphaMap.isTexture === !0 ? n = s.mul(this.getTexture("alphaMap")) : n = s;
    } else if (r === Ne.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? n = this.getTexture("specularMap").r : n = Me(1);
    else if (r === Ne.ROUGHNESS) {
      const s = this.getFloat("roughness");
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("roughnessMap").g) : n = s;
    } else if (r === Ne.METALNESS) {
      const s = this.getFloat("metalness");
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? n = s.mul(this.getTexture("metalnessMap").b) : n = s;
    } else if (r === Ne.EMISSIVE) {
      const s = this.getColor("emissive");
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? n = s.mul(this.getTexture("emissiveMap")) : n = s;
    } else if (r === Ne.CLEARCOAT) {
      const s = this.getFloat("clearcoat");
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? n = s.mul(this.getTexture("clearcoatMap").r) : n = s;
    } else if (r === Ne.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat("clearcoatRoughness");
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("clearcoatRoughnessMap").r) : n = s;
    } else if (r === Ne.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenColorMap").rgb) : n = s;
    } else if (r === Ne.SHEEN_ROUGHNESS) {
      const s = this.getFloat("sheenRoughness");
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenRoughnessMap").a) : n = s, n = n.clamp(0.07, 1);
    } else if (r === Ne.IRIDESCENCE_THICKNESS) {
      const s = Cs(1, "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = Cs(0, "float", t.iridescenceThicknessRange);
        n = s.sub(o).mul(this.getTexture("iridescenceThicknessMap").g).add(o);
      } else
        n = s;
    } else {
      const s = this.getNodeType(e);
      n = lo(r, s);
    }
    return n;
  }
}
Ne.ALPHA_TEST = "alphaTest";
Ne.COLOR = "color";
Ne.OPACITY = "opacity";
Ne.SHININESS = "shininess";
Ne.SPECULAR = "specular";
Ne.SPECULAR_STRENGTH = "specularStrength";
Ne.REFLECTIVITY = "reflectivity";
Ne.ROUGHNESS = "roughness";
Ne.METALNESS = "metalness";
Ne.CLEARCOAT = "clearcoat";
Ne.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
Ne.EMISSIVE = "emissive";
Ne.ROTATION = "rotation";
Ne.SHEEN = "sheen";
Ne.SHEEN_ROUGHNESS = "sheenRoughness";
Ne.IRIDESCENCE = "iridescence";
Ne.IRIDESCENCE_IOR = "iridescenceIOR";
Ne.IRIDESCENCE_THICKNESS = "iridescenceThickness";
const Yn = Ne, Dy = le(Ne, Ne.ALPHA_TEST), ih = le(Ne, Ne.COLOR), zy = le(Ne, Ne.SHININESS), By = le(Ne, Ne.EMISSIVE), ah = le(Ne, Ne.OPACITY), ky = le(Ne, Ne.SPECULAR_COLOR), rN = le(Ne, Ne.SPECULAR_STRENGTH), oN = le(Ne, Ne.REFLECTIVITY), Gy = le(Ne, Ne.ROUGHNESS), Vy = le(Ne, Ne.METALNESS), iN = le(Ne, Ne.CLEARCOAT), aN = le(Ne, Ne.CLEARCOAT_ROUGHNESS), jy = le(Ne, Ne.ROTATION), Wy = le(Ne, Ne.SHEEN), Hy = le(Ne, Ne.SHEEN_ROUGHNESS), cN = le(Ne, Ne.IRIDESCENCE), lN = le(Ne, Ne.IRIDESCENCE_IOR), uN = le(Ne, Ne.IRIDESCENCE_THICKNESS);
re("MaterialNode", Ne);
class ze extends Le {
  constructor(e = ze.VIEW_MATRIX, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = ut.OBJECT, this._uniformNode = new nt(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === ze.WORLD_MATRIX || e === ze.VIEW_MATRIX)
      return "mat4";
    if (e === ze.NORMAL_MATRIX)
      return "mat3";
    if (e === ze.POSITION || e === ze.VIEW_POSITION || e === ze.DIRECTION || e === ze.SCALE)
      return "vec3";
  }
  update(e) {
    const t = this.object3d, r = this._uniformNode, n = this.scope;
    if (n === ze.VIEW_MATRIX)
      r.value = t.modelViewMatrix;
    else if (n === ze.NORMAL_MATRIX)
      r.value = t.normalMatrix;
    else if (n === ze.WORLD_MATRIX)
      r.value = t.matrixWorld;
    else if (n === ze.POSITION)
      r.value = r.value || new ye(), r.value.setFromMatrixPosition(t.matrixWorld);
    else if (n === ze.SCALE)
      r.value = r.value || new ye(), r.value.setFromMatrixScale(t.matrixWorld);
    else if (n === ze.DIRECTION)
      r.value = r.value || new ye(), t.getWorldDirection(r.value);
    else if (n === ze.VIEW_POSITION) {
      const s = e.camera;
      r.value = r.value || new ye(), r.value.setFromMatrixPosition(t.matrixWorld), r.value.applyMatrix4(s.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return t === ze.WORLD_MATRIX || t === ze.VIEW_MATRIX ? this._uniformNode.nodeType = "mat4" : t === ze.NORMAL_MATRIX ? this._uniformNode.nodeType = "mat3" : (t === ze.POSITION || t === ze.VIEW_POSITION || t === ze.DIRECTION || t === ze.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
ze.VIEW_MATRIX = "viewMatrix";
ze.NORMAL_MATRIX = "normalMatrix";
ze.WORLD_MATRIX = "worldMatrix";
ze.POSITION = "position";
ze.SCALE = "scale";
ze.VIEW_POSITION = "viewPosition";
ze.DIRECTION = "direction";
const gn = ze, hN = J(ze, ze.DIRECTION), dN = J(ze, ze.VIEW_MATRIX), fN = J(ze, ze.NORMAL_MATRIX), pN = J(ze, ze.WORLD_MATRIX), Fa = J(ze, ze.POSITION), mN = J(ze, ze.SCALE), ch = J(ze, ze.VIEW_POSITION);
re("Object3DNode", ze);
class it extends gn {
  constructor(e = it.POSITION) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? "mat4" : t === it.NEAR || t === it.FAR ? "float" : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera, r = this._uniformNode, n = this.scope;
    n === it.VIEW_MATRIX ? r.value = t.matrixWorldInverse : n === it.PROJECTION_MATRIX ? r.value = t.projectionMatrix : n === it.NEAR ? r.value = t.near : n === it.FAR ? r.value = t.far : (this.object3d = t, super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? this._uniformNode.nodeType = "mat4" : (t === it.NEAR || t === it.FAR) && (this._uniformNode.nodeType = "float"), super.generate(e);
  }
}
it.PROJECTION_MATRIX = "projectionMatrix";
it.NEAR = "near";
it.FAR = "far";
const lh = it, Ns = sc(le(it, it.PROJECTION_MATRIX), "projectionMatrix"), fa = le(it, it.NEAR), pa = le(it, it.FAR), Rs = le(it, it.VIEW_MATRIX), gN = le(it, it.NORMAL_MATRIX), yN = le(it, it.WORLD_MATRIX), vN = le(it, it.POSITION);
re("CameraNode", it);
class Gt extends gn {
  constructor(e = Gt.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
const xN = Gt, bN = le(Gt, Gt.DIRECTION), Nr = sc(le(Gt, Gt.VIEW_MATRIX), "modelViewMatrix"), uh = le(Gt, Gt.NORMAL_MATRIX), si = le(Gt, Gt.WORLD_MATRIX), NN = le(Gt, Gt.POSITION), wN = le(Gt, Gt.SCALE), TN = le(Gt, Gt.VIEW_POSITION);
re("ModelNode", Gt);
class Ct extends Le {
  constructor(e = Ct.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Ct.GEOMETRY)
      r = Ot("normal", "vec3");
    else if (t === Ct.LOCAL)
      r = ct(ri);
    else if (t === Ct.VIEW) {
      const n = uh.mul(wr);
      r = Fn(ct(n));
    } else if (t === Ct.WORLD) {
      const n = ds.transformDirection(Rs);
      r = Fn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Ct.GEOMETRY = "geometry";
Ct.LOCAL = "local";
Ct.VIEW = "view";
Ct.WORLD = "world";
const Wo = Ct, ri = le(Ct, Ct.GEOMETRY), wr = le(Ct, Ct.LOCAL), ds = le(Ct, Ct.VIEW), lc = le(Ct, Ct.WORLD), _t = Ts("vec3", "TransformedNormalView"), Xy = _t.transformDirection(Rs).normalize(), pr = Ts("vec3", "TransformedClearcoatNormalView");
re("NormalNode", Ct);
class hh extends Le {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  assign(e) {
    return e.traverse((t, r) => {
      r && t.uuid === this.uuid && r(this.node);
    }), this.node = e, this;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node, r = this.name;
    if (r === null && t.isTempNode === !0)
      return t.build(e);
    const n = e.getVectorType(this.getNodeType(e)), s = t.build(e, n), o = e.getVarFromNode(this, n);
    r !== null && (o.name = r);
    const i = e.getPropertyName(o);
    return e.addLineFlowCode(`${i} = ${s}`), i;
  }
}
const $y = hh, oi = J(hh);
W("temp", oi);
re("VarNode", hh);
class St extends Le {
  constructor(e = St.LOCAL) {
    super(), this.scope = e;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === St.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === St.GEOMETRY)
      r = Ot("tangent", "vec4");
    else if (t === St.LOCAL)
      r = ct(ii.xyz);
    else if (t === St.VIEW) {
      const n = Nr.mul(uc).xyz;
      r = Fn(ct(n));
    } else if (t === St.WORLD) {
      const n = xi.transformDirection(Rs);
      r = Fn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
St.GEOMETRY = "geometry";
St.LOCAL = "local";
St.VIEW = "view";
St.WORLD = "world";
const Zr = St, ii = le(St, St.GEOMETRY), uc = le(St, St.LOCAL), xi = le(St, St.VIEW), qy = le(St, St.WORLD), dh = oi(xi, "TransformedTangentView"), SN = Fn(dh.transformDirection(Rs));
re("TangentNode", St);
class Et extends Le {
  constructor(e = Et.LOCAL) {
    super("vec3"), this.scope = e;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r;
    t === Et.GEOMETRY ? r = ri.cross(ii) : t === Et.LOCAL ? r = wr.cross(uc) : t === Et.VIEW ? r = ds.cross(xi) : t === Et.WORLD && (r = lc.cross(qy));
    const n = r.mul(ii.w).xyz;
    return Fn(ct(n)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Et.GEOMETRY = "geometry";
Et.LOCAL = "local";
Et.VIEW = "view";
Et.WORLD = "world";
const Qr = Et, _N = le(Et, Et.GEOMETRY), MN = le(Et, Et.LOCAL), Jy = le(Et, Et.VIEW), AN = le(Et, Et.WORLD), Yy = Fn(_t.cross(dh).mul(ii.w)), CN = Fn(Yy.transformDirection(Rs));
re("BitangentNode", Et);
class lt extends Le {
  constructor(e = lt.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === lt.GEOMETRY)
      r = Ot("position", "vec3");
    else if (t === lt.LOCAL)
      r = ct(pn);
    else if (t === lt.WORLD) {
      const n = si.mul(bn);
      r = ct(n);
    } else if (t === lt.VIEW) {
      const n = Nr.mul(bn);
      r = ct(n);
    } else if (t === lt.VIEW_DIRECTION) {
      const n = ts.negate();
      r = Fn(ct(n));
    } else if (t === lt.WORLD_DIRECTION) {
      const n = bn.transformDirection(si);
      r = Fn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
lt.GEOMETRY = "geometry";
lt.LOCAL = "local";
lt.WORLD = "world";
lt.WORLD_DIRECTION = "worldDirection";
lt.VIEW = "view";
lt.VIEW_DIRECTION = "viewDirection";
const Bs = lt, pn = le(lt, lt.GEOMETRY), bn = le(lt, lt.LOCAL), fh = le(lt, lt.WORLD), ph = le(lt, lt.WORLD_DIRECTION), ts = le(lt, lt.VIEW), It = le(lt, lt.VIEW_DIRECTION);
re("PositionNode", lt);
class mh extends Le {
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    return e.getFrontFacing();
  }
}
const Ky = mh, Zy = le(mh), gh = Me(Zy).mul(2).sub(1);
re("FrontFacingNode", mh);
const EN = Ze((c) => {
  const { eye_pos: e, surf_norm: t, mapN: r, uv: n } = c, s = e.dFdx(), o = e.dFdy(), i = n.dFdx(), a = n.dFdy(), l = t, u = o.cross(l), h = l.cross(s), d = u.mul(i.x).add(h.mul(a.x)), f = u.mul(i.y).add(h.mul(a.y)), p = d.dot(d).max(f.dot(f)), m = gh.mul(p.inverseSqrt());
  return xn(d.mul(r.x, m), f.mul(r.y, m), l.mul(r.z)).normalize();
});
class yh extends Mt {
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = If;
  }
  setup(e) {
    const { normalMapType: t, scaleNode: r } = this;
    let n = this.node.mul(2).sub(1);
    r !== null && (n = Fe(n.xy.mul(r), n.z));
    let s = null;
    return t === lx ? s = uh.mul(n).normalize() : t === If && (e.hasGeometryAttribute("tangent") === !0 ? s = e0.mul(n).normalize() : s = EN({
      eye_pos: ts,
      surf_norm: ds,
      mapN: n,
      uv: vt()
    })), s;
  }
}
const Qy = yh, Hl = J(yh), e0 = As(xi, Jy, ds);
re("NormalMapNode", yh);
const RN = Ze(({ bumpTexture: c, bumpScale: e }) => {
  const t = vt(), r = en(c, t).x;
  return st(
    en(c, t.add(t.dFdx())).x.sub(r),
    en(c, t.add(t.dFdy())).x.sub(r)
  ).mul(e);
}), FN = Ze((c) => {
  const { surf_pos: e, surf_norm: t, dHdxy: r } = c, n = e.dFdx(), s = e.dFdy(), o = t, i = s.cross(o), a = o.cross(n), l = n.dot(i).mul(gh), u = l.sign().mul(r.x.mul(i).add(r.y.mul(a)));
  return l.abs().mul(t).sub(u).normalize();
});
class vh extends Mt {
  constructor(e, t = null) {
    super("vec3"), this.texture = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = RN({ bumpTexture: this.texture, bumpScale: e });
    return FN({
      surf_pos: ts.negate(),
      surf_norm: ds,
      dHdxy: t
    });
  }
}
const LN = vh, t0 = J(vh);
re("BumpMapNode", vh);
class Cn extends Yn {
  constructor(e) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    let r = null;
    return (t === Cn.NORMAL || t === Cn.CLEARCOAT_NORMAL) && (r = "vec3"), r || super.getNodeType(e);
  }
  setup(e) {
    const t = e.material, r = this.scope;
    let n = null;
    return r === Cn.NORMAL ? t.normalMap ? n = Hl(this.getTexture("normalMap"), lo("normalScale", "vec2")) : t.bumpMap ? n = t0(t.bumpMap, lo("bumpScale", "float")) : n = ds : r === Cn.CLEARCOAT_NORMAL && (n = t.clearcoatNormalMap ? Hl(this.getTexture("clearcoatNormalMap"), lo("clearcoatNormalScale", "vec2")) : ds), n || super.setup(e);
  }
}
Cn.NORMAL = "normal";
Cn.CLEARCOAT_NORMAL = "clearcoatNormal";
const ON = Cn, n0 = le(Cn, Cn.NORMAL), IN = le(Cn, Cn.CLEARCOAT_NORMAL);
re("ExtendedMaterialNode", Cn);
class xh extends Mt {
  constructor(e = bn) {
    super("vec4"), this.positionNode = e;
  }
  setup() {
    return Ns.mul(Nr).mul(this.positionNode);
  }
}
const s0 = xh, r0 = J(xh);
re("ModelViewProjectionNode", xh);
class bh extends Cu {
  constructor(e, t = null, r = 0, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = r, this.bufferOffset = n, this.usage = ux, this.instanced = !1, this.attribute = null, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null)
      return;
    const t = this.getNodeType(e), r = this.value, n = e.getTypeLength(t), s = this.bufferStride || n, o = this.bufferOffset, i = r.isInterleavedBuffer === !0 ? r : new hm(r, s), a = new Ws(i, n, o);
    i.setUsage(this.usage), this.attribute = a, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const t = this.getNodeType(e), r = e.getBufferAttributeFromNode(this, t), n = e.getPropertyName(r);
    let s = null;
    return e.shaderStage === "vertex" ? s = n : s = ct(this).build(e, t), s;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const PN = bh, bi = (c, e, t, r) => Ae(new bh(c, e, t, r)), o0 = (c, e, t, r) => bi(c, e, t, r).setUsage(mu), i0 = (c, e, t, r) => bi(c, e, t, r).setInstanced(!0), a0 = (c, e, t, r) => o0(c, e, t, r).setInstanced(!0);
W("toAttribute", (c) => bi(c.value));
re("BufferAttributeNode", bh);
class Nh extends Le {
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null;
  }
  setup(e) {
    let t = this.instanceMatrixNode;
    if (t === null) {
      const a = this.instanceMesh.instanceMatrix, l = new Na(a.array, 16, 1), u = a.usage === mu ? a0 : i0, h = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        u(l, "vec4", 16, 0),
        u(l, "vec4", 16, 4),
        u(l, "vec4", 16, 8),
        u(l, "vec4", 16, 12)
      ];
      t = Lu(...h), this.instanceMatrixNode = t;
    }
    const r = t.mul(bn).xyz, n = As(t[0].xyz, t[1].xyz, t[2].xyz), s = wr.div(Fe(n[0].dot(n[0]), n[1].dot(n[1]), n[2].dot(n[2]))), o = n.mul(s).xyz;
    e.stack.assign(bn, r), e.stack.assign(wr, o);
  }
}
const UN = Nh, c0 = J(Nh);
re("InstanceNode", Nh);
class wh extends nt {
  constructor(e, t, r = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = r;
  }
  getInputType() {
    return "buffer";
  }
}
const Th = wh, Sh = (c, e, t) => Ae(new wh(c, e, t));
re("BufferNode", wh);
class _h extends Le {
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = ut.OBJECT, this.skinIndexNode = Ot("skinIndex", "uvec4"), this.skinWeightNode = Ot("skinWeight", "vec4"), this.bindMatrixNode = Ft(e.bindMatrix, "mat4"), this.bindMatrixInverseNode = Ft(e.bindMatrixInverse, "mat4"), this.boneMatricesNode = Sh(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length);
  }
  setup(e) {
    const { skinIndexNode: t, skinWeightNode: r, bindMatrixNode: n, bindMatrixInverseNode: s, boneMatricesNode: o } = this, i = o.element(t.x), a = o.element(t.y), l = o.element(t.z), u = o.element(t.w), h = n.mul(bn), d = xn(
      i.mul(r.x).mul(h),
      a.mul(r.y).mul(h),
      l.mul(r.z).mul(h),
      u.mul(r.w).mul(h)
    ), f = s.mul(d).xyz;
    let p = xn(
      r.x.mul(i),
      r.y.mul(a),
      r.z.mul(l),
      r.w.mul(u)
    );
    p = s.mul(p).mul(n);
    const m = p.transformDirection(wr).xyz;
    e.stack.assign(bn, f), e.stack.assign(wr, m), e.hasGeometryAttribute("tangent") && e.stack.assign(uc, m);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const l0 = _h, u0 = J(_h);
re("SkinningNode", _h);
class Mh extends Le {
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Ft(1), this.updateType = ut.OBJECT;
  }
  setupAttribute(e, t, r = bn) {
    const n = this.mesh, s = n.geometry.morphAttributes[t];
    e.stack.assign(r, r.mul(this.morphBaseInfluence));
    for (let o = 0; o < s.length; o++) {
      const i = s[o], a = bi(i.array, "vec3"), l = Cs(o, "float", n.morphTargetInfluences);
      e.stack.assign(r, r.add(a.mul(l)));
    }
  }
  setup(e) {
    this.setupAttribute(e, "position");
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, r) => t + r, 0);
  }
}
const DN = Mh, h0 = J(Mh);
re("MorphNode", Mh);
class Ah extends Le {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return It.negate().reflect(_t).transformDirection(Rs);
  }
}
const d0 = Ah, f0 = le(Ah);
re("ReflectVectorNode", Ah);
class Ch extends vi {
  constructor(e, t = null, r = null) {
    super(e, t, r), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return f0;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.value;
    if (!s || s.isCubeTexture !== !0)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const o = nt.prototype.generate.call(this, e, "cubeTexture");
    if (t === "sampler")
      return o + "_sampler";
    if (e.isReference(t))
      return o;
    {
      const i = this.getNodeType(e), a = e.getDataFromNode(this);
      let l = a.propertyName;
      if (l === void 0) {
        const d = Fe(r.x.negate(), r.yz).build(e, "vec3"), f = e.getVarFromNode(this, "vec4");
        l = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(this, o, d, m);
        } else
          p = e.getTexture(this, o, d);
        e.addLineFlowCode(`${l} = ${p}`), e.context.tempWrite !== !1 && (a.snippet = p, a.propertyName = l);
      }
      let u = l;
      return e.needsColorSpaceToLinear(this.value) && (u = ac(No(u, i), this.value.colorSpace).setup(e).build(e, i)), e.format(u, "vec4", t);
    }
  }
}
const p0 = Ch, hc = J(Ch);
W("cubeTexture", hc);
re("CubeTextureNode", Ch);
class m0 extends Le {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Ni = m0;
re("LightingNode", m0);
let Jc = null;
class g0 extends Ni {
  constructor(e = null) {
    super(), this.updateType = ut.FRAME, this.light = e, this.rtt = null, this.shadowNode = null, this.color = new Ve(), this.colorNode = Ft(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    let t = this.shadowNode;
    if (t === null) {
      Jc === null && (Jc = e.createNodeMaterial("MeshBasicNodeMaterial"));
      const r = this.light.shadow, n = e.getRenderTarget(r.mapSize.width, r.mapSize.height), s = new dm();
      s.minFilter = Hs, s.magFilter = Hs, s.image.width = r.mapSize.width, s.image.height = r.mapSize.height, s.compareFunction = hx, n.depthTexture = s, r.camera.updateProjectionMatrix();
      const o = Cs("bias", "float", r), i = Cs("normalBias", "float", r);
      let a = Ft(r.matrix).mul(fh.add(lc.mul(i)));
      a = a.xyz.div(a.w);
      const l = a.x.greaterThanEqual(0).and(a.x.lessThanEqual(1)).and(a.y.greaterThanEqual(0)).and(a.y.lessThanEqual(1)).and(a.z.lessThanEqual(1));
      a = Fe(
        a.x,
        a.y.oneMinus(),
        // WebGPU: Flip Y
        a.z.add(o).mul(2).sub(1)
        // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
      ), t = ((h, d, f) => en(h, d).compare(f))(s, a.xy, a.z), this.rtt = n, this.colorNode = this.colorNode.mul(l.mix(1, t)), this.shadowNode = t, this.updateBeforeType = ut.RENDER;
    }
  }
  setup(e) {
    this.light.castShadow && this.setupShadow(e);
  }
  updateShadow(e) {
    const { rtt: t, light: r } = this, { renderer: n, scene: s } = e;
    s.overrideMaterial = Jc, t.setSize(r.shadow.mapSize.width, r.shadow.mapSize.height), r.shadow.updateMatrices(r), n.setRenderTarget(t), n.render(s, r.shadow.camera), n.setRenderTarget(null), s.overrideMaterial = null;
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const or = g0;
re("AnalyticLightNode", g0);
const La = /* @__PURE__ */ new WeakMap(), zN = (c) => c.sort((e, t) => e.id - t.id);
class Eh extends Le {
  constructor(e = []) {
    super("vec3"), this.lightNodes = e, this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  setup(e) {
    const t = this.lightNodes;
    for (const r of t)
      r.build(e);
  }
  getHash(e) {
    if (this._hash === null) {
      let t = "";
      const r = this.lightNodes;
      for (const n of r)
        t += n.getHash(e) + " ";
      this._hash = t;
    }
    return this._hash;
  }
  getLightNodeByHash(e) {
    const t = this.lightNodes;
    for (const r of t)
      if (r.light.uuid === e)
        return r;
    return null;
  }
  fromLights(e = []) {
    const t = [];
    e = zN(e);
    for (const r of e) {
      let n = this.getLightNodeByHash(r.uuid);
      if (n === null) {
        const s = r.constructor, o = La.has(s) ? La.get(s) : or;
        n = Ae(new o(r));
      }
      t.push(n);
    }
    return this.lightNodes = t, this._hash = null, this;
  }
}
const y0 = Eh, BN = (c) => Ae(new Eh().fromLights(c)), v0 = J(Eh);
function _r(c, e) {
  if (La.has(c))
    throw new Error(`Redefinition of light node ${e.type}`);
  if (typeof c != "function")
    throw new Error(`Light ${c.name} is not a class`);
  if (typeof e != "function" || !e.type)
    throw new Error(`Light node ${e.type} is not a class`);
  La.set(c, e);
}
class x0 extends Ni {
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    const r = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(r);
  }
}
const Rh = x0;
re("AONode", x0);
class Fh extends ku {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.lightingModel = t, this.backdropNode = r, this.backdropAlphaNode = n;
  }
  getNodeType() {
    return "vec3";
  }
  setup(e) {
    const { lightingModel: t, backdropNode: r, backdropAlphaNode: n } = this, s = this.context = {}, o = e.getNodeProperties(this), i = Fe().temp(), a = Fe().temp(), l = Fe().temp(), u = Fe().temp();
    let h = xn(i, l);
    r !== null && (h = Fe(n !== null ? on(h, r, n) : r));
    const d = xn(a, u), f = xn(h, d).temp(), p = {
      directDiffuse: i,
      directSpecular: a,
      indirectDiffuse: l,
      indirectSpecular: u,
      total: f
    }, m = {
      radiance: Fe().temp(),
      irradiance: Fe().temp(),
      iblIrradiance: Fe().temp(),
      ambientOcclusion: Me(1).temp()
    };
    return s.reflectedLight = p, s.lightingModel = t || s.lightingModel, Object.assign(o, p, m), Object.assign(s, m), t && (t.init(s, e.stack, e), t.indirectDiffuse(s, e.stack, e), t.indirectSpecular(s, e.stack, e), t.ambientOcclusion(s, e.stack, e)), super.setup(e);
  }
  generate(e) {
    const { context: t } = this, r = this.getNodeType(e);
    return super.generate(e, r), t.reflectedLight.total.build(e, r);
  }
}
const kN = Fh, Lh = J(Fh);
W("lightingContext", Lh);
re("LightingContextNode", Fh);
class Oh extends Mt {
  constructor(e = ph) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, t = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), r = e.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return st(t, r);
  }
}
const b0 = Oh, dc = J(Oh);
re("EquirectUVNode", Oh);
class Ih extends nt {
  constructor(e) {
    super(0), this.textureNode = e, this.updateType = ut.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, r = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (r && r.width !== void 0) {
      const { width: n, height: s } = r;
      this.value = Math.log2(Math.max(n, s));
    }
  }
}
const N0 = Ih, Ph = J(Ih);
re("MaxMipLevelNode", Ih);
class Uh extends Le {
  constructor(e, t = null) {
    super("float"), this.textureNode = e, this.roughnessNode = t;
  }
  setup() {
    const { textureNode: e, roughnessNode: t } = this, r = Ph(e), n = t.mul(t).mul(Math.PI).div(t.add(1));
    return r.add(n.log2()).clamp(0, r);
  }
}
const w0 = Uh, Dh = J(Uh);
re("SpecularMIPLevelNode", Uh);
const Wf = /* @__PURE__ */ new WeakMap();
class T0 extends Ni {
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    let t = this.envNode;
    const r = e.getNodeProperties(this);
    if (t.isTextureNode && t.value.isCubeTexture !== !0) {
      let l = Wf.get(t.value);
      if (l === void 0) {
        const u = t.value, h = e.renderer, d = e.getCubeRenderTarget(512).fromEquirectangularTexture(h, u);
        l = hc(d.texture), Wf.set(t.value, l);
      }
      t = l;
    }
    const n = Cs("envMapIntensity", "float", e.material), s = Zn(t, Hf(ao, _t)).mul(n), o = Zn(t, GN(Xy)).mul(Math.PI).mul(n), i = _a(s);
    e.context.radiance.addAssign(i), e.context.iblIrradiance.addAssign(o);
    const a = e.context.lightingModel.clearcoatRadiance;
    if (a) {
      const l = Zn(t, Hf(Aa, pr)).mul(n), u = _a(l);
      a.addAssign(u);
    }
    r.radiance = i, r.irradiance = o;
  }
}
const Hf = (c, e) => {
  let t = null, r = null;
  return {
    getUVNode: (n) => {
      let s = null;
      return t === null && (t = It.negate().reflect(e), t = c.mul(c).mix(t, e).normalize(), t = t.transformDirection(Rs)), n.isCubeTextureNode ? s = t : n.isTextureNode && (r === null && (r = dc(t)), s = r), s;
    },
    getSamplerLevelNode: () => c,
    getMIPLevelAlgorithmNode: (n, s) => Dh(n, s)
  };
}, GN = (c) => {
  let e = null;
  return {
    getUVNode: (t) => {
      let r = null;
      return t.isCubeTextureNode ? r = c : t.isTextureNode && (e === null && (e = dc(c), e = st(e.x, e.y.oneMinus())), r = e), r;
    },
    getSamplerLevelNode: () => Me(1),
    getMIPLevelAlgorithmNode: (t, r) => Dh(t, r)
  };
}, zh = T0;
re("EnvironmentNode", T0);
const Xl = /* @__PURE__ */ new Map();
class tn extends hs {
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.unlit = this.constructor === tn.prototype.constructor, this.fog = !0, this.lights = !0, this.normals = !0, this.colorSpace = !0, this.lightsNode = null, this.envNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.outputNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + Ja(this);
  }
  build(e) {
    this.setup(e);
  }
  setup(e) {
    e.addStack(), e.stack.outputNode = this.setupPosition(e), e.addFlow("vertex", e.removeStack()), e.addStack();
    let t;
    if (this.unlit === !1) {
      this.normals === !0 && this.setupNormal(e), this.setupDiffuseColor(e), this.setupVariants(e);
      const r = this.setupLighting(e);
      t = this.setupOutput(e, ot(r, $t.a)), e.stack.assign(Eg, t), this.outputNode !== null && (t = this.outputNode);
    } else
      t = this.setupOutput(e, this.outputNode || ot(0, 0, 0, 1));
    e.stack.outputNode = t, e.addFlow("fragment", e.removeStack());
  }
  setupPosition(e) {
    const t = e.object, r = t.geometry;
    return e.addStack(), (r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color) && e.stack.add(h0(t)), t.isSkinnedMesh === !0 && e.stack.add(u0(t)), t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && e.isAvailable("instance") === !0 && e.stack.add(c0(t)), this.positionNode !== null && e.stack.assign(bn, this.positionNode), e.context.vertex = e.removeStack(), this.vertexNode || r0();
  }
  setupDiffuseColor({ stack: e, geometry: t }) {
    let r = this.colorNode ? ot(this.colorNode) : ih;
    this.vertexColors === !0 && t.hasAttribute("color") && (r = ot(r.xyz.mul(Ot("color")), r.a)), e.assign($t, r);
    const n = this.opacityNode ? Me(this.opacityNode) : ah;
    if (e.assign($t.a, $t.a.mul(n)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const s = this.alphaTestNode !== null ? Me(this.alphaTestNode) : Dy;
      e.add($t.a.lessThanEqual(s).discard());
    }
  }
  setupVariants() {
  }
  setupNormal({ stack: e }) {
    if (this.flatShading === !0) {
      const t = Zu(ts), r = Qu(ts), n = t.cross(r).normalize();
      e.assign(_t, n);
    } else {
      const t = this.normalNode ? Fe(this.normalNode) : n0;
      e.assign(_t, t);
    }
  }
  getEnvNode(e) {
    let t = null;
    return this.envNode ? t = this.envNode : this.envMap ? t = this.envMap.isCubeTexture ? hc(this.envMap) : en(this.envMap) : e.environmentNode && (t = e.environmentNode), t;
  }
  setupLights(e) {
    const t = this.getEnvNode(e), r = [];
    t && r.push(new zh(t)), e.material.aoMap && r.push(new Rh(en(e.material.aoMap)));
    let n = this.lightsNode || e.lightsNode;
    return r.length > 0 && (n = v0([...n.lightNodes, ...r])), n;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: t } = e, { backdropNode: r, backdropAlphaNode: n, emissiveNode: s } = this, i = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let a = $t.rgb;
    if (i && i.hasLight !== !1) {
      const l = this.setupLightingModel(e);
      a = Lh(i, l, r, n);
    } else
      r !== null && (a = Fe(n !== null ? on(a, r, n) : r));
    return (s && s.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (a = a.add(Fe(s || By))), a;
  }
  setupOutput(e, t) {
    const r = e.renderer, n = e.toneMappingNode;
    if (n && (t = ot(n.context({ color: t.rgb }), t.a)), this.fog === !0) {
      const s = e.fogNode;
      s && (t = ot(s.mixAssign(t.rgb), t.a));
    }
    if (this.colorSpace === !0) {
      const s = r.getRenderTarget();
      let o;
      s !== null ? Array.isArray(s.texture) ? o = s.texture[0].colorSpace : o = s.texture.colorSpace : o = r.outputColorSpace, o !== Rn && o !== fm && (t = t.linearToColorSpace(o));
    }
    return t;
  }
  setDefaultValues(e) {
    for (const r in e) {
      const n = e[r];
      this[r] === void 0 && (this[r] = n, n && n.clone && (this[r] = n.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const r in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, r) === void 0 && t[r].get !== void 0 && Object.defineProperty(this.constructor.prototype, r, t[r]);
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const r = kn.prototype.toJSON.call(this, e), n = ei(this);
    r.inputNodes = {};
    for (const { property: o, childNode: i } of n)
      r.inputNodes[o] = i.toJSON(e).uuid;
    function s(o) {
      const i = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, i.push(l);
      }
      return i;
    }
    if (t) {
      const o = s(e.textures), i = s(e.images), a = s(e.nodes);
      o.length > 0 && (r.textures = o), i.length > 0 && (r.images = i), a.length > 0 && (r.nodes = a);
    }
    return r;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.outputNode = e.outputNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
  static fromMaterial(e) {
    if (e.isNodeMaterial === !0)
      return e;
    const t = e.type.replace("Material", "NodeMaterial"), r = wo(t);
    if (r === void 0)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const n in e)
      r[n] = e[n];
    return r;
  }
}
function wn(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node material ${c} is not a class`);
  if (Xl.has(c))
    throw new Error(`Redefinition of node material ${c}`);
  Xl.set(c, e), e.type = c;
}
function wo(c) {
  const e = Xl.get(c);
  if (e !== void 0)
    return new e();
}
wn("NodeMaterial", tn);
const VN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addNodeMaterial: wn,
  createNodeMaterialFromType: wo,
  default: tn
}, Symbol.toStringTag, { value: "Module" }));
class Mr {
  constructor(e, t = null) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class jN extends Mr {
  constructor(e, t = 0) {
    super(e, t), this.isFloatUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class WN extends Mr {
  constructor(e, t = new wt()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class HN extends Mr {
  constructor(e, t = new ye()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class XN extends Mr {
  constructor(e, t = new pt()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class $N extends Mr {
  constructor(e, t = new Ve()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class qN extends Mr {
  constructor(e, t = new ws()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class JN extends Mr {
  constructor(e, t = new Ge()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class YN extends jN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class KN extends WN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class ZN extends HN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class QN extends XN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class ew extends $N {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class tw extends qN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class nw extends JN {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Bh extends Le {
  constructor(e, t, r = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = r;
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const r = this.elseNode.getNodeType(e);
      if (e.getTypeLength(r) > e.getTypeLength(t))
        return r;
    }
    return t;
  }
  generate(e) {
    const t = this.getNodeType(e), r = { tempWrite: !1 }, { ifNode: n, elseNode: s } = this, o = n.getNodeType(e) !== "void" || s && s.getNodeType(e) !== "void", i = o ? Ts(t).build(e) : "", a = Zn(
      this.condNode
      /*, context*/
    ).build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${a} ) {

`).addFlowTab();
    let l = Zn(this.ifNode, r).build(e, t);
    if (l = o ? i + " = " + l + ";" : l, e.removeFlowTab().addFlowCode(e.tab + "	" + l + `

` + e.tab + "}"), s !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let u = Zn(s, r).build(e, t);
      u = i ? i + " = " + u + ";" : u, e.removeFlowTab().addFlowCode(e.tab + "	" + u + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return i;
  }
}
const kh = Bh, gr = J(Bh);
W("cond", gr);
re("CondNode", Bh);
class Gh extends Le {
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode("i".charCodeAt() + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0)
      return t;
    const r = {};
    for (let n = 0, s = this.params.length - 1; n < s; n++) {
      const o = this.getVarName(n);
      r[o] = No(o, "int");
    }
    return t.returnsNode = this.params[this.params.length - 1](r, e.addStack(), e), t.stackNode = e.removeStack(), t;
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e), r = { tempWrite: !1 }, n = this.params, s = t.stackNode;
    for (let a = 0, l = n.length - 1; a < l; a++) {
      const u = n[a], h = this.getVarName(a);
      let d = null, f = null, p = null;
      u.isNode ? (d = "0", f = u.build(e, "int"), p = "forward") : (d = u.start, f = u.end, p = u.direction, typeof d == "number" ? d = d.toString() : d && d.isNode && (d = d.build(e, "int")), typeof f == "number" ? f = f.toString() : f && f.isNode && (f = f.build(e, "int")), d !== void 0 && f === void 0 ? (d = d + " - 1", f = "0", p = "backwards") : f !== void 0 && d === void 0 && (d = "0", p = "forward"), p === void 0 && (Number(d) > Number(f) ? p = "backwards" : p = "forward"));
      const m = { start: d, end: f, direction: p }, g = m.start, b = m.end;
      let v = "", y = "", x = "";
      v += e.getVar("int", h) + " = " + g, m.direction === "backwards" ? (y += h + " >= " + b, x += h + " --") : (y += h + " < " + b, x += h + " ++");
      const N = `for ( ${v}; ${y}; ${x} )`;
      e.addFlowCode((a === 0 ? `
` : "") + e.tab + N + ` {

`).addFlowTab();
    }
    const o = Zn(s, r).build(e, "void"), i = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + o);
    for (let a = 0, l = this.params.length - 1; a < l; a++)
      e.addFlowCode((a === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), i;
  }
}
const sw = Gh, Vh = (...c) => Ae(new Gh(mr(c, "int")));
W("loop", (c, ...e) => tc(c, Vh(...e)));
re("LoopNode", Gh);
class jh extends Le {
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(tc(No(), e)), this;
  }
  if(e, t) {
    const r = new Ms(t);
    return this._currentCond = gr(e, r), this.add(this._currentCond);
  }
  elseif(e, t) {
    const r = new Ms(t), n = gr(e, r);
    return this._currentCond.elseNode = n, this._currentCond = n, this;
  }
  else(e) {
    return this._currentCond.elseNode = new Ms(e), this;
  }
  assign(e, t) {
    return this.add(Ju(e, t));
  }
  loop(...e) {
    return this.add(Vh(...e));
  }
  build(e, ...t) {
    for (const r of this.nodes)
      r.build(e, "void");
    return this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
  }
}
const rw = jh, $l = J(jh);
re("StackNode", jh);
class ow extends dx {
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, t) {
    const r = t.minFilter, n = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const s = new Wa(5, 5, 5), o = dc(ph), i = wo("MeshBasicNodeMaterial");
    i.colorNode = en(t, o, 0), i.side = gu, i.blending = fx;
    const a = new qt(s, i), l = new Ha();
    return l.add(a), t.minFilter === xo && (t.minFilter = fo), new px(1, 10, this).update(e, l), t.minFilter = r, t.currentGenerateMipmaps = n, a.geometry.dispose(), a.material.dispose(), this;
  }
}
const iw = ow, aw = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), cw = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), lw = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]), ki = (c) => (c = Number(c), c + (c % 1 ? "" : ".0"));
class uw {
  constructor(e, t, r, n = null, s = null) {
    this.object = e, this.material = s || e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = r, this.scene = n, this.nodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.hashNodes = {}, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.toneMappingNode = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: [] }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.codes = { vertex: [], fragment: [], compute: [] }, this.bindings = { vertex: [], fragment: [], compute: [] }, this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }, this.bindingsArray = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.vars = { vertex: [], fragment: [], compute: [] }, this.flow = { code: "" }, this.chaining = [], this.stack = $l(), this.tab = "	", this.context = {
      keywords: new Hu(),
      material: this.material,
      getMIPLevelAlgorithmNode: (o, i) => i.mul(Ph(o))
    }, this.cache = new nc(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  getRenderTarget(e, t, r) {
    return new mx(e, t, r);
  }
  getCubeRenderTarget(e, t) {
    return new iw(e, t);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  getBindings() {
    let e = this.bindingsArray;
    if (e === null) {
      const t = this.bindings;
      this.bindingsArray = e = this.material !== null ? [...t.vertex, ...t.fragment] : t.compute;
    }
    return e;
  }
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  buildUpdateNodes() {
    for (const e of this.nodes) {
      const t = e.getUpdateType(), r = e.getUpdateBeforeType();
      t !== ut.NONE && this.updateNodes.push(e.getSelf()), r !== ut.NONE && this.updateBeforeNodes.push(e);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new Ve() : e === "vec2" ? t = new wt() : e === "vec3" ? t = new ye() : e === "vec4" && (t = new pt())), e === "float")
      return ki(t);
    if (e === "int")
      return `${Math.round(t)}`;
    if (e === "uint")
      return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool")
      return t ? "true" : "false";
    if (e === "color")
      return `${this.getType("vec3")}( ${ki(t.r)}, ${ki(t.g)}, ${ki(t.b)} )`;
    const r = this.getTypeLength(e), n = this.getComponentType(e), s = (o) => this.getConst(n, o);
    if (r === 2)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (r === 3)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (r === 4)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (r > 4 && t && (t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (r > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  generateMethod(e) {
    return e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, t) {
    const r = this.attributes;
    for (const s of r)
      if (s.name === e)
        return s;
    const n = new Ma(e, t);
    return r.push(n), n;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(e) {
    return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."), this.getTextureColorSpaceFromMap(e) === vn ? gx : yx;
  }
  getTextureColorSpaceFromMap(e) {
    let t;
    return e && e.isTexture ? t = e.colorSpace : e && e.isWebGLRenderTarget ? t = e.texture.colorSpace : t = fm, t;
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint")
      return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" ? "vec4" : e;
  }
  getTypeFromLength(e, t = "float") {
    if (e === 1)
      return t;
    const r = aw.get(e);
    return (t === "float" ? "" : t[0]) + r;
  }
  getTypeFromArray(e) {
    return cw.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const r = t.array, n = lw.has(r.constructor) ? e.itemSize : t.stride || e.itemSize, s = e.normalized;
    let o;
    return !(e instanceof vx) && s !== !0 && (o = this.getTypeFromArray(r)), this.getTypeFromLength(n, o);
  }
  getTypeLength(e) {
    const t = this.getVectorType(e), r = /vec([2-4])/.exec(t);
    return r !== null ? Number(r[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = $l(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, e;
  }
  getDataFromNode(e, t = this.shaderStage) {
    const r = e.isGlobal(this) ? this.globalCache : this.cache;
    let n = r.getNodeData(e);
    return n === void 0 && (n = {}, r.setNodeData(e, n)), n[t] === void 0 && (n[t] = {}), n[t];
  }
  getNodeProperties(e, t = "any") {
    const r = this.getDataFromNode(e, t);
    return r.properties || (r.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, t) {
    const r = this.getDataFromNode(e);
    let n = r.bufferAttribute;
    if (n === void 0) {
      const s = this.uniforms.index++;
      n = new Ma("nodeAttribute" + s, t, e), this.bufferAttributes.push(n), r.bufferAttribute = n;
    }
    return n;
  }
  getStructTypeFromNode(e, t = this.shaderStage, r = null) {
    const n = this.getDataFromNode(e, t);
    if (n.structType === void 0) {
      const o = this.structs.index++;
      e.name = `StructType${o}`, this.structs[t].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, t, r = this.shaderStage, n = null) {
    const s = this.getDataFromNode(e, r);
    let o = s.uniform;
    if (o === void 0) {
      const i = this.uniforms.index++;
      o = new Vu(n || "nodeUniform" + i, t, e), this.uniforms[r].push(o), s.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e, r);
    let s = n.variable;
    if (s === void 0) {
      const o = this.vars[r], i = o.length;
      s = new rc("nodeVar" + i, t), o.push(s), n.variable = s;
    }
    return s;
  }
  getVaryingFromNode(e, t) {
    const r = this.getDataFromNode(e, "any");
    let n = r.varying;
    if (n === void 0) {
      const s = this.varyings, o = s.length;
      n = new ju("nodeVarying" + o, t), s.push(n), r.varying = n;
    }
    return n;
  }
  getCodeFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e);
    let s = n.code;
    if (s === void 0) {
      const o = this.codes[r], i = o.length;
      s = new Wu("nodeCode" + i, t), o.push(s), n.code = s;
    }
    return s;
  }
  addLineFlowCode(e) {
    return e === "" ? this : (e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const t = e.getNodeType(this), r = this.flowChildNode(e, t);
    return this.flowsData.set(e, r), r;
  }
  flowChildNode(e, t = null) {
    const r = this.flow, n = {
      code: ""
    };
    return this.flow = n, n.result = e.build(this, t), this.flow = r, n;
  }
  flowNodeFromShaderStage(e, t, r = null, n = null) {
    const s = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(t, r);
    return n !== null && (o.code += `${this.tab + n} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(s), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, t) {
    return `${this.getType(e)} ${t}`;
  }
  getVars(e) {
    let t = "";
    const r = this.vars[e];
    for (const n of r)
      t += `${this.getVar(n.type, n.name)}; `;
    return t;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const t = this.codes[e];
    let r = "";
    for (const n of t)
      r += n.code + `
`;
    return r;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const e of Um) {
      this.setBuildStage(e), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const t of Dm) {
        this.setShaderStage(t);
        const r = this.flowNodes[t];
        for (const n of r)
          e === "generate" ? this.flowNode(n) : n.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, t) {
    if (t === "float")
      return new YN(e);
    if (t === "vec2")
      return new KN(e);
    if (t === "vec3")
      return new ZN(e);
    if (t === "vec4")
      return new QN(e);
    if (t === "color")
      return new ew(e);
    if (t === "mat3")
      return new tw(e);
    if (t === "mat4")
      return new nw(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  createNodeMaterial(e) {
    return wo(e);
  }
  format(e, t, r) {
    if (t = this.getVectorType(t), r = this.getVectorType(r), t === r || r === null || this.isReference(r))
      return e;
    const n = this.getTypeLength(t), s = this.getTypeLength(r);
    return n > 4 || s > 4 || s === 0 ? e : n === s ? `${this.getType(r)}( ${e} )` : n > s ? this.format(`${e}.${"xyz".slice(0, s)}`, this.getTypeFromLength(s, this.getComponentType(t)), r) : s === 4 ? `${this.getType(r)}( ${this.format(e, t, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(r)}( ${this.format(e, t, "vec2")}, 0.0 )` : `${this.getType(r)}( ${e} )`;
  }
  getSignature() {
    return `// Three.js r${xx} - NodeMaterial System
`;
  }
}
const S0 = uw;
class hw {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, t) {
    let r = e.get(t);
    return r === void 0 && (r = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(t, r)), r;
  }
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateBeforeMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.updateBefore(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.updateBefore(this)) : t === ut.OBJECT && e.updateBefore(this);
  }
  updateNode(e) {
    const t = e.getUpdateType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.update(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.update(this)) : t === ut.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
const Wh = hw;
class _0 {
  constructor(e, t, r = null, n = "", s = !1) {
    this.type = e, this.name = t, this.count = r, this.qualifier = n, this.isConst = s;
  }
}
_0.isNodeFunctionInput = !0;
const Hh = _0;
class M0 extends Le {
  constructor(e) {
    super(), this.types = e, this.isStructTypeNode = !0;
  }
  getMemberTypes() {
    return this.types;
  }
}
const dw = M0;
re("StructTypeNode", M0);
class Xh extends Le {
  constructor(...e) {
    super(), this.isOutputStructNode = !0, this.members = e;
  }
  setup(e) {
    super.setup(e);
    const t = this.members, r = [];
    for (let n = 0; n < t.length; n++)
      r.push(t[n].getNodeType(e));
    this.nodeType = e.getStructTypeFromNode(new dw(r)).name;
  }
  generate(e, t) {
    const r = e.getVarFromNode(this, this.nodeType);
    r.isOutputStructVar = !0;
    const n = e.getPropertyName(r), s = this.members, o = n !== "" ? n + "." : "";
    for (let i = 0; i < s.length; i++) {
      const a = s[i].build(e, t);
      e.addLineFlowCode(`${o}m${i} = ${a}`);
    }
    return n;
  }
}
const fw = Xh, pw = J(Xh);
re("OutputStructNode", Xh);
class $h extends Le {
  constructor(e) {
    super(), this.seedNode = e;
  }
  setup() {
    const e = this.seedNode.uint().mul(747796405).add(2891336453), t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
    return t.shiftRight(22).bitXor(t).float().mul(1 / 2 ** 32);
  }
}
const mw = $h, A0 = J($h);
W("hash", A0);
re("HashNode", $h);
let Yc;
class qh extends kh {
  constructor(e) {
    Yc = Yc || No("discard"), super(e, Yc);
  }
}
const gw = qh, C0 = J(qh);
W("discard", C0);
re("DiscardNode", qh);
class Jh extends Mt {
  constructor() {
    super("vec2");
  }
  setup() {
    const e = Fe(It.z, 0, It.x.negate()).normalize(), t = It.cross(e);
    return st(e.dot(_t), t.dot(_t)).mul(0.495).add(0.5);
  }
}
const E0 = Jh, yw = le(Jh);
re("MatcapUVNode", Jh);
class Pt extends nt {
  constructor(e = Pt.LOCAL, t = 1, r = 0) {
    super(r), this.scope = e, this.scale = t, this.updateType = ut.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(e) {
    const t = this.scope, r = this.scale;
    t === Pt.LOCAL ? this.value += e.deltaTime * r : t === Pt.DELTA ? this.value = e.deltaTime * r : t === Pt.FRAME ? this.value = e.frameId : this.value = e.time * r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope, e.scale = this.scale;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope, this.scale = e.scale;
  }
}
Pt.LOCAL = "local";
Pt.GLOBAL = "global";
Pt.DELTA = "delta";
Pt.FRAME = "frame";
const R0 = Pt, Yh = (c, e = 0) => Ae(new Pt(Pt.LOCAL, c, e)), vw = (c, e = 0) => Ae(new Pt(Pt.GLOBAL, c, e)), xw = (c, e = 0) => Ae(new Pt(Pt.DELTA, c, e)), bw = le(Pt, Pt.FRAME).uint();
re("TimerNode", Pt);
class Rt extends Le {
  constructor(e = Rt.SINE, t = Yh()) {
    super(), this.method = e, this.timeNode = t;
  }
  getNodeType(e) {
    return this.timeNode.getNodeType(e);
  }
  setup() {
    const e = this.method, t = Ae(this.timeNode);
    let r = null;
    return e === Rt.SINE ? r = t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5) : e === Rt.SQUARE ? r = t.fract().round() : e === Rt.TRIANGLE ? r = t.add(0.5).fract().mul(2).sub(1).abs() : e === Rt.SAWTOOTH && (r = t.fract()), r;
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Rt.SINE = "sine";
Rt.SQUARE = "square";
Rt.TRIANGLE = "triangle";
Rt.SAWTOOTH = "sawtooth";
const eo = Rt, Nw = J(Rt, Rt.SINE), ww = J(Rt, Rt.SQUARE), Tw = J(Rt, Rt.TRIANGLE), Sw = J(Rt, Rt.SAWTOOTH);
re("OscNode", Rt);
class ns extends Mt {
  constructor(e, t) {
    super(), this.scope = e, this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup() {
    const { scope: e, node: t } = this;
    let r = null;
    return e === ns.DIRECTION_TO_COLOR ? r = t.mul(0.5).add(0.5) : e === ns.COLOR_TO_DIRECTION && (r = t.mul(2).sub(1)), r;
  }
}
ns.DIRECTION_TO_COLOR = "directionToColor";
ns.COLOR_TO_DIRECTION = "colorToDirection";
const _w = ns, Kh = J(ns, ns.DIRECTION_TO_COLOR), F0 = J(ns, ns.COLOR_TO_DIRECTION);
W("directionToColor", Kh);
W("colorToDirection", F0);
re("PackingNode", ns);
class fc extends Le {
  constructor(e, t, r, n, s) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = r, this.outLowNode = n, this.outHighNode = s, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: r, outLowNode: n, outHighNode: s, doClamp: o } = this;
    let i = e.sub(t).div(r.sub(t));
    return o === !0 && (i = i.clamp()), i.mul(s.sub(n)).add(n);
  }
}
const L0 = fc, O0 = J(fc, null, null, { doClamp: !1 }), I0 = J(fc);
W("remap", O0);
W("remapClamp", I0);
re("RemapNode", fc);
class Zh extends Mt {
  constructor(e, t, r = st(0.5)) {
    super("vec2"), this.uvNode = e, this.rotationNode = t, this.centerNode = r;
  }
  setup() {
    const { uvNode: e, rotationNode: t, centerNode: r } = this, n = t.cos(), s = t.sin(), o = e.sub(r);
    return st(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      st(n, s).dot(o),
      st(s.negate(), n).dot(o)
    ).add(r);
  }
}
const P0 = Zh, U0 = J(Zh);
W("rotateUV", U0);
re("RotateUVNode", Zh);
class Qh extends Le {
  constructor(e, t = vt(), r = Me(0)) {
    super("vec2"), this.countNode = e, this.uvNode = t, this.frameNode = r;
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: r } = this, { width: n, height: s } = r, o = e.mod(n.mul(s)).floor(), i = o.mod(n), a = s.sub(o.add(1).div(n).ceil()), l = r.reciprocal(), u = st(i, a);
    return t.add(u).mul(l);
  }
}
const D0 = Qh, z0 = J(Qh);
re("SpriteSheetUVNode", Qh);
class ed extends Le {
  constructor(e, t = null, r = null, n = Me(1), s = fh, o = lc) {
    super("vec4"), this.textureXNode = e, this.textureYNode = t, this.textureZNode = r, this.scaleNode = n, this.positionNode = s, this.normalNode = o;
  }
  setup() {
    const { textureXNode: e, textureYNode: t, textureZNode: r, scaleNode: n, positionNode: s, normalNode: o } = this;
    let i = o.abs().normalize();
    i = i.div(i.dot(Fe(1)));
    const a = s.yz.mul(n), l = s.zx.mul(n), u = s.xy.mul(n), h = e.value, d = t !== null ? t.value : h, f = r !== null ? r.value : h, p = en(h, a).mul(i.x), m = en(d, l).mul(i.y), g = en(f, u).mul(i.z);
    return xn(p, m, g);
  }
}
const B0 = ed, k0 = J(ed), G0 = (...c) => k0(...c);
W("triplanarTexture", G0);
re("TriplanarTexturesNode", ed);
class Jt extends Yn {
  setup() {
    return this.getFloat(this.scope);
  }
}
Jt.SCALE = "scale";
Jt.DASH_SIZE = "dashSize";
Jt.GAP_SIZE = "gapSize";
Jt.LINEWIDTH = "linewidth";
Jt.DASH_OFFSET = "dashOffset";
const Mw = Jt, Oa = le(Jt, Jt.SCALE), ql = le(Jt, Jt.DASH_OFFSET), td = le(Jt, Jt.DASH_SIZE), nd = le(Jt, Jt.GAP_SIZE), Xr = le(Jt, Jt.LINEWIDTH);
re("LineMaterialNode", Jt);
const pc = 1 / 6, V0 = (c) => Qt(pc, Qt(c, Qt(c, c.negate().add(3)).sub(3)).add(1)), Jl = (c) => Qt(pc, Qt(c, Qt(c, Qt(3, c).sub(6))).add(4)), j0 = (c) => Qt(pc, Qt(c, Qt(c, Qt(-3, c).add(3)).add(3)).add(1)), Yl = (c) => Qt(pc, th(c, 3)), Xf = (c) => V0(c).add(Jl(c)), $f = (c) => j0(c).add(Yl(c)), qf = (c) => xn(-1, Jl(c).div(V0(c).add(Jl(c)))), Jf = (c) => xn(1, Yl(c).div(j0(c).add(Yl(c)))), Yf = (c, e, t) => {
  const r = c.uvNode, n = Qt(r, e.zw).add(0.5), s = oc(n), o = ic(n), i = Xf(o.x), a = $f(o.x), l = qf(o.x), u = Jf(o.x), h = qf(o.y), d = Jf(o.y), f = st(s.x.add(l), s.y.add(h)).sub(0.5).mul(e.xy), p = st(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy), m = st(s.x.add(l), s.y.add(d)).sub(0.5).mul(e.xy), g = st(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy), b = Xf(o.y).mul(xn(i.mul(c.uv(f).level(t)), a.mul(c.uv(p).level(t)))), v = $f(o.y).mul(xn(i.mul(c.uv(m).level(t)), a.mul(c.uv(g).level(t))));
  return b.add(v);
}, Aw = (c, e) => {
  const t = st(c.size(Sa(e))), r = st(c.size(Sa(e.add(1)))), n = yo(1, t), s = yo(1, r), o = Yf(c, ot(n, t), oc(e)), i = Yf(c, ot(s, r), Ku(e));
  return ic(e).mix(o, i);
};
class sd extends Mt {
  constructor(e, t = Me(3)) {
    super("vec4"), this.textureNode = e, this.blurNode = t;
  }
  setup() {
    return Aw(this.textureNode, this.blurNode);
  }
}
const Cw = sd, W0 = J(sd);
W("bicubic", W0);
re("TextureBicubicNode", sd);
class rd extends Le {
  constructor() {
    super("vec2"), this.isPointUVNode = !0;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const H0 = rd, X0 = le(rd);
re("PointUVNode", rd);
class Gn extends Le {
  constructor(e = Gn.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  setup(e) {
    const t = this.scope, r = this.scene !== null ? this.scene : e.scene;
    let n;
    return t === Gn.BACKGROUND_BLURRINESS ? n = Cs("backgroundBlurriness", "float", r) : t === Gn.BACKGROUND_INTENSITY ? n = Cs("backgroundIntensity", "float", r) : console.error("THREE.SceneNode: Unknown scope:", t), n;
  }
}
Gn.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Gn.BACKGROUND_INTENSITY = "backgroundIntensity";
const Ew = Gn, Rw = le(Gn, Gn.BACKGROUND_BLURRINESS), Fw = le(Gn, Gn.BACKGROUND_INTENSITY);
re("SceneNode", Gn);
class od extends Th {
  constructor(e, t, r = 0) {
    super(e, t, r), this.isStorageBufferNode = !0;
  }
  getInputType() {
    return "storageBuffer";
  }
}
const Lw = od, Ow = (c, e, t) => Ae(new od(c, e, t));
re("StorageBufferNode", od);
class id extends vi {
  constructor(e, t, r = null) {
    super(e, t), this.storeNode = r, this.isStoreTextureNode = !0;
  }
  getNodeType() {
    return "void";
  }
}
const Iw = id, Pw = J(id);
re("TextureStoreNode", id);
class ad extends cc {
  constructor(e, t, r = null) {
    super(e, t, r), this.userData = r;
  }
  update(e) {
    this.reference = this.userData !== null ? this.userData : e.object.userData, super.update(e);
  }
}
const Uw = ad, Dw = (c, e, t) => Ae(new ad(c, e, t));
re("UserDataNode", ad);
const zw = Ze(({ base: c, blend: e }) => {
  const t = (r) => e[r].lessThan(Yu).cond(e[r], c[r].oneMinus().div(e[r]).oneMinus().max(0));
  return Fe(t("x"), t("y"), t("z"));
}), Bw = Ze(({ base: c, blend: e }) => {
  const t = (r) => e[r].equal(1).cond(e[r], c[r].div(e[r].oneMinus()).max(0));
  return Fe(t("x"), t("y"), t("z"));
}), kw = Ze(({ base: c, blend: e }) => {
  const t = (r) => c[r].oneMinus().mul(e[r].oneMinus()).oneMinus();
  return Fe(t("x"), t("y"), t("z"));
}), Gw = Ze(({ base: c, blend: e }) => {
  const t = (r) => c[r].lessThan(0.5).cond(c[r].mul(e[r], 2), c[r].oneMinus().mul(e[r].oneMinus()).oneMinus());
  return Fe(t("x"), t("y"), t("z"));
});
class Ut extends Mt {
  constructor(e, t, r) {
    super(), this.blendMode = e, this.baseNode = t, this.blendNode = r;
  }
  setup() {
    const { blendMode: e, baseNode: t, blendNode: r } = this, n = { base: t, blend: r };
    let s = null;
    return e === Ut.BURN ? s = zw(n) : e === Ut.DODGE ? s = Bw(n) : e === Ut.SCREEN ? s = kw(n) : e === Ut.OVERLAY && (s = Gw(n)), s;
  }
}
Ut.BURN = "burn";
Ut.DODGE = "dodge";
Ut.SCREEN = "screen";
Ut.OVERLAY = "overlay";
const to = Ut, $0 = J(Ut, Ut.BURN), q0 = J(Ut, Ut.DODGE), J0 = J(Ut, Ut.OVERLAY), Y0 = J(Ut, Ut.SCREEN);
W("burn", $0);
W("dodge", q0);
W("overlay", J0);
W("screen", Y0);
re("BlendModeNode", Ut);
const Vw = Ze(({ color: c, adjustment: e }) => e.mix(tv(c), c)), jw = Ze(({ color: c, adjustment: e }) => {
  const t = xn(c.r, c.g, c.b).div(3), r = c.r.max(c.g.max(c.b)), n = r.sub(t).mul(e).mul(-3);
  return on(c, r, n);
}), Ww = Ze(({ color: c, adjustment: e }) => {
  const t = As(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135), r = As(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046), n = t.mul(c), s = n.z.atan2(n.y).add(e), o = n.yz.length();
  return r.mul(Fe(n.x, o.mul(s.cos()), o.mul(s.sin())));
});
class rn extends Mt {
  constructor(e, t, r = Me(1)) {
    super("vec3"), this.method = e, this.colorNode = t, this.adjustmentNode = r;
  }
  setup() {
    const { method: e, colorNode: t, adjustmentNode: r } = this, n = { color: t, adjustment: r };
    let s = null;
    return e === rn.SATURATION ? s = Vw(n) : e === rn.VIBRANCE ? s = jw(n) : e === rn.HUE ? s = Ww(n) : console.error(`${this.type}: Method "${this.method}" not supported!`), s;
  }
}
rn.SATURATION = "saturation";
rn.VIBRANCE = "vibrance";
rn.HUE = "hue";
const Ho = rn, K0 = J(rn, rn.SATURATION), Z0 = J(rn, rn.VIBRANCE), Q0 = J(rn, rn.HUE), ev = Fe(0.2125, 0.7154, 0.0721), tv = (c, e = ev) => js(c, e);
W("saturation", K0);
W("vibrance", Z0);
W("hue", Q0);
re("ColorAdjustmentNode", rn);
class cd extends Mt {
  constructor(e, t) {
    super(), this.sourceNode = e, this.stepsNode = t;
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const nv = cd, sv = J(cd);
W("posterize", sv);
re("PosterizeNode", cd);
const Hw = Ze(({ color: c, exposure: e }) => c.mul(e).clamp()), Xw = Ze(({ color: c, exposure: e }) => (c = c.mul(e), c.div(c.add(1)).clamp())), $w = Ze(({ color: c, exposure: e }) => {
  c = c.mul(e), c = c.sub(4e-3).max(0);
  const t = c.mul(c.mul(6.2).add(0.5)), r = c.mul(c.mul(6.2).add(1.7)).add(0.06);
  return t.div(r).pow(2.2);
}), qw = Ze(({ color: c }) => {
  const e = c.mul(c.add(0.0245786)).sub(90537e-9), t = c.mul(c.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), Jw = Ze(({ color: c, exposure: e }) => {
  const t = As(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), r = As(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return c = c.mul(e).div(0.6), c = t.mul(c), c = qw({ color: c }), c = r.mul(c), c.clamp();
}), Yw = {
  [bx]: Hw,
  [Nx]: Xw,
  [wx]: $w,
  [pm]: Jw
};
class ld extends Mt {
  constructor(e = Pf, t = Me(1), r = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = r;
  }
  getCacheKey() {
    let e = super.getCacheKey();
    return e = "{toneMapping:" + this.toneMapping + ",nodes:" + e + "}", e;
  }
  setup(e) {
    const t = this.colorNode || e.context.color, r = this.toneMapping;
    if (r === Pf)
      return t;
    const n = { exposure: this.exposureNode, color: t }, s = Yw[r];
    let o = null;
    return s ? o = s(n) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", r), o = t), o;
  }
}
const rv = ld, Kw = (c, e, t) => Ae(new ld(c, Ae(e), Ae(t)));
re("ToneMappingNode", ld);
let Kc, Zc;
class Ke extends Le {
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Ke.COORDINATE || this.scope === Ke.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = ut.NONE;
    return (this.scope === Ke.RESOLUTION || this.scope === Ke.VIEWPORT) && (e = ut.FRAME), this.updateType = e, e;
  }
  update({ renderer: e }) {
    this.scope === Ke.VIEWPORT ? e.getViewport(Zc) : e.getDrawingBufferSize(Kc);
  }
  setup(e) {
    const t = this.scope;
    if (t === Ke.COORDINATE)
      return;
    let r = null;
    if (t === Ke.RESOLUTION)
      r = Ft(Kc || (Kc = new wt()));
    else if (t === Ke.VIEWPORT)
      r = Ft(Zc || (Zc = new pt()));
    else {
      const n = st(new Ke(Ke.COORDINATE)), s = new Ke(Ke.RESOLUTION);
      r = n.div(s);
      let o = r.x, i = r.y;
      (/top/i.test(t) && e.isFlipY() || /bottom/i.test(t) && e.isFlipY() === !1) && (i = i.oneMinus()), /right/i.test(t) && (o = o.oneMinus()), r = st(o, i);
    }
    return r;
  }
  generate(e) {
    return this.scope === Ke.COORDINATE ? e.getFragCoord() : super.generate(e);
  }
}
Ke.COORDINATE = "coordinate";
Ke.RESOLUTION = "resolution";
Ke.VIEWPORT = "viewport";
Ke.TOP_LEFT = "topLeft";
Ke.BOTTOM_LEFT = "bottomLeft";
Ke.TOP_RIGHT = "topRight";
Ke.BOTTOM_RIGHT = "bottomRight";
const ks = Ke, Zw = le(Ke, Ke.COORDINATE), Qw = le(Ke, Ke.RESOLUTION), ma = le(Ke, Ke.VIEWPORT), mc = le(Ke, Ke.TOP_LEFT), e2 = le(Ke, Ke.BOTTOM_LEFT), t2 = le(Ke, Ke.TOP_RIGHT), n2 = le(Ke, Ke.BOTTOM_RIGHT);
re("ViewportNode", Ke);
const Oo = new wt();
class gc extends vi {
  constructor(e = mc, t = null, r = null) {
    r === null && (r = new mm(), r.minFilter = xo), super(r, e, t), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = ut.FRAME;
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(Oo);
    const r = this.value;
    (r.image.width !== Oo.width || r.image.height !== Oo.height) && (r.image.width = Oo.width, r.image.height = Oo.height, r.needsUpdate = !0);
    const n = r.generateMipmaps;
    r.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(r), r.generateMipmaps = n;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
}
const ud = gc, ov = J(gc), iv = J(gc, null, null, { generateMipmaps: !0 });
W("viewportTexture", ov);
W("viewportMipTexture", iv);
re("ViewportTextureNode", gc);
let Qc = null;
class hd extends ud {
  constructor(e = mc, t = null) {
    Qc === null && (Qc = new mm()), super(e, t, Qc);
  }
}
const s2 = hd, av = J(hd);
W("viewportSharedTexture", av);
re("ViewportSharedTextureNode", hd);
let Or = null;
class dd extends ud {
  constructor(e = mc, t = null) {
    Or === null && (Or = new dm(), Or.minFilter = xo, Or.type = Tx, Or.format = Sx), super(e, t, Or);
  }
}
const r2 = dd, fd = J(dd);
W("viewportDepthTexture", fd);
re("ViewportDepthTextureNode", dd);
class ss extends Le {
  constructor(e, t = null) {
    super("float"), this.scope = e, this.textureNode = t, this.isViewportDepthNode = !0;
  }
  setup() {
    const { scope: e } = this;
    let t = null;
    if (e === ss.DEPTH)
      t = Kl(ts.z, fa, pa);
    else if (e === ss.DEPTH_TEXTURE) {
      const r = this.textureNode || fd(), n = cv(r, fa, pa);
      t = Kl(n, fa, pa);
    }
    return t;
  }
}
const Kl = (c, e, t) => c.add(e).div(e.sub(t)), o2 = (c, e, t) => e.sub(t).mul(c).sub(e), i2 = (c, e, t) => e.add(c).mul(t).div(e.sub(t).mul(c)), cv = (c, e, t) => e.mul(t).div(t.sub(e).mul(c).sub(t));
ss.DEPTH = "depth";
ss.DEPTH_TEXTURE = "depthTexture";
const a2 = ss, c2 = le(ss, ss.DEPTH), l2 = J(ss, ss.DEPTH_TEXTURE);
re("ViewportDepthNode", ss);
class pd extends Le {
  constructor(e = "", t = [], r = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = r, this._includes = t;
  }
  setIncludes(e) {
    return this._includes = e, this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const n of t)
      n.build(e);
    const r = e.getCodeFromNode(this, this.getNodeType(e));
    return r.code = this.code, r.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
const md = pd, yc = J(pd), u2 = (c, e) => yc(c, e, "js"), h2 = (c, e) => yc(c, e, "wgsl"), gd = (c, e) => yc(c, e, "glsl");
re("CodeNode", pd);
class yd extends Mt {
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [], r = this.functionNode, n = r.getInputs(e), s = this.parameters;
    if (Array.isArray(s))
      for (let i = 0; i < s.length; i++) {
        const a = n[i], l = s[i];
        t.push(l.build(e, a.type));
      }
    else
      for (const i of n) {
        const a = s[i.name];
        if (a !== void 0)
          t.push(a.build(e, i.type));
        else
          throw new Error(`FunctionCallNode: Input '${i.name}' not found in FunctionNode.`);
      }
    return `${r.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const d2 = yd, lv = (c, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? mr(e) : ec(e[0]), Ae(new yd(Ae(c), e)));
W("call", lv);
re("FunctionCallNode", yd);
class vd extends md {
  constructor(e = "", t = [], r = "") {
    super(e, t, r), this.keywords = {};
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let r = t.nodeFunction;
    return r === void 0 && (r = e.parser.parseFunction(this.code), t.nodeFunction = r), r;
  }
  generate(e, t) {
    super.generate(e);
    const r = this.getNodeFunction(e), n = r.name, s = r.type, o = e.getCodeFromNode(this, s);
    n !== "" && (o.name = n);
    const i = e.getPropertyName(o);
    let a = this.getNodeFunction(e).getCode(i);
    const l = this.keywords, u = Object.keys(l);
    if (u.length > 0)
      for (const h of u) {
        const d = new RegExp(`\\b${h}\\b`, "g"), f = l[h].build(e, "property");
        a = a.replace(d, f);
      }
    return o.code = a, t === "property" ? i : e.format(`${i}()`, s, t);
  }
}
const uv = vd, hv = (c, e = [], t = "") => {
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof o == "function" && (e[s] = o.functionNode);
  }
  const r = Ae(new vd(c, e, t)), n = (...s) => r.call(...s);
  return n.functionNode = r, n;
}, cn = (c, e) => hv(c, e, "glsl"), f2 = (c, e) => hv(c, e, "wgsl");
re("FunctionNode", vd);
class xd extends Le {
  constructor(e = null) {
    super(), this._value = e, this._cache = null, this.inputType = null, this.outpuType = null, this.events = new pu(), this.isScriptableValueNode = !0;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e && (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer && (URL.revokeObjectURL(this._cache), this._cache = null), this._value = e, this.events.dispatchEvent({ type: "change" }), this.refresh());
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const e = this.value;
    if (e && this._cache === null && this.inputType === "URL" && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (e && e.value !== null && e.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof e.value == "string" || this.inputType === "Number" && typeof e.value == "number" || this.inputType === "Vector2" && e.value.isVector2 || this.inputType === "Vector3" && e.value.isVector3 || this.inputType === "Vector4" && e.value.isVector4 || this.inputType === "Color" && e.value.isColor || this.inputType === "Matrix3" && e.value.isMatrix3 || this.inputType === "Matrix4" && e.value.isMatrix4))
      return e.value;
    return this._cache || e;
  }
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : Me();
  }
  serialize(e) {
    super.serialize(e), this.value !== null ? this.inputType === "ArrayBuffer" ? e.value = Mu(this.value) : e.value = this.value ? this.value.toJSON(e.meta).uuid : null : e.value = null, e.inputType = this.inputType, e.outputType = this.outputType;
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null && (e.inputType === "ArrayBuffer" ? t = Au(e.value) : e.inputType === "Texture" ? t = e.meta.textures[e.value] : t = e.meta.nodes[e.value] || null), this.value = t, this.inputType = e.inputType, this.outputType = e.outputType;
  }
}
const p2 = xd, Xo = J(xd);
W("scriptableValue", Xo);
re("ScriptableValueNode", xd);
class dv extends Map {
  get(e, t = null, ...r) {
    if (this.has(e))
      return super.get(e);
    if (t !== null) {
      const n = t(...r);
      return this.set(e, n), n;
    }
  }
}
class m2 {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const ga = new dv();
class bd extends Le {
  constructor(e = null, t = {}) {
    super(), this.codeNode = e, this.parameters = t, this._local = new dv(), this._output = Xo(), this._outputs = {}, this._source = this.source, this._method = null, this._object = null, this._value = null, this._needsOutputUpdate = !0, this.onRefresh = this.onRefresh.bind(this), this.isScriptableNode = !0;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  getLocal(e) {
    return this._local.get(e);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e))
        return t;
  }
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e))
        return t;
  }
  setOutput(e, t) {
    const r = this._outputs;
    return r[e] === void 0 ? r[e] = Xo(t) : r[e].value = t, this;
  }
  getOutput(e) {
    return this._outputs[e];
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    const r = this.parameters;
    return t && t.isScriptableNode ? (this.deleteParameter(e), r[e] = t, r[e].getDefaultOutput().events.addEventListener("refresh", this.onRefresh)) : t && t.isScriptableValueNode ? (this.deleteParameter(e), r[e] = t, r[e].events.addEventListener("refresh", this.onRefresh)) : r[e] === void 0 ? (r[e] = Xo(t), r[e].events.addEventListener("refresh", this.onRefresh)) : r[e].value = t, this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(e) {
    let t = this.parameters[e];
    return t && (t.isScriptableNode && (t = t.getDefaultOutput()), t.events.removeEventListener("refresh", this.onRefresh)), this;
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters))
      this.deleteParameter(e);
    return this.needsUpdate = !0, this;
  }
  call(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n(...t);
  }
  async callAsync(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n.constructor.name === "AsyncFunction" ? await n(...t) : n(...t);
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  getObject() {
    if (this.needsUpdate && this.dispose(), this._object !== null)
      return this._object;
    const e = () => this.refresh(), t = (l, u) => this.setOutput(l, u), r = new m2(this), n = ga.get("THREE"), s = ga.get("TSL"), o = this.getMethod(this.codeNode), i = [r, this._local, ga, e, t, n, s];
    this._object = o(...i);
    const a = this._object.layout;
    if (a && (a.cache === !1 && this._local.clear(), this._output.outputType = a.outputType || null, Array.isArray(a.elements)))
      for (const l of a.elements) {
        const u = l.id || l.name;
        l.inputType && (this.getParameter(u) === void 0 && this.setParameter(u, null), this.getParameter(u).inputType = l.inputType), l.outputType && (this.getOutput(u) === void 0 && this.setOutput(u, null), this.getOutput(u).outputType = l.outputType);
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let r = this.parameters[t];
      r.isScriptableNode && (r = r.getDefaultOutput()), r.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : Me();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate && this.dispose(), this._method !== null)
      return this._method;
    const e = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"], r = ["layout", "init", "main", "dispose"].join(", "), n = "var " + r + `; var output = {};
`, s = `
return { ...output, ` + r + " };", o = n + this.codeNode.code + s;
    return this._method = new Function(...e, o), this._method;
  }
  dispose() {
    this._method !== null && (this._object && typeof this._object.dispose == "function" && this._object.dispose(), this._method = null, this._object = null, this._source = null, this._value = null, this._needsOutputUpdate = !0, this._output.value = null, this._outputs = {});
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    return this.codeNode === null ? this : (this._needsOutputUpdate === !0 && (this._value = this.call("main"), this._needsOutputUpdate = !1), this._output.value = this._value, this);
  }
  _refresh() {
    this.needsUpdate = !0, this._exec(), this._output.refresh();
  }
}
const g2 = bd, fv = J(bd);
W("scriptable", fv);
re("ScriptableNode", bd);
class Nd extends Le {
  constructor(e, t) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = t;
  }
  mixAssign(e) {
    return this.mix(e, this.colorNode);
  }
  setup() {
    return this.factorNode;
  }
}
const vc = Nd, pv = J(Nd);
W("fog", pv);
re("FogNode", Nd);
class wd extends vc {
  constructor(e, t, r) {
    super(e), this.isFogRangeNode = !0, this.nearNode = t, this.farNode = r;
  }
  setup() {
    return Qs(this.nearNode, this.farNode, ts.z.negate());
  }
}
const mv = wd, gv = J(wd);
W("rangeFog", gv);
re("FogRangeNode", wd);
class Td extends vc {
  constructor(e, t) {
    super(e), this.isFogExp2Node = !0, this.densityNode = t;
  }
  setup() {
    const e = ts.z.negate(), t = this.densityNode;
    return t.mul(t, e, e).negate().exp().oneMinus();
  }
}
const yv = Td, vv = J(Td);
W("densityFog", vv);
re("FogExp2Node", Td);
let ir = null, ar = null;
class Sd extends Le {
  constructor(e = Me(), t = Me()) {
    super(), this.minNode = e, this.maxNode = t;
  }
  getVectorLength(e) {
    const t = e.getTypeLength(Xs(this.minNode.value)), r = e.getTypeLength(Xs(this.maxNode.value));
    return t > r ? t : r;
  }
  getNodeType(e) {
    return e.object.isInstancedMesh === !0 ? e.getTypeFromLength(this.getVectorLength(e)) : "float";
  }
  setup(e) {
    const t = e.object;
    let r = null;
    if (t.isInstancedMesh === !0) {
      const n = this.minNode.value, s = this.maxNode.value, o = e.getTypeLength(Xs(n)), i = e.getTypeLength(Xs(s));
      ir = ir || new pt(), ar = ar || new pt(), ir.setScalar(0), ar.setScalar(0), o === 1 ? ir.setScalar(n) : n.isColor ? ir.set(n.r, n.g, n.b) : ir.set(n.x, n.y, n.z || 0, n.w || 0), i === 1 ? ar.setScalar(s) : s.isColor ? ar.set(s.r, s.g, s.b) : ar.set(s.x, s.y, s.z || 0, s.w || 0);
      const a = 4, l = a * t.count, u = new Float32Array(l);
      for (let d = 0; d < l; d++) {
        const f = d % a, p = ir.getComponent(f), m = ar.getComponent(f);
        u[d] = Zt.lerp(p, m, Math.random());
      }
      const h = this.getNodeType(e);
      r = Sh(u, "vec4", t.count).element(Sg).convert(h);
    } else
      r = Me(0);
    return r;
  }
}
const xv = Sd, y2 = J(Sd);
re("RangeNode", Sd);
class _d extends Le {
  constructor(e, t, r = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = t, this.workgroupSize = r, this.dispatchCount = 0, this.version = 1, this.updateType = ut.OBJECT, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let r = t[0];
    for (let n = 1; n < t.length; n++)
      r *= t[n];
    this.dispatchCount = Math.ceil(e / r);
  }
  onInit() {
  }
  update({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: t } = e;
    if (t === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r);
    }
  }
}
const bv = _d, Nv = (c, e, t) => Ae(new _d(Ae(c), e, t));
W("compute", Nv);
re("ComputeNode", _d);
class er extends Le {
  constructor(e = er.TARGET_DIRECTION, t = null) {
    super(), this.scope = e, this.light = t;
  }
  setup() {
    const { scope: e, light: t } = this;
    let r = null;
    return e === er.TARGET_DIRECTION && (r = Rs.transformDirection(Fa(t).sub(Fa(t.target)))), r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
er.TARGET_DIRECTION = "targetDirection";
const v2 = er, Md = J(er, er.TARGET_DIRECTION);
re("LightNode", er);
const Ad = Ze((c) => {
  const { lightDistance: e, cutoffDistance: t, decayExponent: r } = c, n = e.pow(r).max(0.01).reciprocal();
  return t.greaterThan(0).cond(
    n.mul(e.div(t).pow4().oneMinus().clamp().pow2()),
    n
  );
});
class Cd extends or {
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  setup(e) {
    const { colorNode: t, cutoffDistanceNode: r, decayExponentNode: n, light: s } = this, o = e.context.lightingModel, i = ch(s).sub(ts), a = i.normalize(), l = i.length(), u = Ad({
      lightDistance: l,
      cutoffDistance: r,
      decayExponent: n
    }), h = t.mul(u), d = e.context.reflectedLight;
    o.direct({
      lightDirection: a,
      lightColor: h,
      reflectedLight: d
    });
  }
}
const wv = Cd;
re("PointLightNode", Cd);
_r(Zo, Cd);
class Ed extends or {
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, r = this.colorNode, n = Md(this.light), s = e.context.reflectedLight;
    t.direct({
      lightDirection: n,
      lightColor: r,
      reflectedLight: s
    });
  }
}
const x2 = Ed;
re("DirectionalLightNode", Ed);
_r(pi, Ed);
class Rd extends or {
  constructor(e = null) {
    super(e), this.coneCosNode = Ft(0), this.penumbraCosNode = Ft(0), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: t, penumbraCosNode: r } = this;
    return Qs(t, r, e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, { colorNode: r, cutoffDistanceNode: n, decayExponentNode: s, light: o } = this, i = ch(o).sub(ts), a = i.normalize(), l = a.dot(Md(o)), u = this.getSpotAttenuation(l), h = i.length(), d = Ad({
      lightDistance: h,
      cutoffDistance: n,
      decayExponent: s
    }), f = r.mul(u).mul(d), p = e.context.reflectedLight;
    t.direct({
      lightDirection: a,
      lightColor: f,
      reflectedLight: p
    });
  }
}
const Tv = Rd;
re("SpotLightNode", Rd);
_r(mi, Rd);
class b2 extends mi {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, n, s, o), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
const N2 = b2;
class Fd extends Tv {
  getSpotAttenuation(e) {
    const t = this.light.iesMap;
    let r = null;
    if (t && t.isTexture === !0) {
      const n = e.acos().mul(1 / Math.PI);
      r = en(t, st(n, 0), 0).r;
    } else
      r = super.getSpotAttenuation(e);
    return r;
  }
}
const w2 = Fd;
re("IESSpotLightNode", Fd);
_r(N2, Fd);
class Ld extends or {
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
const T2 = Ld;
re("AmbientLightNode", Ld);
_r(yu, Ld);
class Od extends or {
  constructor(e = null) {
    super(e), this.lightPositionNode = Fa(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Ft(new Ve());
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: r, lightDirectionNode: n } = this, o = ds.dot(n).mul(0.5).add(0.5), i = on(r, t, o);
    e.context.irradiance.addAssign(i);
  }
}
const Sv = Od;
re("HemisphereLightNode", Od);
_r(gm, Od);
const S2 = Ze((c) => {
  const e = c.uv.mul(2), t = e.x.floor(), r = e.y.floor();
  return t.add(r).mod(2).sign();
});
class Id extends Mt {
  constructor(e = vt()) {
    super("float"), this.uvNode = e;
  }
  setup() {
    return S2({ uv: this.uvNode });
  }
}
const _v = Id, Mv = J(Id);
W("checker", Mv);
re("CheckerNode", Id);
class _2 extends xr {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, n) {
    const s = new Ks(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      try {
        t(this.parse(JSON.parse(o)));
      } catch (i) {
        n ? n(i) : console.error(i), this.manager.itemError(e);
      }
    }, r, n);
  }
  parseNodes(e) {
    const t = {};
    if (e !== void 0) {
      for (const n of e) {
        const { uuid: s, type: o } = n;
        t[s] = Ae(Vl(o)), t[s].uuid = s;
      }
      const r = { nodes: t, textures: this.textures };
      for (const n of e)
        n.meta = r, t[n.uuid].deserialize(n), delete n.meta;
    }
    return t;
  }
  parse(e) {
    const t = Ae(Vl(e.type));
    t.uuid = e.uuid;
    const n = { nodes: this.parseNodes(e.nodes), textures: this.textures };
    return e.meta = n, t.deserialize(e), delete e.meta, t;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
const Av = _2, M2 = new vu();
class Cv extends tn {
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(M2), this.setValues(e);
  }
}
const Ev = Cv;
wn("LineBasicNodeMaterial", Cv);
const A2 = new ym();
class Rv extends tn {
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(A2), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants({ stack: e }) {
    const t = this.offsetNode, r = this.dashScaleNode ? Me(this.dashScaleNode) : Oa, n = this.dashSizeNode ? Me(this.dashSizeNode) : td, s = this.dashSizeNode ? Me(this.dashGapNode) : nd;
    e.assign(co, n), e.assign(Ea, s);
    const o = ct(Ot("lineDistance").mul(r)), i = t ? o.add(t) : o;
    e.add(i.mod(co.add(Ea)).greaterThan(co).discard());
  }
}
const C2 = Rv;
wn("LineDashedNodeMaterial", Rv);
const E2 = new ym();
class Fv extends tn {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.setDefaultValues(E2), this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.useDash = e.dashed, this.useWorldUnits = !1, this.dashOffset = 0, this.lineWidth = 1, this.lineColorNode = null, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor, r = this.dashed, n = this.worldUnits, s = Ze(({ start: i, end: a }) => {
      const l = Ns.element(2).element(2), d = Ns.element(3).element(2).mul(-0.5).div(l).sub(i.z).div(a.z.sub(i.z));
      return ot(on(i.xyz, a.xyz, d), a.w);
    });
    this.vertexNode = new Ms((i) => {
      i.assign(ct(st(), "vUv"), vt());
      const a = Ot("instanceStart"), l = Ot("instanceEnd"), u = Ts("vec4", "start"), h = Ts("vec4", "end");
      i.assign(u, Nr.mul(ot(a, 1))), i.assign(h, Nr.mul(ot(l, 1))), n && (i.assign(ct(Fe(), "worldStart"), u.xyz), i.assign(ct(Fe(), "worldEnd"), h.xyz));
      const d = ma.z.div(ma.w), f = Ns.element(2).element(3).equal(-1);
      i.if(f, (x) => {
        x.if(u.z.lessThan(0).and(h.z.greaterThan(0)), (N) => {
          N.assign(h, s({ start: u, end: h }));
        }).elseif(h.z.lessThan(0).and(u.z.greaterThanEqual(0)), (N) => {
          N.assign(u, s({ start: h, end: u }));
        });
      });
      const p = Ns.mul(u), m = Ns.mul(h), g = p.xyz.div(p.w), b = m.xyz.div(m.w), v = b.xy.sub(g.xy);
      i.assign(v.x, v.x.mul(d)), i.assign(v, v.normalize());
      const y = oi(ot());
      if (n) {
        const x = h.xyz.sub(u.xyz).normalize(), N = pn.y.lessThan(0.5).cond(
          u.xyz.cross(x).normalize(),
          h.xyz.cross(x).normalize()
        );
        i.assign(N, pn.x.lessThan(0).cond(N.negate(), N));
        const w = x.dot(Fe(0, 0, 1));
        r || (i.assign(u, u.sub(ot(x.mul(Xr).mul(0.5), 0))), i.assign(h, h.add(ot(x.mul(Xr).mul(0.5), 0))), i.assign(N, N.sub(Fe(v.mul(w), 0))), i.assign(N.z, N.z.add(0.5))), i.if(pn.y.greaterThan(1).or(pn.y.lessThan(0)), (F) => {
          F.assign(N, N.add(Fe(v.mul(2).mul(w), 0)));
        }), i.assign(N, N.mul(Xr).mul(0.5));
        const T = ct(ot(), "worldPos");
        i.assign(T, pn.y.lessThan(0.5).cond(u, h)), i.assign(T, T.add(ot(N, 0))), i.assign(y, Ns.mul(T));
        const _ = oi(Fe());
        i.assign(_, pn.y.lessThan(0.5).cond(g, b)), i.assign(y.z, _.z.mul(y.w));
      } else {
        const x = Ts("vec2", "offset");
        i.assign(x, st(v.y, v.x.negate())), i.assign(v.x, v.x.div(d)), i.assign(x.x, x.x.div(d)), i.assign(x, pn.x.lessThan(0).cond(x.negate(), x)), i.if(pn.y.lessThan(0), (N) => {
          N.assign(x, x.sub(v));
        }).elseif(pn.y.greaterThan(1), (N) => {
          N.assign(x, x.add(v));
        }), i.assign(x, x.mul(Xr)), i.assign(x, x.div(ma.w)), i.assign(y, pn.y.lessThan(0.5).cond(p, m)), i.assign(x, x.mul(y.w)), i.assign(y, y.add(ot(x, 0, 0)));
      }
      return y;
    });
    const o = Ze(({ p1: i, p2: a, p3: l, p4: u }) => {
      const h = i.sub(l), d = u.sub(l), f = a.sub(i), p = js(h, d), m = js(d, f), g = js(h, f), b = js(d, d), y = js(f, f).mul(b).sub(m.mul(m)), x = p.mul(m).sub(g.mul(b)), N = ni(x.div(y), 0, 1), w = ni(p.add(m.mul(N)).div(b), 0, 1);
      return st(N, w);
    });
    this.colorNode = new Ms((i) => {
      const a = ct(st(), "vUv");
      if (r) {
        const h = this.offsetNode ? Me(this.offsetNodeNode) : ql, d = this.dashScaleNode ? Me(this.dashScaleNode) : Oa, f = this.dashSizeNode ? Me(this.dashSizeNode) : td, p = this.dashSizeNode ? Me(this.dashGapNode) : nd;
        i.assign(co, f), i.assign(Ea, p);
        const m = Ot("instanceDistanceStart"), g = Ot("instanceDistanceEnd"), b = pn.y.lessThan(0.5).cond(d.mul(m), Oa.mul(g)), v = ct(b.add(ql)), y = h ? v.add(h) : v;
        i.add(a.y.lessThan(-1).or(a.y.greaterThan(1)).discard()), i.add(eh(y, co.add(Ea)).greaterThan(co).discard());
      }
      const l = Ts("float", "alpha");
      if (i.assign(l, 1), n) {
        let h = ct(Fe(), "worldStart"), d = ct(Fe(), "worldEnd");
        const f = ct(ot(), "worldPos").xyz.normalize().mul(1e5), p = d.sub(h), m = o({ p1: h, p2: d, p3: Fe(0, 0, 0), p4: f }), g = h.add(p.mul(m.x)), b = f.mul(m.y), x = g.sub(b).length().div(Xr);
        if (!r)
          if (e) {
            const N = x.fwidth();
            i.assign(l, Qs(N.negate().add(0.5), N.add(0.5), x).oneMinus());
          } else
            i.add(x.greaterThan(0.5).discard());
      } else if (e) {
        const h = a.x, d = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1)), f = h.mul(h).add(d.mul(d)), p = Ts("float", "dlen");
        i.assign(p, f.fwidth()), i.if(ti(a.y).greaterThan(1), (m) => {
          m.assign(l, Qs(p.oneMinus(), p.add(1), f).oneMinus());
        });
      } else
        i.if(ti(a.y).greaterThan(1), (h) => {
          const d = a.x, f = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1)), p = d.mul(d).add(f.mul(f));
          h.add(p.greaterThan(1).discard());
        });
      let u;
      if (this.lineColorNode)
        u = this.lineColorNode;
      else if (t) {
        const h = Ot("instanceColorStart"), d = Ot("instanceColorEnd");
        u = ct(pn.y.lessThan(0.5).cond(h, d));
      } else
        u = ih;
      return ot(u, l);
    }), this.needsUpdate = !0;
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(e) {
    this.useWorldUnits !== e && (this.useWorldUnits = e, this.setupShaders());
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(e) {
    this.useDash !== e && (this.useDash = e, this.setupShaders());
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const R2 = Fv;
wn("Line2NodeMaterial", Fv);
const F2 = new _x();
class Lv extends tn {
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.colorSpace = !1, this.setDefaultValues(F2), this.setValues(e);
  }
  setupDiffuseColor({ stack: e }) {
    const t = this.opacityNode ? Me(this.opacityNode) : ah;
    e.assign($t, ot(Kh(_t), t));
  }
}
const L2 = Lv;
wn("MeshNormalNodeMaterial", Lv);
const O2 = new An();
class Ov extends tn {
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(O2), this.setValues(e);
  }
}
const Iv = Ov;
wn("MeshBasicNodeMaterial", Ov);
const I2 = Ze(({ f0: c, f90: e, dotVH: t }) => {
  const r = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return c.mul(r.oneMinus()).add(e.mul(r));
}), vo = I2, P2 = Ze((c) => c.diffuseColor.mul(1 / Math.PI)), ai = P2, U2 = () => Me(0.25), D2 = Ze(({ dotNH: c }) => Ca.mul(0.5 / Math.PI).add(1).mul(c.pow(Ca))), z2 = Ze(({ lightDirection: c }) => {
  const e = c.add(It).normalize(), t = _t.dot(e).clamp(), r = It.dot(e).clamp(), n = vo({ f0: ls, f90: 1, dotVH: r }), s = U2(), o = D2({ dotNH: t });
  return n.mul(s).mul(o);
});
class B2 extends Gu {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = _t.dot(e).clamp().mul(t);
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: $t.rgb }))), this.specular === !0 && r.directSpecular.addAssign(s.mul(z2({ lightDirection: e })).mul(rN));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: $t })));
  }
}
const Pd = B2, k2 = new vm();
class Pv extends tn {
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(k2), this.setValues(e);
  }
  setupLightingModel() {
    return new Pd(!1);
  }
}
const G2 = Pv;
wn("MeshLambertNodeMaterial", Pv);
const V2 = new ha();
class Uv extends tn {
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(V2), this.setValues(e);
  }
  setupLightingModel() {
    return new Pd();
  }
  setupVariants({ stack: e }) {
    const t = (this.shininessNode ? Me(this.shininessNode) : zy).max(1e-4);
    e.assign(Ca, t);
    const r = this.specularNode || ky;
    e.assign(ls, r);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const j2 = Uv;
wn("MeshPhongNodeMaterial", Uv);
const W2 = Ze(() => {
  const c = ri.dFdx().abs().max(ri.dFdy().abs());
  return c.x.max(c.y).max(c.z);
}), Dv = W2, H2 = Ze((c) => {
  const { roughness: e } = c, t = Dv();
  let r = e.max(0.0525);
  return r = r.add(t), r = r.min(1), r;
}), zv = H2, X2 = Ze((c) => {
  const { alpha: e, dotNL: t, dotNV: r } = c, n = e.pow2(), s = t.mul(n.add(n.oneMinus().mul(r.pow2())).sqrt()), o = r.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt());
  return yo(0.5, s.add(o).max(Yu));
}), Bv = X2, $2 = Ze((c) => {
  const { alpha: e, dotNH: t } = c, r = e.pow2(), n = t.pow2().mul(r.oneMinus()).oneMinus();
  return r.div(n.pow2()).mul(1 / Math.PI);
}), kv = $2, q2 = Ze((c) => {
  const { lightDirection: e, f0: t, f90: r, roughness: n, iridescenceFresnel: s } = c, o = c.normalView || _t, i = n.pow2(), a = e.add(It).normalize(), l = o.dot(e).clamp(), u = o.dot(It).clamp(), h = o.dot(a).clamp(), d = It.dot(a).clamp();
  let f = vo({ f0: t, f90: r, dotVH: d });
  s && (f = $u.mix(f, s));
  const p = Bv({ alpha: i, dotNL: l, dotNV: u }), m = kv({ alpha: i, dotNH: h });
  return f.mul(p).mul(m);
}), Zl = q2, J2 = Ze((c) => {
  const { roughness: e } = c, t = c.dotNV || _t.dot(It).clamp(), r = ot(-1, -0.0275, -0.572, 0.022), n = ot(1, 0.0425, 1.04, -0.04), s = e.mul(r).add(n), o = s.x.mul(s.x).min(t.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return st(-1.04, 1.04).mul(o).add(s.zw);
}), Ud = J2, Y2 = Ze((c) => {
  const { dotNV: e, specularColor: t, specularF90: r, roughness: n } = c, s = Ud({ dotNV: e, roughness: n });
  return t.mul(s.x).add(r.mul(s.y));
}), K2 = Y2, Z2 = Ze(({ f: c, f90: e, dotVH: t }) => {
  const r = t.oneMinus().saturate(), n = r.mul(r), s = r.mul(n, n).clamp(0, 0.9999);
  return c.sub(Fe(e).mul(s)).div(s.oneMinus());
}), Gv = Z2, Q2 = (c, e) => {
  const t = c.pow2(), r = Me(1).div(t), s = e.pow2().oneMinus().max(78125e-7);
  return Me(2).add(r).mul(s.pow(r.mul(0.5))).div(2 * Math.PI);
}, eT = (c, e) => Me(1).div(Me(4).mul(e.add(c).sub(e.mul(c)))), tT = Ze(({ lightDirection: c }) => {
  const e = c.add(It).normalize(), t = _t.dot(c).clamp(), r = _t.dot(It).clamp(), n = _t.dot(e).clamp(), s = Q2(Xu, n), o = eT(r, t);
  return Kr.mul(s).mul(o);
}), nT = tT, sT = As(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), rT = (c) => {
  const e = c.sqrt();
  return Fe(1).add(e).div(Fe(1).sub(e));
}, Kf = (c, e) => c.sub(e).div(c.add(e)).pow2(), oT = (c, e) => {
  const t = c.mul(2 * Math.PI * 1e-9), r = Fe(54856e-17, 44201e-17, 52481e-17), n = Fe(1681e3, 1795300, 2208400), s = Fe(43278e5, 93046e5, 66121e5), o = Me(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let i = r.mul(s.mul(2 * Math.PI).sqrt()).mul(n.mul(t).add(e).cos()).mul(t.pow2().negate().mul(s).exp());
  return i = Fe(i.x.add(o), i.y, i.z).div(10685e-11), sT.mul(i);
}, iT = (c, e, t, r, n) => {
  const s = on(c, e, Qs(0, 0.03, r)), o = c.div(s).pow2().mul(Me(1).sub(t.pow2())), a = Me(1).sub(o).sqrt(), l = Kf(s, c), u = vo({ f0: l, f90: 1, dotVH: t }), h = u.oneMinus(), d = s.lessThan(c).cond(Math.PI, 0), f = Me(Math.PI).sub(d), p = rT(n.clamp(0, 0.9999)), m = Kf(p, s.vec3()), g = vo({ f0: m, f90: 1, dotVH: a }), b = Fe(
    p.x.lessThan(s).cond(Math.PI, 0),
    p.y.lessThan(s).cond(Math.PI, 0),
    p.z.lessThan(s).cond(Math.PI, 0)
  ), v = s.mul(r, a, 2), y = Fe(f).add(b), x = u.mul(g).clamp(1e-5, 0.9999), N = x.sqrt(), w = h.pow2().mul(g).div(Fe(1).sub(x));
  let _ = u.add(w), F = w.sub(h);
  for (let A = 1; A <= 2; ++A) {
    F = F.mul(N);
    const D = oT(Me(A).mul(v), Me(A).mul(y)).mul(2);
    _ = _.add(F.mul(D));
  }
  return _.max(Fe(0));
}, aT = (c, e, t) => {
  const r = c.dot(e).saturate(), n = t.pow2(), s = gr(
    t.lessThan(0.25),
    Me(-339.2).mul(n).add(Me(161.4).mul(t)).sub(25.9),
    Me(-8.48).mul(n).add(Me(14.3).mul(t)).sub(9.95)
  ), o = gr(
    t.lessThan(0.25),
    Me(44).mul(n).sub(Me(23.7).mul(t)).add(3.26),
    Me(1.97).mul(n).sub(Me(3.27).mul(t)).add(0.72)
  );
  return gr(t.lessThan(0.25), 0, Me(0.1).mul(t).sub(0.025)).add(s.mul(r).add(o).exp()).mul(1 / Math.PI).saturate();
}, el = Fe(0.04), tl = Fe(1);
class cT extends Gu {
  constructor(e = !0, t = !0, r = !0) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = r, this.clearcoatRadiance = null, this.clearcoatSpecular = null, this.sheenSpecular = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  init({ reflectedLight: e }) {
    if (this.clearcoat === !0) {
      this.clearcoatRadiance = Fe().temp(), this.clearcoatSpecular = Fe().temp();
      const t = pr.dot(It).clamp(), r = vo({
        dotVH: t,
        f0: el,
        f90: tl
      }), n = e.total, s = n.mul(Wl.mul(r).oneMinus()).add(this.clearcoatSpecular.mul(Wl));
      n.assign(s);
    }
    if (this.sheen === !0) {
      this.sheenSpecular = Fe().temp();
      const t = e.total, r = Kr.r.max(Kr.g).max(Kr.b).mul(0.157).oneMinus(), n = t.mul(r).add(this.sheenSpecular);
      t.assign(n);
    }
    if (this.iridescence === !0) {
      const t = _t.dot(It).clamp();
      this.iridescenceFresnel = iT(Me(1), Ag, t, Cg, ls), this.iridescenceF0 = Gv({ f: this.iridescenceFresnel, f90: 1, dotVH: t });
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, r = Me(1)) {
    const n = Ud({ roughness: ao }), o = (this.iridescenceF0 ? $u.mix(ls, this.iridescenceF0) : ls).mul(n.x).add(r.mul(n.y)), a = n.x.add(n.y).oneMinus(), l = ls.add(ls.oneMinus().mul(0.047619)), u = o.mul(l).div(a.mul(l).oneMinus());
    e.addAssign(o), t.addAssign(u.mul(a));
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = _t.dot(e).clamp().mul(t);
    if (this.sheen === !0 && this.sheenSpecular.addAssign(s.mul(nT({ lightDirection: e }))), this.clearcoat === !0) {
      const i = pr.dot(e).clamp().mul(t);
      this.clearcoatSpecular.addAssign(i.mul(Zl({ lightDirection: e, f0: el, f90: tl, roughness: Aa, normalView: pr })));
    }
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: $t.rgb }))), r.directSpecular.addAssign(s.mul(Zl({ lightDirection: e, f0: ls, f90: 1, roughness: ao, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: $t })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: r }) {
    if (this.sheen === !0 && this.sheenSpecular.addAssign(t.mul(
      Kr,
      aT(_t, It, Xu)
    )), this.clearcoat === !0) {
      const l = pr.dot(It).clamp(), u = K2({
        dotNV: l,
        specularColor: el,
        specularF90: tl,
        roughness: Aa
      });
      this.clearcoatSpecular.addAssign(this.clearcoatRadiance.mul(u));
    }
    const n = Fe().temp(), s = Fe().temp(), o = t.mul(1 / Math.PI);
    this.computeMultiscattering(n, s);
    const i = n.add(s), a = $t.mul(i.r.max(i.g).max(i.b).oneMinus());
    r.indirectSpecular.addAssign(e.mul(n)), r.indirectSpecular.addAssign(s.mul(o)), r.indirectDiffuse.addAssign(a.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
    const n = _t.dot(It).clamp().add(e), s = ao.mul(-16).oneMinus().negate().exp2(), o = e.sub(n.pow(s).oneMinus()).clamp();
    t.indirectDiffuse.mulAssign(e), t.indirectSpecular.mulAssign(o);
  }
}
const Dd = cT, lT = new jn();
class Vv extends tn {
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(lT), this.setValues(e);
  }
  setupLightingModel() {
    return new Dd(!1, !1);
  }
  setupVariants({ stack: e }) {
    const t = this.metalnessNode ? Me(this.metalnessNode) : Vy;
    e.assign(Mg, t);
    let r = this.roughnessNode ? Me(this.roughnessNode) : Gy;
    r = zv({ roughness: r }), e.assign(ao, r);
    const n = on(Fe(0.04), $t.rgb, t);
    e.assign(ls, n), e.assign($t, ot($t.rgb.mul(t.oneMinus()), $t.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const zd = Vv;
wn("MeshStandardNodeMaterial", Vv);
const uT = new Es();
class jv extends zd {
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.setDefaultValues(uT), this.setValues(e);
  }
  setupLightingModel() {
    return new Dd();
  }
  setupVariants(e) {
    super.setupVariants(e);
    const { stack: t } = e, r = this.clearcoatNode ? Me(this.clearcoatNode) : iN, n = this.clearcoatRoughnessNode ? Me(this.clearcoatRoughnessNode) : aN;
    t.assign(Wl, r), t.assign(Aa, n);
    const s = this.sheenNode ? Fe(this.sheenNode) : Wy, o = this.sheenRoughnessNode ? Me(this.sheenRoughnessNode) : Hy;
    t.assign(Kr, s), t.assign(Xu, o);
    const i = this.iridescenceNode ? Me(this.iridescenceNode) : cN, a = this.iridescenceIORNode ? Me(this.iridescenceIORNode) : lN, l = this.iridescenceThicknessNode ? Me(this.iridescenceThicknessNode) : uN;
    t.assign($u, i), t.assign(Ag, a), t.assign(Cg, l);
  }
  setupNormal(e) {
    super.setupNormal(e);
    const t = this.clearcoatNormalNode ? Fe(this.clearcoatNormalNode) : IN;
    e.stack.assign(pr, t);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, super.copy(e);
  }
}
const Wv = jv;
wn("MeshPhysicalNodeMaterial", jv);
const hT = new xm();
class Hv extends tn {
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.normals = !1, this.transparent = !0, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.sizeNode = null, this.positionNode = null, this.setDefaultValues(hT), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
const Bd = Hv;
wn("PointsNodeMaterial", Hv);
const dT = new Mx();
class Xv extends tn {
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this.normals = !1, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(dT), this.setValues(e);
  }
  setupPosition({ object: e, context: t }) {
    const { positionNode: r, rotationNode: n, scaleNode: s } = this, o = bn;
    let i = Nr.mul(Fe(r || 0)), a = st(si[0].xyz.length(), si[1].xyz.length());
    s !== null && (a = a.mul(s));
    let l = o.xy;
    e.center && e.center.isVector2 === !0 && (l = l.sub(Ft(e.center).sub(0.5))), l = l.mul(a);
    const u = Me(n || jy), h = u.cos(), d = u.sin(), f = st(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      st(h, d.negate()).dot(l),
      st(d, h).dot(l)
    );
    i = ot(i.xy.add(f), i.zw);
    const p = Ns.mul(i);
    return t.vertex = o, p;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
}
const $v = Xv;
wn("SpriteNodeMaterial", Xv);
const fT = gi.createMaterialFromType;
gi.createMaterialFromType = function(c) {
  const e = wo(c);
  return e !== void 0 ? e : fT.call(this, c);
};
class pT extends gi {
  constructor(e) {
    super(e), this.nodes = {};
  }
  parse(e) {
    const t = super.parse(e), r = this.nodes, n = e.inputNodes;
    for (const s in n) {
      const o = n[s];
      t[s] = r[o];
    }
    return t;
  }
  setNodes(e) {
    return this.nodes = e, this;
  }
}
const Ia = pT;
class mT extends Ax {
  constructor(e) {
    super(e), this._nodesJSON = null;
  }
  parse(e, t) {
    this._nodesJSON = e.nodes;
    const r = super.parse(e, t);
    return this._nodesJSON = null, r;
  }
  parseNodes(e, t) {
    if (e !== void 0) {
      const r = new Av();
      return r.setTextures(t), r.parseNodes(e);
    }
    return {};
  }
  parseMaterials(e, t) {
    const r = {};
    if (e !== void 0) {
      const n = this.parseNodes(this._nodesJSON, t), s = new Ia();
      s.setTextures(t), s.setNodes(n);
      for (let o = 0, i = e.length; o < i; o++) {
        const a = e[o];
        r[a.uuid] = s.parse(a);
      }
    }
    return r;
  }
}
const gT = mT;
class yT {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
const vT = yT;
class qv {
  constructor(e, t, r = "", n = "") {
    this.type = e, this.inputs = t, this.name = r, this.presicion = n;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
qv.isNodeFunction = !0;
const xT = qv, bT = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, NT = /[a-z_0-9]+/ig, Zf = "#pragma main", wT = (c) => {
  c = c.trim();
  const e = c.indexOf(Zf), t = e !== -1 ? c.slice(e + Zf.length) : c, r = t.match(bT);
  if (r !== null && r.length === 5) {
    const n = r[4], s = [];
    let o = null;
    for (; (o = NT.exec(n)) !== null; )
      s.push(o);
    const i = [];
    let a = 0;
    for (; a < s.length; ) {
      const p = s[a][0] === "const";
      p === !0 && a++;
      let m = s[a][0];
      m === "in" || m === "out" || m === "inout" ? a++ : m = "";
      const g = s[a++][0];
      let b = Number.parseInt(s[a][0]);
      Number.isNaN(b) === !1 ? a++ : b = null;
      const v = s[a++][0];
      i.push(new Hh(g, v, b, m, p));
    }
    const l = t.substring(r[0].length), u = r[3] !== void 0 ? r[3] : "", h = r[2], d = r[1] !== void 0 ? r[1] : "", f = e !== -1 ? c.slice(0, e) : "";
    return {
      type: h,
      inputs: i,
      name: u,
      presicion: d,
      inputsCode: n,
      blockCode: l,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class TT extends xT {
  constructor(e) {
    const { type: t, inputs: r, name: n, presicion: s, inputsCode: o, blockCode: i, headerCode: a } = wT(e);
    super(t, r, n, s), this.inputsCode = o, this.blockCode = i, this.headerCode = a;
  }
  getCode(e = this.name) {
    let t;
    const r = this.blockCode;
    if (r !== "") {
      const { type: n, inputsCode: s, headerCode: o, presicion: i } = this;
      let a = `${n} ${e} ( ${s.trim()} )`;
      i !== "" && (a = `${i} ${a}`), t = o + a + r;
    } else
      t = "";
    return t;
  }
}
const ST = TT;
class _T extends vT {
  parseFunction(e) {
    return new ST(e);
  }
}
const Jv = _T, MT = gd(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`), rs = [MT], Yv = cn("float mx_perlin_noise_float( any p )", rs), AT = cn("vec2 mx_perlin_noise_vec2( any p )", rs), Kv = cn("vec3 mx_perlin_noise_vec3( any p )", rs), CT = cn("float mx_cell_noise_float( vec3 p )", rs), ET = cn("float mx_worley_noise_float( any p, float jitter, int metric )", rs), RT = cn("float mx_worley_noise_vec2( any p, float jitter, int metric )", rs), FT = cn("float mx_worley_noise_vec3( any p, float jitter, int metric )", rs), LT = cn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", rs), OT = cn("float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", rs), IT = cn("float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", rs), PT = cn("float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", rs), UT = cn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`), DT = cn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`), zT = gd(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`), BT = [zT], kT = cn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", BT), Zv = (c, e) => {
  c = Me(c), e = Me(e);
  const t = st(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476);
  return Qs(c.sub(t), c.add(t), e);
}, Qv = (c, e, t, r) => on(c, e, t[r].clamp()), GT = (c, e, t = vt()) => Qv(c, e, t, "x"), VT = (c, e, t = vt()) => Qv(c, e, t, "y"), e1 = (c, e, t, r, n) => on(c, e, Zv(t, r[n])), jT = (c, e, t, r = vt()) => e1(c, e, t, r, "x"), WT = (c, e, t, r = vt()) => e1(c, e, t, r, "y"), HT = (c = 1, e = 0, t = vt()) => t.mul(c).add(e), XT = (c, e = 1) => (c = Me(c), c.abs().pow(e).mul(c.sign())), $T = (c, e = 1, t = 0.5) => Me(c).sub(t).mul(e).add(t), qT = (c = vt(), e = 1, t = 0) => Yv(c.convert("vec2|vec3")).mul(e).add(t), JT = (c = vt(), e = 1, t = 0) => AT(c.convert("vec2|vec3")).mul(e).add(t), YT = (c = vt(), e = 1, t = 0) => Kv(c.convert("vec2|vec3")).mul(e).add(t), KT = (c = vt(), e = 1, t = 0) => (c = c.convert("vec2|vec3"), ot(Kv(c), Yv(c.add(st(19, 73)))).mul(e).add(t)), ZT = (c = vt(), e = 1) => ET(c.convert("vec2|vec3"), e, 1), QT = (c = vt(), e = 1) => RT(c.convert("vec2|vec3"), e, 1), eS = (c = vt(), e = 1) => FT(c.convert("vec2|vec3"), e, 1), tS = (c = vt()) => CT(c.convert("vec2|vec3")), nS = (c = vt(), e = 3, t = 2, r = 0.5, n = 1) => LT(c, e, t, r).mul(n), sS = (c = vt(), e = 3, t = 2, r = 0.5, n = 1) => OT(c, e, t, r).mul(n), rS = (c = vt(), e = 3, t = 2, r = 0.5, n = 1) => IT(c, e, t, r).mul(n), oS = (c = vt(), e = 3, t = 2, r = 0.5, n = 1) => PT(c, e, t, r).mul(n), t1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AONode: Rh,
  AmbientLightNode: T2,
  AnalyticLightNode: or,
  ArrayElementNode: Ya,
  ArrayUniformNode: bg,
  AttributeNode: Uu,
  BRDF_GGX: Zl,
  BRDF_Lambert: ai,
  BitangentNode: Qr,
  BlendModeNode: to,
  BufferAttributeNode: PN,
  BufferNode: Th,
  BumpMapNode: LN,
  BypassNode: wg,
  CacheNode: Tg,
  CameraNode: lh,
  CheckerNode: _v,
  CodeNode: md,
  ColorAdjustmentNode: Ho,
  ColorSpaceNode: jo,
  ComputeNode: bv,
  CondNode: kh,
  ConstNode: Ln,
  ContextNode: ku,
  ConvertNode: Ka,
  CubeTextureNode: p0,
  DFGApprox: Ud,
  D_GGX: kv,
  DirectionalLightNode: x2,
  DiscardNode: gw,
  EPSILON: Yu,
  EnvironmentNode: zh,
  EquirectUVNode: b0,
  ExpressionNode: Py,
  ExtendedMaterialNode: ON,
  F_Schlick: vo,
  FogExp2Node: yv,
  FogNode: vc,
  FogRangeNode: mv,
  FrontFacingNode: Ky,
  FunctionCallNode: d2,
  FunctionNode: uv,
  GLSLNodeParser: Jv,
  HashNode: mw,
  HemisphereLightNode: Sv,
  IESSpotLightNode: w2,
  INFINITY: Kb,
  IndexNode: Vb,
  InstanceNode: UN,
  JoinNode: jm,
  LightNode: v2,
  LightingContextNode: kN,
  LightingModel: Gu,
  LightingNode: Ni,
  LightsNode: y0,
  Line2NodeMaterial: R2,
  LineBasicNodeMaterial: Ev,
  LineDashedNodeMaterial: C2,
  LineMaterialNode: Mw,
  LoopNode: sw,
  MatcapUVNode: E0,
  MaterialNode: Yn,
  MaterialReferenceNode: Uy,
  MathNode: ke,
  MaxMipLevelNode: N0,
  MeshBasicNodeMaterial: Iv,
  MeshLambertNodeMaterial: G2,
  MeshNormalNodeMaterial: L2,
  MeshPhongNodeMaterial: j2,
  MeshPhysicalNodeMaterial: Wv,
  MeshStandardNodeMaterial: zd,
  ModelNode: xN,
  ModelViewProjectionNode: s0,
  MorphNode: DN,
  Node: Le,
  NodeAttribute: Ma,
  NodeBuilder: S0,
  NodeCache: nc,
  NodeCode: Wu,
  NodeFrame: Wh,
  NodeFunctionInput: Hh,
  NodeKeywords: Hu,
  NodeLoader: Av,
  NodeMaterial: tn,
  NodeMaterialLoader: Ia,
  NodeObjectLoader: gT,
  NodeShaderStage: kl,
  NodeType: wb,
  NodeUniform: Vu,
  NodeUpdateType: ut,
  NodeUtils: Tb,
  NodeVar: rc,
  NodeVarying: ju,
  NormalMapNode: Qy,
  NormalNode: Wo,
  Object3DNode: gn,
  OperatorNode: Og,
  OscNode: eo,
  OutputStructNode: fw,
  PackingNode: _w,
  PhongLightingModel: Pd,
  PhysicalLightingModel: Dd,
  PointLightNode: wv,
  PointUVNode: H0,
  PointsNodeMaterial: Bd,
  PositionNode: Bs,
  PosterizeNode: nv,
  PropertyNode: _g,
  RangeNode: xv,
  ReferenceNode: cc,
  ReflectVectorNode: d0,
  RemapNode: L0,
  RotateUVNode: P0,
  SceneNode: Ew,
  Schlick_to_F0: Gv,
  ScriptableNode: g2,
  ScriptableValueNode: p2,
  SetNode: Xm,
  ShaderNode: Ms,
  SkinningNode: l0,
  SpecularMIPLevelNode: w0,
  SplitNode: Ta,
  SpotLightNode: Tv,
  SpriteNodeMaterial: $v,
  SpriteSheetUVNode: D0,
  StackNode: rw,
  StorageBufferNode: Lw,
  TBNViewMatrix: e0,
  TangentNode: Zr,
  TempNode: Mt,
  TextureBicubicNode: Cw,
  TextureNode: vi,
  TextureStoreNode: Iw,
  TimerNode: R0,
  ToneMappingNode: rv,
  TriplanarTexturesNode: B0,
  UVNode: Rg,
  UniformNode: nt,
  UserDataNode: Uw,
  V_GGX_SmithCorrelated: Bv,
  VarNode: $y,
  VaryingNode: Ng,
  ViewportDepthNode: a2,
  ViewportDepthTextureNode: r2,
  ViewportNode: ks,
  ViewportSharedTextureNode: s2,
  ViewportTextureNode: ud,
  abs: ti,
  acos: iy,
  add: xn,
  addLightNode: _r,
  addNodeClass: re,
  addNodeElement: W,
  addNodeMaterial: wn,
  and: kg,
  arrayBuffer: gg,
  asin: oy,
  assign: Ju,
  atan: ay,
  atan2: gy,
  attribute: Ot,
  backgroundBlurriness: Rw,
  backgroundIntensity: Fw,
  bitAnd: jg,
  bitOr: Wg,
  bitXor: Hg,
  bitangentGeometry: _N,
  bitangentLocal: MN,
  bitangentView: Jy,
  bitangentWorld: AN,
  bmat3: hg,
  bmat4: pg,
  bool: Qm,
  buffer: Sh,
  bufferAttribute: bi,
  bumpMap: t0,
  burn: $0,
  bvec2: ng,
  bvec3: og,
  bvec4: cg,
  bypass: tc,
  cache: _a,
  call: lv,
  cameraFar: pa,
  cameraNear: fa,
  cameraNormalMatrix: gN,
  cameraPosition: vN,
  cameraProjectionMatrix: Ns,
  cameraViewMatrix: Rs,
  cameraWorldMatrix: yN,
  ceil: Ku,
  checker: Mv,
  clamp: ni,
  code: yc,
  color: Km,
  colorSpaceToLinear: ac,
  colorToDirection: F0,
  compute: Nv,
  cond: gr,
  context: Zn,
  convert: vg,
  cos: sy,
  createNodeFromType: Vl,
  createNodeMaterialFromType: wo,
  cross: Ty,
  cubeTexture: hc,
  dFdx: Zu,
  dFdy: Qu,
  defaultBuildStages: Um,
  defaultShaderStages: Jr,
  degrees: Jg,
  densityFog: vv,
  depth: c2,
  depthTexture: l2,
  difference: wy,
  diffuseColor: $t,
  directionToColor: Kh,
  discard: C0,
  distance: Ny,
  div: yo,
  dodge: q0,
  dot: js,
  dynamicBufferAttribute: o0,
  element: yg,
  equal: Pg,
  equirectUV: dc,
  exp: Yg,
  exp2: Kg,
  expression: No,
  faceDirection: gh,
  faceForward: Ry,
  float: Me,
  floor: oc,
  fog: pv,
  fract: ic,
  frameId: bw,
  frontFacing: Zy,
  fwidth: my,
  getConstNodeType: Ym,
  getDistanceAttenuation: Ad,
  getGeometryRoughness: Dv,
  getRoughness: zv,
  global: ga,
  glsl: gd,
  glslFn: cn,
  greaterThan: Dg,
  greaterThanEqual: Bg,
  hash: A0,
  hue: Q0,
  imat3: lg,
  imat4: dg,
  instance: c0,
  instanceIndex: Sg,
  instancedBufferAttribute: i0,
  instancedDynamicBufferAttribute: a0,
  int: Sa,
  inverseSqrt: ty,
  ivec2: eg,
  ivec3: sg,
  ivec4: ig,
  js: u2,
  label: sc,
  length: ly,
  lessThan: Ug,
  lessThanEqual: zg,
  lightTargetDirection: Md,
  lightingContext: Lh,
  lights: BN,
  lightsWithoutWrap: v0,
  linearToColorSpace: Ly,
  linearTosRGB: Oy,
  log: Zg,
  log2: Qg,
  loop: Vh,
  lumaCoeffs: ev,
  luminance: tv,
  mat3: As,
  mat4: Lu,
  matcapUV: yw,
  materialAlphaTest: Dy,
  materialColor: ih,
  materialEmissive: By,
  materialLineDashOffset: ql,
  materialLineDashSize: td,
  materialLineGapSize: nd,
  materialLineScale: Oa,
  materialLineWidth: Xr,
  materialMetalness: Vy,
  materialNormal: n0,
  materialOpacity: ah,
  materialReference: lo,
  materialReflectivity: oN,
  materialRotation: jy,
  materialRoughness: Gy,
  materialSheen: Wy,
  materialSheenRoughness: Hy,
  materialShininess: zy,
  materialSpecularColor: ky,
  max: vy,
  maxMipLevel: Ph,
  metalness: Mg,
  min: yy,
  mix: on,
  mod: eh,
  modelDirection: bN,
  modelNormalMatrix: uh,
  modelPosition: NN,
  modelScale: wN,
  modelViewMatrix: Nr,
  modelViewPosition: TN,
  modelViewProjection: r0,
  modelWorldMatrix: si,
  morph: h0,
  mul: Qt,
  mx_aastep: Zv,
  mx_cell_noise_float: tS,
  mx_contrast: $T,
  mx_fractal_noise_float: nS,
  mx_fractal_noise_vec2: sS,
  mx_fractal_noise_vec3: rS,
  mx_fractal_noise_vec4: oS,
  mx_hsvtorgb: UT,
  mx_noise_float: qT,
  mx_noise_vec2: JT,
  mx_noise_vec3: YT,
  mx_noise_vec4: KT,
  mx_ramplr: GT,
  mx_ramptb: VT,
  mx_rgbtohsv: DT,
  mx_safepower: XT,
  mx_splitlr: jT,
  mx_splittb: WT,
  mx_srgb_texture_to_lin_rec709: kT,
  mx_transform_uv: HT,
  mx_worley_noise_float: ZT,
  mx_worley_noise_vec2: QT,
  mx_worley_noise_vec3: eS,
  negate: uy,
  nodeArray: mr,
  nodeImmutable: le,
  nodeObject: Ae,
  nodeObjects: ec,
  nodeProxy: J,
  normalGeometry: ri,
  normalLocal: wr,
  normalMap: Hl,
  normalView: ds,
  normalWorld: lc,
  normalize: Fn,
  objectDirection: hN,
  objectNormalMatrix: fN,
  objectPosition: Fa,
  objectScale: mN,
  objectViewMatrix: dN,
  objectViewPosition: ch,
  objectWorldMatrix: pN,
  oneMinus: hy,
  or: Gg,
  orthographicDepthToViewZ: o2,
  oscSawtooth: Sw,
  oscSine: Nw,
  oscSquare: ww,
  oscTriangle: Tw,
  output: Eg,
  outputStruct: pw,
  overlay: J0,
  perspectiveDepthToViewZ: cv,
  pointUV: X0,
  positionGeometry: pn,
  positionLocal: bn,
  positionView: ts,
  positionViewDirection: It,
  positionWorld: fh,
  positionWorldDirection: ph,
  posterize: sv,
  pow: th,
  pow2: Sy,
  pow3: _y,
  pow4: My,
  property: Ts,
  radians: qg,
  range: y2,
  rangeFog: gv,
  reciprocal: fy,
  reference: Cs,
  reflect: by,
  reflectVector: f0,
  refract: Ey,
  remainder: Ig,
  remap: O0,
  remapClamp: I0,
  rotateUV: U0,
  roughness: ao,
  round: dy,
  sRGBToLinear: Iy,
  sampler: sN,
  saturate: Cy,
  saturation: K0,
  screen: Y0,
  scriptable: fv,
  scriptableValue: Xo,
  shader: zb,
  shaderStages: Dm,
  shiftLeft: Xg,
  shiftRight: $g,
  shininess: Ca,
  sign: cy,
  sin: ny,
  skinning: u0,
  smoothstep: Qs,
  specularColor: ls,
  specularMIPLevel: Dh,
  split: Bb,
  spritesheetUV: z0,
  sqrt: ey,
  stack: $l,
  step: xy,
  storage: Ow,
  string: mg,
  sub: Ra,
  tan: ry,
  tangentGeometry: ii,
  tangentLocal: uc,
  tangentView: xi,
  tangentWorld: qy,
  temp: oi,
  texture: en,
  textureBicubic: W0,
  textureStore: Pw,
  timerDelta: xw,
  timerGlobal: vw,
  timerLocal: Yh,
  toneMapping: Kw,
  transformDirection: Ay,
  transformedBitangentView: Yy,
  transformedBitangentWorld: CN,
  transformedClearcoatNormalView: pr,
  transformedNormalView: _t,
  transformedNormalWorld: Xy,
  transformedTangentView: dh,
  transformedTangentWorld: SN,
  triplanarTexture: G0,
  triplanarTextures: k0,
  trunc: py,
  tslFn: Ze,
  uint: Zm,
  umat3: ug,
  umat4: fg,
  uniform: Ft,
  userData: Dw,
  uv: vt,
  uvec2: tg,
  uvec3: rg,
  uvec4: ag,
  varying: ct,
  vec2: st,
  vec3: Fe,
  vec4: ot,
  vectorComponents: qa,
  vertexIndex: jb,
  vibrance: Z0,
  viewZToOrthographicDepth: Kl,
  viewZToPerspectiveDepth: i2,
  viewport: ma,
  viewportBottomLeft: e2,
  viewportBottomRight: n2,
  viewportCoordinate: Zw,
  viewportDepthTexture: fd,
  viewportMipTexture: iv,
  viewportResolution: Qw,
  viewportSharedTexture: av,
  viewportTexture: ov,
  viewportTopLeft: mc,
  viewportTopRight: t2,
  wgsl: h2,
  wgslFn: f2,
  xor: Vg
}, Symbol.toStringTag, { value: "Module" })), n1 = {
  BitangentNodeScope: {
    LOCAL: Qr.LOCAL,
    VIEW: Qr.VIEW,
    WORLD: Qr.WORLD,
    GEOMETRY: Qr.GEOMETRY
  },
  Blending: { AdditiveBlending: M.AdditiveBlending, CustomBlending: M.CustomBlending, MultiplyBlending: M.MultiplyBlending, NoBlending: M.NoBlending, NormalBlending: M.NormalBlending, SubtractiveBlending: M.SubtractiveBlending },
  BlendingDstFactor: { DstAlphaFactor: M.DstAlphaFactor, DstColorFactor: M.DstColorFactor, OneFactor: M.OneFactor, OneMinusDstAlphaFactor: M.OneMinusDstAlphaFactor, OneMinusDstColorFactor: M.OneMinusDstColorFactor, OneMinusSrcAlphaFactor: M.OneMinusSrcAlphaFactor, OneMinusSrcColorFactor: M.OneMinusSrcColorFactor, SrcAlphaFactor: M.SrcAlphaFactor, SrcColorFactor: M.SrcColorFactor, ZeroFactor: M.ZeroFactor },
  BlendingSrcFactor: { SrcAlphaSaturateFactor: M.SrcAlphaSaturateFactor },
  BlendingEquation: { AddEquation: M.AddEquation, MaxEquation: M.MaxEquation, MinEquation: M.MinEquation, ReverseSubtractEquation: M.ReverseSubtractEquation, SubtractEquation: M.SubtractEquation },
  BlendMode: {
    BURN: to.BURN,
    DODGE: to.DODGE,
    SCREEN: to.SCREEN,
    OVERLAY: to.OVERLAY
  },
  CameraNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION,
    PROJECTION_MATRIX: lh.PROJECTION_MATRIX
  },
  ColorAdjustmentMethod: {
    SATURATION: Ho.SATURATION,
    VIBRANCE: Ho.VIBRANCE,
    HUE: Ho.HUE
  },
  ColorSpace: { DisplayP3ColorSpace: M.DisplayP3ColorSpace, LinearDisplayP3ColorSpace: M.LinearDisplayP3ColorSpace, LinearSRGBColorSpace: M.LinearSRGBColorSpace, NoColorSpace: M.NoColorSpace, SRGBColorSpace: M.SRGBColorSpace },
  ColorSpaceNodeMethod: {
    LINEAR_TO_LINEAR: jo.LINEAR_TO_LINEAR,
    LINEAR_TO_sRGB: jo.LINEAR_TO_sRGB,
    sRGB_TO_LINEAR: jo.sRGB_TO_LINEAR
  },
  Combine: { AddOperation: M.AddOperation, MixOperation: M.MixOperation, MultiplyOperation: M.MultiplyOperation },
  CompressedPixelFormat: { RED_GREEN_RGTC2_Format: M.RED_GREEN_RGTC2_Format, RED_RGTC1_Format: M.RED_RGTC1_Format, RGBA_ASTC_10x10_Format: M.RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format: M.RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format: M.RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format: M.RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format: M.RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format: M.RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format: M.RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format: M.RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format: M.RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format: M.RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format: M.RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format: M.RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format: M.RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format: M.RGBA_ASTC_8x8_Format, RGBA_BPTC_Format: M.RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: M.RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format: M.RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format: M.RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format: M.RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format: M.RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format: M.RGBA_S3TC_DXT5_Format, RGB_BPTC_SIGNED_Format: M.RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format: M.RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format: M.RGB_ETC1_Format, RGB_ETC2_Format: M.RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format: M.RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format: M.RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: M.RGB_S3TC_DXT1_Format, SIGNED_RED_GREEN_RGTC2_Format: M.SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format: M.SIGNED_RED_RGTC1_Format },
  CoordinateSystem: { WebGLCoordinateSystem: M.WebGLCoordinateSystem, WebGPUCoordinateSystem: M.WebGPUCoordinateSystem },
  CubeTextureMapping: { CubeReflectionMapping: M.CubeReflectionMapping, CubeRefractionMapping: M.CubeRefractionMapping, CubeUVReflectionMapping: M.CubeUVReflectionMapping },
  DeepTexturePixelFormat: { DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat },
  DepthModes: { AlwaysDepth: M.AlwaysDepth, EqualDepth: M.EqualDepth, GreaterDepth: M.GreaterDepth, GreaterEqualDepth: M.GreaterEqualDepth, LessDepth: M.LessDepth, LessEqualDepth: M.LessEqualDepth, NeverDepth: M.NeverDepth, NotEqualDepth: M.NotEqualDepth },
  DepthPackingStrategies: { BasicDepthPacking: M.BasicDepthPacking, RGBADepthPacking: M.RGBADepthPacking },
  GLSLVersion: { GLSL1: M.GLSL1, GLSL3: M.GLSL3 },
  MagnificationTextureFilter: { LinearFilter: M.LinearFilter, NearestFilter: M.NearestFilter },
  Mapping: { EquirectangularReflectionMapping: M.EquirectangularReflectionMapping, EquirectangularRefractionMapping: M.EquirectangularRefractionMapping, UVMapping: M.UVMapping },
  MaterialNodeScope: {
    ALPHA_TEST: Yn.ALPHA_TEST,
    COLOR: Yn.COLOR,
    OPACITY: Yn.OPACITY,
    ROUGHNESS: Yn.ROUGHNESS,
    METALNESS: Yn.METALNESS,
    EMISSIVE: Yn.EMISSIVE,
    ROTATION: Yn.ROTATION
  },
  MathNodeMethod1: {
    RADIANS: ke.RADIANS,
    DEGREES: ke.DEGREES,
    EXP: ke.EXP,
    EXP2: ke.EXP2,
    LOG: ke.LOG,
    LOG2: ke.LOG2,
    SQRT: ke.SQRT,
    INVERSE_SQRT: ke.INVERSE_SQRT,
    FLOOR: ke.FLOOR,
    CEIL: ke.CEIL,
    NORMALIZE: ke.NORMALIZE,
    FRACT: ke.FRACT,
    SIN: ke.SIN,
    COS: ke.COS,
    TAN: ke.TAN,
    ASIN: ke.ASIN,
    ACOS: ke.ACOS,
    ATAN: ke.ATAN,
    ABS: ke.ABS,
    SIGN: ke.SIGN,
    LENGTH: ke.LENGTH,
    NEGATE: ke.NEGATE,
    ONE_MINUS: ke.ONE_MINUS,
    DFDX: ke.DFDX,
    DFDY: ke.DFDY,
    ROUND: ke.ROUND
  },
  MathNodeMethod2: {
    ATAN2: ke.ATAN2,
    MIN: ke.MIN,
    MAX: ke.MAX,
    MOD: ke.MOD,
    STEP: ke.STEP,
    REFLECT: ke.REFLECT,
    DISTANCE: ke.DISTANCE,
    DOT: ke.DOT,
    CROSS: ke.CROSS,
    POW: ke.POW,
    TRANSFORM_DIRECTION: ke.TRANSFORM_DIRECTION
  },
  MathNodeMethod3: {
    MIX: ke.MIX,
    CLAMP: ke.CLAMP,
    REFRACT: ke.REFRACT,
    SMOOTHSTEP: ke.SMOOTHSTEP,
    FACEFORWARD: ke.FACEFORWARD
  },
  MinificationTextureFilter: { LinearFilter: M.LinearFilter, LinearMipMapLinearFilter: M.LinearMipMapLinearFilter, LinearMipMapNearestFilter: M.LinearMipMapNearestFilter, LinearMipmapLinearFilter: M.LinearMipmapLinearFilter, LinearMipmapNearestFilter: M.LinearMipmapNearestFilter, NearestFilter: M.NearestFilter, NearestMipMapLinearFilter: M.NearestMipMapLinearFilter, NearestMipMapNearestFilter: M.NearestMipMapNearestFilter, NearestMipmapLinearFilter: M.NearestMipmapLinearFilter, NearestMipmapNearestFilter: M.NearestMipmapNearestFilter },
  NodeTypeOption: "void,bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","),
  NormalMapTypes: { ObjectSpaceNormalMap: M.ObjectSpaceNormalMap, TangentSpaceNormalMap: M.TangentSpaceNormalMap },
  NormalNodeScope: {
    GEOMETRY: Wo.GEOMETRY,
    LOCAL: Wo.LOCAL,
    VIEW: Wo.VIEW
  },
  Object3DNodeScope: {
    VIEW_MATRIX: gn.VIEW_MATRIX,
    NORMAL_MATRIX: gn.NORMAL_MATRIX,
    WORLD_MATRIX: gn.WORLD_MATRIX,
    POSITION: gn.POSITION,
    VIEW_POSITION: gn.VIEW_POSITION
  },
  OperatorNodeOp: ["=", "%", "&", "|", "^", ">>", "<<", "==", "&&", "||", "^^", "<", ">", "<=", ">=", "+", "-", "*", "/"],
  OscNodeMethod: {
    SINE: eo.SINE,
    SQUARE: eo.SQUARE,
    TRIANGLE: eo.TRIANGLE,
    SAWTOOTH: eo.SAWTOOTH
  },
  PixelFormatGPU: ["ALPHA", "DEPTH24_STENCIL8", "DEPTH32F_STENCIL8", "DEPTH_COMPONENT16", "DEPTH_COMPONENT24", "DEPTH_COMPONENT32F", "LUMINANCE", "LUMINANCE_ALPHA", "R11F_G11F_B10F", "R16F", "R16I", "R16UI", "R32F", "R32I", "R32UI", "R8", "R8I", "R8UI", "R8_SNORM", "RED_INTEGER", "RG16F", "RG16I", "RG16UI", "RG32F", "RG32I", "RG32UI", "RG8", "RG8I", "RG8UI", "RG8_SNORM", "RGB", "RGB10_A2", "RGB10_A2UI", "RGB16F", "RGB16I", "RGB16UI", "RGB32F", "RGB32I", "RGB32UI", "RGB565", "RGB5_A1", "RGB8", "RGB8I", "RGB8UI", "RGB8_SNORM", "RGB9_E5", "RGBA", "RGBA16F", "RGBA16I", "RGBA16UI", "RGBA32F", "RGBA32I", "RGBA32UI", "RGBA4", "RGBA8", "RGBA8I", "RGBA8UI", "RGBA8_SNORM", "SRGB8", "SRGB8_ALPHA8"],
  PositionNodeScope: {
    GEOMETRY: Bs.GEOMETRY,
    LOCAL: Bs.LOCAL,
    WORLD: Bs.WORLD,
    WORLD_DIRECTION: Bs.WORLD_DIRECTION,
    VIEW: Bs.VIEW,
    VIEW_DIRECTION: Bs.VIEW_DIRECTION
  },
  Precision: ["highp", "mediump", "lowp"],
  Side: { BackSide: M.BackSide, DoubleSide: M.DoubleSide, FrontSide: M.FrontSide, TwoPassDoubleSide: M.TwoPassDoubleSide },
  StencilFunc: { AlwaysStencilFunc: M.AlwaysStencilFunc, EqualStencilFunc: M.EqualStencilFunc, GreaterEqualStencilFunc: M.GreaterEqualStencilFunc, GreaterStencilFunc: M.GreaterStencilFunc, LessEqualStencilFunc: M.LessEqualStencilFunc, LessStencilFunc: M.LessStencilFunc, NeverStencilFunc: M.NeverStencilFunc, NotEqualStencilFunc: M.NotEqualStencilFunc },
  StencilOp: { DecrementStencilOp: M.DecrementStencilOp, DecrementWrapStencilOp: M.DecrementWrapStencilOp, IncrementStencilOp: M.IncrementStencilOp, IncrementWrapStencilOp: M.IncrementWrapStencilOp, InvertStencilOp: M.InvertStencilOp, KeepStencilOp: M.KeepStencilOp, ReplaceStencilOp: M.ReplaceStencilOp, ZeroStencilOp: M.ZeroStencilOp },
  TangentNodeScope: {
    LOCAL: Zr.LOCAL,
    VIEW: Zr.VIEW,
    WORLD: Zr.WORLD,
    GEOMETRY: Zr.GEOMETRY
  },
  TextureComparisonFunction: { AlwaysCompare: M.AlwaysCompare, EqualCompare: M.EqualCompare, GreaterCompare: M.GreaterCompare, GreaterEqualCompare: M.GreaterEqualCompare, LessCompare: M.LessCompare, LessEqualCompare: M.LessEqualCompare, NeverCompare: M.NeverCompare, NotEqualCompare: M.NotEqualCompare },
  TextureDataType: { ByteType: M.ByteType, FloatType: M.FloatType, HalfFloatType: M.HalfFloatType, IntType: M.IntType, ShortType: M.ShortType, UnsignedByteType: M.UnsignedByteType, UnsignedInt248Type: M.UnsignedInt248Type, UnsignedIntType: M.UnsignedIntType, UnsignedShort4444Type: M.UnsignedShort4444Type, UnsignedShort5551Type: M.UnsignedShort5551Type, UnsignedShortType: M.UnsignedShortType },
  TextureEncoding: { LinearEncoding: M.LinearEncoding, sRGBEncoding: M.sRGBEncoding },
  ToneMapping: {
    NoToneMapping: M.NoToneMapping,
    LinearToneMapping: M.LinearToneMapping,
    ReinhardToneMapping: M.ReinhardToneMapping,
    CineonToneMapping: M.CineonToneMapping,
    ACESFilmicToneMapping: M.ACESFilmicToneMapping,
    CustomToneMapping: M.CustomToneMapping
  },
  ViewportNodeScope: {
    COORDINATE: ks.COORDINATE,
    RESOLUTION: ks.RESOLUTION,
    TOP_LEFT: ks.TOP_LEFT,
    BOTTOM_LEFT: ks.BOTTOM_LEFT,
    TOP_RIGHT: ks.TOP_RIGHT,
    BOTTOM_RIGHT: ks.BOTTOM_RIGHT
  },
  WebGL1PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGFormat: M.RGFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  WebGL2PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGBAFormat: M.RGBAFormat, RGBAIntegerFormat: M.RGBAIntegerFormat, RGFormat: M.RGFormat, RGIntegerFormat: M.RGIntegerFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  Wrapping: { ClampToEdgeWrapping: M.ClampToEdgeWrapping, MirroredRepeatWrapping: M.MirroredRepeatWrapping, RepeatWrapping: M.RepeatWrapping }
}, Pa = {
  AmbientLight: {
    cls: M.AmbientLight,
    isAmbientLight: !0,
    members: {
      // type: "string | 'AmbientLight'"
    },
    proto: "Light"
  },
  AmbientLightProbe: {
    // cls: THREE.AmbientLightProbe,
    isAmbientLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  ArrayCamera: {
    cls: M.ArrayCamera,
    isArrayCamera: !0,
    members: { cameras: "PerspectiveCamera[]" },
    proto: "PerspectiveCamera"
  },
  Audio: {
    cls: M.Audio,
    members: {},
    proto: "Object3D"
  },
  AudioListener: {
    cls: M.AudioListener,
    members: {},
    proto: "Object3D"
  },
  Camera: {
    cls: M.Camera,
    isCamera: !0,
    members: {
      coordinateSystem: "types.CoordinateSystem",
      // layers: 'Layers',
      matrixWorldInverse: "Matrix4",
      projectionMatrix: "Matrix4",
      projectionMatrixInverse: "Matrix4"
      // type: "string | 'Camera'"
    },
    proto: "Object3D"
  },
  CanvasTexture: {
    cls: M.CanvasTexture,
    isCanvasTexture: !0,
    members: {},
    proto: "Texture"
  },
  CompressedArrayTexture: {
    cls: M.CompressedArrayTexture,
    isCompressedArrayTexture: !0,
    members: { wrapR: "types.Wrapping" },
    proto: "CompressedTexture"
  },
  CompressedTexture: {
    cls: M.CompressedTexture,
    isCompressedTexture: !0,
    members: {
      flipY: "boolean",
      format: "types.CompressedPixelFormat",
      generateMipmaps: "boolean"
      // mipmaps: 'ImageData[]'
    },
    proto: "Texture"
  },
  CubeCamera: {
    cls: M.CubeCamera,
    members: {
      coordinateSystem: "types.CoordinateSystem"
      // renderTarget: 'WebGLCubeRenderTarget',
      // type: "string | 'CubeCamera'"
    },
    proto: "Object3D"
  },
  CubeTexture: {
    cls: M.CubeTexture,
    isCubeTexture: !0,
    members: {
      flipY: "boolean",
      mapping: "types.CubeTextureMapping"
    },
    proto: "Texture"
  },
  Data3DTexture: {
    cls: M.Data3DTexture,
    isData3DTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "types.Wrapping"
    },
    proto: "Texture"
  },
  DataArrayTexture: {
    cls: M.DataArrayTexture,
    isDataArrayTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "boolean"
    },
    proto: "Texture"
  },
  DataTexture: {
    cls: M.DataTexture,
    isDataTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number"
    },
    proto: "Texture"
  },
  DepthTexture: {
    cls: M.DepthTexture,
    isDepthTexture: !0,
    members: {
      compareFunction: "types.TextureComparisonFunction | null",
      flipY: "boolean",
      format: "types.DeepTexturePixelFormat",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      type: "types.TextureDataType"
    },
    proto: "Texture"
  },
  DirectionalLight: {
    cls: M.DirectionalLight,
    isDirectionalLight: !0,
    members: {
      castShadow: "boolean",
      position: "Vector3",
      // shadow: 'DirectionalLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'DirectionalLight'"
    },
    proto: "Light"
  },
  DirectionalLightShadow: {
    cls: M.DirectionalLightShadow,
    isDirectionalLightShadow: !0,
    members: {
      camera: "OrthographicCamera"
    },
    proto: "LightShadow"
  },
  Fog: {
    cls: M.Fog,
    isFog: !0,
    members: {
      color: "Color",
      far: "number",
      // name: 'string',
      near: "number"
    },
    proto: "FogBase"
  },
  FogExp2: {
    cls: M.FogExp2,
    isFogExp2: !0,
    members: {
      color: "Color",
      density: "number"
      // name: 'string'
    },
    proto: "FogBase"
  },
  FramebufferTexture: {
    cls: M.FramebufferTexture,
    isFramebufferTexture: !0,
    members: {
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter"
    },
    proto: "Texture"
  },
  HemisphereLight: {
    cls: M.HemisphereLight,
    isHemisphereLight: !0,
    members: {
      color: "Color",
      groundColor: "Color",
      position: "Vector3"
      // type: "string | 'HemisphereLight'"
    },
    proto: "Light"
  },
  HemisphereLightProbe: {
    // cls: THREE.HemisphereLightProbe,
    isHemisphereLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  InstancedMesh: {
    cls: M.InstancedMesh,
    members: {
      count: "number"
    },
    proto: "Mesh"
  },
  Light: {
    cls: M.Light,
    isLight: !0,
    members: {
      color: "Color",
      intensity: "number",
      shadow: "LightShadow"
      // type: "string | 'Light'"
    },
    proto: "Object3D"
  },
  LightProbe: {
    cls: M.LightProbe,
    isLightProbe: !0,
    members: {
      sh: "SphericalHarmonics3"
    },
    proto: "Light"
  },
  LightShadow: {
    cls: M.LightShadow,
    members: {
      // autoUpdate: 'boolean',
      bias: "number",
      blurSamples: "number",
      camera: "Camera",
      // map: 'WebGLRenderTarget | null',
      // mapPass: 'WebGLRenderTarget | null',
      mapSize: "Vector2",
      matrix: "Matrix4",
      // needsUpdate: 'boolean',
      normalBias: "number",
      radius: "number"
    }
  },
  LineBasicMaterial: {
    cls: M.LineBasicMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      linecap: "string",
      linejoin: "string",
      linewidth: "number",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  LineDashedMaterial: {
    cls: M.LineDashedMaterial,
    isLineDashedMaterial: !0,
    members: {
      dashSize: "number",
      gapSize: "number",
      scale: "number"
      // type: 'string'
    },
    proto: "LineBasicMaterial"
  },
  Material: {
    cls: M.Material,
    isMaterial: !0,
    members: {
      alphaHash: "boolean",
      // alphaTest: 'number',
      // alphaToCoverage: 'boolean',
      // blendDst: 'types.BlendingDstFactor',
      // blendDstAlpha: 'number | null',
      // blendEquation: 'types.BlendingEquation',
      // blendEquationAlpha: 'number | null',
      blendSrc: "types.BlendingSrcFactor | types.BlendingDstFactor",
      blendSrcAlpha: "number | null",
      blending: "types.Blending",
      // clipIntersection: 'boolean',
      // clipShadows: 'boolean',
      // clippingPlanes: 'Plane[]',
      // colorWrite: 'boolean',
      // defines: 'undefined | { [key: string]: any }',
      depthFunc: "types.DepthModes",
      depthTest: "boolean",
      depthWrite: "boolean",
      // dithering: 'boolean',
      // forceSinglePass: 'boolean',
      // id: 'number',
      // name: 'string',
      // needsUpdate: 'boolean',
      opacity: "number",
      // polygonOffset: 'boolean',
      // polygonOffsetFactor: 'number',
      // polygonOffsetUnits: 'number',
      precision: "types.Precision | null",
      premultipliedAlpha: "boolean",
      shadowSide: "types.Side | null",
      side: "types.Side",
      stencilFail: "types.StencilOp",
      stencilFunc: "types.StencilFunc",
      stencilFuncMask: "number",
      stencilRef: "number",
      stencilWrite: "boolean",
      stencilWriteMask: "number",
      stencilZFail: "types.StencilOp",
      stencilZPass: "types.StencilOp",
      toneMapped: "boolean",
      transparent: "boolean",
      // type: 'string',
      // userData: 'any',
      // uuid: 'string',
      // version: 'number',
      // vertexColors: 'boolean',
      visible: "boolean"
    },
    proto: "EventDispatcher"
  },
  Mesh: {
    cls: M.Mesh,
    members: {
      castShadow: "boolean",
      receiveShadow: "boolean",
      material: "Material"
    },
    proto: "Object3D"
  },
  MeshBasicMaterial: {
    cls: M.MeshBasicMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      color: "Color",
      combine: "types.Combine",
      envMap: "Texture | null",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDepthMaterial: {
    cls: M.MeshDepthMaterial,
    members: {
      alphaMap: "Texture | null",
      depthPacking: "types.DepthPackingStrategies",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDistanceMaterial: {
    cls: M.MeshDistanceMaterial,
    members: {
      alphaMap: "Texture | null",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshLambertMaterial: {
    cls: M.MeshLambertMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshMatcapMaterial: {
    cls: M.MeshMatcapMaterial,
    members: {
      alphaMap: "Texture | null",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      fog: "boolean",
      map: "Texture | null",
      matcap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshNormalMaterial: {
    cls: M.MeshNormalMaterial,
    members: {
      bumpMap: "Texture | null",
      bumpScale: "number",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhongMaterial: {
    cls: M.MeshPhongMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metal: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      shininess: "number",
      specular: "Color",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhysicalMaterial: {
    cls: M.MeshPhysicalMaterial,
    members: {
      anisotropy: "number",
      anisotropyMap: "Texture | null",
      anisotropyRotation: "number",
      attenuationColor: "Color",
      attenuationDistance: "number",
      clearcoat: "number",
      clearcoatMap: "Texture | null",
      clearcoatNormalMap: "Texture | null",
      clearcoatNormalScale: "Vector2",
      clearcoatRoughness: "number",
      clearcoatRoughnessMap: "Texture | null",
      // defines: '{ [key: string]: any }',
      ior: "number",
      iridescence: "number",
      iridescenceIOR: "number",
      iridescenceMap: "Texture | null",
      iridescenceThicknessMap: "Texture | null",
      iridescenceThicknessRange: "number[]",
      reflectivity: "number",
      sheen: "number",
      sheenColor: "Color",
      sheenColorMap: "Texture | null",
      sheenRoughness: "number",
      sheenRoughnessMap: "Texture | null",
      specularColor: "Color",
      specularColorMap: "Texture | null",
      specularIntensity: "number",
      specularIntensityMap: "Texture | null",
      thickness: "number",
      thicknessMap: "Texture | null",
      transmission: "number",
      transmissionMap: "Texture | null"
      // type: 'string'
    },
    proto: "MeshStandardMaterial"
  },
  MeshStandardMaterial: {
    cls: M.MeshStandardMaterial,
    isMeshStandardMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }', 
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      envMapIntensity: "number",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metalness: "number",
      metalnessMap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      roughness: "number",
      roughnessMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshToonMaterial: {
    cls: M.MeshToonMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      fog: "boolean",
      gradientMap: "Texture | null",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  Object3D: {
    cls: M.Object3D,
    isObject3D: !0,
    members: {
      up: "Vector3",
      position: "Vector3",
      rotation: "Euler",
      scale: "Vector3",
      visible: "Boolean"
    }
  },
  OrthographicCamera: {
    cls: M.OrthographicCamera,
    isOrthographicCamera: !0,
    members: {
      bottom: "number",
      far: "number",
      left: "number",
      near: "number",
      right: "number",
      top: "number",
      // type: "string | 'OrthographicCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PerspectiveCamera: {
    cls: M.PerspectiveCamera,
    isPerspectiveCamera: !0,
    members: {
      aspect: "number",
      far: "number",
      filmGauge: "number",
      filmOffset: "number",
      focus: "number",
      fov: "number",
      near: "number",
      //   type: "string | 'PerspectiveCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PointLight: {
    cls: M.PointLight,
    members: {
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      power: "number",
      // shadow: 'PointLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number"
      // type: 'string'
    },
    proto: "Light"
  },
  PointLightShadow: {
    cls: M.PointLightShadow,
    isPointLightShadow: !0,
    members: {},
    proto: "LightShadow"
  },
  Points: {
    cls: M.Points,
    members: {
      material: "Material"
    },
    proto: "Object3D"
  },
  PointsMaterial: {
    cls: M.PointsMaterial,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      size: "number",
      sizeAttenuation: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  PositionalAudio: {
    cls: M.PositionalAudio,
    members: {},
    proto: "Audio"
  },
  RawShaderMaterial: {
    cls: M.RawShaderMaterial,
    members: {},
    proto: "ShaderMaterial"
  },
  RectAreaLight: {
    cls: M.RectAreaLight,
    isRectAreaLight: !0,
    members: {
      height: "number",
      intensity: "number",
      power: "number",
      // type: "string | 'RectAreaLight'",
      width: "number"
    },
    proto: "Light"
  },
  Scene: {
    cls: M.Scene,
    isScene: !0,
    members: {
      background: "Color | Texture | CubeTexture | null",
      backgroundBlurriness: "number",
      backgroundIntensity: "number",
      environment: "Texture | null",
      fog: "FogBase | null",
      overrideMaterial: "Material | null"
      // type: "'Scene'"
    },
    proto: "Object3D"
  },
  ShaderMaterial: {
    cls: M.ShaderMaterial,
    isShaderMaterial: !0,
    members: {
      // clipping: 'boolean',
      //   defaultAttributeValues: 'any',
      //   defines: '{ [key: string]: any }', derivatives: 'any',
      //   extensions: `{
      //     derivatives: boolean;
      //     fragDepth: boolean;
      //     drawBuffers: boolean;
      //     shaderTextureLOD: boolean;
      // }`,
      fog: "boolean",
      // fragmentShader: 'string',
      // glslVersion: 'types.GLSLVersion | null',
      // index0AttributeName: 'string | undefined', lights: 'boolean', linewidth: 'number',
      // type: 'string',
      // uniforms: '{ [uniform: string]: IUniform }',
      // uniformsGroups: 'UniformsGroup[]',
      // uniformsNeedUpdate: 'boolean',
      // vertexShader: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  ShadowMaterial: {
    cls: M.ShadowMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  Source: {
    cls: M.Source,
    isSource: !0,
    members: {
      // data: 'any', id: 'number', uuid: 'string', version: 'number'
    }
  },
  SphericalHarmonics3: {
    cls: M.SphericalHarmonics3,
    isSphericalHarmonics3: !0,
    members: { coefficients: "Vector3[]" }
  },
  SpotLight: {
    cls: M.SpotLight,
    isSpotLight: !0,
    members: {
      angle: "number",
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      map: "Texture | null",
      penumbra: "number",
      position: "Vector3",
      power: "number",
      // shadow: 'SpotLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'SpotLight'"
    },
    proto: "Light"
  },
  SpotLightShadow: {
    cls: M.SpotLightShadow,
    isSpotLightShadow: !0,
    members: { camera: "PerspectiveCamera", focus: "number" },
    proto: "LightShadow"
  },
  SpriteMaterial: {
    cls: M.SpriteMaterial,
    isSpriteMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      rotation: "number",
      sizeAttenuation: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  StereoCamera: {
    cls: M.StereoCamera,
    members: {
      aspect: "number",
      cameraL: "PerspectiveCamera",
      cameraR: "PerspectiveCamera",
      eyeSep: "number"
      // type: "'StereoCamera'"
    },
    proto: "Camera"
  },
  Texture: {
    cls: M.Texture,
    isTexture: !0,
    members: {
      anisotropy: "number",
      center: "Vector2",
      channel: "number",
      colorSpace: "types.ColorSpace",
      encoding: "types.TextureEncoding",
      flipY: "boolean",
      format: "types.WebGL1PixelFormat | types.WebGL2PixelFormat | types.DeepTexturePixelFormat | types.CompressedPixelFormat",
      generateMipmaps: "boolean",
      // id: 'number',
      image: "Image",
      internalFormat: "types.PixelFormatGPU | null",
      // isRenderTargetTexture: 'boolean',
      magFilter: "types.MagnificationTextureFilter",
      mapping: "types.Mapping | types.CubeTextureMapping",
      matrix: "Matrix3",
      // matrixAutoUpdate: 'boolean', minFilter: 'types.MinificationTextureFilter', mipmaps: 'any[]',
      // name: 'string',
      // needsPMREMUpdate: 'boolean',
      offset: "Vector2",
      // onUpdate: '() => void',
      premultiplyAlpha: "boolean",
      repeat: "Vector2",
      rotation: "number",
      // source: 'Source',
      type: "types.TextureDataType",
      unpackAlignment: "number",
      // userData: 'any',
      // uuid: 'string', version: 'number',
      wrapS: "types.Wrapping",
      wrapT: "types.Wrapping"
    },
    proto: "EventDispatcher"
  },
  VideoTexture: {
    cls: M.VideoTexture,
    isVideoTexture: !0,
    members: { generateMipmaps: "boolean", magFilter: "types.MagnificationTextureFilter", minFilter: "types.MinificationTextureFilter" },
    proto: "Texture"
  }
}, ci = {
  AONode: {
    cls: Rh,
    group: "lighting",
    members: { aoNode: "Node | null" },
    proto: "LightingNode"
  },
  AnalyticLightNode: {
    cls: or,
    group: "lighting",
    members: { colorNode: "Node", light: "Light | null" },
    proto: "LightingNode"
  },
  ArrayElementNode: {
    cls: Ya,
    group: "utils",
    members: { indexNode: "Node", node: "Node" },
    proto: "TempNode"
  },
  ArrayUniformNode: {
    cls: bg,
    group: "core",
    isArrayUniformNode: !0,
    members: { nodes: "Node[]" },
    proto: "UniformNode"
  },
  AttributeNode: {
    cls: Uu,
    group: "core",
    members: {},
    proto: "Node"
  },
  BitangentNode: {
    cls: Qr,
    group: "accessors",
    members: { scope: "types.BitangentNodeScope" },
    proto: "Node"
  },
  BlendModeNode: {
    cls: to,
    group: "display",
    members: { baseNode: "Node", blendMode: "types.BlendMode", blendNode: "Node" },
    proto: "TempNode"
  },
  BufferNode: {
    cls: Th,
    group: "accessors",
    isBufferNode: !0,
    members: { bufferCount: "number", bufferType: "string" },
    proto: "UniformNode"
  },
  BypassNode: {
    cls: wg,
    group: "core",
    isBypassNode: !0,
    members: { callNode: "Node", outputNode: "Node" },
    proto: "Node"
  },
  CacheNode: {
    cls: Tg,
    group: "core",
    isCacheNode: !0,
    members: { cache: "NodeCache", node: "Node" },
    proto: "Node"
  },
  CameraNode: {
    cls: lh,
    group: "accessors",
    members: { scope: "types.CameraNodeScope" },
    proto: "Object3DNode"
  },
  CheckerNode: {
    cls: _v,
    group: "procedural",
    members: { uvNode: "Node" },
    proto: "TempNode"
  },
  CodeNode: {
    cls: md,
    group: "code",
    isCodeNode: !0,
    members: { code: "string" },
    proto: "Node"
  },
  ColorAdjustmentNode: {
    cls: Ho,
    group: "display",
    members: { adjustmentNode: "Node", colorNode: "Node", method: "types.ColorAdjustmentMethod" },
    proto: "TempNode"
  },
  ColorSpaceNode: {
    cls: jo,
    group: "display",
    members: { method: "types.ColorSpaceNodeMethod", node: "Node" },
    proto: "TempNode"
  },
  ComputeNode: {
    cls: bv,
    group: "gpgpu",
    isComputeNode: !0,
    members: { count: "number", dispatchCount: "number", workgroupSize: "number[]" },
    proto: "Node"
  },
  CondNode: {
    cls: kh,
    group: "math",
    members: { condNode: "Node", elseNode: "Node", ifNode: "Node" },
    proto: "Node"
  },
  ConstNode: {
    cls: Ln,
    group: "core",
    isConstNode: !0,
    members: {},
    proto: "InputNode"
  },
  ContextNode: {
    cls: ku,
    group: "core",
    isContextNode: !0,
    members: { context: "Object", node: "Node" },
    proto: "Node"
  },
  ConvertNode: {
    cls: Ka,
    group: "utils",
    members: { convertTo: "types.NodeTypeOption", node: "Node" },
    proto: "Node"
  },
  CubeTextureNode: {
    cls: p0,
    group: "accessors",
    isCubeTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "CubeTexture" },
    proto: "TextureNode"
  },
  EnvironmentNode: {
    cls: zh,
    group: "lighting",
    members: { envNode: "Node | null" },
    proto: "LightingNode"
  },
  EquirectUVNode: {
    cls: b0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  ExpressionNode: {
    cls: Py,
    group: "code",
    members: { snipped: "string" },
    proto: "TempNode"
  },
  FogExp2Node: {
    cls: yv,
    group: "fog",
    isFogExp2Node: !0,
    members: { densityNode: "Node" },
    proto: "FogNode"
  },
  FogNode: {
    cls: vc,
    group: "fog",
    isFogNode: !0,
    members: { colorNode: "Node", factorNode: "Node" },
    proto: "Node"
  },
  FogRangeNode: {
    cls: mv,
    group: "fog",
    isFogRangeNode: !0,
    members: { farNode: "Node", nearNode: "Node" },
    proto: "FogNode"
  },
  FrontFacingNode: {
    cls: Ky,
    group: "display",
    isFrontFacingNode: !0,
    members: {},
    proto: "Node"
  },
  // FunctionCallNode: {
  //   cls: Nodes.FunctionCallNode,
  //   group: 'code',
  //   members: {
  //     functionNode: 'FunctionNode<P>',
  //     parameters: '{ [name: string]: Node }'
  //   },
  //   proto: 'TempNode'
  // },
  FunctionNode: {
    cls: uv,
    group: "code",
    members: { keywords: "{ [key: string]: Node }" },
    proto: "CodeNode"
  },
  HemisphereLightNode: {
    cls: Sv,
    group: "lighting",
    members: { groundColorNode: "Node", lightDirectionNode: "Node", lightPositionNode: "Object3DNode" },
    proto: "AnalyticLightNode"
  },
  InputNode: {
    // cls: Nodes.InputNode,
    group: "core",
    isInputNode: !0,
    members: { precision: "types.Precision | null", value: "Color | Vector2 | Vector3 | Vector4 | Matrix3 | Matrix4 | boolean | number" },
    proto: "Node"
  },
  // InstanceNode: {
  //   cls: Nodes.InstanceNode,
  //   group: 'accessors',
  //   members: { instanceMatrixNode: 'Node', instanceMesh: 'InstancedMesh' },
  //   proto: 'Node'
  // },
  // LightingContextNode: {
  //   cls: Nodes.LightingContextNode,
  //   group: 'lighting',
  //   members: { lightingModelNode: 'LightingModelNode | null' },
  //   proto: 'ContextNode'
  // },
  LightingNode: {
    cls: Ni,
    group: "lighting",
    members: {},
    proto: "Node"
  },
  LightsNode: {
    cls: y0,
    group: "lighting",
    members: { lightNodes: "LightingNode[]" },
    proto: "Node"
  },
  LineBasicNodeMaterial: {
    cls: Ev,
    group: "materials",
    isLineBasicNodeMaterial: !0,
    members: {},
    proto: ["LineBasicMaterial", "NodeMaterial"]
  },
  MatcapUVNode: {
    cls: E0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  MaterialNode: {
    cls: Yn,
    group: "accessors",
    members: { scope: "types.MaterialNodeScope" },
    proto: "Node"
  },
  MaterialReferenceNode: {
    cls: Uy,
    group: "accessors",
    members: {},
    proto: "ReferenceNode"
  },
  MathNode: {
    cls: ke,
    group: "math",
    members: { aNode: "Node", bNode: "Node | null", cNode: "Node | null", method: "types.MathNodeMethod1 | types.MathNodeMethod2 | types.MathNodeMethod3" },
    proto: "TempNode"
  },
  MaxMipLevelNode: {
    cls: N0,
    group: "utils",
    members: { textureNode: "TextureNode" },
    proto: "UniformNode"
  },
  MeshBasicNodeMaterial: {
    cls: Iv,
    group: "materials",
    isMeshBasicNodeMaterial: !0,
    members: { lights: "true" },
    proto: ["MeshBasicMaterial", "NodeMaterial"]
  },
  MeshPhysicalNodeMaterial: {
    cls: Wv,
    group: "materials",
    members: { attenuationColorNode: "Node | null", attenuationDistanceNode: "Node | null", iridescenceIORNode: "null | Node", iridescenceNode: "null | CheckerNode", iridescenceThicknessNode: "null | Node", specularColorNode: "Node | null", specularIntensityNode: "Node | null", thicknessNode: "Node | null", transmissionNode: "Node | null" },
    proto: ["MeshPhysicalMaterial", "MeshStandardNodeMaterial"]
  },
  MeshStandardNodeMaterial: {
    cls: zd,
    group: "materials",
    isMeshStandardNodeMaterial: !0,
    members: { clearcoatNode: "Node | null", clearcoatRoughnessNode: "Node | null", emissiveNode: "Node | null", metalnessNode: "Node | null", roughnessNode: "Node | null" },
    proto: ["MeshStandardMaterial", "NodeMaterial"]
  },
  ModelViewProjectionNode: {
    cls: s0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  Node: {
    cls: Le,
    group: "core",
    isNode: !0,
    members: {
      // id: 'number',
      // nodeType: 'NodeTypeOption | null',
      // type: 'string',
      // updateType: 'NodeUpdateTypeOption',
      // uuid: 'string'
    }
  },
  NodeAttribute: {
    cls: Ma,
    group: "core",
    isNodeAttribute: !0,
    members: { name: "string", type: "string" }
  },
  // NodeBuilder: {
  //   cls: Nodes.NodeBuilder,
  //   group: 'core',
  //   members: { buildStage: 'BuildStageOption | null', cache: 'NodeCache', computeShader: 'string', flowsData: 'any', fogNode: 'FogNode', fragmentShader: 'string', geometry: 'BufferGeometry', globalCache: 'NodeCache', hashNodes: '{ [hash: string]: Node }', lightsNode: 'LightsNode', material: 'Material', nodes: 'Node[]', object: 'Object3D', parser: 'NodeParser', renderer: 'Renderer', shaderStage: 'NodeShaderStageOption | null', stack: 'Node[]', updateNodes: 'Node[]', vertexShader: 'string' }
  // },
  NodeCache: {
    cls: nc,
    group: "core",
    members: {
      // id: 'number', nodesData: 'WeakMap<Node, NodeData>' 
    }
  },
  NodeCode: {
    cls: Wu,
    group: "core",
    isNodeCode: !0,
    members: {}
  },
  // NodeFrame: {
  //   cls: Nodes.NodeFrame,
  //   group: 'core',
  //   members: { camera: 'null | Camera', deltaTime: 'number', frameId: 'number', material: 'null | Material', object: 'null | Object3D', renderer: 'null | Renderer', startTime: 'null | number', time: 'number' }
  // },
  NodeFunction: {
    // cls: Nodes.NodeFunction,
    group: "core",
    isNodeFunction: !0,
    members: { inputs: "NodeFunctionInput[]", name: "string", presicion: "string", type: "string" }
  },
  NodeFunctionInput: {
    cls: Hh,
    group: "core",
    isNodeFunctionInput: !0,
    members: { count: "null | number", isConst: "boolean", qualifier: "string" }
  },
  NodeKeywords: {
    cls: Hu,
    group: "core",
    members: {
      keywords: "string[]",
      // keywordsCallback: '{ [name: string]: (name: string) => Node }',
      nodes: "Node[]"
    }
  },
  // NodeLoader: {
  //   cls: Nodes.NodeLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'Loader<NodeLoaderResult>'
  // },
  NodeMaterial: {
    cls: tn,
    group: "materials",
    isNodeMaterial: !0,
    members: {
      alphaTestNode: "Node | null",
      backdropAlphaNode: "Node | null",
      backdropNode: "Node | null",
      colorNode: "Node | null",
      envNode: "Node | null",
      lights: "true",
      lightsNode: "Node | null",
      normalNode: "Node | null",
      normals: "true",
      opacityNode: "Node | null",
      positionNode: "Node | null"
      // type: 'string'
    },
    proto: "ShaderMaterial"
  },
  // NodeMaterialLoader: {
  //   cls: Nodes.NodeMaterialLoader,
  //   group: 'loaders',
  //   members: { nodes: 'NodeLoaderResult' },
  //   proto: 'MaterialLoader'
  // },
  // NodeObjectLoader: {
  //   cls: Nodes.NodeObjectLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'ObjectLoader'
  // },
  // NodeParser: {
  //   // cls: Nodes.NodeParser,
  //   group: 'core',
  //   members: {}
  // },
  NodeUniform: {
    cls: Vu,
    group: "core",
    isNodeUniform: !0,
    members: { name: "string", needsUpdate: "boolean", node: "InputNode", type: "string", value: "NodeValueOption" }
  },
  NodeVar: {
    cls: rc,
    group: "core",
    isNodeVar: !0,
    members: { name: "string", type: "string" }
  },
  NodeVarying: {
    cls: ju,
    group: "core",
    isNodeVarying: !0,
    members: { needsInterpolation: "false" },
    proto: "NodeVar"
  },
  NormalMapNode: {
    cls: Qy,
    group: "display",
    members: { node: "Node", normalMapType: "types.NormalMapTypes", scaleNode: "Node | null" },
    proto: "TempNode"
  },
  NormalNode: {
    cls: Wo,
    group: "accessors",
    members: { scope: "types.NormalNodeScope" },
    proto: "Node"
  },
  Object3DNode: {
    cls: gn,
    group: "accessors",
    members: { object3d: "Object3D | null", scope: "types.Object3DNodeScope" },
    proto: "Node"
  },
  OperatorNode: {
    cls: Og,
    group: "math",
    members: { aNode: "Node", bNode: "Node", op: "types.OperatorNodeOp" },
    proto: "TempNode"
  },
  OscNode: {
    cls: eo,
    group: "utils",
    members: { method: "types.OscNodeMethod", timeNode: "Node" },
    proto: "Node"
  },
  PointLightNode: {
    cls: wv,
    group: "lighting",
    members: { coneCosNode: "Node", cutoffDistanceNode: "Node", decayExponentNode: "Node", directionNode: "Node", penumbraCosNode: "Node" },
    proto: "AnalyticLightNode"
  },
  PointUVNode: {
    cls: H0,
    group: "accessors",
    isPointUVNode: !0,
    members: {},
    proto: "Node"
  },
  PointsNodeMaterial: {
    cls: Bd,
    group: "materials",
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", isPointsNodeMateria: "true", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", sizeNode: "Node | null" },
    proto: ["PointsMaterial", "NodeMaterial"]
  },
  PositionNode: {
    cls: Bs,
    group: "accessors",
    members: { scope: "types.PositionNodeScope" },
    proto: "Node"
  },
  PosterizeNode: {
    cls: nv,
    group: "display",
    members: { sourceNode: "Node", stepsNode: "Node" },
    proto: "Node"
  },
  PropertyNode: {
    cls: _g,
    group: "core",
    members: {},
    proto: "Node"
  },
  RangeNode: {
    cls: xv,
    group: "geometry",
    members: { max: "number | Color | Vector2 | Vector3 | Vector4", min: "number | Color | Vector2 | Vector3 | Vector4" },
    proto: "Node"
  },
  ReferenceNode: {
    cls: cc,
    group: "accessors",
    members: { node: "Node | null", object: "Object", property: "string", uniformType: "string" },
    proto: "Node"
  },
  ReflectVectorNode: {
    cls: d0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  RemapNode: {
    cls: L0,
    group: "utils",
    members: { doClamp: "boolean", inHighNode: "Node", inLowNode: "Node", node: "Node", outHighNode: "Node", outLowNode: "Node" },
    proto: "Node"
  },
  RotateUVNode: {
    cls: P0,
    group: "utils",
    members: { centerNode: "Node", rotationNode: "Node", uvNode: "Node" },
    proto: "TempNode"
  },
  SkinningNode: {
    cls: l0,
    group: "accessors",
    members: { bindMatrixInverseNode: "Node", bindMatrixNode: "Node", boneMatricesNode: "Node", skinIndexNode: "Node", skinWeightNode: "Node" },
    proto: "Node"
  },
  SpecularMIPLevelNode: {
    cls: w0,
    group: "utils",
    members: { roughnessNode: "Node | null", textureNode: "TextureNode" },
    proto: "Node"
  },
  SpriteNodeMaterial: {
    cls: $v,
    group: "materials",
    isSpriteNodeMaterial: !0,
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", rotationNode: "Node | null", scaleNode: "Node | null" },
    proto: ["SpriteMaterial", "NodeMaterial"]
  },
  SpriteSheetUVNode: {
    cls: D0,
    group: "utils",
    members: { countNode: "Node", frameNode: "Node", uvNode: "Node" },
    proto: "Node"
  },
  // StackNode: {
  //   cls: Nodes.StackNode,
  //   group: 'core',
  //   isStackNode: true,
  //   members: { nodes: 'Node[]', outputNode: 'Node | null' },
  //   proto: 'Node'
  // },
  // StorageBufferNode: {
  //   // cls: Nodes.StorageBufferNode,
  //   group: 'accessors',
  //   members: {},
  //   proto: 'BufferNode'
  // },
  TangentNode: {
    cls: Zr,
    group: "accessors",
    members: { scope: "types.TangentNodeScope" },
    proto: "Node"
  },
  TempNode: {
    cls: Mt,
    group: "core",
    isTempNode: !0,
    members: {},
    proto: "Node"
  },
  TextureNode: {
    cls: vi,
    group: "accessors",
    isTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "Texture" },
    proto: "UniformNode"
  },
  TimerNode: {
    cls: R0,
    group: "utils",
    members: {
      scale: "number"
      // scope: 'TimerNodeScope'
    },
    proto: "UniformNode"
  },
  ToneMappingNode: {
    cls: rv,
    group: "display",
    members: { colorNode: "Node | null", exposureNode: "Node", toneMapping: "types.ToneMapping" },
    proto: "TempNode"
  },
  TriplanarTexturesNode: {
    cls: B0,
    group: "utils",
    members: {
      normalNode: "PositionNode",
      positionNode: "PositionNode",
      scaleNode: "Node",
      textureXNode: "TextureNode",
      textureYNode: "TextureNode | null",
      textureZNode: "TextureNode | null"
    },
    proto: "Node"
  },
  UVNode: {
    cls: Rg,
    group: "accessors",
    isUVNode: !0,
    members: { index: "number" },
    proto: "AttributeNode"
  },
  UniformNode: {
    cls: nt,
    group: "core",
    isUniformNode: !0,
    members: {},
    proto: "InputNode"
  },
  // UserDataNode: {
  //   cls: Nodes.UserDataNode,
  //   group: 'accessors',
  //   members: { userData: 'NodeUserData | null' },
  //   proto: 'ReferenceNode<NodeUserData>'
  // },
  VarNode: {
    cls: $y,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  VaryingNode: {
    cls: Ng,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  ViewportNode: {
    cls: ks,
    group: "display",
    isViewportNode: !0,
    members: { scope: "types.ViewportNodeScope" },
    proto: "Node"
  }
};
let Io = console;
const Be = {
  debug(...c) {
    Io.debug(...c);
  },
  notice(...c) {
    Io.info(...c);
  },
  warn(...c) {
    Io.warn(...c);
  },
  error(...c) {
    Io.error(...c);
  },
  panic(...c) {
    return Io.error(...c), `${c}`;
  }
}, Qf = {};
function ep(c) {
  const e = Object.entries(c);
  return e.forEach((t) => delete c[t[0]]), e.sort((t, r) => t[0].localeCompare(r[0])), e.forEach((t) => c[t[0]] = t[1]), c;
}
function xc(c) {
  return /Material$/.test(c) || !!ci[c];
}
const iS = new Set("bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","));
function aS(c) {
  return iS.has(c);
}
const cS = new Set("void,Boolean,Number,String,Script,Color,Vector2,Vector3,Vector4,Matrix3,Matrix4,Euler,Audio,Image,Texture,CubeTexture,Material,Object3D,Object".split(","));
function lS(c) {
  return cS.has(c.split("[")[0]);
}
function uS(c) {
  return aS(c) || lS(c);
}
function hS(c, e) {
  for (const t of c)
    if (!e.includes(t))
      return !1;
  return !0;
}
function dS(c, e) {
  return c[`is${e}`];
}
function Ql(c, e) {
  if (c === e)
    return !0;
  const t = kd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (Ql(r, e))
        return !0;
    return !1;
  }
  return Ql(t.proto, e);
}
function fS(c, e) {
  if (e.includes(c))
    return !0;
  for (const t of e)
    if (Ql(c, t))
      return !0;
  return !1;
}
function li(c, e) {
  if (c === e)
    return !0;
  const t = kd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (li(r, e))
        return !0;
    return !1;
  }
  return li(t.proto, e);
}
function pS(c) {
  let e = null, t = null;
  const r = [];
  for (const n of c) {
    if (/^".+"$/.test(n)) {
      const i = /^"(.+)"$/.exec(n)[1];
      t ? t.push(i) : (t = [i], r.push(t));
      continue;
    }
    const [, s, o] = /^([^[\]]+)(\[\])?$/.exec(n) || [];
    if (s.startsWith("types.")) {
      const i = n1[s.substring(6)];
      if (!i)
        throw Be.panic(`type[${s}] not found`);
      Array.isArray(i) ? t ? t.push(...i) : (t = [...i], r.push(t)) : e ? Object.assign(e, i) : (e = { ...i }, r.push(e));
    } else
      n === "null" ? r.push(null) : s === "boolean" || /true|false/i.test(n) ? r.push("Boolean" + (o || "")) : s === "string" ? r.push("String" + (o || "")) : s === "number" ? r.push("Number" + (o || "")) : (!uS(s) && !xc(s) && Be.warn(`type[${n}] unsupported!`), r.push(n));
  }
  return r;
}
function tp(c, e, t) {
  for (const [r, n] of Object.entries(e)) {
    const s = pS(n.replace(/\s/mg, "").split("|")), [, o, i] = /^(.+)(Node)$/.exec(r) || [, r], a = !!i || s.findIndex((u) => typeof u == "string" && xc(u)) !== -1, l = c[o] || (c[o] = { types: s, direct: t });
    a && (l.nname = r), mS(l.types, s);
  }
  return c;
}
function mS(c, e) {
  const t = c.filter((r) => r !== null && !xc(r) && !e.includes(r));
  for (const r of e)
    c.includes(r) || c.push(JSON.parse(JSON.stringify(r)));
  t.forEach((r) => c.splice(c.indexOf(r), 1));
}
function gS(c, e) {
  for (const t of e)
    c.includes(t) || c.push(JSON.parse(JSON.stringify(t)));
}
function np(c, e) {
  for (const [t, r] of Object.entries(e)) {
    const n = c[t];
    if (!n) {
      c[t] = JSON.parse(JSON.stringify(r));
      continue;
    }
    if (n.nname && r.nname && n.nname !== r.nname)
      throw Be.panic("type mismatched!");
    n.nname || (n.nname = r.nname), gS(n.types, r.types);
  }
  return c;
}
function Ua(c) {
  const e = (t) => {
    const r = Qf[t];
    if (r)
      return r;
    const n = { in: {}, out: {} }, s = ci[t] || Pa[t];
    if (!s)
      return n;
    let o = s.proto;
    if (o) {
      o = Array.isArray(o) ? o : [o];
      for (const i of o) {
        const a = e(i);
        np(n.in, a.in), np(n.out, a.out);
      }
    }
    return tp(n.in, s.members, "in"), s.out && tp(n.out, s.out, "out"), ep(n.in), ep(n.out), Qf[t] = n, n;
  };
  return e(c);
}
function sp(c) {
  const e = xS(c);
  if (!e)
    throw Be.panic(`Node constructor[${c}] not found!`);
  return e.clsName;
}
function yS(c) {
  const e = kd(c);
  if (e)
    return e.proto;
}
function kd(c) {
  return ci[c] || Pa[c];
}
function Fs(c, e, t, r, n) {
  if (ci[c])
    throw Be.panic(`class[${c}] exists`);
  if (re(c, e), ci[c] = { cls: e, members: t || {}, proto: r }, n)
    for (const [o, i] of Object.entries(n))
      bc(o, i);
}
const vS = [], Da = {};
function bc(c, e) {
  if (Da[c])
    throw Be.panic(`Node Constructor[${c}] aready exists`);
  const r = (e.group || `Others.${c}`).split(".");
  let n = vS;
  const s = r.pop();
  for (const l of r) {
    let u = n.find((h) => h.name === l);
    u || (u = {
      name: l,
      icon: "",
      children: []
    }, n.push(u)), n = u.children;
  }
  if (n.find((l) => l.name === c))
    throw Be.panic(`Node Constructor[${c}] aready exists`);
  const i = Ua(e.clsName), a = {
    name: c,
    ...e,
    title: s || c,
    in: { ...i.in },
    out: { ...i.out }
  };
  Da[c] = a, n.push(a);
}
function xS(c) {
  return Da[c];
}
function eu(c, e) {
  const t = Da[c];
  if (!t)
    throw Be.panic(`Node Constructor[${c}] not found`);
  const r = t.func();
  if (e)
    if (r.copy)
      r.copy(e);
    else
      for (const n of [...Object.keys(t.in), ...Object.keys(t.out)]) {
        const s = e[n], o = typeof s, i = r[n];
        o === "undefined" || s === null || o === "boolean" || o === "string" || o === "number" ? r[n] = s : s.clone ? r[n] = s.clone() : i && i.copy ? i.copy(s) : r[n] = s;
      }
  return r;
}
const { createNodeMaterialFromType: bS } = VN, NS = gi.createMaterialFromType, za = {};
gi.createMaterialFromType = function(c) {
  const e = bS(c);
  return e || (za[c] ? new za[c]() : NS.call(this, c));
};
function wS(c, e) {
  if (za[c])
    throw Be.panic(`Material[${c}] aready exists`);
  za[c] = e;
}
const rp = {};
function Je(c, e) {
  if (rp[c])
    throw Be.panic(`Class[${c}] aready exists`);
  if (rp[c] = e, Pa[c] || (Pa[c] = e), li(c, "Object3D")) {
    if (Ba[c])
      return;
    Ba[c] = (t) => e.create(t || {});
  }
}
const Ba = {
  AmbientLight: (c) => new M.AmbientLight(c.color, c.intensity),
  Bone: (c) => new M.Bone(),
  DirectionalLight: (c) => new M.DirectionalLight(c.color, c.intensity),
  HemisphereLight: (c) => new M.HemisphereLight(c.color, c.groundColor, c.intensity),
  Group: (c) => new M.Group(),
  InstancedMesh: (c) => {
    const e = new M.InstancedMesh(c.geometry, c.material, c.count), t = c.instanceMatrix, r = c.instanceColor;
    return e.instanceMatrix = new M.InstancedBufferAttribute(new Float32Array(t.array), 16), r !== void 0 && (e.instanceColor = new M.InstancedBufferAttribute(new Float32Array(r.array), r.itemSize)), e;
  },
  LOD: (c) => new M.LOD(),
  Line: (c) => new M.Line(c.geometry, c.material),
  LineLoop: (c) => new M.LineLoop(c.geometry, c.material),
  LineSegments: (c) => new M.LineSegments(c.geometry, c.material),
  LightProbe: (c) => new M.LightProbe().fromJSON(c),
  Mesh: (c) => new M.Mesh(c.geometry, c.material),
  Object3D: (c) => new M.Object3D(),
  OrthographicCamera: (c) => new M.OrthographicCamera(c.left, c.right, c.top, c.bottom, c.near, c.far),
  PerspectiveCamera: (c) => new M.PerspectiveCamera(c.fov, c.aspect, c.near, c.far),
  PointCloud: (c) => new M.Points(c.geometry, c.material),
  PointLight: (c) => new M.PointLight(c.color, c.intensity, c.distance, c.decay),
  Points: (c) => new M.Points(c.geometry, c.material),
  RectAreaLight: (c) => new M.RectAreaLight(c.color, c.intensity, c.width, c.height),
  Scene: (c) => new M.Scene(),
  SpotLight: (c) => new M.SpotLight(c.color, c.intensity, c.distance, c.angle, c.penumbra, c.decay),
  SkinnedMesh: (c) => new M.SkinnedMesh(c.geometry, c.material),
  Sprite: (c) => new M.Sprite(c.material)
}, TS = new Set(Object.keys(Ba));
function SS(c, e) {
  const t = Ba[c];
  if (t)
    return t(e);
  throw Be.panic(`object class[${c}] not found`);
}
function s1(c) {
  if (TS.has(c))
    return c;
  const e = yS(c);
  if (e)
    return s1(e);
}
function _s(c) {
  Object.keys(c).forEach((e) => delete c[e]);
}
const kt = Symbol("getProxyRawObject");
function Gd(c, e) {
  return new Proxy(c, {
    get(t, r, n) {
      if (r === kt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      if (Reflect.get(t, r, s) === n)
        return !0;
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else
        i = Reflect.set(t, r, n, t);
      return i && e && e(r, n), i;
    }
  });
}
function tr(c, e) {
  e || (e = {});
  for (const [t, r] of Object.entries(c))
    r && typeof r == "object" && r.toArray ? e[t] = r.toArray() : e[t] = c[t];
  return e;
}
function nr(c, e) {
  const t = [];
  for (const [r, n] of Object.entries(c)) {
    const s = e[r];
    s == null || s === n || (t.push(r), typeof n == "object" && n.fromArray ? n.fromArray(s) : c[r] = s);
  }
  return t;
}
Je("Object3D", {
  // cls: Object3D,
  create: () => new En(),
  members: {},
  group: "Objects.Empty Object3D",
  icon: "box"
});
const Gi = new M.Matrix4();
let nl, op, ip;
function r1(c, e, t) {
  var l, u;
  if (!t || !t.geometry)
    return 0;
  nl || (nl = new Ammo.btVector3(), op = new Ammo.btVector3(), ip = new Ammo.btVector3());
  const r = t.geometry, n = ((l = r.attributes.position) == null ? void 0 : l.array) || [], s = ((u = r.index) == null ? void 0 : u.array) || [];
  let o = 0, i;
  if (e && e !== t) {
    let h;
    e.quaternion ? h = e.quaternion : e.rotation ? h = new M.Quaternion().setFromEuler(e.rotation) : h = new M.Quaternion().identity();
    const d = new M.Matrix4().compose(new M.Vector3(1, 1, 1), h, e.position);
    Gi.copy(d.invert()), t.updateWorldMatrix(!1, !1), i = t.matrixWorld.clone().multiply(Gi);
  } else
    Gi.makeScale(t.scale.x, t.scale.y, t.scale.z), i = Gi;
  const a = s.length / 3;
  for (let h = 0; h < a; h++) {
    const d = [];
    for (let f = 0; f < 3; f++) {
      let p = new M.Vector3(n[s[h * 3 + f] * 3 + 0], n[s[h * 3 + f] * 3 + 1], n[s[h * 3 + f] * 3 + 2]);
      p = p.applyMatrix4(i);
      let m;
      f == 0 ? m = nl : f == 1 ? m = op : m = ip, m.setValue(p.x, p.y, p.z), d.push(m);
    }
    c.addTriangle(d[0], d[1], d[2]), o++;
  }
  return t.children.forEach((h) => {
    o += r1(c, e, h);
  }), o;
}
var qs;
((c) => {
  function e(o) {
    return new ammo.btVector3(o.x, o.y, o.z);
  }
  c.t2aVector3 = e;
  function t(o) {
    return new M.Vector3(o.x(), o.y(), o.z());
  }
  c.a2tVector3 = t;
  function r(o) {
    var a, l;
    const i = o.geometry;
    if (i)
      if (i.type === "PlaneGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = new ammo.btBoxShape(new ammo.btVector3(d, f, 0));
        return p.setMargin(0.01), p;
      } else if (i.type === "BoxGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = h.depth !== void 0 ? h.depth / 2 : 0.5, m = new ammo.btBoxShape(new ammo.btVector3(d, f, p));
        return m.setMargin(1e-3), m;
      } else if (i.type === "CylinderGeometry") {
        const h = i.parameters, d = new ammo.btCylinderShape(new ammo.btVector3(h.radiusBottom, h.height, h.radiusTop));
        return d.setMargin(0.01), d;
      } else if (i.type === "ConeGeometry") {
        const h = i.parameters, d = new ammo.btConeShape(h.radius, h.height);
        return d.setMargin(0.01), d;
      } else if (i.type === "CapsuleGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = h.length !== void 0 ? h.length : 1, p = new ammo.btCapsuleShape(d, f);
        return p.setMargin(0.01), p;
      } else if (i.type === "SphereGeometry" || i.type === "IcosahedronGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = new ammo.btSphereShape(d);
        return f.setMargin(1e-3), f;
      } else {
        const u = new ammo.btTriangleMesh(!0, !0), h = ((a = i.attributes.position) == null ? void 0 : a.array) || [], d = ((l = i.index) == null ? void 0 : l.array) || [];
        for (let p = 0; p * 3 < d.length; p += 1)
          u.addTriangle(
            new ammo.btVector3(
              h[d[p * 3] * 3],
              h[d[p * 3] * 3 + 1],
              h[d[p * 3] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 1] * 3],
              h[d[p * 3 + 1] * 3 + 1],
              h[d[p * 3 + 1] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 2] * 3],
              h[d[p * 3 + 2] * 3 + 1],
              h[d[p * 3 + 2] * 3 + 2]
            ),
            !1
          );
        const f = new ammo.btConvexTriangleMeshShape(u, !0);
        return f.setMargin(1e-3), f;
      }
    else {
      const u = new ammo.btTriangleMesh(!0, !0), d = r1(u, o, o) ? new Ammo.btBvhTriangleMeshShape(u, !0) : new Ammo.btCompoundShape();
      return d.setMargin(0.01), d;
    }
  }
  c.createShape = r;
  function n(o, i = 0, a) {
    const l = a || r(o);
    function u(d, f, p) {
      const m = d.position, g = d.quaternion, b = new ammo.btTransform();
      b.setIdentity(), b.setOrigin(new ammo.btVector3(m.x, m.y, m.z)), b.setRotation(new ammo.btQuaternion(g.x, g.y, g.z, g.w));
      const v = new ammo.btDefaultMotionState(b), y = new ammo.btVector3(0, 0, 0);
      p.calculateLocalInertia(f, y);
      const x = new ammo.btRigidBodyConstructionInfo(f, v, p, y);
      return new ammo.btRigidBody(x);
    }
    function h(d, f, p) {
      const m = d.instanceMatrix.array, g = [];
      for (let b = 0; b < d.count; b++) {
        const v = b * 16, y = new ammo.btTransform();
        y.setFromOpenGLMatrix(MS(m, v, v + 16));
        const x = new ammo.btDefaultMotionState(y), N = new ammo.btVector3(0, 0, 0);
        p.calculateLocalInertia(f, N);
        const w = new ammo.btRigidBodyConstructionInfo(f, x, p, N), T = new ammo.btRigidBody(w);
        g.push(T);
      }
      return g;
    }
    return o.isInstancedMesh ? h(o, i, l) : (o.isMesh, u(o, i, l));
  }
  c.createBody = n;
  function s(o) {
    ammo.destroy(o);
  }
  c.destroyBody = s;
})(qs || (qs = {}));
class _S {
  constructor(e = -9.82) {
    G(this, "world");
    G(this, "collisionConfiguration");
    G(this, "dispatcher");
    G(this, "broadphase");
    G(this, "solver");
    G(this, "softBodySolver");
    G(this, "softBodyHelpers");
    G(this, "worldTransform");
    G(this, "destroyed", !1);
    G(this, "meshes", []);
    G(this, "meshMap", /* @__PURE__ */ new WeakMap());
    G(this, "meshIdx", {});
    G(this, "conllisionMap", /* @__PURE__ */ new Set());
    this.collisionConfiguration = new ammo.btDefaultCollisionConfiguration(), this.dispatcher = new ammo.btCollisionDispatcher(this.collisionConfiguration), this.broadphase = new ammo.btDbvtBroadphase(), this.solver = new ammo.btSequentialImpulseConstraintSolver(), this.softBodySolver = new ammo.btDefaultSoftBodySolver(), this.softBodyHelpers = new Ammo.btSoftBodyHelpers(), this.world = new ammo.btSoftRigidDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collisionConfiguration, this.softBodySolver), this.world.setGravity(new ammo.btVector3(0, e, 0)), this.worldTransform = new ammo.btTransform();
  }
  dispose() {
    if (!this.destroyed) {
      for (const e of this.meshes) {
        const t = this.meshMap.get(e);
        this.meshMap.delete(e), ammo.destroy(t);
      }
      this.meshes.length = 0, ammo.destroy(this.collisionConfiguration), ammo.destroy(this.dispatcher), ammo.destroy(this.broadphase), ammo.destroy(this.solver), ammo.destroy(this.softBodySolver), ammo.destroy(this.softBodyHelpers), ammo.destroy(this.world), ammo.destroy(this.worldTransform), this.destroyed = !0;
    }
  }
  addMesh(e, t) {
    if (t) {
      if (Array.isArray(t))
        for (const r of t)
          this.world.addRigidBody(r);
      else
        this.world.addRigidBody(t);
      this.meshes.push(e), this.meshMap.set(e, t), e.id && (this.meshIdx[e.id] = e);
    }
    e.world = this;
  }
  removeMesh(e) {
    const t = this.meshMap.get(e), r = this.meshes.indexOf(e);
    if (!t) {
      e.world = void 0;
      return;
    }
    if (r !== -1 && this.meshes.splice(r, 1), this.meshMap.delete(e), delete this.meshIdx[e.id], Array.isArray(t))
      for (const n of t)
        this.world.removeRigidBody(n);
    else
      this.world.removeRigidBody(t);
    e.world = void 0;
  }
  findBody(e) {
    return this.meshMap.get(e);
  }
  setMeshPosition(e, t, r = 0) {
    if (e.isInstancedMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      const s = n[r];
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), s.setWorldTransform(this.worldTransform);
    } else if (e.isMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), n.setWorldTransform(this.worldTransform);
    }
  }
  detectCollision() {
    const e = this.dispatcher.getNumManifolds(), t = /* @__PURE__ */ new Set();
    for (let n = 0; n < e; n++) {
      const s = this.dispatcher.getManifoldByIndexInternal(n), o = s.getBody0().getUserIndex(), i = s.getBody1().getUserIndex();
      t.add(`${o}:${i}`);
    }
    for (const n of t) {
      if (this.conllisionMap.has(n))
        continue;
      this.conllisionMap.add(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionEnter", target: a }), a.dispatchEvent({ type: "onCollisionEnter", target: i }));
    }
    const r = [];
    for (const n of this.conllisionMap)
      t.has(n) || r.push(n);
    for (const n of r) {
      this.conllisionMap.delete(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionLeave", target: a }), a.dispatchEvent({ type: "onCollisionLeave", target: i }));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  step(e, t) {
    if (e) {
      this.world.stepSimulation(e, 10), this.detectCollision();
      for (let r = 0, n = this.meshes.length; r < n; r++) {
        const s = this.meshes[r];
        if (s.mass) {
          if (s.isInstancedMesh) {
            const o = s.instanceMatrix.array, i = this.meshMap.get(s);
            for (let a = 0; a < i.length; a++) {
              i[a].getMotionState().getWorldTransform(this.worldTransform);
              const h = this.worldTransform.getOrigin(), d = this.worldTransform.getRotation();
              AS(h, d, o, a * 16);
            }
            s.instanceMatrix.needsUpdate = !0, s.computeBoundingSphere();
          } else if (s.isMesh) {
            this.meshMap.get(s).getMotionState().getWorldTransform(this.worldTransform);
            const a = this.worldTransform.getOrigin(), l = this.worldTransform.getRotation();
            s.position.set(a.x(), a.y(), a.z()), s.quaternion.set(l.x(), l.y(), l.z(), l.w());
          }
        }
      }
    }
  }
}
function MS(c, e, t) {
  const r = [], n = e + t;
  for (let s = e; s < n; s++)
    r.push(c[s]);
  return r;
}
function AS(c, e, t, r) {
  const n = e.x(), s = e.y(), o = e.z(), i = e.w(), a = n + n, l = s + s, u = o + o, h = n * a, d = n * l, f = n * u, p = s * l, m = s * u, g = o * u, b = i * a, v = i * l, y = i * u;
  t[r + 0] = 1 - (p + g), t[r + 1] = d + y, t[r + 2] = f - v, t[r + 3] = 0, t[r + 4] = d - y, t[r + 5] = 1 - (h + g), t[r + 6] = m + b, t[r + 7] = 0, t[r + 8] = f + v, t[r + 9] = m - b, t[r + 10] = 1 - (h + p), t[r + 11] = 0, t[r + 12] = c.x(), t[r + 13] = c.y(), t[r + 14] = c.z(), t[r + 15] = 1;
}
var Nc = /* @__PURE__ */ ((c) => (c[c.Ghost = 0] = "Ghost", c[c.RigidBody = 1] = "RigidBody", c))(Nc || {});
n1.BodyType = {
  Ghost: 0,
  RigidBody: 1
  // SoftBody: 2,
};
const cr = 1e-3;
class Nn extends qt {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Wa(), r || new An({ wireframe: !0 }));
    G(this, "isEntity", !0);
    G(this, "geo");
    G(this, "geoMatrix", new Ge().identity());
    G(this, "physicalBody", null);
    G(this, "world");
    G(this, "_tmpAmmoVectorA", new Ammo.btVector3(0, 0, 0));
    G(this, "_tmpAmmoQuaternion", new Ammo.btQuaternion(0, 0, 0, 1));
    this._bodyType = n, this._mass = s, this.type = "Entity", t || this.rebuildBody(), this.geo = Gd(Object.assign({}, this.parameters), () => {
      this.rebuildGeometry();
    });
  }
  get mass() {
    return this._mass;
  }
  set mass(t) {
    this._mass !== t && (this._mass === 0 || t === 0 ? (this._mass = t, this.rebuildBody()) : this.physicalBody.setMassProps(t));
  }
  get bodyType() {
    return this._bodyType;
  }
  set bodyType(t) {
    this._bodyType !== t && (this._bodyType = t, this.rebuildBody());
  }
  get parameters() {
    return this.geometry.parameters || {};
  }
  moveTo(t) {
    this.physicalBody && this.setPhysicsBodyTransformation(t), this.position.copy(t);
  }
  applyTranslation(t) {
    return this.applyGeoMatrix4(new Ge().makeTranslation(t));
  }
  applyRotationFromEuler(t) {
    return this.applyGeoMatrix4(new Ge().makeRotationFromEuler(t));
  }
  applyScale(t) {
    return this.applyGeoMatrix4(new Ge().makeScale(t.x, t.y, t.z));
  }
  applyGeoMatrix4(t) {
    this.geoMatrix.premultiply(t), this.geometry.applyMatrix4(t);
  }
  clone(t) {
    const r = super.clone(t), n = this._mass || 0, s = this._bodyType || 0;
    (n !== this._mass || s !== this._bodyType) && (r._mass = n, r._bodyType = s, r.rebuildBody());
    const o = r.geo[kt];
    return Object.assign(o, this.parameters), r.geoMatrix.copy(this.geoMatrix), r;
  }
  serialize(t) {
    t.mass = this._mass, t.bodyType = this._bodyType, t.geoMatrix = this.geoMatrix.toArray();
  }
  deserialize(t) {
    const r = t.mass || 0, n = t.bodyType || 0;
    (r !== this._mass || n !== this._bodyType) && (this._mass = r, this._bodyType = n, this.rebuildBody());
    const s = this.geo[kt];
    Object.assign(s, this.parameters), t.geoMatrix && (this.geoMatrix.fromArray(t.geoMatrix), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox()), this.setPhysicsBodyTransformation(this.position);
  }
  dispose() {
    if (this.material instanceof kn)
      this.material.dispose();
    else if (Array.isArray(this.material))
      for (const t of this.material)
        t.material.dispose();
    this.physicalBody && (this.world && this.world.removeMesh(this), qs.destroyBody(this.physicalBody), this.physicalBody = null);
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose(), this.geometry = t.fromJSON(this.geo[kt]), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
  rebuildBody() {
    const t = this.world;
    this.physicalBody && (this.world && this.world.removeMesh(this), qs.destroyBody(this.physicalBody)), this._bodyType !== 0 ? (this.physicalBody = qs.createBody(this, this._mass), this.physicalBody.setUserIndex(this.id), t && t.addMesh(this, this.physicalBody)) : this.physicalBody = null;
  }
  /**
   * Sets the babylon object's position/rotation from the physics body's position/rotation
   * @param impostor imposter containing the physics body and babylon object
   * @param newPosition new position
   * @param newRotation new rotation
   */
  setPhysicsBodyTransformation(t, r) {
    if (!this.physicalBody)
      return;
    const n = this.physicalBody.getWorldTransform();
    if (Math.abs(n.getOrigin().x() - t.x) > cr || Math.abs(n.getOrigin().y() - t.y) > cr || Math.abs(n.getOrigin().z() - t.z) > cr || r && (Math.abs(n.getRotation().x() - r.x) > cr || Math.abs(n.getRotation().y() - r.y) > cr || Math.abs(n.getRotation().z() - r.z) > cr || Math.abs(n.getRotation().w() - r.w) > cr))
      if (this._tmpAmmoVectorA.setValue(t.x, t.y, t.z), n.setOrigin(this._tmpAmmoVectorA), r && (this._tmpAmmoQuaternion.setValue(r.x, r.y, r.z, r.w), n.setRotation(this._tmpAmmoQuaternion)), this.physicalBody.setWorldTransform(n), this.mass == 0) {
        const s = this.physicalBody.getMotionState();
        s && s.setWorldTransform(n);
      } else
        this.physicalBody.activate();
  }
}
Je("Entity", {
  create: ({ material: c, geometry: e } = {}) => new Nn(e, c),
  members: {
    mass: "Number",
    bodyType: "types.BodyType"
  },
  proto: "Mesh",
  group: "",
  icon: ""
});
const CS = 1024, ES = 1024, sl = new ye(), RS = new ye(), sn = {
  /** world time delta */
  delta: 0,
  /** world current time */
  now: 0,
  /** to y axis */
  gravity: new ye(0, -9.8, 0),
  windForce: new ye(),
  scene: null,
  gpuComputeRender: null,
  /** wait for x miliseconds */
  wait(c) {
    return new Promise((e) => {
      setTimeout(e, c, !0);
    });
  },
  random(c, e) {
    return c + Math.floor(Math.random() * (e - c + 1));
  },
  randomChoice(c) {
    if (Array.isArray(c)) {
      const e = Math.floor(Math.random() * c.length);
      return c[e];
    } else {
      const e = Object.keys(c), t = Math.floor(Math.random() * e.length);
      return c[t];
    }
  },
  calcObjectPosition(c, e, t, r) {
    if (t <= 0)
      return [c, e];
    const n = r ? sl.copy(e).normalize().multiply(e).multiply(e).multiplyScalar(-r) : sl.set(0, 0, 0);
    n.add(this.windForce);
    const s = n.divideScalar(t);
    s.add(this.gravity);
    const o = s.multiplyScalar(this.delta).add(e);
    return [RS.copy(o).add(e).multiplyScalar(0.5 * this.delta).add(c), sl];
  },
  combineBuffer(c, e, t) {
    let r = 0, n = 3;
    c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        n = f.itemSize, r += f.array.length;
      }
    });
    const s = r / n, o = t && s > t ? Math.ceil(s / t) : 1, i = Math.ceil(r / (n * o)), a = new Float32Array(i * n);
    let l = 0, u = 0, h = 0;
    return c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        if (o === 1)
          a.set(f.array, h * n), l += f.array.length, h += f.array.length / n, u = l / n;
        else {
          const p = f.count;
          for (let m = 0; m < p; m++)
            u % o === 0 && (a[h * n] = f.array[m * n], a[h * n + 1] = f.array[m * n + 1], a[h * n + 2] = f.array[m * n + 2], h++), u++;
          l += f.array.length;
        }
      }
    }), new ro(a, n);
  }
};
class o1 extends Ha {
  constructor() {
    super();
    G(this, "isPhysicalScene", !0);
    G(this, "physics");
    G(this, "windForce", new ye());
    /** to y axis */
    G(this, "_gravity", -9.8);
    G(this, "objectsTrash", {});
    this.type = "PhysicalScene", this.physics = new _S(this._gravity);
  }
  get gravity() {
    return this._gravity;
  }
  set gravity(t) {
    this._gravity !== t && (this._gravity = t, this.physics.world.setGravity(new Ammo.btVector3(0, this._gravity, 0)));
  }
  update(t, r, n, s, o = !1) {
    sn.scene = this, sn.gravity.y = this._gravity;
    const i = this.windForce.clone().multiplyScalar(0.5 + 0.5 * Math.sin(s / 2e3));
    if (sn.windForce.copy(i), !o) {
      for (const a of this.children)
        a.visible && a.graph && a.graph.update(t, r, n, s);
      this.physics.step(n, s);
    }
  }
  add(...t) {
    super.add(...t);
    for (const r of t)
      delete this.objectsTrash[r.id], r instanceof Nn && this.physics.addMesh(r, r.physicalBody), r.dispatchEvent({ type: "onBorn", source: this, object: r });
    return this;
  }
  remove(...t) {
    super.remove(...t);
    for (const r of t)
      r instanceof Nn && this.physics.removeMesh(r), r.dispatchEvent({ type: "onDead", source: this, object: r }), this.objectsTrash[r.id] = r;
    return this;
  }
  serialize(t) {
    t.gravity = this.gravity, t.windForce = this.windForce.toArray();
  }
  deserialize(t) {
    t.gravity && (this.gravity = t.gravity), t.windForce && this.windForce.fromArray(t.windForce);
  }
  active() {
    this.dispatchEvent({ type: "onBorn", source: this, object: this });
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onBorn", source: this, object: t });
  }
  deactive() {
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onDead", source: this, object: t });
    this.dispatchEvent({ type: "onDead", source: this, object: this });
  }
  dispose() {
    for (const t of Object.values(this.objectsTrash))
      t.traverse((r) => {
        if (r.dispose)
          r.dispose();
        else if (r.geometry instanceof Kn && r.geometry.dispose(), r.material instanceof kn)
          r.material.dispose();
        else if (Array.isArray(r.material))
          for (const n of r.material)
            n.dispose();
      });
    this.physics.dispose();
  }
}
Je("PhysicalScene", {
  // cls: PhysicalScene,
  members: {
    gravity: "Number",
    windForce: "Vector3"
  },
  proto: "Scene",
  group: "Scenes.Physical Scene",
  icon: "scene",
  create: () => new o1()
});
const ap = new sr(), Vi = new ye();
class i1 extends bm {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new yn(e, 3)), this.setAttribute("uv", new yn(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Na(t, 6, 1);
    return this.setAttribute("instanceStart", new Ws(r, 3, 0)), this.setAttribute("instanceEnd", new Ws(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Na(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Ws(r, 3, 0)), this.setAttribute("instanceColorEnd", new Ws(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Cx(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sr());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), ap.setFromBufferAttribute(t), this.boundingBox.union(ap));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Vi.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Vi)), Vi.fromBufferAttribute(t, s), n = Math.max(n, r.distanceToSquared(Vi));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
oo.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new wt(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
cs.line = {
  uniforms: rr.merge([
    oo.common,
    oo.fog,
    oo.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Vd extends hs {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: rr.clone(cs.line.uniforms),
      vertexShader: cs.line.vertexShader,
      fragmentShader: cs.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const cp = new ye(), lp = new ye(), jt = new pt(), Wt = new pt(), is = new pt(), rl = new ye(), ol = new Ge(), Xt = new Ex(), up = new ye(), ji = new sr(), Wi = new yi(), as = new pt();
let us, yr;
function hp(c, e, t) {
  return as.set(0, 0, -e, 1).applyMatrix4(c.projectionMatrix), as.multiplyScalar(1 / as.w), as.x = yr / t.width, as.y = yr / t.height, as.applyMatrix4(c.projectionMatrixInverse), as.multiplyScalar(1 / as.w), Math.abs(Math.max(as.x, as.y));
}
function FS(c, e) {
  const t = c.matrixWorld, r = c.geometry, n = r.attributes.instanceStart, s = r.attributes.instanceEnd, o = Math.min(r.instanceCount, n.count);
  for (let i = 0, a = o; i < a; i++) {
    Xt.start.fromBufferAttribute(n, i), Xt.end.fromBufferAttribute(s, i), Xt.applyMatrix4(t);
    const l = new ye(), u = new ye();
    us.distanceSqToSegment(Xt.start, Xt.end, u, l), u.distanceTo(l) < yr * 0.5 && e.push({
      point: u,
      pointOnLine: l,
      distance: us.origin.distanceTo(u),
      object: c,
      face: null,
      faceIndex: i,
      uv: null,
      uv1: null
    });
  }
}
function LS(c, e, t) {
  const r = e.projectionMatrix, s = c.material.resolution, o = c.matrixWorld, i = c.geometry, a = i.attributes.instanceStart, l = i.attributes.instanceEnd, u = Math.min(i.instanceCount, a.count), h = -e.near;
  us.at(1, is), is.w = 1, is.applyMatrix4(e.matrixWorldInverse), is.applyMatrix4(r), is.multiplyScalar(1 / is.w), is.x *= s.x / 2, is.y *= s.y / 2, is.z = 0, rl.copy(is), ol.multiplyMatrices(e.matrixWorldInverse, o);
  for (let d = 0, f = u; d < f; d++) {
    if (jt.fromBufferAttribute(a, d), Wt.fromBufferAttribute(l, d), jt.w = 1, Wt.w = 1, jt.applyMatrix4(ol), Wt.applyMatrix4(ol), jt.z > h && Wt.z > h)
      continue;
    if (jt.z > h) {
      const y = jt.z - Wt.z, x = (jt.z - h) / y;
      jt.lerp(Wt, x);
    } else if (Wt.z > h) {
      const y = Wt.z - jt.z, x = (Wt.z - h) / y;
      Wt.lerp(jt, x);
    }
    jt.applyMatrix4(r), Wt.applyMatrix4(r), jt.multiplyScalar(1 / jt.w), Wt.multiplyScalar(1 / Wt.w), jt.x *= s.x / 2, jt.y *= s.y / 2, Wt.x *= s.x / 2, Wt.y *= s.y / 2, Xt.start.copy(jt), Xt.start.z = 0, Xt.end.copy(Wt), Xt.end.z = 0;
    const m = Xt.closestPointToPointParameter(rl, !0);
    Xt.at(m, up);
    const g = Zt.lerp(jt.z, Wt.z, m), b = g >= -1 && g <= 1, v = rl.distanceTo(up) < yr * 0.5;
    if (b && v) {
      Xt.start.fromBufferAttribute(a, d), Xt.end.fromBufferAttribute(l, d), Xt.start.applyMatrix4(o), Xt.end.applyMatrix4(o);
      const y = new ye(), x = new ye();
      us.distanceSqToSegment(Xt.start, Xt.end, x, y), t.push({
        point: x,
        pointOnLine: y,
        distance: us.origin.distanceTo(x),
        object: c,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class OS extends qt {
  constructor(e = new i1(), t = new Vd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, i = 0, a = t.count; o < a; o++, i += 2)
      cp.fromBufferAttribute(t, o), lp.fromBufferAttribute(r, o), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + cp.distanceTo(lp);
    const s = new Na(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Ws(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Ws(s, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, n = e.camera;
    n === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    us = e.ray;
    const o = this.matrixWorld, i = this.geometry, a = this.material;
    yr = a.linewidth + s, i.boundingSphere === null && i.computeBoundingSphere(), Wi.copy(i.boundingSphere).applyMatrix4(o);
    let l;
    if (r)
      l = yr * 0.5;
    else {
      const h = Math.max(n.near, Wi.distanceToPoint(us.origin));
      l = hp(n, h, a.resolution);
    }
    if (Wi.radius += l, us.intersectsSphere(Wi) === !1)
      return;
    i.boundingBox === null && i.computeBoundingBox(), ji.copy(i.boundingBox).applyMatrix4(o);
    let u;
    if (r)
      u = yr * 0.5;
    else {
      const h = Math.max(n.near, ji.distanceToPoint(us.origin));
      u = hp(n, h, a.resolution);
    }
    ji.expandByScalar(u), us.intersectsBox(ji) !== !1 && (r ? FS(this, t) : LS(this, n, t));
  }
}
class a1 extends i1 {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class IS extends OS {
  constructor(e = new a1(), t = new Vd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class il extends a1 {
  constructor() {
    super(...arguments);
    G(this, "isBezieoLineGeometry", !0);
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    return t.uuid = this.uuid, t.type = "BufferGeometry", t.data = {}, t;
  }
}
class ka extends Vd {
  constructor() {
    super();
    G(this, "isBezierLineMaterial", !0);
    this.type = "BezierLineMaterial";
  }
}
class PS extends IS {
  constructor() {
    super(new il(), new ka());
    G(this, "isBezierLine", !0);
    G(this, "fromPosition", new ye());
    G(this, "toPosition", new ye(1, 1, 0));
    G(this, "ctrl1", new ye(0.2, 0.1, 0));
    G(this, "ctrl2", new ye(0.8, 0.9, 0));
    G(this, "density", 10);
    G(this, "_tmpSize", new wt());
    this.type = "BezierLine", this.material.worldUnits = !0, this.material.linewidth = 0.1, this.onBeforeRender = (t, r, n, s, o, i) => {
      const { x: a, y: l } = t.getSize(this._tmpSize);
      (this.material.resolution.x !== a || this.material.resolution.y !== l) && (this.material.resolution.set(a, l), this.material.uniformsNeedUpdate = !0);
    }, this.updatePositions();
  }
  updatePositions() {
    const t = new Rx(this.fromPosition, this.ctrl1, this.ctrl2, this.toPosition), r = Math.abs(this.fromPosition.clone().distanceTo(this.toPosition)), n = t.getPoints(this.density * r);
    this.geometry.setPositions(n.map((s) => [s.x, s.y, s.z]).flat()), this.computeLineDistances();
  }
  serialize(t) {
    t.type = "BezierLine", t.fromPosition = this.fromPosition.toArray(), t.toPosition = this.toPosition.toArray(), t.ctrl1 = this.ctrl1.toArray(), t.ctrl2 = this.ctrl2.toArray(), t.density = this.density;
  }
  deserialize(t) {
    this.fromPosition.fromArray(t.fromPosition), this.toPosition.fromArray(t.toPosition), this.ctrl1.fromArray(t.ctrl1), this.ctrl2.fromArray(t.ctrl2), this.density = t.density, this.geometry instanceof il || (this.geometry = new il()), this.updatePositions();
  }
}
wS("BezierLineMaterial", ka);
Je("BezierLine", {
  // cls: BezierLine,
  create: () => new PS(),
  members: {
    fromPosition: "Vector3",
    toPosition: "Vector3",
    ctrl1: "Vector3",
    ctrl2: "Vector3",
    density: "Number"
  },
  proto: "Mesh",
  group: "Objects.Bezier Line",
  icon: "line"
});
Fs("BezierLineMaterial", ka, {
  color: "Color",
  dashed: "Boolean",
  dashScale: "Number",
  dashSize: "Number",
  dashOffset: "Number",
  gapSize: "Number",
  opacity: "Number",
  linewidth: "Number",
  alphaToCoverage: "Boolean",
  worldUnits: "Boolean"
}, "ShaderMaterial", {
  bezierLineMaterial: { clsName: "bezierLineMaterial", func: () => new ka(), group: "Material.Bezier Line Material", icon: "brand-medium" }
});
Je("PerspectiveCamera", {
  // cls: PerspectiveCamera,
  create: () => new br(),
  members: {},
  group: "Cameras.Perspective Camera",
  icon: "camera"
});
Je("OrthographicCamera", {
  // cls: OrthographicCamera,
  create: () => new Xa(),
  members: {},
  group: "Cameras.Orthographic Camera",
  icon: "camera"
});
class US extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isBox", !0);
    this.type = "Box";
  }
}
Je("Box", {
  create: ({ material: c, geometry: e } = {}) => new US(e, c || new jn()),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.depthSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Box",
  icon: "box"
});
class DS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCapsule", !0);
    this.type = "Capsule";
  }
}
Je("Capsule", {
  create: ({ material: c, geometry: e } = {}) => new DS(e || new Nm(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Capsule",
  icon: "capsule"
});
class zS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCone", !0);
    this.type = "Cone";
  }
}
Je("Cone", {
  create: ({ material: c, geometry: e } = {}) => new zS(e || new Fx(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cone",
  icon: "cone"
});
class BS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCylinder", !0);
    this.type = "Cylinder";
  }
}
Je("Cylinder", {
  create: ({ material: c, geometry: e } = {}) => new BS(e || new Lx(), c || new jn()),
  members: {
    "geo.radiusTop": "Number",
    "geo.radiusBottom": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cylinder",
  icon: "cylinder"
});
let kS = class extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isSphere", !0);
    this.type = "Sphere";
  }
};
Je("Sphere", {
  create: ({ material: c, geometry: e } = {}) => new kS(e || new $a(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.phiStart": "Number",
    "geo.phiLength": "Number",
    "geo.phiSegments": "Number",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Sphere",
  icon: "sphere"
});
class GS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorus", !0);
    this.type = "Torus";
  }
}
Je("Torus", {
  create: ({ material: c, geometry: e } = {}) => new GS(e || new Ox(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.arc": "Number"
  },
  proto: "Entity",
  group: "Entities.Torus",
  icon: "ring"
});
class VS extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorusKnot", !0);
    this.type = "TorusKnot";
  }
}
Je("TorusKnot", {
  create: ({ material: c, geometry: e } = {}) => new VS(e || new Ix(), c || new jn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.p": "Number",
    "geo.q": "Number"
  },
  proto: "Entity",
  group: "Entities.TorusKnot",
  icon: "pipe"
});
const jS = {
  curveSegments: 12,
  steps: 1,
  depth: 1,
  bevelEnabled: !0,
  bevelThickness: 0.2,
  bevelSize: 0.1,
  bevelOffset: 0,
  bevelSegments: 3
};
let Ar = class extends Nn {
  constructor(t, r, n, s = 0, o = 0) {
    super(t || new wm(), r || new jn(), s, o);
    G(this, "isShape", !0);
    G(this, "shapes", []);
    G(this, "props");
    this.type = "Shape", this.props = Gd({ ...n }, () => {
      this.rebuildShapes();
    }), t || this.rebuildShapes();
  }
  get parameters() {
    var r;
    const t = ((r = this.geometry.parameters) == null ? void 0 : r.options) || {};
    return Object.keys(t).length ? t : { ...jS };
  }
  clone(t) {
    const r = super.clone(t), n = this.props[kt], s = tr(n), o = r.props[kt];
    return nr(o, s), r;
  }
  serialize(t) {
    super.serialize(t);
    const r = this.props[kt];
    t.props = tr(r);
  }
  deserialize(t) {
    if (super.deserialize(t), t.props) {
      const r = this.props[kt];
      nr(r, t.props);
    }
    this.shapes = Array.isArray(this.geometry.parameters.shapes) ? this.geometry.parameters.shapes : [this.geometry.parameters.shapes];
  }
  rebuildShapes() {
    this.rebuildGeometry();
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose();
    const r = this.geo[kt];
    this.geometry = t.fromJSON({ shapes: this.shapes.map((n, s) => s), options: r }, this.shapes), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
};
Je("Shape", {
  create: ({ material: c, geometry: e } = {}) => new Ar(e, c),
  members: {
    "geo.curveSegments": "Number",
    "geo.steps": "Number",
    "geo.depth": "Number",
    "geo.bevelEnabled": "Boolean",
    "geo.bevelThickness": "Number",
    "geo.bevelSize": "Number",
    "geo.bevelOffset": "Number",
    "geo.bevelSegments": "Number"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class WS extends Nn {
  constructor(t, r) {
    super(t || new Sr(), r || new jn(), Nc.Ghost, 0);
    G(this, "isPlane", !0);
    this.type = "Plane";
  }
}
Je("Plane", {
  create: ({ material: c, geometry: e } = {}) => new WS(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number"
  },
  /** yes, we hide mass and body-type properties */
  proto: "Mesh",
  group: "Shapes.Plane",
  icon: "plane"
});
class HS extends Ar {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { vec1: new wt(0, 0), vec2: new wt(1, 0), vec3: new wt(0, 1) }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeTriangle";
  }
  rebuildShapes() {
    const t = new xu(), r = new bo();
    t.subPaths.push(r);
    const { vec1: n, vec2: s, vec3: o } = this.props;
    r.moveTo(n.x, n.y), r.lineTo(s.x, s.y), r.lineTo(o.x, o.y), r.lineTo(n.x, n.y), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Je("ShapeTriangle", {
  create: ({ material: c, geometry: e } = {}) => new HS(e, c),
  members: {
    "props.vec1": "Vector2",
    "props.vec2": "Vector2",
    "props.vec3": "Vector2"
  },
  proto: "Shape",
  group: "Shapes.Triangle",
  icon: "triangle"
});
class XS extends Ar {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { size: 1 }, n, s);
    G(this, "isShapeSquare", !0);
    this.type = "ShapeSquare";
  }
  rebuildShapes() {
    const t = new bo(), { size: r } = this.props;
    t.moveTo(0, 0), t.lineTo(r, 0), t.lineTo(r, r), t.lineTo(0, r), t.lineTo(0, 0), this.shapes = [t], this.rebuildGeometry();
  }
}
Je("ShapeSquare", {
  create: ({ material: c, geometry: e } = {}) => new XS(e, c),
  members: {
    "props.size": "Number"
  },
  proto: "Shape",
  group: "Shapes.Square",
  icon: "square"
});
class $S extends Ar {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { width: 1, height: 1, radius: 0.2 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeRounded";
  }
  rebuildShapes() {
    const t = new xu(), r = new bo();
    t.subPaths.push(r);
    const { width: n, height: s, radius: o } = this.props;
    r.moveTo(0, o), r.lineTo(0, s - o), r.quadraticCurveTo(0, s, o, s), r.lineTo(0 + n - o, s), r.quadraticCurveTo(n, s, n, s - o), r.lineTo(0 + n, o), r.quadraticCurveTo(n, 0, n - o, 0), r.lineTo(o, 0), r.quadraticCurveTo(0, 0, 0, o), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Je("ShapeRounded", {
  create: ({ material: c, geometry: e } = {}) => new $S(e, c),
  members: {
    "props.width": "Number",
    "props.height": "Number",
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Rounded rectangle",
  icon: "square"
});
class qS extends Ar {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeCircle";
  }
  rebuildShapes() {
    const t = new bo(), { radius: r } = this.props;
    t.moveTo(0, r).quadraticCurveTo(r, r, r, 0).quadraticCurveTo(r, -r, 0, -r).quadraticCurveTo(-r, -r, -r, 0).quadraticCurveTo(-r, r, 0, r), this.shapes = [t], this.rebuildGeometry();
  }
}
Je("ShapeCircle", {
  create: ({ material: c, geometry: e } = {}) => new qS(e, c),
  members: {
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Circle",
  icon: "ring"
});
class JS extends Ar {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1, innerRadius: 0.5 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeArc";
  }
  rebuildShapes() {
    const t = new bo(), { radius: r, innerRadius: n } = this.props;
    t.moveTo(r, 0).absarc(0, 0, r, 0, Math.PI * 2, !1);
    const s = new Px().moveTo(n, 0).absarc(0, 0, n, 0, Math.PI * 2, !0);
    t.holes.push(s), this.shapes = [t], this.rebuildGeometry();
  }
}
Je("ShapeArc", {
  create: ({ material: c, geometry: e } = {}) => new JS(e, c),
  members: {
    "props.radius": "Number",
    "props.innerRadius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Arc Circle",
  icon: "ring"
});
Je("PointLight", {
  // cls: PointLight,
  create: () => {
    const c = new Zo();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Point Light",
  icon: "bulb"
});
Je("SpotLight", {
  // cls: SpotLight,
  create: () => {
    const c = new mi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Spot Light",
  icon: "bulb"
});
Je("DirectionalLight", {
  // cls: DirectionalLight,
  create: () => {
    const c = new pi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c.shadow.bias = -0.1, c;
  },
  members: {},
  group: "Lights.Directional Light",
  icon: "bulb"
});
Je("AmbientLight", {
  // cls: AmbientLight,
  create: () => new yu(),
  members: {},
  group: "Lights.Ambient Light",
  icon: "bulb"
});
Je("HemisphereLight", {
  // cls: HemisphereLight,
  create: () => new gm(),
  members: {},
  group: "Lights.Hemisphere Light",
  icon: "bulb"
});
function YS() {
  var c = /* @__PURE__ */ Object.create(null);
  function e(n, s) {
    var o = n.id, i = n.name, a = n.dependencies;
    a === void 0 && (a = []);
    var l = n.init;
    l === void 0 && (l = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !c[o])
      try {
        a = a.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = c[d.id].value), d;
        }), l = r("<" + i + ">.init", l), u && (u = r("<" + i + ">.getTransferables", u));
        var h = null;
        typeof l == "function" ? h = l.apply(void 0, a) : console.error("worker module init function failed to rehydrate"), c[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, s(h);
      } catch (d) {
        d && d.noLog || console.error(d), s(d);
      }
  }
  function t(n, s) {
    var o, i = n.id, a = n.args;
    (!c[i] || typeof c[i].value != "function") && s(new Error("Worker module " + i + ": not found or its 'init' did not return a function"));
    try {
      var l = (o = c[i]).value.apply(o, a);
      l && typeof l.then == "function" ? l.then(u, function(h) {
        return s(h instanceof Error ? h : new Error("" + h));
      }) : u(l);
    } catch (h) {
      s(h);
    }
    function u(h) {
      try {
        var d = c[i].getTransferables && c[i].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), s(h, d);
      } catch (f) {
        console.error(f), s(f);
      }
    }
  }
  function r(n, s) {
    var o = void 0;
    self.troikaDefine = function(a) {
      return o = a;
    };
    var i = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(i);
    } catch (a) {
      console.error(a);
    }
    return URL.revokeObjectURL(i), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var s = n.data, o = s.messageId, i = s.action, a = s.data;
    try {
      i === "registerModule" && e(a, function(l) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof l == "function" }
        });
      }), i === "callModule" && t(a, function(l, u) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: l
        }, u || void 0);
      });
    } catch (l) {
      postMessage({
        messageId: o,
        success: !1,
        error: l.stack
      });
    }
  });
}
function KS(c) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = c.dependencies, r = c.init;
    t = Array.isArray(t) ? t.map(
      function(s) {
        return s && s._getInitResult ? s._getInitResult() : s;
      }
    ) : [];
    var n = Promise.all(t).then(function(s) {
      return r.apply(null, s);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var c1 = function() {
  var c = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), c = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return c1 = function() {
    return c;
  }, c;
}, ZS = 0, QS = 0, al = !1, $o = /* @__PURE__ */ Object.create(null), qo = /* @__PURE__ */ Object.create(null), tu = /* @__PURE__ */ Object.create(null);
function fs(c) {
  if ((!c || typeof c.init != "function") && !al)
    throw new Error("requires `options.init` function");
  var e = c.dependencies, t = c.init, r = c.getTransferables, n = c.workerId;
  if (!c1())
    return KS(c);
  n == null && (n = "#default");
  var s = "workerModule" + ++ZS, o = c.name || s, i = null;
  e = e && e.map(function(l) {
    return typeof l == "function" && !l.workerModuleData && (al = !0, l = fs({
      workerId: n,
      name: "<" + o + "> function dependency: " + l.name,
      init: `function(){return (
` + ya(l) + `
)}`
    }), al = !1), l && l.workerModuleData && (l = l.workerModuleData), l;
  });
  function a() {
    for (var l = [], u = arguments.length; u--; )
      l[u] = arguments[u];
    if (!i) {
      i = dp(n, "registerModule", a.workerModuleData);
      var h = function() {
        i = null, qo[n].delete(h);
      };
      (qo[n] || (qo[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return i.then(function(d) {
      var f = d.isCallable;
      if (f)
        return dp(n, "callModule", { id: s, args: l });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return a.workerModuleData = {
    isWorkerModule: !0,
    id: s,
    name: o,
    dependencies: e,
    init: ya(t),
    getTransferables: r && ya(r)
  }, a;
}
function e_(c) {
  qo[c] && qo[c].forEach(function(e) {
    e();
  }), $o[c] && ($o[c].terminate(), delete $o[c]);
}
function ya(c) {
  var e = c.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function t_(c) {
  var e = $o[c];
  if (!e) {
    var t = ya(YS);
    e = $o[c] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + c.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var n = r.data, s = n.messageId, o = tu[s];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete tu[s], o(n);
    };
  }
  return e;
}
function dp(c, e, t) {
  return new Promise(function(r, n) {
    var s = ++QS;
    tu[s] = function(o) {
      o.success ? r(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, t_(c).postMessage({
      messageId: s,
      action: e,
      data: t
    });
  });
}
function l1() {
  var c = function(e) {
    function t(H, X, C, O, I, k, z, Q) {
      var j = 1 - z;
      Q.x = j * j * H + 2 * j * z * C + z * z * I, Q.y = j * j * X + 2 * j * z * O + z * z * k;
    }
    function r(H, X, C, O, I, k, z, Q, j, q) {
      var ie = 1 - j;
      q.x = ie * ie * ie * H + 3 * ie * ie * j * C + 3 * ie * j * j * I + j * j * j * z, q.y = ie * ie * ie * X + 3 * ie * ie * j * O + 3 * ie * j * j * k + j * j * j * Q;
    }
    function n(H, X) {
      for (var C = /([MLQCZ])([^MLQCZ]*)/g, O, I, k, z, Q; O = C.exec(H); ) {
        var j = O[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(q) {
          return parseFloat(q);
        });
        switch (O[1]) {
          case "M":
            z = I = j[0], Q = k = j[1];
            break;
          case "L":
            (j[0] !== z || j[1] !== Q) && X("L", z, Q, z = j[0], Q = j[1]);
            break;
          case "Q": {
            X("Q", z, Q, z = j[2], Q = j[3], j[0], j[1]);
            break;
          }
          case "C": {
            X("C", z, Q, z = j[4], Q = j[5], j[0], j[1], j[2], j[3]);
            break;
          }
          case "Z":
            (z !== I || Q !== k) && X("L", z, Q, I, k);
            break;
        }
      }
    }
    function s(H, X, C) {
      C === void 0 && (C = 16);
      var O = { x: 0, y: 0 };
      n(H, function(I, k, z, Q, j, q, ie, ae, $) {
        switch (I) {
          case "L":
            X(k, z, Q, j);
            break;
          case "Q": {
            for (var L = k, te = z, Z = 1; Z < C; Z++)
              t(
                k,
                z,
                q,
                ie,
                Q,
                j,
                Z / (C - 1),
                O
              ), X(L, te, O.x, O.y), L = O.x, te = O.y;
            break;
          }
          case "C": {
            for (var Y = k, ee = z, fe = 1; fe < C; fe++)
              r(
                k,
                z,
                q,
                ie,
                ae,
                $,
                Q,
                j,
                fe / (C - 1),
                O
              ), X(Y, ee, O.x, O.y), Y = O.x, ee = O.y;
            break;
          }
        }
      });
    }
    var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", i = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", a = /* @__PURE__ */ new WeakMap(), l = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(H, X) {
      var C = H.getContext ? H.getContext("webgl", l) : H, O = a.get(C);
      if (!O) {
        let ie = function(Y) {
          var ee = k[Y];
          if (!ee && (ee = k[Y] = C.getExtension(Y), !ee))
            throw new Error(Y + " not supported");
          return ee;
        }, ae = function(Y, ee) {
          var fe = C.createShader(ee);
          return C.shaderSource(fe, Y), C.compileShader(fe), fe;
        }, $ = function(Y, ee, fe, ne) {
          if (!z[Y]) {
            var ue = {}, de = {}, K = C.createProgram();
            C.attachShader(K, ae(ee, C.VERTEX_SHADER)), C.attachShader(K, ae(fe, C.FRAGMENT_SHADER)), C.linkProgram(K), z[Y] = {
              program: K,
              transaction: function(pe) {
                C.useProgram(K), pe({
                  setUniform: function(he, $e) {
                    for (var ce = [], be = arguments.length - 2; be-- > 0; )
                      ce[be] = arguments[be + 2];
                    var ge = de[$e] || (de[$e] = C.getUniformLocation(K, $e));
                    C["uniform" + he].apply(C, [ge].concat(ce));
                  },
                  setAttribute: function(he, $e, ce, be, ge) {
                    var Te = ue[he];
                    Te || (Te = ue[he] = {
                      buf: C.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: C.getAttribLocation(K, he),
                      data: null
                    }), C.bindBuffer(C.ARRAY_BUFFER, Te.buf), C.vertexAttribPointer(Te.loc, $e, C.FLOAT, !1, 0, 0), C.enableVertexAttribArray(Te.loc), I ? C.vertexAttribDivisor(Te.loc, be) : ie("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Te.loc, be), ge !== Te.data && (C.bufferData(C.ARRAY_BUFFER, ge, ce), Te.data = ge);
                  }
                });
              }
            };
          }
          z[Y].transaction(ne);
        }, L = function(Y, ee) {
          j++;
          try {
            C.activeTexture(C.TEXTURE0 + j);
            var fe = Q[Y];
            fe || (fe = Q[Y] = C.createTexture(), C.bindTexture(C.TEXTURE_2D, fe), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MIN_FILTER, C.NEAREST), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MAG_FILTER, C.NEAREST)), C.bindTexture(C.TEXTURE_2D, fe), ee(fe, j);
          } finally {
            j--;
          }
        }, te = function(Y, ee, fe) {
          var ne = C.createFramebuffer();
          q.push(ne), C.bindFramebuffer(C.FRAMEBUFFER, ne), C.activeTexture(C.TEXTURE0 + ee), C.bindTexture(C.TEXTURE_2D, Y), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_2D, Y, 0);
          try {
            fe(ne);
          } finally {
            C.deleteFramebuffer(ne), C.bindFramebuffer(C.FRAMEBUFFER, q[--q.length - 1] || null);
          }
        }, Z = function() {
          k = {}, z = {}, Q = {}, j = -1, q.length = 0;
        };
        var I = typeof WebGL2RenderingContext < "u" && C instanceof WebGL2RenderingContext, k = {}, z = {}, Q = {}, j = -1, q = [];
        C.canvas.addEventListener("webglcontextlost", function(Y) {
          Z(), Y.preventDefault();
        }, !1), a.set(C, O = {
          gl: C,
          isWebGL2: I,
          getExtension: ie,
          withProgram: $,
          withTexture: L,
          withTextureFramebuffer: te,
          handleContextLoss: Z
        });
      }
      X(O);
    }
    function h(H, X, C, O, I, k, z, Q) {
      z === void 0 && (z = 15), Q === void 0 && (Q = null), u(H, function(j) {
        var q = j.gl, ie = j.withProgram, ae = j.withTexture;
        ae("copy", function($, L) {
          q.texImage2D(q.TEXTURE_2D, 0, q.RGBA, I, k, 0, q.RGBA, q.UNSIGNED_BYTE, X), ie("copy", o, i, function(te) {
            var Z = te.setUniform, Y = te.setAttribute;
            Y("aUV", 2, q.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", L), q.bindFramebuffer(q.FRAMEBUFFER, Q || null), q.disable(q.BLEND), q.colorMask(z & 8, z & 4, z & 2, z & 1), q.viewport(C, O, I, k), q.scissor(C, O, I, k), q.drawArrays(q.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(H, X, C) {
      var O = H.width, I = H.height;
      u(H, function(k) {
        var z = k.gl, Q = new Uint8Array(O * I * 4);
        z.readPixels(0, 0, O, I, z.RGBA, z.UNSIGNED_BYTE, Q), H.width = X, H.height = C, h(z, Q, 0, 0, O, I);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function p(H, X, C, O, I, k) {
      k === void 0 && (k = 1);
      var z = new Uint8Array(H * X), Q = O[2] - O[0], j = O[3] - O[1], q = [];
      s(C, function(Y, ee, fe, ne) {
        q.push({
          x1: Y,
          y1: ee,
          x2: fe,
          y2: ne,
          minX: Math.min(Y, fe),
          minY: Math.min(ee, ne),
          maxX: Math.max(Y, fe),
          maxY: Math.max(ee, ne)
        });
      }), q.sort(function(Y, ee) {
        return Y.maxX - ee.maxX;
      });
      for (var ie = 0; ie < H; ie++)
        for (var ae = 0; ae < X; ae++) {
          var $ = te(
            O[0] + Q * (ie + 0.5) / H,
            O[1] + j * (ae + 0.5) / X
          ), L = Math.pow(1 - Math.abs($) / I, k) / 2;
          $ < 0 && (L = 1 - L), L = Math.max(0, Math.min(255, Math.round(L * 255))), z[ae * H + ie] = L;
        }
      return z;
      function te(Y, ee) {
        for (var fe = 1 / 0, ne = 1 / 0, ue = q.length; ue--; ) {
          var de = q[ue];
          if (de.maxX + ne <= Y)
            break;
          if (Y + ne > de.minX && ee - ne < de.maxY && ee + ne > de.minY) {
            var K = b(Y, ee, de.x1, de.y1, de.x2, de.y2);
            K < fe && (fe = K, ne = Math.sqrt(fe));
          }
        }
        return Z(Y, ee) && (ne = -ne), ne;
      }
      function Z(Y, ee) {
        for (var fe = 0, ne = q.length; ne--; ) {
          var ue = q[ne];
          if (ue.maxX <= Y)
            break;
          var de = ue.y1 > ee != ue.y2 > ee && Y < (ue.x2 - ue.x1) * (ee - ue.y1) / (ue.y2 - ue.y1) + ue.x1;
          de && (fe += ue.y1 < ue.y2 ? 1 : -1);
        }
        return fe !== 0;
      }
    }
    function m(H, X, C, O, I, k, z, Q, j, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), j === void 0 && (j = 0), q === void 0 && (q = 0), g(H, X, C, O, I, k, z, null, Q, j, q);
    }
    function g(H, X, C, O, I, k, z, Q, j, q, ie) {
      k === void 0 && (k = 1), j === void 0 && (j = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0);
      for (var ae = p(H, X, C, O, I, k), $ = new Uint8Array(ae.length * 4), L = 0; L < ae.length; L++)
        $[L * 4 + ie] = ae[L];
      h(z, $, j, q, H, X, 1 << 3 - ie, Q);
    }
    function b(H, X, C, O, I, k) {
      var z = I - C, Q = k - O, j = z * z + Q * Q, q = j ? Math.max(0, Math.min(1, ((H - C) * z + (X - O) * Q) / j)) : 0, ie = H - (C + q * z), ae = X - (O + q * Q);
      return ie * ie + ae * ae;
    }
    var v = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: p,
      generateIntoCanvas: m,
      generateIntoFramebuffer: g
    }), y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", N = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", w = new Float32Array([0, 0, 2, 0, 0, 2]), T = null, _ = !1, F = {}, A = /* @__PURE__ */ new WeakMap();
    function D(H) {
      if (!_ && !U(H))
        throw new Error("WebGL generation not supported");
    }
    function S(H, X, C, O, I, k, z) {
      if (k === void 0 && (k = 1), z === void 0 && (z = null), !z && (z = T, !z)) {
        var Q = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Q)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        z = T = Q.getContext("webgl", { depth: !1 });
      }
      D(z);
      var j = new Uint8Array(H * X * 4);
      u(z, function($) {
        var L = $.gl, te = $.withTexture, Z = $.withTextureFramebuffer;
        te("readable", function(Y, ee) {
          L.texImage2D(L.TEXTURE_2D, 0, L.RGBA, H, X, 0, L.RGBA, L.UNSIGNED_BYTE, null), Z(Y, ee, function(fe) {
            E(
              H,
              X,
              C,
              O,
              I,
              k,
              L,
              fe,
              0,
              0,
              0
              // red channel
            ), L.readPixels(0, 0, H, X, L.RGBA, L.UNSIGNED_BYTE, j);
          });
        });
      });
      for (var q = new Uint8Array(H * X), ie = 0, ae = 0; ie < j.length; ie += 4)
        q[ae++] = j[ie];
      return q;
    }
    function R(H, X, C, O, I, k, z, Q, j, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), j === void 0 && (j = 0), q === void 0 && (q = 0), E(H, X, C, O, I, k, z, null, Q, j, q);
    }
    function E(H, X, C, O, I, k, z, Q, j, q, ie) {
      k === void 0 && (k = 1), j === void 0 && (j = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0), D(z);
      var ae = [];
      s(C, function($, L, te, Z) {
        ae.push($, L, te, Z);
      }), ae = new Float32Array(ae), u(z, function($) {
        var L = $.gl, te = $.isWebGL2, Z = $.getExtension, Y = $.withProgram, ee = $.withTexture, fe = $.withTextureFramebuffer, ne = $.handleContextLoss;
        if (ee("rawDistances", function(ue, de) {
          (H !== ue._lastWidth || X !== ue._lastHeight) && L.texImage2D(
            L.TEXTURE_2D,
            0,
            L.RGBA,
            ue._lastWidth = H,
            ue._lastHeight = X,
            0,
            L.RGBA,
            L.UNSIGNED_BYTE,
            null
          ), Y("main", y, x, function(K) {
            var _e = K.setAttribute, pe = K.setUniform, xe = !te && Z("ANGLE_instanced_arrays"), he = !te && Z("EXT_blend_minmax");
            _e("aUV", 2, L.STATIC_DRAW, 0, w), _e("aLineSegment", 4, L.DYNAMIC_DRAW, 1, ae), pe.apply(void 0, ["4f", "uGlyphBounds"].concat(O)), pe("1f", "uMaxDistance", I), pe("1f", "uExponent", k), fe(ue, de, function($e) {
              L.enable(L.BLEND), L.colorMask(!0, !0, !0, !0), L.viewport(0, 0, H, X), L.scissor(0, 0, H, X), L.blendFunc(L.ONE, L.ONE), L.blendEquationSeparate(L.FUNC_ADD, te ? L.MAX : he.MAX_EXT), L.clear(L.COLOR_BUFFER_BIT), te ? L.drawArraysInstanced(L.TRIANGLES, 0, 3, ae.length / 4) : xe.drawArraysInstancedANGLE(L.TRIANGLES, 0, 3, ae.length / 4);
            });
          }), Y("post", o, N, function(K) {
            K.setAttribute("aUV", 2, L.STATIC_DRAW, 0, w), K.setUniform("1i", "tex", de), L.bindFramebuffer(L.FRAMEBUFFER, Q), L.disable(L.BLEND), L.colorMask(ie === 0, ie === 1, ie === 2, ie === 3), L.viewport(j, q, H, X), L.scissor(j, q, H, X), L.drawArrays(L.TRIANGLES, 0, 3);
          });
        }), L.isContextLost())
          throw ne(), new Error("webgl context lost");
      });
    }
    function U(H) {
      var X = !H || H === T ? F : H.canvas || H, C = A.get(X);
      if (C === void 0) {
        _ = !0;
        var O = null;
        try {
          var I = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], k = S(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            H
          );
          C = k && I.length === k.length && k.every(function(z, Q) {
            return z === I[Q];
          }), C || (O = "bad trial run results", console.info(I, k));
        } catch (z) {
          C = !1, O = z.message;
        }
        O && console.warn("WebGL SDF generation not supported:", O), _ = !1, A.set(X, C);
      }
      return C;
    }
    var P = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: S,
      generateIntoCanvas: R,
      generateIntoFramebuffer: E,
      isSupported: U
    });
    function se(H, X, C, O, I, k) {
      I === void 0 && (I = Math.max(O[2] - O[0], O[3] - O[1]) / 2), k === void 0 && (k = 1);
      try {
        return S.apply(P, arguments);
      } catch (z) {
        return console.info("WebGL SDF generation failed, falling back to JS", z), p.apply(v, arguments);
      }
    }
    function oe(H, X, C, O, I, k, z, Q, j, q) {
      I === void 0 && (I = Math.max(O[2] - O[0], O[3] - O[1]) / 2), k === void 0 && (k = 1), Q === void 0 && (Q = 0), j === void 0 && (j = 0), q === void 0 && (q = 0);
      try {
        return R.apply(P, arguments);
      } catch (ie) {
        return console.info("WebGL SDF generation failed, falling back to JS", ie), m.apply(v, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = se, e.generateIntoCanvas = oe, e.javascript = v, e.pathToLineSegments = s, e.webgl = P, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
function u1() {
  var c = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, n = {};
    r.L = 1, n[1] = "L", Object.keys(t).forEach(function(ne, ue) {
      r[ne] = 1 << ue + 1, n[r[ne]] = ne;
    }), Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI, o = r.L | r.R | r.AL, i = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, a = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, l = r.S | r.WS | r.B | s | r.PDI | a, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var ne = function(de) {
          if (t.hasOwnProperty(de)) {
            var K = 0;
            t[de].split(",").forEach(function(_e) {
              var pe = _e.split("+"), xe = pe[0], he = pe[1];
              xe = parseInt(xe, 36), he = he ? parseInt(he, 36) : 0, u.set(K += xe, r[de]);
              for (var $e = 0; $e < he; $e++)
                u.set(++K, r[de]);
            });
          }
        };
        for (var ue in t)
          ne(ue);
      }
    }
    function d(ne) {
      return h(), u.get(ne.codePointAt(0)) || r.L;
    }
    function f(ne) {
      return n[d(ne)];
    }
    var p = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(ne, ue) {
      var de = 36, K = 0, _e = /* @__PURE__ */ new Map(), pe = ue && /* @__PURE__ */ new Map(), xe;
      return ne.split(",").forEach(function he($e) {
        if ($e.indexOf("+") !== -1)
          for (var ce = +$e; ce--; )
            he(xe);
        else {
          xe = $e;
          var be = $e.split(">"), ge = be[0], Te = be[1];
          ge = String.fromCodePoint(K += parseInt(ge, de)), Te = String.fromCodePoint(K += parseInt(Te, de)), _e.set(ge, Te), ue && pe.set(Te, ge);
        }
      }), { map: _e, reverseMap: pe };
    }
    var g, b, v;
    function y() {
      if (!g) {
        var ne = m(p.pairs, !0), ue = ne.map, de = ne.reverseMap;
        g = ue, b = de, v = m(p.canonical, !1).map;
      }
    }
    function x(ne) {
      return y(), g.get(ne) || null;
    }
    function N(ne) {
      return y(), b.get(ne) || null;
    }
    function w(ne) {
      return y(), v.get(ne) || null;
    }
    var T = r.L, _ = r.R, F = r.EN, A = r.ES, D = r.ET, S = r.AN, R = r.CS, E = r.B, U = r.S, P = r.ON, se = r.BN, oe = r.NSM, H = r.AL, X = r.LRO, C = r.RLO, O = r.LRE, I = r.RLE, k = r.PDF, z = r.LRI, Q = r.RLI, j = r.FSI, q = r.PDI;
    function ie(ne, ue) {
      for (var de = 125, K = new Uint32Array(ne.length), _e = 0; _e < ne.length; _e++)
        K[_e] = d(ne[_e]);
      var pe = /* @__PURE__ */ new Map();
      function xe(hn, Xn) {
        var dn = K[hn];
        K[hn] = Xn, pe.set(dn, pe.get(dn) - 1), dn & i && pe.set(i, pe.get(i) - 1), pe.set(Xn, (pe.get(Xn) || 0) + 1), Xn & i && pe.set(i, (pe.get(i) || 0) + 1);
      }
      for (var he = new Uint8Array(ne.length), $e = /* @__PURE__ */ new Map(), ce = [], be = null, ge = 0; ge < ne.length; ge++)
        be || ce.push(be = {
          start: ge,
          end: ne.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: ue === "rtl" ? 1 : ue === "ltr" ? 0 : Lf(ge, !1)
        }), K[ge] & E && (be.end = ge, be = null);
      for (var Te = I | O | C | X | s | q | k | E, Pe = function(hn) {
        return hn + (hn & 1 ? 1 : 2);
      }, qe = function(hn) {
        return hn + (hn & 1 ? 2 : 1);
      }, Se = 0; Se < ce.length; Se++) {
        be = ce[Se];
        var De = [{
          _level: be.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], me = void 0, je = 0, Xe = 0, ht = 0;
        pe.clear();
        for (var Qe = be.start; Qe <= be.end; Qe++) {
          var ve = K[Qe];
          if (me = De[De.length - 1], pe.set(ve, (pe.get(ve) || 0) + 1), ve & i && pe.set(i, (pe.get(i) || 0) + 1), ve & Te)
            if (ve & (I | O)) {
              he[Qe] = me._level;
              var Oe = (ve === I ? qe : Pe)(me._level);
              Oe <= de && !je && !Xe ? De.push({
                _level: Oe,
                _override: 0,
                _isolate: 0
              }) : je || Xe++;
            } else if (ve & (C | X)) {
              he[Qe] = me._level;
              var Dt = (ve === C ? qe : Pe)(me._level);
              Dt <= de && !je && !Xe ? De.push({
                _level: Dt,
                _override: ve & C ? _ : T,
                _isolate: 0
              }) : je || Xe++;
            } else if (ve & s) {
              ve & j && (ve = Lf(Qe + 1, !0) === 1 ? Q : z), he[Qe] = me._level, me._override && xe(Qe, me._override);
              var Ce = (ve === Q ? qe : Pe)(me._level);
              Ce <= de && je === 0 && Xe === 0 ? (ht++, De.push({
                _level: Ce,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Qe
              })) : je++;
            } else if (ve & q) {
              if (je > 0)
                je--;
              else if (ht > 0) {
                for (Xe = 0; !De[De.length - 1]._isolate; )
                  De.pop();
                var Re = De[De.length - 1]._isolInitIndex;
                Re != null && ($e.set(Re, Qe), $e.set(Qe, Re)), De.pop(), ht--;
              }
              me = De[De.length - 1], he[Qe] = me._level, me._override && xe(Qe, me._override);
            } else
              ve & k ? (je === 0 && (Xe > 0 ? Xe-- : !me._isolate && De.length > 1 && (De.pop(), me = De[De.length - 1])), he[Qe] = me._level) : ve & E && (he[Qe] = be.level);
          else
            he[Qe] = me._level, me._override && ve !== se && xe(Qe, me._override);
        }
        for (var tt = [], Ue = null, we = be.start; we <= be.end; we++) {
          var We = K[we];
          if (!(We & a)) {
            var gt = he[we], at = We & s, rt = We === q;
            Ue && gt === Ue._level ? (Ue._end = we, Ue._endsWithIsolInit = at) : tt.push(Ue = {
              _start: we,
              _end: we,
              _level: gt,
              _startsWithPDI: rt,
              _endsWithIsolInit: at
            });
          }
        }
        for (var Lt = [], On = 0; On < tt.length; On++) {
          var ln = tt[On];
          if (!ln._startsWithPDI || ln._startsWithPDI && !$e.has(ln._start)) {
            for (var Tn = [Ue = ln], In = void 0; Ue && Ue._endsWithIsolInit && (In = $e.get(Ue._end)) != null; )
              for (var un = On + 1; un < tt.length; un++)
                if (tt[un]._start === In) {
                  Tn.push(Ue = tt[un]);
                  break;
                }
            for (var yt = [], Wn = 0; Wn < Tn.length; Wn++)
              for (var df = Tn[Wn], Cc = df._start; Cc <= df._end; Cc++)
                yt.push(Cc);
            for (var tx = he[yt[0]], ff = be.level, Mi = yt[0] - 1; Mi >= 0; Mi--)
              if (!(K[Mi] & a)) {
                ff = he[Mi];
                break;
              }
            var Ec = yt[yt.length - 1], nx = he[Ec], pf = be.level;
            if (!(K[Ec] & s)) {
              for (var Ai = Ec + 1; Ai <= be.end; Ai++)
                if (!(K[Ai] & a)) {
                  pf = he[Ai];
                  break;
                }
            }
            Lt.push({
              _seqIndices: yt,
              _sosType: Math.max(ff, tx) % 2 ? _ : T,
              _eosType: Math.max(pf, nx) % 2 ? _ : T
            });
          }
        }
        for (var Rc = 0; Rc < Lt.length; Rc++) {
          var Fc = Lt[Rc], Ie = Fc._seqIndices, To = Fc._sosType, sx = Fc._eosType, Er = he[Ie[0]] & 1 ? _ : T;
          if (pe.get(oe))
            for (var Ci = 0; Ci < Ie.length; Ci++) {
              var mf = Ie[Ci];
              if (K[mf] & oe) {
                for (var Lc = To, Ei = Ci - 1; Ei >= 0; Ei--)
                  if (!(K[Ie[Ei]] & a)) {
                    Lc = K[Ie[Ei]];
                    break;
                  }
                xe(mf, Lc & (s | q) ? P : Lc);
              }
            }
          if (pe.get(F))
            for (var Ri = 0; Ri < Ie.length; Ri++) {
              var gf = Ie[Ri];
              if (K[gf] & F)
                for (var Fi = Ri - 1; Fi >= -1; Fi--) {
                  var yf = Fi === -1 ? To : K[Ie[Fi]];
                  if (yf & o) {
                    yf === H && xe(gf, S);
                    break;
                  }
                }
            }
          if (pe.get(H))
            for (var Oc = 0; Oc < Ie.length; Oc++) {
              var vf = Ie[Oc];
              K[vf] & H && xe(vf, _);
            }
          if (pe.get(A) || pe.get(R))
            for (var So = 1; So < Ie.length - 1; So++) {
              var Ic = Ie[So];
              if (K[Ic] & (A | R)) {
                for (var Rr = 0, Pc = 0, Uc = So - 1; Uc >= 0 && (Rr = K[Ie[Uc]], !!(Rr & a)); Uc--)
                  ;
                for (var Dc = So + 1; Dc < Ie.length && (Pc = K[Ie[Dc]], !!(Pc & a)); Dc++)
                  ;
                Rr === Pc && (K[Ic] === A ? Rr === F : Rr & (F | S)) && xe(Ic, Rr);
              }
            }
          if (pe.get(F))
            for (var os = 0; os < Ie.length; os++) {
              var rx = Ie[os];
              if (K[rx] & F) {
                for (var Li = os - 1; Li >= 0 && K[Ie[Li]] & (D | a); Li--)
                  xe(Ie[Li], F);
                for (os++; os < Ie.length && K[Ie[os]] & (D | a | F); os++)
                  K[Ie[os]] !== F && xe(Ie[os], F);
              }
            }
          if (pe.get(D) || pe.get(A) || pe.get(R))
            for (var _o = 0; _o < Ie.length; _o++) {
              var xf = Ie[_o];
              if (K[xf] & (D | A | R)) {
                xe(xf, P);
                for (var Oi = _o - 1; Oi >= 0 && K[Ie[Oi]] & a; Oi--)
                  xe(Ie[Oi], P);
                for (var Ii = _o + 1; Ii < Ie.length && K[Ie[Ii]] & a; Ii++)
                  xe(Ie[Ii], P);
              }
            }
          if (pe.get(F))
            for (var zc = 0, bf = To; zc < Ie.length; zc++) {
              var Nf = Ie[zc], Bc = K[Nf];
              Bc & F ? bf === T && xe(Nf, T) : Bc & o && (bf = Bc);
            }
          if (pe.get(i)) {
            var Mo = _ | F | S, wf = Mo | T, Pi = [];
            {
              for (var Fr = [], Lr = 0; Lr < Ie.length; Lr++)
                if (K[Ie[Lr]] & i) {
                  var Ao = ne[Ie[Lr]], Tf = void 0;
                  if (x(Ao) !== null)
                    if (Fr.length < 63)
                      Fr.push({ char: Ao, seqIndex: Lr });
                    else
                      break;
                  else if ((Tf = N(Ao)) !== null)
                    for (var Co = Fr.length - 1; Co >= 0; Co--) {
                      var kc = Fr[Co].char;
                      if (kc === Tf || kc === N(w(Ao)) || x(w(kc)) === Ao) {
                        Pi.push([Fr[Co].seqIndex, Lr]), Fr.length = Co;
                        break;
                      }
                    }
                }
              Pi.sort(function(hn, Xn) {
                return hn[0] - Xn[0];
              });
            }
            for (var Gc = 0; Gc < Pi.length; Gc++) {
              for (var Sf = Pi[Gc], Ui = Sf[0], Vc = Sf[1], _f = !1, Hn = 0, jc = Ui + 1; jc < Vc; jc++) {
                var Mf = Ie[jc];
                if (K[Mf] & wf) {
                  _f = !0;
                  var Af = K[Mf] & Mo ? _ : T;
                  if (Af === Er) {
                    Hn = Af;
                    break;
                  }
                }
              }
              if (_f && !Hn) {
                Hn = To;
                for (var Wc = Ui - 1; Wc >= 0; Wc--) {
                  var Cf = Ie[Wc];
                  if (K[Cf] & wf) {
                    var Ef = K[Cf] & Mo ? _ : T;
                    Ef !== Er ? Hn = Ef : Hn = Er;
                    break;
                  }
                }
              }
              if (Hn) {
                if (K[Ie[Ui]] = K[Ie[Vc]] = Hn, Hn !== Er) {
                  for (var Eo = Ui + 1; Eo < Ie.length; Eo++)
                    if (!(K[Ie[Eo]] & a)) {
                      d(ne[Ie[Eo]]) & oe && (K[Ie[Eo]] = Hn);
                      break;
                    }
                }
                if (Hn !== Er) {
                  for (var Ro = Vc + 1; Ro < Ie.length; Ro++)
                    if (!(K[Ie[Ro]] & a)) {
                      d(ne[Ie[Ro]]) & oe && (K[Ie[Ro]] = Hn);
                      break;
                    }
                }
              }
            }
            for (var Ls = 0; Ls < Ie.length; Ls++)
              if (K[Ie[Ls]] & i) {
                for (var Rf = Ls, Hc = Ls, Xc = To, Fo = Ls - 1; Fo >= 0; Fo--)
                  if (K[Ie[Fo]] & a)
                    Rf = Fo;
                  else {
                    Xc = K[Ie[Fo]] & Mo ? _ : T;
                    break;
                  }
                for (var Ff = sx, Lo = Ls + 1; Lo < Ie.length; Lo++)
                  if (K[Ie[Lo]] & (i | a))
                    Hc = Lo;
                  else {
                    Ff = K[Ie[Lo]] & Mo ? _ : T;
                    break;
                  }
                for (var $c = Rf; $c <= Hc; $c++)
                  K[Ie[$c]] = Xc === Ff ? Xc : Er;
                Ls = Hc;
              }
          }
        }
        for (var Sn = be.start; Sn <= be.end; Sn++) {
          var ox = he[Sn], Di = K[Sn];
          if (ox & 1 ? Di & (T | F | S) && he[Sn]++ : Di & _ ? he[Sn]++ : Di & (S | F) && (he[Sn] += 2), Di & a && (he[Sn] = Sn === 0 ? be.level : he[Sn - 1]), Sn === be.end || d(ne[Sn]) & (U | E))
            for (var zi = Sn; zi >= 0 && d(ne[zi]) & l; zi--)
              he[zi] = be.level;
        }
      }
      return {
        levels: he,
        paragraphs: ce
      };
      function Lf(hn, Xn) {
        for (var dn = hn; dn < ne.length; dn++) {
          var Os = K[dn];
          if (Os & (_ | H))
            return 1;
          if (Os & (E | T) || Xn && Os === q)
            return 0;
          if (Os & s) {
            var Of = ix(dn);
            dn = Of === -1 ? ne.length : Of;
          }
        }
        return 0;
      }
      function ix(hn) {
        for (var Xn = 1, dn = hn + 1; dn < ne.length; dn++) {
          var Os = K[dn];
          if (Os & E)
            break;
          if (Os & q) {
            if (--Xn === 0)
              return dn;
          } else
            Os & s && Xn++;
        }
        return -1;
      }
    }
    var ae = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", $;
    function L() {
      if (!$) {
        var ne = m(ae, !0), ue = ne.map, de = ne.reverseMap;
        de.forEach(function(K, _e) {
          ue.set(_e, K);
        }), $ = ue;
      }
    }
    function te(ne) {
      return L(), $.get(ne) || null;
    }
    function Z(ne, ue, de, K) {
      var _e = ne.length;
      de = Math.max(0, de == null ? 0 : +de), K = Math.min(_e - 1, K == null ? _e - 1 : +K);
      for (var pe = /* @__PURE__ */ new Map(), xe = de; xe <= K; xe++)
        if (ue[xe] & 1) {
          var he = te(ne[xe]);
          he !== null && pe.set(xe, he);
        }
      return pe;
    }
    function Y(ne, ue, de, K) {
      var _e = ne.length;
      de = Math.max(0, de == null ? 0 : +de), K = Math.min(_e - 1, K == null ? _e - 1 : +K);
      var pe = [];
      return ue.paragraphs.forEach(function(xe) {
        var he = Math.max(de, xe.start), $e = Math.min(K, xe.end);
        if (he < $e) {
          for (var ce = ue.levels.slice(he, $e + 1), be = $e; be >= he && d(ne[be]) & l; be--)
            ce[be] = xe.level;
          for (var ge = xe.level, Te = 1 / 0, Pe = 0; Pe < ce.length; Pe++) {
            var qe = ce[Pe];
            qe > ge && (ge = qe), qe < Te && (Te = qe | 1);
          }
          for (var Se = ge; Se >= Te; Se--)
            for (var De = 0; De < ce.length; De++)
              if (ce[De] >= Se) {
                for (var me = De; De + 1 < ce.length && ce[De + 1] >= Se; )
                  De++;
                De > me && pe.push([me + he, De + he]);
              }
        }
      }), pe;
    }
    function ee(ne, ue, de, K) {
      var _e = fe(ne, ue, de, K), pe = [].concat(ne);
      return _e.forEach(function(xe, he) {
        pe[he] = (ue.levels[xe] & 1 ? te(ne[xe]) : null) || ne[xe];
      }), pe.join("");
    }
    function fe(ne, ue, de, K) {
      for (var _e = Y(ne, ue, de, K), pe = [], xe = 0; xe < ne.length; xe++)
        pe[xe] = xe;
      return _e.forEach(function(he) {
        for (var $e = he[0], ce = he[1], be = pe.slice($e, ce + 1), ge = be.length; ge--; )
          pe[ce - ge] = be[ge];
      }), pe;
    }
    return e.closingToOpeningBracket = N, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = w, e.getEmbeddingLevels = ie, e.getMirroredCharacter = te, e.getMirroredCharactersMap = Z, e.getReorderSegments = Y, e.getReorderedIndices = fe, e.getReorderedString = ee, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
const h1 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function nu(c) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, n) {
    let s = Tm[n];
    return s ? nu(s) : r;
  }
  return c.replace(e, t);
}
const Ht = [];
for (let c = 0; c < 256; c++)
  Ht[c] = (c < 16 ? "0" : "") + c.toString(16);
function n_() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Ht[c & 255] + Ht[c >> 8 & 255] + Ht[c >> 16 & 255] + Ht[c >> 24 & 255] + "-" + Ht[e & 255] + Ht[e >> 8 & 255] + "-" + Ht[e >> 16 & 15 | 64] + Ht[e >> 24 & 255] + "-" + Ht[t & 63 | 128] + Ht[t >> 8 & 255] + "-" + Ht[t >> 16 & 255] + Ht[t >> 24 & 255] + Ht[r & 255] + Ht[r >> 8 & 255] + Ht[r >> 16 & 255] + Ht[r >> 24 & 255]).toUpperCase();
}
const lr = Object.assign || function() {
  let c = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (c[n] = r[n]);
  }
  return c;
}, s_ = Date.now(), fp = /* @__PURE__ */ new WeakMap(), pp = /* @__PURE__ */ new Map();
let r_ = 1e10;
function su(c, e) {
  const t = c_(e);
  let r = fp.get(c);
  if (r || fp.set(c, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const n = `_onBeforeCompile${t}`, s = function(l, u) {
    c.onBeforeCompile.call(this, l, u);
    const h = this.customProgramCacheKey() + "|" + l.vertexShader + "|" + l.fragmentShader;
    let d = pp[h];
    if (!d) {
      const f = o_(this, l, e, t);
      d = pp[h] = f;
    }
    l.vertexShader = d.vertexShader, l.fragmentShader = d.fragmentShader, lr(l.uniforms, this.uniforms), e.timeUniform && (l.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - s_;
      }
    }), this[n] && this[n](l);
  }, o = function() {
    return i(e.chained ? c : c.clone());
  }, i = function(l) {
    const u = Object.create(l, a);
    return Object.defineProperty(u, "baseMaterial", { value: c }), Object.defineProperty(u, "id", { value: r_++ }), u.uuid = n_(), u.uniforms = lr({}, l.uniforms, e.uniforms), u.defines = lr({}, l.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = lr({}, l.extensions, e.extensions), u._listeners = void 0, u;
  }, a = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return c.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(l) {
        this[n] = l;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(l) {
        return c.copy.call(this, l), !c.isShaderMaterial && !c.isDerivedMaterial && (lr(this.extensions, l.extensions), lr(this.defines, l.defines), lr(this.uniforms, rr.clone(l.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const l = new c.constructor();
        return i(l).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._depthMaterial;
        return l || (l = this._depthMaterial = su(
          c.isDerivedMaterial ? c.getDepthMaterial() : new Ux({ depthPacking: Dx }),
          e
        ), l.defines.IS_DEPTH_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._distanceMaterial;
        return l || (l = this._distanceMaterial = su(
          c.isDerivedMaterial ? c.getDistanceMaterial() : new zx(),
          e
        ), l.defines.IS_DISTANCE_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: l, _distanceMaterial: u } = this;
        l && l.dispose(), u && u.dispose(), c.dispose.call(this);
      }
    }
  };
  return r[t] = o, new o();
}
function o_(c, { vertexShader: e, fragmentShader: t }, r, n) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: i,
    vertexTransform: a,
    fragmentDefs: l,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: p
  } = r;
  if (s = s || "", o = o || "", i = i || "", l = l || "", u = u || "", h = h || "", (a || f) && (e = nu(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = nu(t)), f) {
    let m = f({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (d) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (m.push(g), "")
    ), h = `${d}
${m.join(`
`)}
${h}`;
  }
  if (p) {
    const m = `
uniform float ${p};
`;
    s = m + s, l = m + l;
  }
  return a && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, s = `${s}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${a}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, g, b, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, b)) ? g : `troika_${g}_${n}`), c.map && c.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = mp(e, n, s, o, i), t = mp(t, n, l, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function mp(c, e, t, r, n) {
  return (r || n || t) && (c = c.replace(
    h1,
    `
${t}
void troikaOrigMain${e}() {`
  ), c += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${n}
}`), c;
}
function i_(c, e) {
  return c === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let a_ = 0;
const gp = /* @__PURE__ */ new Map();
function c_(c) {
  const e = JSON.stringify(c, i_);
  let t = gp.get(e);
  return t == null && gp.set(e, t = ++a_), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function l_() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var F = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < F; b++) {
            var D = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), D.push({ val1: S, val2: R });
            }
            u.matrix.push(D);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var U = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + U);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var F = n.kern.rval[_].glyph2.indexOf(o);
          if (F != -1)
            return n.kern.rval[_].vals[F];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var F = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[F + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var D = h.lookupRec;
              for (w = 0; w < D.length; w += 2) {
                y = D[w];
                var S = i[D[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, F = 0, A = 0, D = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, D);
        var S = D.val;
        if (p += D.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", U = 0; U < R; U++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (F = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), F = y + l.shift(), A = x + l.shift(), N = F + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (F = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), F = y + l.shift(), A = x + l.shift(), N = F + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), O = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[O], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var j = l.length, q = (se = 0, S == "o31");
            for (se += j - (R = -3 & j); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function u_() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), U = 0; U < 31; ++U)
        E[U] = R += 1 << S[U - 1];
      var P = new r(E[30]);
      for (U = 1; U < 30; ++U)
        for (var se = E[U]; se < E[U + 1]; ++se)
          P[se] = se - E[U] << 5 | U;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var U = S.length, P = 0, se = new t(R); P < U; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < U; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], O = R - S[P], I = H[S[P] - 1]++ << O, k = I | (1 << O) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(U), P = 0; P < U; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var U = R / 8 | 0;
      return (S[U] | S[U + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var U = new Error(R || T[S]);
      if (U.code = S, Error.captureStackTrace && Error.captureStackTrace(U, _), !E)
        throw U;
      return U;
    }, F = function(S, R, E) {
      var U = S.length;
      if (!U || E && !E.l && U < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * U));
      var oe, H = function(me) {
        var je = R.length;
        if (me > je) {
          var Xe = new e(Math.max(2 * je, me));
          Xe.set(R), R = Xe;
        }
      }, X = E.f || 0, C = E.p || 0, O = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, j = 8 * U;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(de = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[de - 3] << 8, ae = de + ie;
            if (ae > U) {
              se && _(0);
              break;
            }
            P && H(O + ie), R.set(S.subarray(de, ae), O), E.b = O += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, L = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < L; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * L;
            var fe = x(Y), ne = (1 << fe) - 1, ue = m(Y, fe, 1);
            for (ee = 0; ee < te; ) {
              var de, K = ue[N(S, C, ne)];
              if (C += 15 & K, (de = K >>> 4) < 16)
                Z[ee++] = de;
              else {
                var _e = 0, pe = 0;
                for (de == 16 ? (pe = 3 + N(S, C, 3), C += 2, _e = Z[ee - 1]) : de == 17 ? (pe = 3 + N(S, C, 7), C += 3) : de == 18 && (pe = 11 + N(S, C, 127), C += 7); pe--; )
                  Z[ee++] = _e;
              }
            }
            var xe = Z.subarray(0, $), he = Z.subarray($);
            z = x(xe), Q = x(he), I = m(xe, z, 1), k = m(he, Q, 1);
          } else
            _(1);
          if (C > j) {
            se && _(0);
            break;
          }
        }
        P && H(O + 131072);
        for (var $e = (1 << z) - 1, ce = (1 << Q) - 1, be = C; ; be = C) {
          var ge = (_e = I[w(S, C) & $e]) >>> 4;
          if ((C += 15 & _e) > j) {
            se && _(0);
            break;
          }
          if (_e || _(2), ge < 256)
            R[O++] = ge;
          else {
            if (ge == 256) {
              be = C, I = null;
              break;
            }
            var Te = ge - 254;
            if (ge > 264) {
              var Pe = n[ee = ge - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var qe = k[w(S, C) & ce], Se = qe >>> 4;
            if (qe || _(3), C += 15 & qe, he = h[Se], Se > 3 && (Pe = s[Se], he += w(S, C) & (1 << Pe) - 1, C += Pe), C > j) {
              se && _(0);
              break;
            }
            P && H(O + 131072);
            for (var De = O + Te; O < De; O += 4)
              R[O] = R[O - he], R[O + 1] = R[O + 1 - he], R[O + 2] = R[O + 2 - he], R[O + 3] = R[O + 3 - he];
            O = De;
          }
        }
        E.l = I, E.p = be, E.b = O, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return O == R.length ? R : function(me, je, Xe) {
        (je == null || je < 0) && (je = 0), (Xe == null || Xe > me.length) && (Xe = me.length);
        var ht = new (me instanceof t ? t : me instanceof r ? r : e)(Xe - je);
        return ht.set(me.subarray(je, Xe)), ht;
      }(R, 0, O);
    }, A = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function U() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: U(), reserved: U(), totalSfntSize: P(), majorVersion: U(), minorVersion: U(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), O = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, j = new Uint8Array(12 + 16 * k.length + k.reduce(function($, L) {
        return $ + L.origLength + 4;
      }, 0)), q = j.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(O), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var L, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          L = new Uint8Array(te, 2), F(L, Z);
        } else
          Z = new Uint8Array(te);
        j.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), j.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function h_(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((F) => {
          let [A, D] = F.split("+");
          A = parseInt(A, 36), D = D ? parseInt(D, 36) : 0, u.set(_ += A, w[T]);
          for (let S = D; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, F = -1;
    for (let A = 0; A < N.length; A++) {
      const D = N.codePointAt(A);
      let S = h(D) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[F]++) : S & (n | l) && (_ === f || _ === m) && w[F]-- : T & (s | l) && (_ === f || _ === m) && w[F]--, _ = w[A] = R, T = S, F = A, D > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let F = 0; F < w.length; F++) {
      const A = w.codePointAt(F);
      A > 65535 && F++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: F, featureList: A } = _;
      let D;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let U = 0; U < E.tab.length; U++) {
            if (R[E.tab[U]])
              continue;
            R[E.tab[U]] = !0;
            const P = F[E.tab[U]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !D && (D = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!D || !se || g[D[oe]] === E.tag) && c.U._applySubs(T, oe, P, F);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, F = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, F), D = {
      unitsPerEm: F,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, U) {
        let P = 0;
        const se = 1 / D.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, O) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", j = 0;
              for (let L = 0, te = k.length; L < te; L++) {
                const Z = t[k[L]];
                Q += k[L];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[j++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let L = 0, te = z.length; L < te; L += 2) {
                  let Z = z[L], Y = z[L + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), U.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return D;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const d_ = /* @__PURE__ */ fs({
  name: "Typr Font Parser",
  dependencies: [l_, u_, h_],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function f_() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var F = x.weight;
      F === void 0 && (F = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), D = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, U = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var O = m.get(C);
        return O || (O = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, O)), O;
      }
      for (var H = function(C) {
        var O = y.codePointAt(C), I = s(O);
        U[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), O > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[U[I]], j = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in j = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== j) {
                  for (var L in Q[$])
                    if (o(k, Q[$][L])) {
                      z = L;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), U[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, O = I);
        }, O = 0; O < y.length; O++)
          C(O);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, O = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (O && (v(k) || f(O).has(k)))
            S[I] = S[I - 1];
          else {
            O = u[U[I]];
            var z = R[O.id];
            if (!z) {
              var Q = O.typeforms, j = g(Q, T, "sans-serif"), q = g(Q[j], _, "normal"), ie = b((C = Q[j]) === null || C === void 0 ? void 0 : C[q], F);
              z = R[O.id] = A + "/font-files/" + O.id + "/" + j + "." + q + "." + ie + ".woff";
            }
            var ae = D.get(z);
            ae == null && (ae = D.size, D.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(D.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function p_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(F = 0) {
        for (let A = F, D = o.length; A < D; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const U = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                U[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: U, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[U];
                  if (!se) {
                    s(U, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < D && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let D = 0, S = A[1] - A[0]; D <= S; D++)
              f[A[0] + D] = w[_++] + T;
            _++;
          });
          let F = 0;
          N.forEach((A, D) => {
            s(A, (S) => {
              p[D + T] = S, ++F === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const m_ = /* @__PURE__ */ fs({
  name: "FontResolver",
  dependencies: [
    p_,
    d_,
    f_
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function g_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let F, A;
      const D = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], D.push(F = { start: S, end: S, fontObj: _[T[S]] })) : F.end = S;
      N(D);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: F = "left",
    textIndent: A = 0,
    whiteSpace: D = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: U = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const O = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - O;
      const z = isFinite(T);
      let Q = null, j = null, q = null, ie = null, ae = null, $ = null, L = null, te = null, Z = 0, Y = 0, ee = D !== "nowrap";
      const fe = /* @__PURE__ */ new Map(), ne = h();
      let ue = A, de = 0, K = new d();
      const _e = [K];
      k.forEach((ce) => {
        const { fontObj: be } = ce, { ascender: ge, descender: Te, unitsPerEm: Pe, lineGap: qe, capHeight: Se, xHeight: De } = be;
        let me = fe.get(be);
        if (!me) {
          const ve = v / Pe, Oe = w === "normal" ? (ge - Te + qe) * ve : w * v, Dt = (Oe - (ge - Te) * ve) / 2, Ce = Math.min(Oe, (ge - Te) * ve), Re = (ge + Te) / 2 * ve + Ce / 2;
          me = {
            index: fe.size,
            src: be.src,
            fontObj: be,
            fontSizeMult: ve,
            unitsPerEm: Pe,
            ascender: ge * ve,
            descender: Te * ve,
            capHeight: Se * ve,
            xHeight: De * ve,
            lineHeight: Oe,
            baseline: -Dt - ge * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ge + Te) / 2 * ve + Ce / 2,
            caretBottom: Re - Ce
          }, fe.set(be, me);
        }
        const { fontSizeMult: je } = me, Xe = p.slice(ce.start, ce.end + 1);
        let ht, Qe;
        be.forEachGlyph(Xe, v, N, (ve, Oe, Dt) => {
          Oe += de, Dt += ce.start, ht = Oe, Qe = ve;
          const Ce = p.charAt(Dt), Re = ve.advanceWidth * je, tt = K.count;
          let Ue;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ce && new RegExp(n).test(Ce), ve.canBreakAfter = !!Ce && s.test(Ce), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || r.test(Ce)), !ve.isWhitespace && !ve.isEmpty && Y++, ee && z && !ve.isWhitespace && Oe + Re + ue > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              Ue = new d(), ue = -Oe;
            else
              for (let We = tt; We--; )
                if (We === 0 && S === "break-word") {
                  Ue = new d(), ue = -Oe;
                  break;
                } else if (K.glyphAt(We).glyphObj.canBreakAfter) {
                  Ue = K.splitAt(We + 1);
                  const gt = Ue.glyphAt(0).x;
                  ue -= gt;
                  for (let at = Ue.count; at--; )
                    Ue.glyphAt(at).x -= gt;
                  break;
                }
            Ue && (K.isSoftWrapped = !0, K = Ue, _e.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = ve, we.x = Oe + ue, we.width = Re, we.charIndex = Dt, we.fontData = me, Ce === `
` && (K = new d(), _e.push(K), ue = -(Oe + Re + N * v) + A);
        }), de = ht + Qe.advanceWidth * je + N * v;
      });
      let pe = 0;
      _e.forEach((ce) => {
        let be = !0;
        for (let ge = ce.count; ge--; ) {
          const Te = ce.glyphAt(ge);
          be && !Te.glyphObj.isWhitespace && (ce.width = Te.x + Te.width, ce.width > Z && (Z = ce.width), be = !1);
          let { lineHeight: Pe, capHeight: qe, xHeight: Se, baseline: De } = Te.fontData;
          Pe > ce.lineHeight && (ce.lineHeight = Pe);
          const me = De - ce.baseline;
          me < 0 && (ce.baseline += me, ce.cap += me, ce.ex += me), ce.cap = Math.max(ce.cap, ce.baseline + qe), ce.ex = Math.max(ce.ex, ce.baseline + Se);
        }
        ce.baseline -= pe, ce.cap -= pe, ce.ex -= pe, pe += ce.lineHeight;
      });
      let xe = 0, he = 0;
      if (R && (typeof R == "number" ? xe = -R : typeof R == "string" && (xe = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? he = -E : typeof E == "string" && (he = E === "top" ? 0 : E === "top-baseline" ? -_e[0].baseline : E === "top-cap" ? -_e[0].cap : E === "top-ex" ? -_e[0].ex : E === "middle" ? pe / 2 : E === "bottom" ? pe : E === "bottom-baseline" ? _e[_e.length - 1].baseline : l(E) * pe)), !U) {
        const ce = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), j = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let be = 0, ge = -1, Te = -1, Pe, qe;
        if (_e.forEach((Se, De) => {
          let { count: me, width: je } = Se;
          if (me > 0) {
            let Xe = 0;
            for (let Ce = me; Ce-- && Se.glyphAt(Ce).glyphObj.isWhitespace; )
              Xe++;
            let ht = 0, Qe = 0;
            if (F === "center")
              ht = (Z - je) / 2;
            else if (F === "right")
              ht = Z - je;
            else if (F === "justify" && Se.isSoftWrapped) {
              let Ce = 0;
              for (let Re = me - Xe; Re--; )
                Se.glyphAt(Re).glyphObj.isWhitespace && Ce++;
              Qe = (Z - je) / Ce;
            }
            if (Qe || ht) {
              let Ce = 0;
              for (let Re = 0; Re < me; Re++) {
                let tt = Se.glyphAt(Re);
                const Ue = tt.glyphObj;
                tt.x += ht + Ce, Qe !== 0 && Ue.isWhitespace && Re < me - Xe && (Ce += Qe, tt.width += Qe);
              }
            }
            const ve = e.getReorderSegments(
              p,
              ce,
              Se.glyphAt(0).charIndex,
              Se.glyphAt(Se.count - 1).charIndex
            );
            for (let Ce = 0; Ce < ve.length; Ce++) {
              const [Re, tt] = ve[Ce];
              let Ue = 1 / 0, we = -1 / 0;
              for (let We = 0; We < me; We++)
                if (Se.glyphAt(We).charIndex >= Re) {
                  let gt = We, at = We;
                  for (; at < me; at++) {
                    let rt = Se.glyphAt(at);
                    if (rt.charIndex > tt)
                      break;
                    at < me - Xe && (Ue = Math.min(Ue, rt.x), we = Math.max(we, rt.x + rt.width));
                  }
                  for (let rt = gt; rt < at; rt++) {
                    const Lt = Se.glyphAt(rt);
                    Lt.x = we - (Lt.x + Lt.width - Ue);
                  }
                  break;
                }
            }
            let Oe;
            const Dt = (Ce) => Oe = Ce;
            for (let Ce = 0; Ce < me; Ce++) {
              const Re = Se.glyphAt(Ce);
              Oe = Re.glyphObj;
              const tt = Oe.index, Ue = ce.levels[Re.charIndex] & 1;
              if (Ue) {
                const we = e.getMirroredCharacter(p[Re.charIndex]);
                we && Re.fontData.fontObj.forEachGlyph(we, 0, 0, Dt);
              }
              if (oe) {
                const { charIndex: we, fontData: We } = Re, gt = Re.x + xe, at = Re.x + Re.width + xe;
                $[we * 4] = Ue ? at : gt, $[we * 4 + 1] = Ue ? gt : at, $[we * 4 + 2] = Se.baseline + We.caretBottom + he, $[we * 4 + 3] = Se.baseline + We.caretTop + he;
                const rt = we - ge;
                rt > 1 && u($, ge, rt), ge = we;
              }
              if (X) {
                const { charIndex: we } = Re;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (qe = X[Te]);
              }
              if (!Oe.isWhitespace && !Oe.isEmpty) {
                const we = be++, { fontSizeMult: We, src: gt, index: at } = Re.fontData, rt = ie[gt] || (ie[gt] = {});
                rt[tt] || (rt[tt] = {
                  path: Oe.path,
                  pathBounds: [Oe.xMin, Oe.yMin, Oe.xMax, Oe.yMax]
                });
                const Lt = Re.x + xe, On = Se.baseline + he;
                q[we * 2] = Lt, q[we * 2 + 1] = On;
                const ln = Lt + Oe.xMin * We, Tn = On + Oe.yMin * We, In = Lt + Oe.xMax * We, un = On + Oe.yMax * We;
                ln < L[0] && (L[0] = ln), Tn < L[1] && (L[1] = Tn), In > L[2] && (L[2] = In), un > L[3] && (L[3] = un), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const yt = Pe.rect;
                if (ln < yt[0] && (yt[0] = ln), Tn < yt[1] && (yt[1] = Tn), In > yt[2] && (yt[2] = In), un > yt[3] && (yt[3] = un), Q[we] = tt, j[we] = at, X) {
                  const Wn = we * 3;
                  ae[Wn] = qe >> 16 & 255, ae[Wn + 1] = qe >> 8 & 255, ae[Wn + 2] = qe & 255;
                }
              }
            }
          }
        }), $) {
          const Se = p.length - ge;
          Se > 1 && u($, ge, Se);
        }
      }
      const $e = [];
      fe.forEach(({ index: ce, src: be, unitsPerEm: ge, ascender: Te, descender: Pe, lineHeight: qe, capHeight: Se, xHeight: De }) => {
        $e[ce] = { src: be, unitsPerEm: ge, ascender: Te, descender: Pe, lineHeight: qe, capHeight: Se, xHeight: De };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: j,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: $e,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: he + _e[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          xe,
          he - pe,
          xe + Z,
          he
        ],
        visibleBounds: L,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const vr = () => (self.performance || Date).now(), wc = /* @__PURE__ */ l1();
let yp;
function y_(c, e, t, r, n, s, o, i, a, l, u = !0) {
  return u ? x_(c, e, t, r, n, s, o, i, a, l).then(
    null,
    (h) => (yp || (console.warn("WebGL SDF generation failed, falling back to JS", h), yp = !0), xp(c, e, t, r, n, s, o, i, a, l))
  ) : xp(c, e, t, r, n, s, o, i, a, l);
}
const va = [], v_ = 5;
let ru = 0;
function d1() {
  const c = vr();
  for (; va.length && vr() - c < v_; )
    va.shift()();
  ru = va.length ? setTimeout(d1, 0) : 0;
}
const x_ = (...c) => new Promise((e, t) => {
  va.push(() => {
    const r = vr();
    try {
      wc.webgl.generateIntoCanvas(...c), e({ timing: vr() - r });
    } catch (n) {
      t(n);
    }
  }), ru || (ru = setTimeout(d1, 0));
}), b_ = 4, N_ = 2e3, vp = {};
let w_ = 0;
function xp(c, e, t, r, n, s, o, i, a, l) {
  const u = "TroikaTextSDFGenerator_JS_" + w_++ % b_;
  let h = vp[u];
  return h || (h = vp[u] = {
    workerModule: fs({
      name: u,
      workerId: u,
      dependencies: [
        l1,
        vr
      ],
      init(d, f) {
        const p = d().javascript.generate;
        return function(...m) {
          const g = f();
          return {
            textureData: p(...m),
            timing: f() - g
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(c, e, t, r, n, s).then(({ textureData: d, timing: f }) => {
    const p = vr(), m = new Uint8Array(d.length * 4);
    for (let g = 0; g < d.length; g++)
      m[g * 4 + l] = d[g];
    return wc.webglUtils.renderImageData(o, m, i, a, c, e, 1 << 3 - l), f += vr() - p, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      e_(u);
    }, N_)), { timing: f };
  });
}
function T_(c) {
  c._warm || (wc.webgl.isSupported(c), c._warm = !0);
}
const S_ = wc.webglUtils.resizeWebGLCanvasWithoutClearing, $r = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, __ = /* @__PURE__ */ new Ve();
function Ir() {
  return (self.performance || Date).now();
}
const bp = /* @__PURE__ */ Object.create(null);
function M_(c, e) {
  c = C_({}, c);
  const t = Ir(), { defaultFontURL: r } = $r, n = [];
  if (r && n.push({ label: "default", src: Np(r) }), c.font && n.push({ label: "user", src: Np(c.font) }), c.font = n, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || $r.sdfGlyphSize, c.unicodeFontsURL = c.unicodeFontsURL || $r.unicodeFontsURL, c.colorRanges != null) {
    let d = {};
    for (let f in c.colorRanges)
      if (c.colorRanges.hasOwnProperty(f)) {
        let p = c.colorRanges[f];
        typeof p != "number" && (p = __.set(p).getHex()), d[f] = p;
      }
    c.colorRanges = d;
  }
  Object.freeze(c);
  const { textureWidth: s, sdfExponent: o } = $r, { sdfGlyphSize: i } = c, a = s / i * 4;
  let l = bp[i];
  if (!l) {
    const d = document.createElement("canvas");
    d.width = s, d.height = i * 256 / a, l = bp[i] = {
      glyphCount: 0,
      sdfGlyphSize: i,
      sdfCanvas: d,
      sdfTexture: new Vn(
        d,
        void 0,
        void 0,
        void 0,
        fo,
        fo
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, A_(l);
  }
  const { sdfTexture: u, sdfCanvas: h } = l;
  R_(c).then((d) => {
    const { glyphIds: f, glyphFontIndices: p, fontData: m, glyphPositions: g, fontSize: b, timings: v } = d, y = [], x = new Float32Array(f.length * 4);
    let N = 0, w = 0;
    const T = Ir(), _ = m.map((R) => {
      let E = l.glyphsByFont.get(R.src);
      return E || l.glyphsByFont.set(R.src, E = /* @__PURE__ */ new Map()), E;
    });
    f.forEach((R, E) => {
      const U = p[E], { src: P, unitsPerEm: se } = m[U];
      let oe = _[U].get(R);
      if (!oe) {
        const { path: I, pathBounds: k } = d.glyphData[P][R], z = Math.max(k[2] - k[0], k[3] - k[1]) / i * ($r.sdfMargin * i + 0.5), Q = l.glyphCount++, j = [
          k[0] - z,
          k[1] - z,
          k[2] + z,
          k[3] + z
        ];
        _[U].set(R, oe = { path: I, atlasIndex: Q, sdfViewBox: j }), y.push(oe);
      }
      const { sdfViewBox: H } = oe, X = g[w++], C = g[w++], O = b / se;
      x[N++] = X + H[0] * O, x[N++] = C + H[1] * O, x[N++] = X + H[2] * O, x[N++] = C + H[3] * O, f[E] = oe.atlasIndex;
    }), v.quads = (v.quads || 0) + (Ir() - T);
    const F = Ir();
    v.sdf = {};
    const A = h.height, D = Math.ceil(l.glyphCount / a), S = Math.pow(2, Math.ceil(Math.log2(D * i)));
    S > A && (console.info(`Increasing SDF texture size ${A}->${S}`), S_(h, s, S), u.dispose()), Promise.all(y.map(
      (R) => f1(R, l, c.gpuAccelerateSDF).then(({ timing: E }) => {
        v.sdf[R.atlasIndex] = E;
      })
    )).then(() => {
      y.length && !l.contextLost && (p1(l), u.needsUpdate = !0), v.sdfTotal = Ir() - F, v.total = Ir() - t, e(Object.freeze({
        parameters: c,
        sdfTexture: u,
        sdfGlyphSize: i,
        sdfExponent: o,
        glyphBounds: x,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || T_(h);
  });
}
function f1({ path: c, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: n, contextLost: s }, o) {
  if (s)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: i, sdfExponent: a } = $r, l = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (i / r) * r, d = Math.floor(u / (i / r)) * r, f = e % 4;
  return y_(r, r, c, t, l, a, n, h, d, f, o);
}
function A_(c) {
  const e = c.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), c.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), c.contextLost = !1;
    const r = [];
    c.glyphsByFont.forEach((n) => {
      n.forEach((s) => {
        r.push(f1(s, c, !0));
      });
    }), Promise.all(r).then(() => {
      p1(c), c.sdfTexture.needsUpdate = !0;
    });
  });
}
function C_(c, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (c[t] = e[t]);
  return c;
}
let Hi;
function Np(c) {
  return Hi || (Hi = typeof document > "u" ? {} : document.createElement("a")), Hi.href = c, Hi.href;
}
function p1(c) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = c, { width: r, height: n } = e, s = c.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== r * n * 4) && (o = new Uint8Array(r * n * 4), t.image = { width: r, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, r, n, s.RGBA, s.UNSIGNED_BYTE, o);
  }
}
const E_ = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    g_,
    m_,
    u1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), R_ = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    E_
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (let t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), wp = {};
function F_(c) {
  let e = wp[c];
  if (!e) {
    const t = new Sr(1, 1, c, c), r = t.clone(), n = t.attributes, s = r.attributes, o = new Kn(), i = n.uv.count;
    for (let a = 0; a < i; a++)
      s.position.array[a * 3] *= -1, s.normal.array[a * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((a) => {
      o.setAttribute(
        a,
        new yn(
          [...n[a].array, ...s[a].array],
          n[a].itemSize
        )
      );
    }), o.setIndex([...t.index.array, ...r.index.array.map((a) => a + i)]), o.translate(0.5, 0.5, 0), e = wp[c] = o;
  }
  return e;
}
const L_ = "aTroikaGlyphBounds", Tp = "aTroikaGlyphIndex", O_ = "aTroikaGlyphColor";
class m1 extends bm {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new yi(), this.boundingBox = new sr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === gu ? t / 2 : 0, e === bu ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = F_(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, r, n, s) {
    cl(this, L_, e, 4), cl(this, Tp, t, 1), cl(this, O_, s, 3), this._blockBounds = r, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: n, floor: s, min: o, max: i, sin: a, cos: l } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, p = e[2] / d, m = s((f + u) / h) !== s((p + u) / h) ? -d : o(a(f) * d, a(p) * d), g = s((f - u) / h) !== s((p - u) / h) ? d : i(a(f) * d, a(p) * d), b = s((f + n) / h) !== s((p + n) / h) ? d * 2 : i(d - l(f) * d, d - l(p) * d);
        r.min.set(m, e[1], t < 0 ? -b : 0), r.max.set(g, e[3], t < 0 ? 0 : b);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(Tp).count, r = this._chunkedBounds;
    if (r)
      for (let n = r.length; n--; ) {
        t = r[n].end;
        let s = r[n].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function cl(c, e, t, r) {
  const n = c.getAttribute(e);
  t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (c.setAttribute(e, new Bx(t, r)), delete c._maxInstanceCount, c.dispose()) : n && c.deleteAttribute(e);
}
const I_ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, P_ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, U_ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, D_ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function z_(c) {
  const e = su(c, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new wt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new pt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new pt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new wt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Ve() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new ws() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: I_,
    vertexTransform: P_,
    fragmentDefs: U_,
    fragmentColorTransform: D_,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(r) && (r = r.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        h1,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const jd = /* @__PURE__ */ new An({
  color: 16777215,
  side: bu,
  transparent: !0
}), Sp = 8421504, _p = /* @__PURE__ */ new Ge(), Xi = /* @__PURE__ */ new ye(), ll = /* @__PURE__ */ new ye(), Po = [], B_ = /* @__PURE__ */ new ye(), ul = "+x+y";
function Mp(c) {
  return Array.isArray(c) ? c[0] : c;
}
let g1 = () => {
  const c = new qt(
    new Sr(1, 1),
    jd
  );
  return g1 = () => c, c;
}, y1 = () => {
  const c = new qt(
    new Sr(1, 1, 32, 1),
    jd
  );
  return y1 = () => c, c;
};
const k_ = { type: "syncstart" }, G_ = { type: "synccomplete" }, v1 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], V_ = v1.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class x1 extends qt {
  constructor() {
    const e = new m1();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Sp, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = ul, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(k_), M_({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((n) => n && n());
      })), this.dispatchEvent(G_), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, r, n, s, o) {
    this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s), s._hadOwnSide = s.hasOwnProperty("side"), this.geometry.setSide(s._actualSide = s.side), s.side = Sm;
  }
  onAfterRender(e, t, r, n, s, o) {
    s._hadOwnSide ? s.side = s._actualSide : delete s.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = jd.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = z_(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Mp(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Mp(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: i, blockBounds: a } = n;
      r.uTroikaSDFTexture.value = i, r.uTroikaSDFTextureSize.value.set(i.image.width, i.image.height), r.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, r.uTroikaSDFExponent.value = n.sdfExponent, r.uTroikaTotalBounds.value.fromArray(a), r.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let l = 0, u = 0, h = 0, d, f, p, m = 0, g = 0;
      if (t) {
        let { outlineWidth: v, outlineOffsetX: y, outlineOffsetY: x, outlineBlur: N, outlineOpacity: w } = this;
        l = this._parsePercent(v) || 0, u = Math.max(0, this._parsePercent(N) || 0), d = w, m = this._parsePercent(y) || 0, g = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (p = this.strokeColor, r.uTroikaStrokeColor.value.set(p ?? Sp), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      r.uTroikaDistanceOffset.value = l, r.uTroikaPositionOffset.value.set(m, g), r.uTroikaBlurRadius.value = u, r.uTroikaStrokeWidth.value = h, r.uTroikaStrokeOpacity.value = f, r.uTroikaFillOpacity.value = d ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let b = this.clipRect;
      if (b && Array.isArray(b) && b.length === 4)
        r.uTroikaClipRect.value.fromArray(b);
      else {
        const v = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          a[0] - v,
          a[1] - v,
          a[2] + v,
          a[3] + v
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null)
      delete e.color;
    else {
      const i = e.hasOwnProperty("color") ? e.color : e.color = new Ve();
      (s !== i._input || typeof s == "object") && i.set(i._input = s);
    }
    let o = this.orientation || ul;
    if (o !== e._orientation) {
      let i = r.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let a = o !== ul && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (a) {
        let [, l, u, h, d] = a;
        Xi.set(0, 0, 0)[u] = l === "-" ? 1 : -1, ll.set(0, 0, 0)[d] = h === "-" ? -1 : 1, _p.lookAt(B_, Xi.cross(ll), ll), i.setFromMatrix4(_p);
      } else
        i.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new wt()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new wt()) {
    return Xi.copy(e), this.localPositionToTextCoords(this.worldToLocal(Xi), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: n } = this;
    if (r) {
      const s = r.blockBounds, o = n ? y1() : g1(), i = o.geometry, { position: a, uv: l } = i.attributes;
      for (let u = 0; u < l.count; u++) {
        let h = s[0] + l.getX(u) * (s[2] - s[0]);
        const d = s[1] + l.getY(u) * (s[3] - s[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), a.setXYZ(u, h, d, f);
      }
      i.boundingSphere = this.geometry.boundingSphere, i.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, Po.length = 0, o.raycast(e, Po);
      for (let u = 0; u < Po.length; u++)
        Po[u].object = this, t.push(Po[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, V_.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
v1.forEach((c) => {
  const e = "_private_" + c;
  Object.defineProperty(x1.prototype, c, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const Ga = {
  text: "String",
  anchorX: 'number|"left"|"center"|"right"',
  anchorY: 'number|"top"|"top-baseline"|"top-cap"|"top-ex"|"middle"|"bottom-baseline"|"bottom"',
  curveRadius: "number",
  direction: '"auto"|"ltr"|"rtl"',
  font: "string",
  fontSize: "number",
  fontWeight: 'number|"normal" | "bold"',
  fontStyle: '"normal"|"italic"',
  letterSpacing: "number",
  lineHeight: 'number|"normal"',
  maxWidth: "number",
  overflowWrap: '"normal" | "break-word"',
  textAlign: '"left" | "right" | "center" | "justify"',
  textIndent: "number",
  whiteSpace: '"normal"| "nowrap"',
  color: "Color",
  outlineWidth: "number",
  outlineColor: "Color",
  outlineOpacity: "number",
  outlineBlur: "number",
  outlineOffsetX: "number",
  outlineOffsetY: "number",
  strokeWidth: "number",
  strokeColor: "Color",
  strokeOpacity: "number",
  fillOpacity: "number",
  depthOffset: "number",
  clipRect: "number[]",
  orientation: "string",
  glyphGeometryDetail: "number",
  sdfGlyphSize: "number|null",
  gpuAccelerateSDF: "boolean"
};
class b1 extends x1 {
  constructor() {
    super();
    G(this, "isTextMesh", !0);
    this.type = "TextMesh", this.text = "text", this.font = "/assets/fonts/STFangsong.ttf", this.color = new Ve(), this.outlineColor = new Ve(), this.strokeColor = new Ve();
  }
  serialize(t) {
    for (const [r, n] of Object.entries(Ga))
      if (n === "Color") {
        const s = this[r];
        t[r] = (s instanceof Ve ? s : new Ve(s)).toArray();
      } else
        t[r] = this[r];
    t.geo = {
      detail: this.geometry.detail,
      curveRadius: this.geometry.curveRadius,
      groups: this.geometry.groups,
      boundingSphere: { center: this.geometry.boundingSphere.center.toArray(), radius: this.geometry.boundingSphere.radius },
      boundingBox: { min: this.geometry.boundingBox.min.toArray(), max: this.geometry.boundingBox.max.toArray() }
    };
  }
  deserialize(t) {
    const r = new m1();
    r.copy(this.geometry), this.geometry = r, t.geo && (r.detail = t.geo.detail, r.curveRadius = t.geo.curveRadius, r.groups = t.geo.groups, r.boundingSphere.set(new ye().fromArray(t.geo.boundingSphere.center), t.geo.boundingSphere.radius), r.boundingBox = new sr(new ye().fromArray(t.geo.boundingBox.min), new ye().fromArray(t.geo.boundingBox.max)));
    for (const [n, s] of Object.entries(Ga)) {
      const o = t[n];
      o !== void 0 && (s === "Color" ? this[n] = new Ve().fromArray(o) : this[n] = o);
    }
    this.sync();
  }
}
Je("TextMesh", {
  // cls: TextMesh,
  create: () => new b1(),
  members: Ga,
  proto: "Mesh",
  group: "Text.Text",
  icon: "text"
});
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function j_() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var F = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < F; b++) {
            var D = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), D.push({ val1: S, val2: R });
            }
            u.matrix.push(D);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var U = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + U);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var F = n.kern.rval[_].glyph2.indexOf(o);
          if (F != -1)
            return n.kern.rval[_].vals[F];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var F = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[F + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var D = h.lookupRec;
              for (w = 0; w < D.length; w += 2) {
                y = D[w];
                var S = i[D[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, F = 0, A = 0, D = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, D);
        var S = D.val;
        if (p += D.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", U = 0; U < R; U++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (F = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), F = y + l.shift(), A = x + l.shift(), N = F + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (F = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), F = y + l.shift(), A = x + l.shift(), N = F + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, F, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), O = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[O], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var j = l.length, q = (se = 0, S == "o31");
            for (se += j - (R = -3 & j); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function W_() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), U = 0; U < 31; ++U)
        E[U] = R += 1 << S[U - 1];
      var P = new r(E[30]);
      for (U = 1; U < 30; ++U)
        for (var se = E[U]; se < E[U + 1]; ++se)
          P[se] = se - E[U] << 5 | U;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var U = S.length, P = 0, se = new t(R); P < U; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < U; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], O = R - S[P], I = H[S[P] - 1]++ << O, k = I | (1 << O) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(U), P = 0; P < U; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var U = R / 8 | 0;
      return (S[U] | S[U + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var U = new Error(R || T[S]);
      if (U.code = S, Error.captureStackTrace && Error.captureStackTrace(U, _), !E)
        throw U;
      return U;
    }, F = function(S, R, E) {
      var U = S.length;
      if (!U || E && !E.l && U < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * U));
      var oe, H = function(me) {
        var je = R.length;
        if (me > je) {
          var Xe = new e(Math.max(2 * je, me));
          Xe.set(R), R = Xe;
        }
      }, X = E.f || 0, C = E.p || 0, O = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, j = 8 * U;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(de = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[de - 3] << 8, ae = de + ie;
            if (ae > U) {
              se && _(0);
              break;
            }
            P && H(O + ie), R.set(S.subarray(de, ae), O), E.b = O += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, L = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < L; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * L;
            var fe = x(Y), ne = (1 << fe) - 1, ue = m(Y, fe, 1);
            for (ee = 0; ee < te; ) {
              var de, K = ue[N(S, C, ne)];
              if (C += 15 & K, (de = K >>> 4) < 16)
                Z[ee++] = de;
              else {
                var _e = 0, pe = 0;
                for (de == 16 ? (pe = 3 + N(S, C, 3), C += 2, _e = Z[ee - 1]) : de == 17 ? (pe = 3 + N(S, C, 7), C += 3) : de == 18 && (pe = 11 + N(S, C, 127), C += 7); pe--; )
                  Z[ee++] = _e;
              }
            }
            var xe = Z.subarray(0, $), he = Z.subarray($);
            z = x(xe), Q = x(he), I = m(xe, z, 1), k = m(he, Q, 1);
          } else
            _(1);
          if (C > j) {
            se && _(0);
            break;
          }
        }
        P && H(O + 131072);
        for (var $e = (1 << z) - 1, ce = (1 << Q) - 1, be = C; ; be = C) {
          var ge = (_e = I[w(S, C) & $e]) >>> 4;
          if ((C += 15 & _e) > j) {
            se && _(0);
            break;
          }
          if (_e || _(2), ge < 256)
            R[O++] = ge;
          else {
            if (ge == 256) {
              be = C, I = null;
              break;
            }
            var Te = ge - 254;
            if (ge > 264) {
              var Pe = n[ee = ge - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var qe = k[w(S, C) & ce], Se = qe >>> 4;
            if (qe || _(3), C += 15 & qe, he = h[Se], Se > 3 && (Pe = s[Se], he += w(S, C) & (1 << Pe) - 1, C += Pe), C > j) {
              se && _(0);
              break;
            }
            P && H(O + 131072);
            for (var De = O + Te; O < De; O += 4)
              R[O] = R[O - he], R[O + 1] = R[O + 1 - he], R[O + 2] = R[O + 2 - he], R[O + 3] = R[O + 3 - he];
            O = De;
          }
        }
        E.l = I, E.p = be, E.b = O, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return O == R.length ? R : function(me, je, Xe) {
        (je == null || je < 0) && (je = 0), (Xe == null || Xe > me.length) && (Xe = me.length);
        var ht = new (me instanceof t ? t : me instanceof r ? r : e)(Xe - je);
        return ht.set(me.subarray(je, Xe)), ht;
      }(R, 0, O);
    }, A = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function U() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: U(), reserved: U(), totalSfntSize: P(), majorVersion: U(), minorVersion: U(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), O = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, j = new Uint8Array(12 + 16 * k.length + k.reduce(function($, L) {
        return $ + L.origLength + 4;
      }, 0)), q = j.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(O), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var L, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          L = new Uint8Array(te, 2), F(L, Z);
        } else
          Z = new Uint8Array(te);
        j.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), j.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function H_(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((F) => {
          let [A, D] = F.split("+");
          A = parseInt(A, 36), D = D ? parseInt(D, 36) : 0, u.set(_ += A, w[T]);
          for (let S = D; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, F = -1;
    for (let A = 0; A < N.length; A++) {
      const D = N.codePointAt(A);
      let S = h(D) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[F]++) : S & (n | l) && (_ === f || _ === m) && w[F]-- : T & (s | l) && (_ === f || _ === m) && w[F]--, _ = w[A] = R, T = S, F = A, D > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let F = 0; F < w.length; F++) {
      const A = w.codePointAt(F);
      A > 65535 && F++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: F, featureList: A } = _;
      let D;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let U = 0; U < E.tab.length; U++) {
            if (R[E.tab[U]])
              continue;
            R[E.tab[U]] = !0;
            const P = F[E.tab[U]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !D && (D = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!D || !se || g[D[oe]] === E.tag) && c.U._applySubs(T, oe, P, F);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, F = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, F), D = {
      unitsPerEm: F,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, U) {
        let P = 0;
        const se = 1 / D.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, O) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", j = 0;
              for (let L = 0, te = k.length; L < te; L++) {
                const Z = t[k[L]];
                Q += k[L];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[j++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let L = 0, te = z.length; L < te; L += 2) {
                  let Z = z[L], Y = z[L + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), U.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return D;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const X_ = /* @__PURE__ */ fs({
  name: "Typr Font Parser",
  dependencies: [j_, W_, H_],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
}), $_ = X_;
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function q_() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var F = x.weight;
      F === void 0 && (F = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), D = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, U = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var O = m.get(C);
        return O || (O = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, O)), O;
      }
      for (var H = function(C) {
        var O = y.codePointAt(C), I = s(O);
        U[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), O > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[U[I]], j = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in j = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== j) {
                  for (var L in Q[$])
                    if (o(k, Q[$][L])) {
                      z = L;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), U[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, O = I);
        }, O = 0; O < y.length; O++)
          C(O);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, O = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (O && (v(k) || f(O).has(k)))
            S[I] = S[I - 1];
          else {
            O = u[U[I]];
            var z = R[O.id];
            if (!z) {
              var Q = O.typeforms, j = g(Q, T, "sans-serif"), q = g(Q[j], _, "normal"), ie = b((C = Q[j]) === null || C === void 0 ? void 0 : C[q], F);
              z = R[O.id] = A + "/font-files/" + O.id + "/" + j + "." + q + "." + ie + ".woff";
            }
            var ae = D.get(z);
            ae == null && (ae = D.size, D.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(D.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function J_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(F = 0) {
        for (let A = F, D = o.length; A < D; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const U = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                U[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: U, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[U];
                  if (!se) {
                    s(U, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < D && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let D = 0, S = A[1] - A[0]; D <= S; D++)
              f[A[0] + D] = w[_++] + T;
            _++;
          });
          let F = 0;
          N.forEach((A, D) => {
            s(A, (S) => {
              p[D + T] = S, ++F === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const Y_ = /* @__PURE__ */ fs({
  name: "FontResolver",
  dependencies: [
    J_,
    $_,
    q_
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function K_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let F, A;
      const D = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], D.push(F = { start: S, end: S, fontObj: _[T[S]] })) : F.end = S;
      N(D);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: F = "left",
    textIndent: A = 0,
    whiteSpace: D = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: U = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const O = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - O;
      const z = isFinite(T);
      let Q = null, j = null, q = null, ie = null, ae = null, $ = null, L = null, te = null, Z = 0, Y = 0, ee = D !== "nowrap";
      const fe = /* @__PURE__ */ new Map(), ne = h();
      let ue = A, de = 0, K = new d();
      const _e = [K];
      k.forEach((ce) => {
        const { fontObj: be } = ce, { ascender: ge, descender: Te, unitsPerEm: Pe, lineGap: qe, capHeight: Se, xHeight: De } = be;
        let me = fe.get(be);
        if (!me) {
          const ve = v / Pe, Oe = w === "normal" ? (ge - Te + qe) * ve : w * v, Dt = (Oe - (ge - Te) * ve) / 2, Ce = Math.min(Oe, (ge - Te) * ve), Re = (ge + Te) / 2 * ve + Ce / 2;
          me = {
            index: fe.size,
            src: be.src,
            fontObj: be,
            fontSizeMult: ve,
            unitsPerEm: Pe,
            ascender: ge * ve,
            descender: Te * ve,
            capHeight: Se * ve,
            xHeight: De * ve,
            lineHeight: Oe,
            baseline: -Dt - ge * ve,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ge + Te) / 2 * ve + Ce / 2,
            caretBottom: Re - Ce
          }, fe.set(be, me);
        }
        const { fontSizeMult: je } = me, Xe = p.slice(ce.start, ce.end + 1);
        let ht, Qe;
        be.forEachGlyph(Xe, v, N, (ve, Oe, Dt) => {
          Oe += de, Dt += ce.start, ht = Oe, Qe = ve;
          const Ce = p.charAt(Dt), Re = ve.advanceWidth * je, tt = K.count;
          let Ue;
          if ("isEmpty" in ve || (ve.isWhitespace = !!Ce && new RegExp(n).test(Ce), ve.canBreakAfter = !!Ce && s.test(Ce), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || r.test(Ce)), !ve.isWhitespace && !ve.isEmpty && Y++, ee && z && !ve.isWhitespace && Oe + Re + ue > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              Ue = new d(), ue = -Oe;
            else
              for (let We = tt; We--; )
                if (We === 0 && S === "break-word") {
                  Ue = new d(), ue = -Oe;
                  break;
                } else if (K.glyphAt(We).glyphObj.canBreakAfter) {
                  Ue = K.splitAt(We + 1);
                  const gt = Ue.glyphAt(0).x;
                  ue -= gt;
                  for (let at = Ue.count; at--; )
                    Ue.glyphAt(at).x -= gt;
                  break;
                }
            Ue && (K.isSoftWrapped = !0, K = Ue, _e.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = ve, we.x = Oe + ue, we.width = Re, we.charIndex = Dt, we.fontData = me, Ce === `
` && (K = new d(), _e.push(K), ue = -(Oe + Re + N * v) + A);
        }), de = ht + Qe.advanceWidth * je + N * v;
      });
      let pe = 0;
      _e.forEach((ce) => {
        let be = !0;
        for (let ge = ce.count; ge--; ) {
          const Te = ce.glyphAt(ge);
          be && !Te.glyphObj.isWhitespace && (ce.width = Te.x + Te.width, ce.width > Z && (Z = ce.width), be = !1);
          let { lineHeight: Pe, capHeight: qe, xHeight: Se, baseline: De } = Te.fontData;
          Pe > ce.lineHeight && (ce.lineHeight = Pe);
          const me = De - ce.baseline;
          me < 0 && (ce.baseline += me, ce.cap += me, ce.ex += me), ce.cap = Math.max(ce.cap, ce.baseline + qe), ce.ex = Math.max(ce.ex, ce.baseline + Se);
        }
        ce.baseline -= pe, ce.cap -= pe, ce.ex -= pe, pe += ce.lineHeight;
      });
      let xe = 0, he = 0;
      if (R && (typeof R == "number" ? xe = -R : typeof R == "string" && (xe = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? he = -E : typeof E == "string" && (he = E === "top" ? 0 : E === "top-baseline" ? -_e[0].baseline : E === "top-cap" ? -_e[0].cap : E === "top-ex" ? -_e[0].ex : E === "middle" ? pe / 2 : E === "bottom" ? pe : E === "bottom-baseline" ? _e[_e.length - 1].baseline : l(E) * pe)), !U) {
        const ce = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), j = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let be = 0, ge = -1, Te = -1, Pe, qe;
        if (_e.forEach((Se, De) => {
          let { count: me, width: je } = Se;
          if (me > 0) {
            let Xe = 0;
            for (let Ce = me; Ce-- && Se.glyphAt(Ce).glyphObj.isWhitespace; )
              Xe++;
            let ht = 0, Qe = 0;
            if (F === "center")
              ht = (Z - je) / 2;
            else if (F === "right")
              ht = Z - je;
            else if (F === "justify" && Se.isSoftWrapped) {
              let Ce = 0;
              for (let Re = me - Xe; Re--; )
                Se.glyphAt(Re).glyphObj.isWhitespace && Ce++;
              Qe = (Z - je) / Ce;
            }
            if (Qe || ht) {
              let Ce = 0;
              for (let Re = 0; Re < me; Re++) {
                let tt = Se.glyphAt(Re);
                const Ue = tt.glyphObj;
                tt.x += ht + Ce, Qe !== 0 && Ue.isWhitespace && Re < me - Xe && (Ce += Qe, tt.width += Qe);
              }
            }
            const ve = e.getReorderSegments(
              p,
              ce,
              Se.glyphAt(0).charIndex,
              Se.glyphAt(Se.count - 1).charIndex
            );
            for (let Ce = 0; Ce < ve.length; Ce++) {
              const [Re, tt] = ve[Ce];
              let Ue = 1 / 0, we = -1 / 0;
              for (let We = 0; We < me; We++)
                if (Se.glyphAt(We).charIndex >= Re) {
                  let gt = We, at = We;
                  for (; at < me; at++) {
                    let rt = Se.glyphAt(at);
                    if (rt.charIndex > tt)
                      break;
                    at < me - Xe && (Ue = Math.min(Ue, rt.x), we = Math.max(we, rt.x + rt.width));
                  }
                  for (let rt = gt; rt < at; rt++) {
                    const Lt = Se.glyphAt(rt);
                    Lt.x = we - (Lt.x + Lt.width - Ue);
                  }
                  break;
                }
            }
            let Oe;
            const Dt = (Ce) => Oe = Ce;
            for (let Ce = 0; Ce < me; Ce++) {
              const Re = Se.glyphAt(Ce);
              Oe = Re.glyphObj;
              const tt = Oe.index, Ue = ce.levels[Re.charIndex] & 1;
              if (Ue) {
                const we = e.getMirroredCharacter(p[Re.charIndex]);
                we && Re.fontData.fontObj.forEachGlyph(we, 0, 0, Dt);
              }
              if (oe) {
                const { charIndex: we, fontData: We } = Re, gt = Re.x + xe, at = Re.x + Re.width + xe;
                $[we * 4] = Ue ? at : gt, $[we * 4 + 1] = Ue ? gt : at, $[we * 4 + 2] = Se.baseline + We.caretBottom + he, $[we * 4 + 3] = Se.baseline + We.caretTop + he;
                const rt = we - ge;
                rt > 1 && u($, ge, rt), ge = we;
              }
              if (X) {
                const { charIndex: we } = Re;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (qe = X[Te]);
              }
              if (!Oe.isWhitespace && !Oe.isEmpty) {
                const we = be++, { fontSizeMult: We, src: gt, index: at } = Re.fontData, rt = ie[gt] || (ie[gt] = {});
                rt[tt] || (rt[tt] = {
                  path: Oe.path,
                  pathBounds: [Oe.xMin, Oe.yMin, Oe.xMax, Oe.yMax]
                });
                const Lt = Re.x + xe, On = Se.baseline + he;
                q[we * 2] = Lt, q[we * 2 + 1] = On;
                const ln = Lt + Oe.xMin * We, Tn = On + Oe.yMin * We, In = Lt + Oe.xMax * We, un = On + Oe.yMax * We;
                ln < L[0] && (L[0] = ln), Tn < L[1] && (L[1] = Tn), In > L[2] && (L[2] = In), un > L[3] && (L[3] = un), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const yt = Pe.rect;
                if (ln < yt[0] && (yt[0] = ln), Tn < yt[1] && (yt[1] = Tn), In > yt[2] && (yt[2] = In), un > yt[3] && (yt[3] = un), Q[we] = tt, j[we] = at, X) {
                  const Wn = we * 3;
                  ae[Wn] = qe >> 16 & 255, ae[Wn + 1] = qe >> 8 & 255, ae[Wn + 2] = qe & 255;
                }
              }
            }
          }
        }), $) {
          const Se = p.length - ge;
          Se > 1 && u($, ge, Se);
        }
      }
      const $e = [];
      fe.forEach(({ index: ce, src: be, unitsPerEm: ge, ascender: Te, descender: Pe, lineHeight: qe, capHeight: Se, xHeight: De }) => {
        $e[ce] = { src: be, unitsPerEm: ge, ascender: Te, descender: Pe, lineHeight: qe, capHeight: Se, xHeight: De };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: j,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: $e,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: he + _e[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          xe,
          he - pe,
          xe + Z,
          he
        ],
        visibleBounds: L,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const Z_ = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    K_,
    Y_,
    u1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), Q_ = Z_, eM = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    Q_
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (const t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), tM = new Ve();
let $i;
function nM(c) {
  return $i || ($i = typeof document > "u" ? {} : document.createElement("a")), $i.href = c, $i.href;
}
const N1 = {
  font: "/assets/fonts/STFangsong.ttf",
  lang: "en",
  fontSize: 0.1,
  fontWeight: "normal",
  fontStyle: "normal",
  letterSpacing: 0,
  lineHeight: "normal",
  maxWidth: 1,
  direction: "auto",
  textAlign: "left",
  textIndent: 0,
  whiteSpace: "normal",
  overflowWrap: "normal",
  anchorX: 0,
  anchorY: 0,
  colorRanges: null,
  includeCaretPositions: !0,
  sdfGlyphSize: 64,
  gpuAccelerateSDF: !1
};
async function sM(c) {
  c = { ...N1, ...c };
  const e = [];
  if (c.font && e.push({ label: "user", src: nM(c.font) }), c.font = e, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || 64, c.colorRanges != null) {
    const h = {};
    for (const d in c.colorRanges)
      if (Object.hasOwn(c.colorRanges, d)) {
        let f = c.colorRanges[d];
        typeof f != "number" && (f = tM.set(f).getHex()), h[d] = f;
      }
    c.colorRanges = h;
  }
  Object.freeze(c);
  const t = await eM(c), { glyphIds: r, glyphFontIndices: n, fontData: s, glyphData: o, glyphPositions: i, fontSize: a } = t, l = new xu();
  let u = 0;
  return r.forEach((h, d) => {
    const f = n[d], { src: p, unitsPerEm: m } = s[f], { path: g } = o[p][h], b = i[u++], v = i[u++], y = a / m, x = g.replace(/([A-Z])/mg, (N, w) => `$${w}`).split("$").filter((N) => N);
    for (const N of x) {
      const w = N[0];
      if (w === "Z")
        continue;
      const T = N.substring(1).split(",").map((_, F) => (F % 2 ? v : b) + Number.parseFloat(_) * y);
      w === "M" ? l.moveTo(...T) : w === "L" ? l.lineTo(...T) : w === "Q" ? l.quadraticCurveTo(...T) : w === "C" && l.bezierCurveTo(...T);
    }
  }), l.toShapes(!1);
}
const rM = Object.fromEntries(Object.entries(Ga).map((c) => [`props.${c[0]}`, c[1]]));
class oM extends Ar {
  constructor(t, r) {
    super(t, r, {
      ...N1,
      color: new Ve(),
      strokeColor: new Ve(),
      outlineColor: new Ve()
    }, 0, 0);
    G(this, "isText3D", !0);
    this.type = "Text3D";
  }
  async rebuildShapes() {
    this.shapes = await sM(this.props), this.rebuildGeometry();
  }
}
Je("Text3D", {
  members: rM,
  proto: "Shape",
  group: "Text.3D Text",
  icon: "text",
  create: ({ material: c, geometry: e } = {}) => new oM(e || new wm(), c)
});
class iM extends kx {
  constructor() {
    super();
    G(this, "isAudioListener2", !0);
    this.type = "AudioListener2";
  }
  toJSON(t) {
    const r = super.toJSON(t), n = { ...r.object };
    return delete n.children, t.listeners[n.uuid] = n, r;
  }
}
class aM extends Gx {
  constructor(t) {
    super(t);
    G(this, "isPositionalAudio2", !0);
    G(this, "_src", "");
    this.type = "PositionalAudio2";
  }
  get src() {
    return this._src;
  }
  set src(t) {
    this._src !== t && (this._src = t, this.isPlaying && this.stop(), new Vx().load(t, (r) => {
      this.setBuffer(r);
    }));
  }
  play(t) {
    return this.isPlaying && this.stop(), super.play(t);
  }
  clone(t) {
    const r = go.get(this.listener);
    return new this.constructor(r).copy(this, t);
  }
  serialize(t) {
    t.autoplay = this.autoplay, t.loop = this.loop, t.src = this._src, t.listener = this.listener.uuid;
  }
  deserialize(t) {
    this.autoplay = t.autoplay || !1, this.loop = t.loop || !1, this.src = t.src;
  }
}
Je("AudioListener2", {
  create: () => new iM(),
  proto: "AudioListener",
  members: {},
  group: "Audio.Audio Listener",
  icon: "ear"
});
Je("PositionalAudio2", {
  create: ({ listener: c }) => new aM(c),
  proto: "PositionalAudio",
  members: {
    autoplay: "Boolean",
    loop: "Boolean",
    src: "Audio"
  },
  group: "Audio.Positional Audio",
  icon: "audio"
});
function Ap(c, e) {
  if (e === jx)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), c;
  if (e === Il || e === _m) {
    let t = c.getIndex();
    if (t === null) {
      const o = [], i = c.getAttribute("position");
      if (i !== void 0) {
        for (let a = 0; a < i.count; a++)
          o.push(a);
        c.setIndex(o), t = c.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), c;
    }
    const r = t.count - 2, n = [];
    if (e === Il)
      for (let o = 1; o <= r; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < r; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = c.clone();
    return s.setIndex(n), s.clearGroups(), s;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), c;
}
class Wd extends xr {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new dM(t);
    }), this.register(function(t) {
      return new bM(t);
    }), this.register(function(t) {
      return new NM(t);
    }), this.register(function(t) {
      return new wM(t);
    }), this.register(function(t) {
      return new pM(t);
    }), this.register(function(t) {
      return new mM(t);
    }), this.register(function(t) {
      return new gM(t);
    }), this.register(function(t) {
      return new yM(t);
    }), this.register(function(t) {
      return new hM(t);
    }), this.register(function(t) {
      return new vM(t);
    }), this.register(function(t) {
      return new fM(t);
    }), this.register(function(t) {
      return new xM(t);
    }), this.register(function(t) {
      return new lM(t);
    }), this.register(function(t) {
      return new TM(t);
    }), this.register(function(t) {
      return new SM(t);
    });
  }
  load(e, t, r, n) {
    const s = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = po.extractUrlBase(e), this.manager.itemStart(e);
    const i = function(l) {
      n ? n(l) : console.error(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }, a = new Ks(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        s.parse(l, o, function(u) {
          t(u), s.manager.itemEnd(e);
        }, i);
      } catch (u) {
        i(u);
      }
    }, r, i);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, r, n) {
    let s;
    const o = {}, i = {}, a = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (a.decode(new Uint8Array(e, 0, 4)) === w1) {
        try {
          o[et.KHR_BINARY_GLTF] = new _M(e);
        } catch (h) {
          n && n(h);
          return;
        }
        s = JSON.parse(o[et.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(a.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new zM(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      i[h.name] = h, o[h.name] = !0;
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
        switch (h) {
          case et.KHR_MATERIALS_UNLIT:
            o[h] = new uM();
            break;
          case et.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new MM(s, this.dracoLoader);
            break;
          case et.KHR_TEXTURE_TRANSFORM:
            o[h] = new AM();
            break;
          case et.KHR_MESH_QUANTIZATION:
            o[h] = new CM();
            break;
          default:
            d.indexOf(h) >= 0 && i[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(i), l.parse(r, n);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function(n, s) {
      r.parse(e, t, n, s);
    });
  }
}
function cM() {
  let c = {};
  return {
    get: function(e) {
      return c[e];
    },
    add: function(e, t) {
      c[e] = t;
    },
    remove: function(e) {
      delete c[e];
    },
    removeAll: function() {
      c = {};
    }
  };
}
const et = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class lM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, r = "light:" + e;
    let n = t.cache.get(r);
    if (n)
      return n;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let l;
    const u = new Ve(16777215);
    a.color !== void 0 && u.setRGB(a.color[0], a.color[1], a.color[2], Rn);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        l = new pi(u), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        l = new Zo(u), l.distance = h;
        break;
      case "spot":
        l = new mi(u), l.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, l.angle = a.spot.outerConeAngle, l.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return l.position.set(0, 0, 0), l.decay = 2, Gs(l, a), a.intensity !== void 0 && (l.intensity = a.intensity), l.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(l), t.cache.add(r, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, r = this.parser, s = r.json.nodes[e], i = (s.extensions && s.extensions[this.name] || {}).light;
    return i === void 0 ? null : this._loadLight(i).then(function(a) {
      return r._getNodeRef(t.cache, i, a);
    });
  }
}
class uM {
  constructor() {
    this.name = et.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return An;
  }
  extendParams(e, t, r) {
    const n = [];
    e.color = new Ve(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Rn), e.opacity = o[3];
      }
      s.baseColorTexture !== void 0 && n.push(r.assignTexture(e, "map", s.baseColorTexture, vn));
    }
    return Promise.all(n);
  }
}
class hM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class dM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const i = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new wt(i, i);
    }
    return Promise.all(s);
  }
}
class fM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class pM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new Ve(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const i = o.sheenColorFactor;
      t.sheenColor.setRGB(i[0], i[1], i[2], Rn);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, vn)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s);
  }
}
class mM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s);
  }
}
class gM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const i = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Ve().setRGB(i[0], i[1], i[2], Rn), Promise.all(s);
  }
}
class yM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name];
    return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
}
class vM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const i = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Ve().setRGB(i[0], i[1], i[2], Rn), o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, vn)), Promise.all(s);
  }
}
class xM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : Es;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s);
  }
}
class bM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, r = t.json, n = r.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const s = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class NM {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class wM {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class TM {
  constructor(e) {
    this.name = et.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const n = r.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(i) {
        const a = n.byteOffset || 0, l = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(i, a, l);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class SM {
  constructor(e) {
    this.name = et.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const n = t.meshes[r.mesh];
    for (const l of n.primitives)
      if (l.mode !== Un.TRIANGLES && l.mode !== Un.TRIANGLE_STRIP && l.mode !== Un.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const o = r.extensions[this.name].attributes, i = [], a = {};
    for (const l in o)
      i.push(this.parser.getDependency("accessor", o[l]).then((u) => (a[l] = u, a[l])));
    return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then((l) => {
      const u = l.pop(), h = u.isGroup ? u.children : [u], d = l[0].count, f = [];
      for (const p of h) {
        const m = new Ge(), g = new ye(), b = new fr(), v = new ye(1, 1, 1), y = new Wx(p.geometry, p.material, d);
        for (let x = 0; x < d; x++)
          a.TRANSLATION && g.fromBufferAttribute(a.TRANSLATION, x), a.ROTATION && b.fromBufferAttribute(a.ROTATION, x), a.SCALE && v.fromBufferAttribute(a.SCALE, x), y.setMatrixAt(x, m.compose(g, b, v));
        for (const x in a)
          x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, a[x]);
        En.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), f.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
}
const w1 = "glTF", Uo = 12, Cp = { JSON: 1313821514, BIN: 5130562 };
class _M {
  constructor(e) {
    this.name = et.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Uo), r = new TextDecoder();
    if (this.header = {
      magic: r.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== w1)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Uo, s = new DataView(e, Uo);
    let o = 0;
    for (; o < n; ) {
      const i = s.getUint32(o, !0);
      o += 4;
      const a = s.getUint32(o, !0);
      if (o += 4, a === Cp.JSON) {
        const l = new Uint8Array(e, Uo + o, i);
        this.content = r.decode(l);
      } else if (a === Cp.BIN) {
        const l = Uo + o;
        this.body = e.slice(l, l + i);
      }
      o += i;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class MM {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = et.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, i = {}, a = {}, l = {};
    for (const u in o) {
      const h = ou[u] || u.toLowerCase();
      i[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = ou[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = r.accessors[e.attributes[u]], f = uo[d.componentType];
        l[h] = f.name, a[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(u, function(d) {
          for (const f in d.attributes) {
            const p = d.attributes[f], m = a[f];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, i, l);
      });
    });
  }
}
class AM {
  constructor() {
    this.name = et.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class CM {
  constructor() {
    this.name = et.KHR_MESH_QUANTIZATION;
  }
}
class T1 extends Jx {
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = r[s + o];
    return t;
  }
  interpolate_(e, t, r, n) {
    const s = this.resultBuffer, o = this.sampleValues, i = this.valueSize, a = i * 2, l = i * 3, u = n - t, h = (r - t) / u, d = h * h, f = d * h, p = e * l, m = p - l, g = -2 * f + 3 * d, b = f - d, v = 1 - g, y = b - d + h;
    for (let x = 0; x !== i; x++) {
      const N = o[m + x + i], w = o[m + x + a] * u, T = o[p + x + i], _ = o[p + x] * u;
      s[x] = v * N + y * w + g * T + b * _;
    }
    return s;
  }
}
const EM = new fr();
class RM extends T1 {
  interpolate_(e, t, r, n) {
    const s = super.interpolate_(e, t, r, n);
    return EM.fromArray(s).normalize().toArray(s), s;
  }
}
const Un = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, uo = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Ep = {
  9728: Hs,
  9729: fo,
  9984: Rm,
  9985: Fm,
  9986: Lm,
  9987: xo
}, Rp = {
  33071: mo,
  33648: Om,
  10497: Zs
}, hl = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ou = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Is = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, FM = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Em,
  STEP: qx
}, dl = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function LM(c) {
  return c.DefaultMaterial === void 0 && (c.DefaultMaterial = new jn({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Sm
  })), c.DefaultMaterial;
}
function ur(c, e, t) {
  for (const r in t.extensions)
    c[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]);
}
function Gs(c, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(c.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function OM(c, e, t) {
  let r = !1, n = !1, s = !1;
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (h.POSITION !== void 0 && (r = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (s = !0), r && n && s)
      break;
  }
  if (!r && !n && !s)
    return Promise.resolve(c);
  const o = [], i = [], a = [];
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (r) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : c.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : c.attributes.normal;
      i.push(d);
    }
    if (s) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : c.attributes.color;
      a.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(i),
    Promise.all(a)
  ]).then(function(l) {
    const u = l[0], h = l[1], d = l[2];
    return r && (c.morphAttributes.position = u), n && (c.morphAttributes.normal = h), s && (c.morphAttributes.color = d), c.morphTargetsRelative = !0, c;
  });
}
function IM(c, e) {
  if (c.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, r = e.weights.length; t < r; t++)
      c.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (c.morphTargetInfluences.length === t.length) {
      c.morphTargetDictionary = {};
      for (let r = 0, n = t.length; r < n; r++)
        c.morphTargetDictionary[t[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function PM(c) {
  let e;
  const t = c.extensions && c.extensions[et.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + fl(t.attributes) : e = c.indices + ":" + fl(c.attributes) + ":" + c.mode, c.targets !== void 0)
    for (let r = 0, n = c.targets.length; r < n; r++)
      e += ":" + fl(c.targets[r]);
  return e;
}
function fl(c) {
  let e = "";
  const t = Object.keys(c).sort();
  for (let r = 0, n = t.length; r < n; r++)
    e += t[r] + ":" + c[t[r]] + ";";
  return e;
}
function iu(c) {
  switch (c) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function UM(c) {
  return c.search(/\.jpe?g($|\?)/i) > 0 || c.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : c.search(/\.webp($|\?)/i) > 0 || c.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const DM = new Ge();
class zM {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new cM(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, n = !1, s = -1;
    typeof navigator < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || n && s < 98 ? this.textureLoader = new Nu(this.options.manager) : this.textureLoader = new Hx(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ks(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(o) {
      const i = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: r,
        userData: {}
      };
      return ur(s, i, n), Gs(i, n), Promise.all(r._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(i);
      })).then(function() {
        e(i);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n].joints;
      for (let i = 0, a = o.length; i < a; i++)
        e[o[i]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1)
      return r;
    const n = r.clone(), s = (o, i) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(i, a);
      for (const [l, u] of o.children.entries())
        s(u, i.children[l]);
    };
    return s(r, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const n = e(t[r]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const r = e + ":" + t;
    let n = this.cache.get(r);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(s, o) {
        return r.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[et.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(s, o) {
      r.load(po.resolveURL(t.uri, n.path), s, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(r) {
      const n = t.byteLength || 0, s = t.byteOffset || 0;
      return r.slice(s, s + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, r = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = hl[n.type], i = uo[n.componentType], a = n.normalized === !0, l = new i(n.count * o);
      return Promise.resolve(new ro(l, o, a));
    }
    const s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(o) {
      const i = o[0], a = hl[n.type], l = uo[n.componentType], u = l.BYTES_PER_ELEMENT, h = u * a, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? r.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, g;
      if (f && f !== h) {
        const b = Math.floor(d / f), v = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + b + ":" + n.count;
        let y = t.cache.get(v);
        y || (m = new l(i, b * f, n.count * f / u), y = new hm(m, f / u), t.cache.add(v, y)), g = new Ws(y, a, d % f / u, p);
      } else
        i === null ? m = new l(n.count * a) : m = new l(i, d, n.count * a), g = new ro(m, a, p);
      if (n.sparse !== void 0) {
        const b = hl.SCALAR, v = uo[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, x = n.sparse.values.byteOffset || 0, N = new v(o[1], y, n.sparse.count * b), w = new l(o[2], x, n.sparse.count * a);
        i !== null && (g = new ro(g.array.slice(), g.itemSize, g.normalized));
        for (let T = 0, _ = N.length; T < _; T++) {
          const F = N[T];
          if (g.setX(F, w[T * a]), a >= 2 && g.setY(F, w[T * a + 1]), a >= 3 && g.setZ(F, w[T * a + 2]), a >= 4 && g.setW(F, w[T * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, r = this.options, s = t.textures[e].source, o = t.images[s];
    let i = this.textureLoader;
    if (o.uri) {
      const a = r.manager.getHandler(o.uri);
      a !== null && (i = a);
    }
    return this.loadTextureImage(e, s, i);
  }
  loadTextureImage(e, t, r) {
    const n = this, s = this.json, o = s.textures[e], i = s.images[t], a = (i.uri || i.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const l = this.loadImageSource(t, r).then(function(u) {
      u.flipY = !1, u.name = o.name || i.name || "", u.name === "" && typeof i.uri == "string" && i.uri.startsWith("data:image/") === !1 && (u.name = i.uri);
      const d = (s.samplers || {})[o.sampler] || {};
      return u.magFilter = Ep[d.magFilter] || fo, u.minFilter = Ep[d.minFilter] || xo, u.wrapS = Rp[d.wrapS] || Zs, u.wrapT = Rp[d.wrapT] || Zs, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = l, l;
  }
  loadImageSource(e, t) {
    const r = this, n = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], i = self.URL || self.webkitURL;
    let a = o.uri || "", l = !1;
    if (o.bufferView !== void 0)
      a = r.getDependency("bufferView", o.bufferView).then(function(h) {
        l = !0;
        const d = new Blob([h], { type: o.mimeType });
        return a = i.createObjectURL(d), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(d, f) {
        let p = d;
        t.isImageBitmapLoader === !0 && (p = function(m) {
          const g = new Vn(m);
          g.needsUpdate = !0, d(g);
        }), t.load(po.resolveURL(h, s.path), p, void 0, f);
      });
    }).then(function(h) {
      return l === !0 && i.revokeObjectURL(a), h.userData.mimeType = o.mimeType || UM(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, r, n) {
    const s = this;
    return this.getDependency("texture", r.index).then(function(o) {
      if (!o)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[et.KHR_TEXTURE_TRANSFORM]) {
        const i = r.extensions !== void 0 ? r.extensions[et.KHR_TEXTURE_TRANSFORM] : void 0;
        if (i) {
          const a = s.associations.get(o);
          o = s.extensions[et.KHR_TEXTURE_TRANSFORM].extendTexture(o, i), s.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const i = "PointsMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new xm(), kn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, a.sizeAttenuation = !1, this.cache.add(i, a)), r = a;
    } else if (e.isLine) {
      const i = "LineBasicMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new vu(), kn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, this.cache.add(i, a)), r = a;
    }
    if (n || s || o) {
      let i = "ClonedMaterial:" + r.uuid + ":";
      n && (i += "derivative-tangents:"), s && (i += "vertex-colors:"), o && (i += "flat-shading:");
      let a = this.cache.get(i);
      a || (a = r.clone(), s && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(i, a), this.associations.set(a, this.associations.get(r))), r = a;
    }
    e.material = r;
  }
  getMaterialType() {
    return jn;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, r = this.json, n = this.extensions, s = r.materials[e];
    let o;
    const i = {}, a = s.extensions || {}, l = [];
    if (a[et.KHR_MATERIALS_UNLIT]) {
      const h = n[et.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), l.push(h.extendParams(i, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (i.color = new Ve(1, 1, 1), i.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        i.color.setRGB(d[0], d[1], d[2], Rn), i.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(i, "map", h.baseColorTexture, vn)), i.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, i.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(i, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(i, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, i);
      })));
    }
    s.doubleSided === !0 && (i.side = bu);
    const u = s.alphaMode || dl.OPAQUE;
    if (u === dl.BLEND ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === dl.MASK && (i.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "normalMap", s.normalTexture)), i.normalScale = new wt(1, 1), s.normalTexture.scale !== void 0)) {
      const h = s.normalTexture.scale;
      i.normalScale.set(h, h);
    }
    if (s.occlusionTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (i.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== An) {
      const h = s.emissiveFactor;
      i.emissive = new Ve().setRGB(h[0], h[1], h[2], Rn);
    }
    return s.emissiveTexture !== void 0 && o !== An && l.push(t.assignTexture(i, "emissiveMap", s.emissiveTexture, vn)), Promise.all(l).then(function() {
      const h = new o(i);
      return s.name && (h.name = s.name), Gs(h, s), t.associations.set(h, { materials: e }), s.extensions && ur(n, h, s), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Qo.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, r = this.extensions, n = this.primitiveCache;
    function s(i) {
      return r[et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i, t).then(function(a) {
        return Fp(a, i, t);
      });
    }
    const o = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i], u = PM(l), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        l.extensions && l.extensions[et.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = Fp(new Kn(), l, t), n[u] = { primitive: l, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, r = this.json, n = this.extensions, s = r.meshes[e], o = s.primitives, i = [];
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a].material === void 0 ? LM(this.cache) : this.getDependency("material", o[a].material);
      i.push(u);
    }
    return i.push(t.loadGeometries(o)), Promise.all(i).then(function(a) {
      const l = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let f = 0, p = u.length; f < p; f++) {
        const m = u[f], g = o[f];
        let b;
        const v = l[f];
        if (g.mode === Un.TRIANGLES || g.mode === Un.TRIANGLE_STRIP || g.mode === Un.TRIANGLE_FAN || g.mode === void 0)
          b = s.isSkinnedMesh === !0 ? new Mm(m, v) : new qt(m, v), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), g.mode === Un.TRIANGLE_STRIP ? b.geometry = Ap(b.geometry, _m) : g.mode === Un.TRIANGLE_FAN && (b.geometry = Ap(b.geometry, Il));
        else if (g.mode === Un.LINES)
          b = new Xx(m, v);
        else if (g.mode === Un.LINE_STRIP)
          b = new Am(m, v);
        else if (g.mode === Un.LINE_LOOP)
          b = new $x(m, v);
        else if (g.mode === Un.POINTS)
          b = new Cm(m, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(b.geometry.morphAttributes).length > 0 && IM(b, s), b.name = t.createUniqueName(s.name || "mesh_" + e), Gs(b, s), g.extensions && ur(n, b, g), t.assignFinalMaterial(b), h.push(b);
      }
      for (let f = 0, p = h.length; f < p; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return s.extensions && ur(n, h[0], s), h[0];
      const d = new io();
      s.extensions && ur(n, d, s), t.associations.set(d, { meshes: e });
      for (let f = 0, p = h.length; f < p; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e], n = r[r.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? t = new br(Zt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : r.type === "orthographic" && (t = new Xa(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Gs(t, r), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], r = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      r.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(n) {
      const s = n.pop(), o = n, i = [], a = [];
      for (let l = 0, u = o.length; l < u; l++) {
        const h = o[l];
        if (h) {
          i.push(h);
          const d = new Ge();
          s !== null && d.fromArray(s.array, l * 16), a.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
      }
      return new wu(i, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, r = this, n = t.animations[e], s = n.name ? n.name : "animation_" + e, o = [], i = [], a = [], l = [], u = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const f = n.channels[h], p = n.samplers[f.sampler], m = f.target, g = m.node, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, v = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (o.push(this.getDependency("node", g)), i.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", v)), l.push(p), u.push(m));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(i),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u)
    ]).then(function(h) {
      const d = h[0], f = h[1], p = h[2], m = h[3], g = h[4], b = [];
      for (let v = 0, y = d.length; v < y; v++) {
        const x = d[v], N = f[v], w = p[v], T = m[v], _ = g[v];
        if (x === void 0)
          continue;
        x.updateMatrix && x.updateMatrix();
        const F = r._createAnimationTracks(x, N, w, T, _);
        if (F)
          for (let A = 0; A < F.length; A++)
            b.push(F[A]);
      }
      return new Tu(s, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json, r = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : r.getDependency("mesh", n.mesh).then(function(s) {
      const o = r._getNodeRef(r.meshCache, n.mesh, s);
      return n.weights !== void 0 && o.traverse(function(i) {
        if (i.isMesh)
          for (let a = 0, l = n.weights.length; a < l; a++)
            i.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, r = this, n = t.nodes[e], s = r._loadNodeShallow(e), o = [], i = n.children || [];
    for (let l = 0, u = i.length; l < u; l++)
      o.push(r.getDependency("node", i[l]));
    const a = n.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", n.skin);
    return Promise.all([
      s,
      Promise.all(o),
      a
    ]).then(function(l) {
      const u = l[0], h = l[1], d = l[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, DM);
      });
      for (let f = 0, p = h.length; f < p; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, r = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], o = s.name ? n.createUniqueName(s.name) : "", i = [], a = n._invokeOne(function(l) {
      return l.createNodeMesh && l.createNodeMesh(e);
    });
    return a && i.push(a), s.camera !== void 0 && i.push(n.getDependency("camera", s.camera).then(function(l) {
      return n._getNodeRef(n.cameraCache, s.camera, l);
    })), n._invokeAll(function(l) {
      return l.createNodeAttachment && l.createNodeAttachment(e);
    }).forEach(function(l) {
      i.push(l);
    }), this.nodeCache[e] = Promise.all(i).then(function(l) {
      let u;
      if (s.isBone === !0 ? u = new Pl() : l.length > 1 ? u = new io() : l.length === 1 ? u = l[0] : u = new En(), u !== l[0])
        for (let h = 0, d = l.length; h < d; h++)
          u.add(l[h]);
      if (s.name && (u.userData.name = s.name, u.name = o), Gs(u, s), s.extensions && ur(r, u, s), s.matrix !== void 0) {
        const h = new Ge();
        h.fromArray(s.matrix), u.applyMatrix4(h);
      } else
        s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, r = this.json.scenes[e], n = this, s = new io();
    r.name && (s.name = n.createUniqueName(r.name)), Gs(s, r), r.extensions && ur(t, s, r);
    const o = r.nodes || [], i = [];
    for (let a = 0, l = o.length; a < l; a++)
      i.push(n.getDependency("node", o[a]));
    return Promise.all(i).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        s.add(a[u]);
      const l = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof kn || d instanceof Vn) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = l(s), s;
    });
  }
  _createAnimationTracks(e, t, r, n, s) {
    const o = [], i = e.name ? e.name : e.uuid, a = [];
    Is[s.path] === Is.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && a.push(d.name ? d.name : d.uuid);
    }) : a.push(i);
    let l;
    switch (Is[s.path]) {
      case Is.weights:
        l = Dl;
        break;
      case Is.rotation:
        l = zl;
        break;
      case Is.position:
      case Is.scale:
        l = Ul;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            l = Dl;
            break;
          case 2:
          case 3:
          default:
            l = Ul;
            break;
        }
        break;
    }
    const u = n.interpolation !== void 0 ? FM[n.interpolation] : Em, h = this._getArrayFromAccessor(r);
    for (let d = 0, f = a.length; d < f; d++) {
      const p = new l(
        a[d] + "." + Is[s.path],
        t.array,
        h,
        u
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const r = iu(t.constructor), n = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++)
        n[s] = t[s] * r;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(r) {
      const n = this instanceof zl ? RM : T1;
      return new n(this.times, this.values, this.getValueSize() / 3, r);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function BM(c, e, t) {
  const r = e.attributes, n = new sr();
  if (r.POSITION !== void 0) {
    const i = t.json.accessors[r.POSITION], a = i.min, l = i.max;
    if (a !== void 0 && l !== void 0) {
      if (n.set(
        new ye(a[0], a[1], a[2]),
        new ye(l[0], l[1], l[2])
      ), i.normalized) {
        const u = iu(uo[i.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const s = e.targets;
  if (s !== void 0) {
    const i = new ye(), a = new ye();
    for (let l = 0, u = s.length; l < u; l++) {
      const h = s[l];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, p = d.max;
        if (f !== void 0 && p !== void 0) {
          if (a.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), a.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), a.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
            const m = iu(uo[d.componentType]);
            a.multiplyScalar(m);
          }
          i.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(i);
  }
  c.boundingBox = n;
  const o = new yi();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, c.boundingSphere = o;
}
function Fp(c, e, t) {
  const r = e.attributes, n = [];
  function s(o, i) {
    return t.getDependency("accessor", o).then(function(a) {
      c.setAttribute(i, a);
    });
  }
  for (const o in r) {
    const i = ou[o] || o.toLowerCase();
    i in c.attributes || n.push(s(r[o], i));
  }
  if (e.indices !== void 0 && !c.index) {
    const o = t.getDependency("accessor", e.indices).then(function(i) {
      c.setIndex(i);
    });
    n.push(o);
  }
  return Uf.workingColorSpace !== Rn && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Uf.workingColorSpace}" not supported.`), Gs(c, e), BM(c, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? OM(c, e.targets, t) : c;
  });
}
const pl = /* @__PURE__ */ new WeakMap();
class kM extends xr {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, r, n) {
    const s = new Ks(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      this.parse(o, t, n);
    }, r, n);
  }
  parse(e, t, r) {
    this.decodeDracoFile(e, t, null, null, vn).catch(r);
  }
  decodeDracoFile(e, t, r, n, s = Rn) {
    const o = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: s
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const r = JSON.stringify(t);
    if (pl.has(e)) {
      const a = pl.get(e);
      if (a.key === r)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++, o = e.byteLength, i = this._getWorker(s, o).then((a) => (n = a, new Promise((l, u) => {
      n._callbacks[s] = { resolve: l, reject: u }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return i.catch(() => !0).then(() => {
      n && s && this._releaseTask(n, s);
    }), pl.set(e, {
      key: r,
      promise: i
    }), i;
  }
  _createGeometry(e) {
    const t = new Kn();
    e.index && t.setIndex(new ro(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const n = e.attributes[r], s = n.name, o = n.array, i = n.itemSize, a = new ro(o, i);
      s === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(s, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== vn)
      return;
    const r = new Ve();
    for (let n = 0, s = e.count; n < s; n++)
      r.fromBufferAttribute(e, n).convertSRGBToLinear(), e.setXYZ(n, r.r, r.g, r.b);
  }
  _loadLibrary(e, t) {
    const r = new Ks(this.manager);
    return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((n, s) => {
      r.load(e, n, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((r) => {
      const n = r[0];
      e || (this.decoderConfig.wasmBinary = r[1]);
      const s = GM.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(s) {
          const o = s.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, s) {
          return n._taskLoad > s._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return r._taskCosts[e] = t, r._taskLoad += t, r;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function GM() {
  let c, e;
  onmessage = function(o) {
    const i = o.data;
    switch (i.type) {
      case "init":
        c = i.decoderConfig, e = new Promise(function(u) {
          c.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(c);
        });
        break;
      case "decode":
        const a = i.buffer, l = i.taskConfig;
        e.then((u) => {
          const h = u.draco, d = new h.Decoder();
          try {
            const f = t(h, d, new Int8Array(a), l), p = f.attributes.map((m) => m.array.buffer);
            f.index && p.push(f.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: f }, p);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: i.id, error: f.message });
          } finally {
            h.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, i, a, l) {
    const u = l.attributeIDs, h = l.attributeTypes;
    let d, f;
    const p = i.GetEncodedGeometryType(a);
    if (p === o.TRIANGULAR_MESH)
      d = new o.Mesh(), f = i.DecodeArrayToMesh(a, a.byteLength, d);
    else if (p === o.POINT_CLOUD)
      d = new o.PointCloud(), f = i.DecodeArrayToPointCloud(a, a.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const m = { index: null, attributes: [] };
    for (const g in u) {
      const b = self[h[g]];
      let v, y;
      if (l.useUniqueIDs)
        y = u[g], v = i.GetAttributeByUniqueId(d, y);
      else {
        if (y = i.GetAttributeId(d, o[u[g]]), y === -1)
          continue;
        v = i.GetAttribute(d, y);
      }
      const x = n(o, i, d, g, b, v);
      g === "color" && (x.vertexColorSpace = l.vertexColorSpace), m.attributes.push(x);
    }
    return p === o.TRIANGULAR_MESH && (m.index = r(o, i, d)), o.destroy(d), m;
  }
  function r(o, i, a) {
    const u = a.num_faces() * 3, h = u * 4, d = o._malloc(h);
    i.GetTrianglesUInt32Array(a, h, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function n(o, i, a, l, u, h) {
    const d = h.num_components(), p = a.num_points() * d, m = p * u.BYTES_PER_ELEMENT, g = s(o, u), b = o._malloc(m);
    i.GetAttributeDataArrayForAllPoints(a, h, g, m, b);
    const v = new u(o.HEAPF32.buffer, b, p).slice();
    return o._free(b), {
      name: l,
      array: v,
      itemSize: d
    };
  }
  function s(o, i) {
    switch (i) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Lp = function(c) {
  return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Lp(""));
} catch {
  Lp = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Bn = Uint8Array, $s = Uint16Array, au = Uint32Array, S1 = new Bn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), _1 = new Bn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), VM = new Bn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), M1 = function(c, e) {
  for (var t = new $s(31), r = 0; r < 31; ++r)
    t[r] = e += 1 << c[r - 1];
  for (var n = new au(t[30]), r = 1; r < 30; ++r)
    for (var s = t[r]; s < t[r + 1]; ++s)
      n[s] = s - t[r] << 5 | r;
  return [t, n];
}, A1 = M1(S1, 2), C1 = A1[0], jM = A1[1];
C1[28] = 258, jM[258] = 28;
var WM = M1(_1, 0), HM = WM[0], cu = new $s(32768);
for (var ft = 0; ft < 32768; ++ft) {
  var Ps = (ft & 43690) >>> 1 | (ft & 21845) << 1;
  Ps = (Ps & 52428) >>> 2 | (Ps & 13107) << 2, Ps = (Ps & 61680) >>> 4 | (Ps & 3855) << 4, cu[ft] = ((Ps & 65280) >>> 8 | (Ps & 255) << 8) >>> 1;
}
var Jo = function(c, e, t) {
  for (var r = c.length, n = 0, s = new $s(e); n < r; ++n)
    ++s[c[n] - 1];
  var o = new $s(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + s[n - 1] << 1;
  var i;
  if (t) {
    i = new $s(1 << e);
    var a = 15 - e;
    for (n = 0; n < r; ++n)
      if (c[n])
        for (var l = n << 4 | c[n], u = e - c[n], h = o[c[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          i[cu[h] >>> a] = l;
  } else
    for (i = new $s(r), n = 0; n < r; ++n)
      c[n] && (i[n] = cu[o[c[n] - 1]++] >>> 15 - c[n]);
  return i;
}, wi = new Bn(288);
for (var ft = 0; ft < 144; ++ft)
  wi[ft] = 8;
for (var ft = 144; ft < 256; ++ft)
  wi[ft] = 9;
for (var ft = 256; ft < 280; ++ft)
  wi[ft] = 7;
for (var ft = 280; ft < 288; ++ft)
  wi[ft] = 8;
var E1 = new Bn(32);
for (var ft = 0; ft < 32; ++ft)
  E1[ft] = 5;
var XM = /* @__PURE__ */ Jo(wi, 9, 1), $M = /* @__PURE__ */ Jo(E1, 5, 1), ml = function(c) {
  for (var e = c[0], t = 1; t < c.length; ++t)
    c[t] > e && (e = c[t]);
  return e;
}, $n = function(c, e, t) {
  var r = e / 8 | 0;
  return (c[r] | c[r + 1] << 8) >> (e & 7) & t;
}, gl = function(c, e) {
  var t = e / 8 | 0;
  return (c[t] | c[t + 1] << 8 | c[t + 2] << 16) >> (e & 7);
}, qM = function(c) {
  return (c / 8 | 0) + (c & 7 && 1);
}, JM = function(c, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > c.length) && (t = c.length);
  var r = new (c instanceof $s ? $s : c instanceof au ? au : Bn)(t - e);
  return r.set(c.subarray(e, t)), r;
}, YM = function(c, e, t) {
  var r = c.length;
  if (!r || t && !t.l && r < 5)
    return e || new Bn(0);
  var n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new Bn(r * 3));
  var o = function(Q) {
    var j = e.length;
    if (Q > j) {
      var q = new Bn(Math.max(j * 2, Q));
      q.set(e), e = q;
    }
  }, i = t.f || 0, a = t.p || 0, l = t.b || 0, u = t.l, h = t.d, d = t.m, f = t.n, p = r * 8;
  do {
    if (!u) {
      t.f = i = $n(c, a, 1);
      var m = $n(c, a + 1, 3);
      if (a += 3, m)
        if (m == 1)
          u = XM, h = $M, d = 9, f = 5;
        else if (m == 2) {
          var y = $n(c, a, 31) + 257, x = $n(c, a + 10, 15) + 4, N = y + $n(c, a + 5, 31) + 1;
          a += 14;
          for (var w = new Bn(N), T = new Bn(19), _ = 0; _ < x; ++_)
            T[VM[_]] = $n(c, a + _ * 3, 7);
          a += x * 3;
          for (var F = ml(T), A = (1 << F) - 1, D = Jo(T, F, 1), _ = 0; _ < N; ) {
            var S = D[$n(c, a, A)];
            a += S & 15;
            var g = S >>> 4;
            if (g < 16)
              w[_++] = g;
            else {
              var R = 0, E = 0;
              for (g == 16 ? (E = 3 + $n(c, a, 3), a += 2, R = w[_ - 1]) : g == 17 ? (E = 3 + $n(c, a, 7), a += 3) : g == 18 && (E = 11 + $n(c, a, 127), a += 7); E--; )
                w[_++] = R;
            }
          }
          var U = w.subarray(0, y), P = w.subarray(y);
          d = ml(U), f = ml(P), u = Jo(U, d, 1), h = Jo(P, f, 1);
        } else
          throw "invalid block type";
      else {
        var g = qM(a) + 4, b = c[g - 4] | c[g - 3] << 8, v = g + b;
        if (v > r) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + b), e.set(c.subarray(g, v), l), t.b = l += b, t.p = a = v * 8;
        continue;
      }
      if (a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(l + 131072);
    for (var se = (1 << d) - 1, oe = (1 << f) - 1, H = a; ; H = a) {
      var R = u[gl(c, a) & se], X = R >>> 4;
      if (a += R & 15, a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!R)
        throw "invalid length/literal";
      if (X < 256)
        e[l++] = X;
      else if (X == 256) {
        H = a, u = null;
        break;
      } else {
        var C = X - 254;
        if (X > 264) {
          var _ = X - 257, O = S1[_];
          C = $n(c, a, (1 << O) - 1) + C1[_], a += O;
        }
        var I = h[gl(c, a) & oe], k = I >>> 4;
        if (!I)
          throw "invalid distance";
        a += I & 15;
        var P = HM[k];
        if (k > 3) {
          var O = _1[k];
          P += gl(c, a) & (1 << O) - 1, a += O;
        }
        if (a > p) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + 131072);
        for (var z = l + C; l < z; l += 4)
          e[l] = e[l - P], e[l + 1] = e[l + 1 - P], e[l + 2] = e[l + 2 - P], e[l + 3] = e[l + 3 - P];
        l = z;
      }
    }
    t.l = u, t.p = H, t.b = l, u && (i = 1, t.m = d, t.d = h, t.n = f);
  } while (!i);
  return l == e.length ? e : JM(e, 0, l);
}, KM = /* @__PURE__ */ new Bn(0), ZM = function(c) {
  if ((c[0] & 15) != 8 || c[0] >>> 4 > 7 || (c[0] << 8 | c[1]) % 31)
    throw "invalid zlib data";
  if (c[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function QM(c, e) {
  return YM((ZM(c), c.subarray(2, -4)), e);
}
var eA = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), tA = 0;
try {
  eA.decode(KM, { stream: !0 }), tA = 1;
} catch {
}
function R1(c, e, t) {
  const r = t.length - c - 1;
  if (e >= t[r])
    return r - 1;
  if (e <= t[c])
    return c;
  let n = c, s = r, o = Math.floor((n + s) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? s = o : n = o, o = Math.floor((n + s) / 2);
  return o;
}
function nA(c, e, t, r) {
  const n = [], s = [], o = [];
  n[0] = 1;
  for (let i = 1; i <= t; ++i) {
    s[i] = e - r[c + 1 - i], o[i] = r[c + i] - e;
    let a = 0;
    for (let l = 0; l < i; ++l) {
      const u = o[l + 1], h = s[i - l], d = n[l] / (u + h);
      n[l] = a + u * d, a = h * d;
    }
    n[i] = a;
  }
  return n;
}
function sA(c, e, t, r) {
  const n = R1(c, r, e), s = nA(n, r, c, e), o = new pt(0, 0, 0, 0);
  for (let i = 0; i <= c; ++i) {
    const a = t[n - c + i], l = s[i], u = a.w * l;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * l;
  }
  return o;
}
function rA(c, e, t, r, n) {
  const s = [];
  for (let h = 0; h <= t; ++h)
    s[h] = 0;
  const o = [];
  for (let h = 0; h <= r; ++h)
    o[h] = s.slice(0);
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = s.slice(0);
  i[0][0] = 1;
  const a = s.slice(0), l = s.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[c + 1 - h], l[h] = n[c + h] - e;
    let d = 0;
    for (let f = 0; f < h; ++f) {
      const p = l[f + 1], m = a[h - f];
      i[h][f] = p + m;
      const g = i[f][h - 1] / i[h][f];
      i[f][h] = d + p * g, d = m * g;
    }
    i[h][h] = d;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = i[h][t];
  for (let h = 0; h <= t; ++h) {
    let d = 0, f = 1;
    const p = [];
    for (let m = 0; m <= t; ++m)
      p[m] = s.slice(0);
    p[0][0] = 1;
    for (let m = 1; m <= r; ++m) {
      let g = 0;
      const b = h - m, v = t - m;
      h >= m && (p[f][0] = p[d][0] / i[v + 1][b], g = p[f][0] * i[b][v]);
      const y = b >= -1 ? 1 : -b, x = h - 1 <= v ? m - 1 : t - h;
      for (let w = y; w <= x; ++w)
        p[f][w] = (p[d][w] - p[d][w - 1]) / i[v + 1][b + w], g += p[f][w] * i[b + w][v];
      h <= v && (p[f][m] = -p[d][m - 1] / i[v + 1][h], g += p[f][m] * i[h][v]), o[m][h] = g;
      const N = d;
      d = f, f = N;
    }
  }
  let u = t;
  for (let h = 1; h <= r; ++h) {
    for (let d = 0; d <= t; ++d)
      o[h][d] *= u;
    u *= t - h;
  }
  return o;
}
function oA(c, e, t, r, n) {
  const s = n < c ? n : c, o = [], i = R1(c, r, e), a = rA(i, r, c, s, e), l = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), d = h.w;
    h.x *= d, h.y *= d, h.z *= d, l[u] = h;
  }
  for (let u = 0; u <= s; ++u) {
    const h = l[i - c].clone().multiplyScalar(a[u][0]);
    for (let d = 1; d <= c; ++d)
      h.add(l[i - c + d].clone().multiplyScalar(a[u][d]));
    o[u] = h;
  }
  for (let u = s + 1; u <= n + 1; ++u)
    o[u] = new pt(0, 0, 0);
  return o;
}
function iA(c, e) {
  let t = 1;
  for (let n = 2; n <= c; ++n)
    t *= n;
  let r = 1;
  for (let n = 2; n <= e; ++n)
    r *= n;
  for (let n = 2; n <= c - e; ++n)
    r *= n;
  return t / r;
}
function aA(c) {
  const e = c.length, t = [], r = [];
  for (let s = 0; s < e; ++s) {
    const o = c[s];
    t[s] = new ye(o.x, o.y, o.z), r[s] = o.w;
  }
  const n = [];
  for (let s = 0; s < e; ++s) {
    const o = t[s].clone();
    for (let i = 1; i <= s; ++i)
      o.sub(n[s - i].clone().multiplyScalar(iA(s, i) * r[i]));
    n[s] = o.divideScalar(r[0]);
  }
  return n;
}
function cA(c, e, t, r, n) {
  const s = oA(c, e, t, r, n);
  return aA(s);
}
class lA extends Yx {
  constructor(e, t, r, n, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = s || this.knots.length - 1;
    for (let o = 0; o < r.length; ++o) {
      const i = r[o];
      this.controlPoints[o] = new pt(i.x, i.y, i.z, i.w);
    }
  }
  getPoint(e, t = new ye()) {
    const r = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = sA(this.degree, this.knots, this.controlPoints, n);
    return s.w !== 1 && s.divideScalar(s.w), r.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new ye()) {
    const r = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = cA(this.degree, this.knots, this.controlPoints, n, 1);
    return r.copy(s[1]).normalize(), r;
  }
}
let Ye, Tt, mn;
class uA extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, n) {
    const s = this, o = s.path === "" ? po.extractUrlBase(e) : s.path, i = new Ks(this.manager);
    i.setPath(s.path), i.setResponseType("arraybuffer"), i.setRequestHeader(s.requestHeader), i.setWithCredentials(s.withCredentials), i.load(e, function(a) {
      try {
        t(s.parse(a, o));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, r, n);
  }
  parse(e, t) {
    if (gA(e))
      Ye = new mA().parse(e);
    else {
      const n = I1(e);
      if (!yA(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Ip(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Ip(n));
      Ye = new pA().parse(n);
    }
    const r = new Nu(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new hA(r, this.manager).parse(Ye);
  }
}
class hA {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Tt = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), r = this.parseMaterials(t), n = this.parseDeformers(), s = new dA().parse(n);
    return this.parseScene(n, s, r), mn;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ye && Ye.Connections.connections.forEach(function(r) {
      const n = r[0], s = r[1], o = r[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const i = { ID: s, relationship: o };
      e.get(n).parents.push(i), e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(s).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ye.Objects) {
      const r = Ye.Objects.Video;
      for (const n in r) {
        const s = r[n], o = parseInt(n);
        if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
          const i = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, a = typeof s.Content == "string" && s.Content !== "";
          if (i || a) {
            const l = this.parseImage(r[n]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const r in e) {
      const n = e[r];
      t[n] !== void 0 ? e[r] = t[n] : e[r] = e[r].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, r = e.RelativeFilename || e.Filename, n = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (n) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", r), s = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: s }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ye.Objects) {
      const r = Ye.Objects.Texture;
      for (const n in r) {
        const s = this.parseTexture(r[n], e);
        t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const r = this.loadTexture(e, t);
    r.ID = e.id, r.name = e.attrName;
    const n = e.WrapModeU, s = e.WrapModeV, o = n !== void 0 ? n.value : 0, i = s !== void 0 ? s.value : 0;
    if (r.wrapS = o === 0 ? Zs : mo, r.wrapT = i === 0 ? Zs : mo, "Scaling" in e) {
      const a = e.Scaling.value;
      r.repeat.x = a[0], r.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      r.offset.x = a[0], r.offset.y = a[1];
    }
    return r;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let r;
    const n = this.textureLoader.path, s = Tt.get(e.id).children;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (r = t[s[0].ID], (r.indexOf("blob:") === 0 || r.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const i = e.FileName.slice(-3).toLowerCase();
    if (i === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Vn()) : (a.setPath(this.textureLoader.path), o = a.load(r));
    } else
      i === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Vn()) : o = this.textureLoader.load(r);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ye.Objects) {
      const r = Ye.Objects.Material;
      for (const n in r) {
        const s = this.parseMaterial(r[n], e);
        s !== null && t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const r = e.id, n = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !Tt.has(r))
      return null;
    const o = this.parseParameters(e, t, r);
    let i;
    switch (s.toLowerCase()) {
      case "phong":
        i = new ha();
        break;
      case "lambert":
        i = new vm();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), i = new ha();
        break;
    }
    return i.setValues(o), i.name = n, i;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, r) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new Ve().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new Ve().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new Ve().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new Ve().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new Ve().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new Ve().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return Tt.get(r).children.forEach(function(o) {
      const i = o.relationship;
      switch (i) {
        case "Bump":
          n.bumpMap = s.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = s.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = s.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = vn);
          break;
        case "DisplacementColor":
          n.displacementMap = s.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = s.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = vn);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = s.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = s.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = Im, n.envMap.colorSpace = vn);
          break;
        case "SpecularColor":
          n.specularMap = s.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = vn);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = s.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", i);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ye.Objects && t in Ye.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Tt.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ye.Objects) {
      const r = Ye.Objects.Deformer;
      for (const n in r) {
        const s = r[n], o = Tt.get(parseInt(n));
        if (s.attrType === "Skin") {
          const i = this.parseSkeleton(o, r);
          i.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), i.geometryID = o.parents[0].ID, e[n] = i;
        } else if (s.attrType === "BlendShape") {
          const i = {
            id: n
          };
          i.rawTargets = this.parseMorphTargets(o, r), i.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = i;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const r = [];
    return e.children.forEach(function(n) {
      const s = t[n.ID];
      if (s.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new Ge().fromArray(s.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), r.push(o);
    }), {
      rawBones: r,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const r = [];
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n], o = t[s.ID], i = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      i.geoID = Tt.get(parseInt(s.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, r.push(i);
    }
    return r;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, r) {
    mn = new io();
    const n = this.parseModels(e.skeletons, t, r), s = Ye.Objects.Model, o = this;
    n.forEach(function(a) {
      const l = s[a.ID];
      o.setLookAtProperties(a, l), Tt.get(a.ID).parents.forEach(function(h) {
        const d = n.get(h.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && mn.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), mn.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const l = L1(a.userData.transformData);
        a.applyMatrix4(l), a.updateWorldMatrix();
      }
    });
    const i = new fA().parse();
    mn.children.length === 1 && mn.children[0].isGroup && (mn.children[0].animations = i, mn = mn.children[0]), mn.animations = i;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, r) {
    const n = /* @__PURE__ */ new Map(), s = Ye.Objects.Model;
    for (const o in s) {
      const i = parseInt(o), a = s[o], l = Tt.get(i);
      let u = this.buildSkeleton(l, e, i, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(l);
            break;
          case "Light":
            u = this.createLight(l);
            break;
          case "Mesh":
            u = this.createMesh(l, t, r);
            break;
          case "NurbsCurve":
            u = this.createCurve(l, t);
            break;
          case "LimbNode":
          case "Root":
            u = new Pl();
            break;
          case "Null":
          default:
            u = new io();
            break;
        }
        u.name = a.attrName ? Qo.sanitizeNodeName(a.attrName) : "", u.userData.originalName = a.attrName, u.ID = i;
      }
      this.getTransformData(u, a), n.set(i, u);
    }
    return n;
  }
  buildSkeleton(e, t, r, n) {
    let s = null;
    return e.parents.forEach(function(o) {
      for (const i in t) {
        const a = t[i];
        a.rawBones.forEach(function(l, u) {
          if (l.ID === o.ID) {
            const h = s;
            s = new Pl(), s.matrixWorld.copy(l.transformLink), s.name = n ? Qo.sanitizeNodeName(n) : "", s.userData.originalName = n, s.ID = r, a.bones[u] = s, h !== null && s.add(h);
          }
        });
      }
    }), s;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ye.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new En();
    else {
      let n = 0;
      r.CameraProjectionType !== void 0 && r.CameraProjectionType.value === 1 && (n = 1);
      let s = 1;
      r.NearPlane !== void 0 && (s = r.NearPlane.value / 1e3);
      let o = 1e3;
      r.FarPlane !== void 0 && (o = r.FarPlane.value / 1e3);
      let i = window.innerWidth, a = window.innerHeight;
      r.AspectWidth !== void 0 && r.AspectHeight !== void 0 && (i = r.AspectWidth.value, a = r.AspectHeight.value);
      const l = i / a;
      let u = 45;
      r.FieldOfView !== void 0 && (u = r.FieldOfView.value);
      const h = r.FocalLength ? r.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new br(u, l, s, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new Xa(-i / 2, i / 2, a / 2, -a / 2, s, o);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new En();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ye.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new En();
    else {
      let n;
      r.LightType === void 0 ? n = 0 : n = r.LightType.value;
      let s = 16777215;
      r.Color !== void 0 && (s = new Ve().fromArray(r.Color.value).convertSRGBToLinear());
      let o = r.Intensity === void 0 ? 1 : r.Intensity.value / 100;
      r.CastLightOnObject !== void 0 && r.CastLightOnObject.value === 0 && (o = 0);
      let i = 0;
      r.FarAttenuationEnd !== void 0 && (r.EnableFarAttenuation !== void 0 && r.EnableFarAttenuation.value === 0 ? i = 0 : i = r.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new Zo(s, o, i, a);
          break;
        case 1:
          t = new pi(s, o);
          break;
        case 2:
          let l = Math.PI / 3;
          r.InnerAngle !== void 0 && (l = Zt.degToRad(r.InnerAngle.value));
          let u = 0;
          r.OuterAngle !== void 0 && (u = Zt.degToRad(r.OuterAngle.value), u = Math.max(u, 1)), t = new mi(s, o, i, l, u, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), t = new Zo(s, o);
          break;
      }
      r.CastShadows !== void 0 && r.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, r) {
    let n, s = null, o = null;
    const i = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (s = t.get(a.ID)), r.has(a.ID) && i.push(r.get(a.ID));
    }), i.length > 1 ? o = i : i.length > 0 ? o = i[0] : (o = new ha({
      name: xr.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), i.push(o)), "color" in s.attributes && i.forEach(function(a) {
      a.vertexColors = !0;
    }), s.FBX_Deformer ? (n = new Mm(s, o), n.normalizeSkinWeights()) : n = new qt(s, o), n;
  }
  createCurve(e, t) {
    const r = e.children.reduce(function(s, o) {
      return t.has(o.ID) && (s = t.get(o.ID)), s;
    }, null), n = new vu({
      name: xr.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Am(r, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const r = {};
    "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? r.eulerOrder = O1(t.RotationOrder.value) : r.eulerOrder = "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Tt.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const s = Ye.Objects.Model[n.ID];
        if ("Lcl_Translation" in s) {
          const o = s.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), mn.add(e.target)) : e.lookAt(new ye().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, r) {
    const n = this.parsePoseNodes();
    for (const s in e) {
      const o = e[s];
      Tt.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const l = a.ID;
          Tt.get(l).parents.forEach(function(h) {
            r.has(h.ID) && r.get(h.ID).bind(new wu(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ye.Objects) {
      const t = Ye.Objects.Pose;
      for (const r in t)
        if (t[r].attrType === "BindPose" && t[r].NbPoseNodes > 0) {
          const n = t[r].PoseNode;
          Array.isArray(n) ? n.forEach(function(s) {
            e[s.Node] = new Ge().fromArray(s.Matrix.a);
          }) : e[n.Node] = new Ge().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ye && "AmbientColor" in Ye.GlobalSettings) {
      const e = Ye.GlobalSettings.AmbientColor.value, t = e[0], r = e[1], n = e[2];
      if (t !== 0 || r !== 0 || n !== 0) {
        const s = new Ve(t, r, n).convertSRGBToLinear();
        mn.add(new yu(s, 1));
      }
    }
  }
}
class dA {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ye.Objects) {
      const r = Ye.Objects.Geometry;
      for (const n in r) {
        const s = Tt.get(parseInt(n)), o = this.parseGeometry(s, r[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, r) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, r);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, r) {
    const n = r.skeletons, s = [], o = e.parents.map(function(h) {
      return Ye.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const i = e.children.reduce(function(h, d) {
      return n[d.ID] !== void 0 && (h = n[d.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      r.morphTargets[h.ID] !== void 0 && s.push(r.morphTargets[h.ID]);
    });
    const a = o[0], l = {};
    "RotationOrder" in a && (l.eulerOrder = O1(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
    const u = L1(l);
    return this.genGeometry(t, i, s, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, r, n) {
    const s = new Kn();
    e.attrName && (s.name = e.attrName);
    const o = this.parseGeoNode(e, t), i = this.genBuffers(o), a = new yn(i.vertex, 3);
    if (a.applyMatrix4(n), s.setAttribute("position", a), i.colors.length > 0 && s.setAttribute("color", new yn(i.colors, 3)), t && (s.setAttribute("skinIndex", new Kx(i.weightsIndices, 4)), s.setAttribute("skinWeight", new yn(i.vertexWeights, 4)), s.FBX_Deformer = t), i.normal.length > 0) {
      const l = new ws().getNormalMatrix(n), u = new yn(i.normal, 3);
      u.applyNormalMatrix(l), s.setAttribute("normal", u);
    }
    if (i.uvs.forEach(function(l, u) {
      const h = u === 0 ? "uv" : `uv${u}`;
      s.setAttribute(h, new yn(i.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let l = i.materialIndex[0], u = 0;
      if (i.materialIndex.forEach(function(h, d) {
        h !== l && (s.addGroup(u, d - u, l), l = h, u = d);
      }), s.groups.length > 0) {
        const h = s.groups[s.groups.length - 1], d = h.start + h.count;
        d !== i.materialIndex.length && s.addGroup(d, i.materialIndex.length - d, l);
      }
      s.groups.length === 0 && s.addGroup(0, i.materialIndex.length, i.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, r, n), s;
  }
  parseGeoNode(e, t) {
    const r = {};
    if (r.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], r.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      r.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && r.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return r.weightTable = {}, t !== null && (r.skeleton = t, t.rawBones.forEach(function(n, s) {
      n.indices.forEach(function(o, i) {
        r.weightTable[o] === void 0 && (r.weightTable[o] = []), r.weightTable[o].push({
          id: s,
          weight: n.weights[i]
        });
      });
    })), r;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let r = 0, n = 0, s = !1, o = [], i = [], a = [], l = [], u = [], h = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, p) {
      let m, g = !1;
      f < 0 && (f = f ^ -1, g = !0);
      let b = [], v = [];
      if (o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = qi(p, r, f, e.color);
        a.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          v.push(y.weight), b.push(y.id);
        }), v.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const y = [0, 0, 0, 0], x = [0, 0, 0, 0];
          v.forEach(function(N, w) {
            let T = N, _ = b[w];
            x.forEach(function(F, A, D) {
              if (T > F) {
                D[A] = T, T = F;
                const S = y[A];
                y[A] = _, _ = S;
              }
            });
          }), b = y, v = x;
        }
        for (; v.length < 4; )
          v.push(0), b.push(0);
        for (let y = 0; y < 4; ++y)
          u.push(v[y]), h.push(b[y]);
      }
      if (e.normal) {
        const y = qi(p, r, f, e.normal);
        i.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = qi(p, r, f, e.material)[0], m < 0 && (d.negativeMaterialIndices = !0, m = 0)), e.uv && e.uv.forEach(function(y, x) {
        const N = qi(p, r, f, y);
        l[x] === void 0 && (l[x] = []), l[x].push(N[0]), l[x].push(N[1]);
      }), n++, g && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, o, m, i, a, l, u, h, n), r++, n = 0, o = [], i = [], a = [], l = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, r, n, s, o, i, a, l, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[r[h * 3]]), e.vertex.push(t.vertexPositions[r[h * 3 + 1]]), e.vertex.push(t.vertexPositions[r[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[(h - 1) * 4]), e.weightsIndices.push(l[(h - 1) * 4 + 1]), e.weightsIndices.push(l[(h - 1) * 4 + 2]), e.weightsIndices.push(l[(h - 1) * 4 + 3]), e.weightsIndices.push(l[h * 4]), e.weightsIndices.push(l[h * 4 + 1]), e.weightsIndices.push(l[h * 4 + 2]), e.weightsIndices.push(l[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(i[f][0]), e.uvs[f].push(i[f][1]), e.uvs[f].push(i[f][(h - 1) * 2]), e.uvs[f].push(i[f][(h - 1) * 2 + 1]), e.uvs[f].push(i[f][h * 2]), e.uvs[f].push(i[f][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, r, n) {
    if (r.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    r.forEach(function(o) {
      o.rawTargets.forEach(function(i) {
        const a = Ye.Objects.Geometry[i.geoID];
        a !== void 0 && s.genMorphGeometry(e, t, a, n, i.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, r, n, s) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], i = r.Vertices !== void 0 ? r.Vertices.a : [], a = r.Indexes !== void 0 ? r.Indexes.a : [], l = e.attributes.position.count * 3, u = new Float32Array(l);
    for (let p = 0; p < a.length; p++) {
      const m = a[p] * 3;
      u[m] = i[p * 3], u[m + 1] = i[p * 3 + 1], u[m + 2] = i[p * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, d = this.genBuffers(h), f = new yn(d.vertex, 3);
    f.name = s || r.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Normals.a;
    let s = [];
    return r === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.UV.a;
    let s = [];
    return r === "IndexToDirect" && (s = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Colors.a;
    let s = [];
    r === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let o = 0, i = new Ve(); o < n.length; o += 4)
      i.fromArray(n, o).convertSRGBToLinear().toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: r
      };
    const n = e.Materials.a, s = [];
    for (let o = 0; o < n.length; ++o)
      s.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Kn();
    const r = t - 1, n = e.KnotVector.a, s = [], o = e.Points.a;
    for (let h = 0, d = o.length; h < d; h += 4)
      s.push(new pt().fromArray(o, h));
    let i, a;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      i = r, a = n.length - 1 - i;
      for (let h = 0; h < r; ++h)
        s.push(s[h]);
    }
    const u = new lA(r, n, s, i, a).getPoints(s.length * 12);
    return new Kn().setFromPoints(u);
  }
}
class fA {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const r in t) {
        const n = t[r], s = this.addClip(n);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (Ye.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ye.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const r in e) {
      const n = e[r];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(s.id, s);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ye.Objects.AnimationCurve;
    for (const r in t) {
      const n = {
        id: t[r].id,
        times: t[r].KeyTime.a.map(vA),
        values: t[r].KeyValueFloat.a
      }, s = Tt.get(n.id);
      if (s !== void 0) {
        const o = s.parents[0].ID, i = s.parents[0].relationship;
        i.match(/X/) ? e.get(o).curves.x = n : i.match(/Y/) ? e.get(o).curves.y = n : i.match(/Z/) ? e.get(o).curves.z = n : i.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ye.Objects.AnimationLayer, r = /* @__PURE__ */ new Map();
    for (const n in t) {
      const s = [], o = Tt.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, l) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (s[l] === void 0) {
              const h = Tt.get(a.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const d = Ye.Objects.Model[h.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const f = {
                  modelName: d.attrName ? Qo.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                mn.traverse(function(p) {
                  p.ID === d.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new Ge()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), s[l] = f;
              }
            }
            s[l] && (s[l][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const h = Tt.get(a.ID).parents.filter(function(b) {
                return b.relationship !== void 0;
              })[0].ID, d = Tt.get(h).parents[0].ID, f = Tt.get(d).parents[0].ID, p = Tt.get(f).parents[0].ID, m = Ye.Objects.Model[p], g = {
                modelName: m.attrName ? Qo.sanitizeNodeName(m.attrName) : "",
                morphName: Ye.Objects.Deformer[h].attrName
              };
              s[l] = g;
            }
            s[l][u.attr] = u;
          }
        }
      }), r.set(parseInt(n), s));
    }
    return r;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ye.Objects.AnimationStack, r = {};
    for (const n in t) {
      const s = Tt.get(parseInt(n)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(s[0].ID);
      r[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return r;
  }
  addClip(e) {
    let t = [];
    const r = this;
    return e.layer.forEach(function(n) {
      t = t.concat(r.generateTracks(n));
    }), new Tu(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let r = new ye(), n = new fr(), s = new ye();
    if (e.transform && e.transform.decompose(r, n, s), r = r.toArray(), n = new Ss().setFromQuaternion(n, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, r, n) {
    const s = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(s, t, r);
    return new Ul(e + "." + n, s, o);
  }
  generateRotationTrack(e, t, r, n, s, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Zt.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Zt.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Zt.degToRad));
    const i = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(i, t, r);
    n !== void 0 && (n = n.map(Zt.degToRad), n.push(o), n = new Ss().fromArray(n), n = new fr().setFromEuler(n)), s !== void 0 && (s = s.map(Zt.degToRad), s.push(o), s = new Ss().fromArray(s), s = new fr().setFromEuler(s).invert());
    const l = new fr(), u = new Ss(), h = [];
    for (let d = 0; d < a.length; d += 3)
      u.set(a[d], a[d + 1], a[d + 2], o), l.setFromEuler(u), n !== void 0 && l.premultiply(n), s !== void 0 && l.multiply(s), l.toArray(h, d / 3 * 4);
    return new zl(e + ".quaternion", i, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, r = t.values.map(function(s) {
      return s / 100;
    }), n = mn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Dl(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, r);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(r, n) {
      return r - n;
    }), t.length > 1) {
      let r = 1, n = t[0];
      for (let s = 1; s < t.length; s++) {
        const o = t[s];
        o !== n && (t[r] = o, n = o, r++);
      }
      t = t.slice(0, r);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, r) {
    const n = r, s = [];
    let o = -1, i = -1, a = -1;
    return e.forEach(function(l) {
      if (t.x && (o = t.x.times.indexOf(l)), t.y && (i = t.y.times.indexOf(l)), t.z && (a = t.z.times.indexOf(l)), o !== -1) {
        const u = t.x.values[o];
        s.push(u), n[0] = u;
      } else
        s.push(n[0]);
      if (i !== -1) {
        const u = t.y.values[i];
        s.push(u), n[1] = u;
      } else
        s.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        s.push(u), n[2] = u;
      } else
        s.push(n[2]);
    }), s;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const r = e.values[t - 1], n = e.values[t] - r, s = Math.abs(n);
      if (s >= 180) {
        const o = s / 180, i = n / o;
        let a = r + i;
        const l = e.times[t - 1], h = (e.times[t] - l) / o;
        let d = l + h;
        const f = [], p = [];
        for (; d < e.times[t]; )
          f.push(d), d += h, p.push(a), a += i;
        e.times = Pp(e.times, t, f), e.values = Pp(e.values, t, p);
      }
    }
  }
}
class pA {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new F1(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, r = e.split(/[\r\n]+/);
    return r.forEach(function(n, s) {
      const o = n.match(/^[\s\t]*;/), i = n.match(/^[\s\t]*$/);
      if (o || i)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : l ? t.parseNodeProperty(n, l, r[++s]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const r = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: r }, o = this.parseNodeAttr(n), i = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(r, s) : r in i ? (r === "PoseNode" ? i.PoseNode.push(s) : i[r].id !== void 0 && (i[r] = {}, i[r][i[r].id] = i[r]), o.id !== "" && (i[r][o.id] = s)) : typeof o.id == "number" ? (i[r] = {}, i[r][o.id] = s) : r !== "Properties70" && (r === "PoseNode" ? i[r] = [s] : i[r] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let r = "", n = "";
    return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: r, type: n };
  }
  parseNodeProperty(e, t, r) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, s);
      return;
    }
    if (n === "C") {
      const a = s.split(",").slice(1), l = parseInt(a[0]), u = parseInt(a[1]);
      let h = s.split(",").slice(3);
      h = h.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", s = [l, u], bA(s, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = s), n in o && Array.isArray(o[n]) ? o[n].push(s) : n !== "a" ? o[n] = s : o.a = s, this.setCurrentProp(o, n), n === "a" && s.slice(-1) !== "," && (o.a = vl(s));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = vl(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, r) {
    const n = r.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = n[0], o = n[1], i = n[2], a = n[3];
    let l = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        l = parseFloat(l);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        l = vl(l);
        break;
    }
    this.getPrevNode()[s] = {
      type: o,
      type2: i,
      flag: a,
      value: l
    }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class mA {
  parse(e) {
    const t = new Op(e);
    t.skip(23);
    const r = t.getUint32();
    if (r < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
    const n = new F1();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, r);
      s !== null && n.add(s.name, s);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const r = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), i = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let d = 0; d < s; d++)
      a.push(this.parseProperty(e));
    const l = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (r.singleProperty = s === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(i, r, d);
    }
    return r.propertyList = a, typeof l == "number" && (r.id = l), u !== "" && (r.attrName = u), h !== "" && (r.attrType = h), i !== "" && (r.name = i), r;
  }
  parseSubNode(e, t, r) {
    if (r.singleProperty === !0) {
      const n = r.propertyList[0];
      Array.isArray(n) ? (t[r.name] = r, r.a = n) : t[r.name] = n;
    } else if (e === "Connections" && r.name === "C") {
      const n = [];
      r.propertyList.forEach(function(s, o) {
        o !== 0 && n.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (r.name === "Properties70")
      Object.keys(r).forEach(function(s) {
        t[s] = r[s];
      });
    else if (e === "Properties70" && r.name === "P") {
      let n = r.propertyList[0], s = r.propertyList[1];
      const o = r.propertyList[2], i = r.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? a = [
        r.propertyList[4],
        r.propertyList[5],
        r.propertyList[6]
      ] : a = r.propertyList[4], t[n] = {
        type: s,
        type2: o,
        flag: i,
        value: a
      };
    } else
      t[r.name] === void 0 ? typeof r.id == "number" ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : r.name === "PoseNode" ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : t[r.name][r.id] === void 0 && (t[r.name][r.id] = r);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let r;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return r = e.getUint32(), e.getArrayBuffer(r);
      case "S":
        return r = e.getUint32(), e.getString(r);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), s = e.getUint32(), o = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const i = QM(new Uint8Array(e.getArrayBuffer(o))), a = new Op(i.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class Op {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let r = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = r.indexOf(0);
    return n >= 0 && (r = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(r);
  }
}
class F1 {
  add(e, t) {
    this[e] = t;
  }
}
function gA(c) {
  const e = "Kaydara FBX Binary  \0";
  return c.byteLength >= e.length && e === I1(c, 0, e.length);
}
function yA(c) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function r(n) {
    const s = c[n - 1];
    return c = c.slice(t + n), t++, s;
  }
  for (let n = 0; n < e.length; ++n)
    if (r(1) === e[n])
      return !1;
  return !0;
}
function Ip(c) {
  const e = /FBXVersion: (\d+)/, t = c.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function vA(c) {
  return c / 46186158e3;
}
const xA = [];
function qi(c, e, t, r) {
  let n;
  switch (r.mappingType) {
    case "ByPolygonVertex":
      n = c;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = r.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
  }
  r.referenceType === "IndexToDirect" && (n = r.indices[n]);
  const s = n * r.dataSize, o = s + r.dataSize;
  return NA(xA, r.buffer, s, o);
}
const yl = new Ss(), Pr = new ye();
function L1(c) {
  const e = new Ge(), t = new Ge(), r = new Ge(), n = new Ge(), s = new Ge(), o = new Ge(), i = new Ge(), a = new Ge(), l = new Ge(), u = new Ge(), h = new Ge(), d = new Ge(), f = c.inheritType ? c.inheritType : 0;
  if (c.translation && e.setPosition(Pr.fromArray(c.translation)), c.preRotation) {
    const A = c.preRotation.map(Zt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), t.makeRotationFromEuler(yl.fromArray(A));
  }
  if (c.rotation) {
    const A = c.rotation.map(Zt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), r.makeRotationFromEuler(yl.fromArray(A));
  }
  if (c.postRotation) {
    const A = c.postRotation.map(Zt.degToRad);
    A.push(c.eulerOrder || Ss.DEFAULT_ORDER), n.makeRotationFromEuler(yl.fromArray(A)), n.invert();
  }
  c.scale && s.scale(Pr.fromArray(c.scale)), c.scalingOffset && i.setPosition(Pr.fromArray(c.scalingOffset)), c.scalingPivot && o.setPosition(Pr.fromArray(c.scalingPivot)), c.rotationOffset && a.setPosition(Pr.fromArray(c.rotationOffset)), c.rotationPivot && l.setPosition(Pr.fromArray(c.rotationPivot)), c.parentMatrixWorld && (h.copy(c.parentMatrix), u.copy(c.parentMatrixWorld));
  const p = t.clone().multiply(r).multiply(n), m = new Ge();
  m.extractRotation(u);
  const g = new Ge();
  g.copyPosition(u);
  const b = g.clone().invert().multiply(u), v = m.clone().invert().multiply(b), y = s, x = new Ge();
  if (f === 0)
    x.copy(m).multiply(p).multiply(v).multiply(y);
  else if (f === 1)
    x.copy(m).multiply(v).multiply(p).multiply(y);
  else {
    const D = new Ge().scale(new ye().setFromMatrixScale(h)).clone().invert(), S = v.clone().multiply(D);
    x.copy(m).multiply(p).multiply(S).multiply(y);
  }
  const N = l.clone().invert(), w = o.clone().invert();
  let T = e.clone().multiply(a).multiply(l).multiply(t).multiply(r).multiply(n).multiply(N).multiply(i).multiply(o).multiply(s).multiply(w);
  const _ = new Ge().copyPosition(T), F = u.clone().multiply(_);
  return d.copyPosition(F), T = d.clone().multiply(x), T.premultiply(u.invert()), T;
}
function O1(c) {
  c = c || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return c === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[c];
}
function vl(c) {
  return c.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function I1(c, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = c.byteLength), new TextDecoder().decode(new Uint8Array(c, e, t));
}
function bA(c, e) {
  for (let t = 0, r = c.length, n = e.length; t < n; t++, r++)
    c[r] = e[t];
}
function NA(c, e, t, r) {
  for (let n = t, s = 0; n < r; n++, s++)
    c[s] = e[n];
  return c;
}
function Pp(c, e, t) {
  return c.slice(0, e).concat(t).concat(c.slice(e));
}
const P1 = new kM();
P1.setDecoderPath("/draco/");
class Hd extends Nn {
  constructor(t, r, n = 0, s = 0) {
    super(t || new $a(0.1), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isModel3D", !0);
    G(this, "_model", "");
    G(this, "_modelRoot", null);
    G(this, "_modeMatrix");
    G(this, "_object");
    G(this, "_isLoading", !1);
    G(this, "_castShadowModel", !1);
    G(this, "_receiveShadowModel", !1);
    G(this, "_objectOrgSize", new ye());
    this.type = "Model3D", this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this.onBeforeRender = () => {
      (this._castShadowModel !== this.castShadow || this._receiveShadowModel !== this.receiveShadow) && this.updateModelShadow();
    }, this.geometry.boundingBox || this.geometry.computeBoundingBox();
  }
  get model() {
    return this._model;
  }
  set model(t) {
    this._model !== t && (this._object && this._object.removeFromParent(), this._model && (this._modeMatrix = void 0), this._model = t, this.loadModel());
  }
  async loadModel() {
    if (this._object && (this._object.removeFromParent(), this._object = void 0), !this._model)
      return;
    this._isLoading = !0;
    let t;
    if (/.glb$/i.test(this._model))
      t = new Wd(), t.setDRACOLoader(P1);
    else if (/.fbx$/i.test(this._model))
      t = new uA();
    else
      throw Be.panic(`Model[${this._model}] is not supported!`);
    const r = await t.loadAsync(this._model);
    r instanceof io ? this._object = r : this._object = r.scene, this._modelRoot = r, this._object.__isHidden = !0, this._isLoading = !1, this.material.visible = !1, this.add(this._object), this.objectAutoSize(), this.updateModelShadow();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.resizeObject();
  }
  resizeObject() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0);
    const r = this.geometry.boundingBox.getSize(new ye()).divide(this._objectOrgSize), n = Math.min(r.x, r.y, r.z);
    this._object.scale.set(n, n, n);
  }
  objectAutoSize() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    if (this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0), this._modeMatrix)
      return this._object.applyMatrix4(this._modeMatrix);
    const t = this.geometry.boundingBox.getSize(new ye()).multiply(this.scale), r = this.getWorldPosition(new ye()), n = new sr().setFromObject(this._object, !0), s = n.getCenter(new ye()), o = n.getSize(this._objectOrgSize), i = t.divide(o), a = Math.min(i.x, i.y, i.z);
    this._object.position.copy(r.sub(s).multiply(i)), this._object.scale.set(a, a, a);
  }
  updateModelShadow() {
    this._object && (this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this._object.traverse((t) => {
      t.castShadow = this._castShadowModel, t.receiveShadow = this._receiveShadowModel;
    }));
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), r.geometry = s(t.geometries, this.geometry), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        o !== this._object && r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    super.serialize(t), t.model = this._model, t.objectOrgSize = this._objectOrgSize.toArray(), this._object && (t.modeMatrix = this._object.matrix.toArray());
  }
  deserialize(t) {
    super.deserialize(t), t.objectOrgSize && this._objectOrgSize.fromArray(t.objectOrgSize), t.modeMatrix && (this._modeMatrix = new Ge().fromArray(t.modeMatrix), this._object && this._object.applyMatrix4(this._modeMatrix)), this.model = t.model;
  }
}
Je("Model3D", {
  create: ({ material: c, geometry: e } = {}) => new Hd(e, c),
  members: {
    model: "String"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class wA extends Hd {
  constructor(e, t, r = 0, n = 0) {
    super(e || new Wa(1, 1, 1), t, r, n), this.type = "StaticMesh";
  }
  rebuildBody() {
    if (!this._object)
      return;
    const e = this.world;
    if (this.physicalBody && (this.world && this.world.removeMesh(this), qs.destroyBody(this.physicalBody)), this._bodyType !== Nc.Ghost) {
      const t = qs.createShape(this._object);
      this.physicalBody = qs.createBody(this, this._mass, t), this.physicalBody.setUserIndex(this.id), e && e.addMesh(this, this.physicalBody);
    } else
      this.physicalBody = null;
  }
}
Je("StaticMesh", {
  create: ({ material: c, geometry: e } = {}) => new wA(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    model: "String"
  },
  proto: "Entity",
  group: "Objects.Static Mesh",
  icon: "mesh"
});
class TA extends Hd {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Nm(), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isCharacter", !0);
    G(this, "actions", {});
    G(this, "_mixer");
    G(this, "_clips", []);
    G(this, "_objectOrgSize", new ye());
    this.type = "Character";
  }
  async loadModel() {
    if (await super.loadModel(), !this._object || !this._modelRoot)
      return;
    const t = this._object.getObjectByProperty("isMesh", !0);
    t && (t.onBeforeRender = () => {
      this._mixer && this._mixer.update(sn.delta);
    }), this._mixer = new Zx(this._object), this._mixer.addEventListener("finished", ({ action: r }) => {
      const n = Object.entries(this.actions).find((s) => s[1].action === r);
      n && (Be.notice(`action ${n[0]} finished!`), n[1].isPending = !1, n[1].resolve && (n[1].resolve(!0), n[1].resolve = void 0));
    }), this._clips = this._modelRoot.animations || [];
    for (const r of this._clips)
      this.actions[r.name] = { isPending: !1, action: this._mixer.clipAction(r), resolve: void 0 };
  }
  async act(t, r) {
    const n = this.actions[t];
    if (n) {
      if (n.isPending)
        return !0;
    } else
      return !1;
    n.isPending = !0;
    const s = n.action;
    return s.clampWhenFinished = !0, s.reset().setLoop(r ? Qx : eb, r ? 1 / 0 : 1).setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(1).play(), new Promise((o) => {
      n.resolve = o;
    });
  }
  stop(t) {
    const r = t ? [t] : Object.keys(this.actions);
    for (const n of r) {
      const s = this.actions[n];
      if (s) {
        if (!s.isPending)
          continue;
      } else
        continue;
      s.isPending = !1, s.resolve && (s.resolve(!1), s.resolve = void 0), s.action.stop();
    }
  }
}
Je("Character", {
  create: ({ material: c, geometry: e } = {}) => new TA(e, c),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Model3D",
  group: "Objects.Character",
  icon: "human"
});
const zt = new ye(), SA = new ye();
class _A extends Cm {
  constructor(t, r) {
    super(t || new Kn(), r);
    G(this, "isParticles", !0);
    G(this, "mass", 0);
    /** Resistance Coefficient */
    G(this, "airResCoe", 25e-4);
    G(this, "growSpeed", 1);
    G(this, "spaceSize", new ye(1, 1, 1));
    G(this, "bornSpaceSize", new ye(1, 1, 1));
    G(this, "bornPoint", new ye(0, 0, 0));
    G(this, "_count", 100);
    G(this, "_countFired", 0);
    G(this, "_positions", null);
    G(this, "_velocities", null);
    G(this, "_bornTime", 0);
    this.type = "Particles", this.rebuildBuffer(), this.onBeforeRender = () => {
      this.update();
    };
  }
  get count() {
    return this._count;
  }
  set count(t) {
    t <= 0 && (t = 100), this._count !== t && (this._count = t, this.rebuildBuffer());
  }
  rebuildBuffer() {
    this._countFired = 0, this.geometry.setDrawRange(0, 0);
    const t = new Float32Array(this._count * 3), r = new Float32Array(this._count * 3), n = new yn(t, 3), s = new yn(r, 3);
    n.setUsage(mu), this.geometry.setAttribute("position", n), this._positions = n, this._velocities = s;
  }
  update() {
    for (let t = 0; t < this._countFired; t++) {
      const r = this._positions.getX(t), n = this._positions.getY(t), s = this._positions.getZ(t);
      if (this.isOutofSpace(r, n, s))
        this._positions.setXYZ(t, ...this.randBornPoint()), this._velocities.setXYZ(t, 0, 0, 0);
      else {
        const [o, i] = sn.calcObjectPosition(
          zt.set(r, n, s),
          SA.set(this._velocities.getX(t), this._velocities.getY(t), this._velocities.getZ(t)),
          this.mass,
          this.airResCoe
        );
        this._positions.setXYZ(t, ...o.toArray()), this._velocities.setXYZ(t, ...i.toArray());
      }
    }
    this.grow(), this._positions.needsUpdate = !0;
  }
  grow() {
    if (this._countFired >= this._count)
      return;
    const t = this._bornTime === 0 ? 1 : (sn.now - this._bornTime) / 1e3;
    this._bornTime || (this._bornTime = sn.now);
    const r = Math.floor(t * this.growSpeed), n = Math.min(r, this._count) - this._countFired;
    if (n <= 0)
      return;
    const s = this._countFired;
    this._countFired += n;
    for (let o = s; o < this._countFired; o++)
      this._positions.setXYZ(o, ...this.randBornPoint()), this._velocities.setXYZ(o, 0, 0, 0);
    this.geometry.setDrawRange(0, this._countFired);
  }
  isOutofSpace(t, r, n) {
    return t > this.spaceSize.x || t < -this.spaceSize.x || r > this.spaceSize.y || r < -this.spaceSize.y || n > this.spaceSize.z || n < -this.spaceSize.z;
  }
  randBornPoint() {
    return zt.copy(this.bornPoint), zt.x += this.bornSpaceSize.x * (Math.random() - 0.5) * 2, zt.y += this.bornSpaceSize.y * (Math.random() - 0.5) * 2, zt.z += this.bornSpaceSize.z * (Math.random() - 0.5) * 2, zt.x > this.spaceSize.x ? zt.x = this.spaceSize.x - 1e-5 : zt.x < -this.spaceSize.x && (zt.x = -this.spaceSize.x + 1e-5), zt.y > this.spaceSize.y ? zt.y = this.spaceSize.y - 1e-5 : zt.y < -this.spaceSize.y && (zt.y = -this.spaceSize.y + 1e-5), zt.z > this.spaceSize.z ? zt.z = this.spaceSize.z - 1e-5 : zt.z < -this.spaceSize.z && (zt.z = -this.spaceSize.z + 1e-5), zt.toArray();
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    t.mass = this.mass, t.spaceSize = this.spaceSize.toArray(), t.bornSpaceSize = this.bornSpaceSize.toArray(), t.bornPoint = this.bornPoint.toArray(), t.count = this.count, t.growSpeed = this.growSpeed, t.airResCoe = this.airResCoe;
  }
  deserialize(t) {
    t.mass !== void 0 && (this.mass = t.mass), t.spaceSize && this.spaceSize.fromArray(t.spaceSize), t.bornSpaceSize && this.bornSpaceSize.fromArray(t.bornSpaceSize), t.bornPoint && this.bornPoint.fromArray(t.bornPoint), t.count > 0 && (this.count = t.count), t.growSpeed > 0 && (this.growSpeed = t.growSpeed), t.airResCoe !== void 0 && (this.airResCoe = t.airResCoe);
  }
}
Je("Particles", {
  members: {
    mass: "Number",
    airResCoe: "Number",
    count: "Number",
    spaceSize: "Vector3",
    bornPoint: "Vector3",
    bornSpaceSize: "Vector3",
    growSpeed: "Number"
  },
  proto: "Points",
  group: "Particles.Particles",
  icon: "box",
  create: () => new _A()
});
class Tc extends qt {
  constructor(e, t = {}) {
    super(e), this.isRefractor = !0, this.type = "Refractor", this.camera = new br();
    const r = this, n = t.color !== void 0 ? new Ve(t.color) : new Ve(8355711), s = t.textureWidth || 512, o = t.textureHeight || 512, i = t.clipBias || 0, a = t.shader || Tc.RefractorShader, l = t.multisample !== void 0 ? t.multisample : 4, u = this.camera;
    u.matrixAutoUpdate = !1, u.userData.refractor = !0;
    const h = new Bl(), d = new Ge(), f = new Su(s, o, { samples: l, type: Pm });
    this.material = new hs({
      uniforms: rr.clone(a.uniforms),
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      transparent: !0
      // ensures, refractors are drawn from farthest to closest
    }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = d;
    const p = function() {
      const y = new ye(), x = new ye(), N = new Ge(), w = new ye(), T = new ye();
      return function(F) {
        return y.setFromMatrixPosition(r.matrixWorld), x.setFromMatrixPosition(F.matrixWorld), w.subVectors(y, x), N.extractRotation(r.matrixWorld), T.set(0, 0, 1), T.applyMatrix4(N), w.dot(T) < 0;
      };
    }(), m = function() {
      const y = new ye(), x = new ye(), N = new fr(), w = new ye();
      return function() {
        r.matrixWorld.decompose(x, N, w), y.set(0, 0, 1).applyQuaternion(N).normalize(), y.negate(), h.setFromNormalAndCoplanarPoint(y, x);
      };
    }(), g = function() {
      const y = new Bl(), x = new pt(), N = new pt();
      return function(T) {
        u.matrixWorld.copy(T.matrixWorld), u.matrixWorldInverse.copy(u.matrixWorld).invert(), u.projectionMatrix.copy(T.projectionMatrix), u.far = T.far, y.copy(h), y.applyMatrix4(u.matrixWorldInverse), x.set(y.normal.x, y.normal.y, y.normal.z, y.constant);
        const _ = u.projectionMatrix;
        N.x = (Math.sign(x.x) + _.elements[8]) / _.elements[0], N.y = (Math.sign(x.y) + _.elements[9]) / _.elements[5], N.z = -1, N.w = (1 + _.elements[10]) / _.elements[14], x.multiplyScalar(2 / x.dot(N)), _.elements[2] = x.x, _.elements[6] = x.y, _.elements[10] = x.z + 1 - i, _.elements[14] = x.w;
      };
    }();
    function b(y) {
      d.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), d.multiply(y.projectionMatrix), d.multiply(y.matrixWorldInverse), d.multiply(r.matrixWorld);
    }
    function v(y, x, N) {
      r.visible = !1;
      const w = y.getRenderTarget(), T = y.xr.enabled, _ = y.shadowMap.autoUpdate;
      y.xr.enabled = !1, y.shadowMap.autoUpdate = !1, y.setRenderTarget(f), y.autoClear === !1 && y.clear(), y.render(x, u), y.xr.enabled = T, y.shadowMap.autoUpdate = _, y.setRenderTarget(w);
      const F = N.viewport;
      F !== void 0 && y.state.viewport(F), r.visible = !0;
    }
    this.onBeforeRender = function(y, x, N) {
      N.userData.refractor !== !0 && p(N) && (m(), b(N), g(N), v(y, x, N));
    }, this.getRenderTarget = function() {
      return f;
    }, this.dispose = function() {
      f.dispose(), r.material.dispose();
    };
  }
}
Tc.RefractorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Ji = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
class U1 extends qt {
  constructor(t, r) {
    super(t || new Sr(1, 1), r || new hs({
      name: Ji.name,
      uniforms: rr.clone(Ji.uniforms),
      fragmentShader: Ji.fragmentShader,
      vertexShader: Ji.vertexShader
    }));
    G(this, "isReflector", !0);
    G(this, "props", {
      color: new Ve(8355711),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      multisample: 4
    });
    G(this, "renderTarget");
    G(this, "camera", new br());
    this.type = "Reflector";
    const n = new Bl(), s = new ye(), o = new ye(), i = new ye(), a = new Ge(), l = new ye(0, 0, -1), u = new pt(), h = new ye(), d = new ye(), f = new pt(), p = new Ge(), m = this.camera;
    this.renderTarget = new Su(this.props.textureWidth, this.props.textureHeight, { samples: this.props.multisample, type: Pm }), r ? this.props.color = this.material.uniforms.color.value : this.material.uniforms.color.value = this.props.color, this.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.material.uniforms.textureMatrix.value = p, this.onBeforeRender = (g, b, v) => {
      if (o.setFromMatrixPosition(this.matrixWorld), i.setFromMatrixPosition(v.matrixWorld), a.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(a), h.subVectors(o, i), h.dot(s) > 0)
        return;
      h.reflect(s).negate(), h.add(o), a.extractRotation(v.matrixWorld), l.set(0, 0, -1), l.applyMatrix4(a), l.add(i), d.subVectors(o, l), d.reflect(s).negate(), d.add(o), m.position.copy(h), m.up.set(0, 1, 0), m.up.applyMatrix4(a), m.up.reflect(s), m.lookAt(d), m.far = v instanceof br ? v.far : 1e3, m.updateMatrixWorld(), m.projectionMatrix.copy(v.projectionMatrix), p.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), p.multiply(m.projectionMatrix), p.multiply(m.matrixWorldInverse), p.multiply(this.matrixWorld), n.setFromNormalAndCoplanarPoint(s, o), n.applyMatrix4(m.matrixWorldInverse), u.set(n.normal.x, n.normal.y, n.normal.z, n.constant);
      const y = m.projectionMatrix;
      f.x = (Math.sign(u.x) + y.elements[8]) / y.elements[0], f.y = (Math.sign(u.y) + y.elements[9]) / y.elements[5], f.z = -1, f.w = (1 + y.elements[10]) / y.elements[14], u.multiplyScalar(2 / u.dot(f)), y.elements[2] = u.x, y.elements[6] = u.y, y.elements[10] = u.z + 1 - this.props.clipBias, y.elements[14] = u.w, this.visible = !1;
      const x = g.getRenderTarget(), N = g.xr.enabled, w = g.shadowMap.autoUpdate;
      g.xr.enabled = !1, g.shadowMap.autoUpdate = !1, g.setRenderTarget(this.renderTarget), g.state.buffers.depth.setMask(!0), g.autoClear === !1 && g.clear(), g.render(b, m), g.xr.enabled = N, g.shadowMap.autoUpdate = w, g.setRenderTarget(x);
      const T = v.viewport;
      T !== void 0 && g.state.viewport(T), this.visible = !0;
    };
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t);
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  dispose() {
    this.renderTarget.dispose(), this.material.dispose();
  }
  clone(t) {
    const r = super.clone(t), n = tr(this.props);
    return nr(r.props, n), r;
  }
  serialize(t) {
    t.props = tr(this.props);
  }
  deserialize(t) {
    t.props && nr(this.props, t.props);
  }
}
Je("Reflector", {
  members: {
    castShadow: "Boolean",
    receiveShadow: "Boolean",
    color: "Color",
    textureWidth: "Number",
    textureHeight: "Number",
    clipBias: "Number"
  },
  proto: "Object3D",
  group: "Objects.Reflector",
  icon: "plane",
  create: ({ geometry: c, material: e } = {}) => new U1(c, e)
});
const xa = 0.15, Yi = xa * 0.5, so = class so extends Nn {
  constructor(t, r) {
    super(t || new Sr(10, 10), r || new hs({
      uniforms: rr.merge([
        oo.fog,
        so.WaterShader.uniforms
      ]),
      vertexShader: so.WaterShader.vertexShader,
      fragmentShader: so.WaterShader.fragmentShader,
      transparent: !0,
      fog: !0
    }), 0, 0);
    G(this, "isWaterPlane", !0);
    G(this, "props", {
      color: new Ve(),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      flowDirection: new wt(1, 0),
      flowSpeed: 0.03,
      reflectivity: 0.02,
      scale: 1
    });
    G(this, "textureMatrix", new Ge());
    G(this, "reflector");
    G(this, "refractor");
    G(this, "refractorClipBias");
    this.type = "WaterPlane", t || (this.rotation.x = -Math.PI / 2);
    const n = new U1(t);
    n.textureWidth = this.props.textureWidth, n.textureHeight = this.props.textureHeight, n.clipBias = this.props.clipBias;
    const s = new Tc(t, {
      textureWidth: this.props.textureWidth,
      textureHeight: this.props.textureHeight,
      clipBias: 0
    });
    if (this.refractorClipBias = s.camera.projectionMatrix.elements[10], n.matrixAutoUpdate = !1, s.matrixAutoUpdate = !1, this.reflector = n, this.refractor = s, r)
      this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.props.flowDirection = this.material.uniforms.flowDirection.value, this.props.color = this.material.uniforms.color.value, this.props.reflectivity = this.material.uniforms.reflectivity.value, this.textureMatrix = this.material.uniforms.textureMatrix.value, this.props.scale = this.material.uniforms.config.value.w;
    else {
      this.material.uniforms.flowDirection = {
        type: "v2",
        value: this.props.flowDirection
      };
      const o = new Vn(), i = new Vn();
      o.wrapS = o.wrapT = Zs, i.wrapS = i.wrapT = Zs, this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = o, this.material.uniforms.tNormalMap1.value = i, this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = Yi, this.material.uniforms.config.value.z = Yi, this.material.uniforms.config.value.w = this.props.scale;
    }
    this.onBeforeRender = function(o, i, a) {
      this.updateTextureMatrix(a), this.updateFlow(), this.visible = !1, n.matrixWorld.copy(this.matrixWorld), s.matrixWorld.copy(this.matrixWorld), n.onBeforeRender(o, i, a, null, null, null), s.onBeforeRender(o, i, a, null, null, null), this.visible = !0;
    };
  }
  get normalMap0() {
    return this.material.uniforms.tNormalMap0.value;
  }
  set normalMap0(t) {
    const r = this.material.uniforms.tNormalMap0.value;
    r !== t && (this.material.uniforms.tNormalMap0.value = t, r.dispose());
  }
  get normalMap1() {
    return this.material.uniforms.tNormalMap1.value;
  }
  set normalMap1(t) {
    const r = this.material.uniforms.tNormalMap1.value;
    r !== t && (this.material.uniforms.tNormalMap1.value = t, r.dispose());
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t, this.reflector.clipBias = t);
  }
  get flowDirection() {
    return this.props.flowDirection;
  }
  set flowDirection(t) {
    this.props.flowDirection !== t && (this.props.flowDirection = t, this.material.uniforms.flowDirection.value = t);
  }
  get flowSpeed() {
    return this.props.flowSpeed;
  }
  set flowSpeed(t) {
    this.props.flowSpeed !== t && (this.props.flowSpeed = t);
  }
  get reflectivity() {
    return this.props.reflectivity;
  }
  set reflectivity(t) {
    this.props.reflectivity !== t && (this.props.reflectivity = t, this.material.uniforms.reflectivity.value = this.props.reflectivity);
  }
  get waterScale() {
    return this.props.scale;
  }
  set waterScale(t) {
    this.props.scale !== t && (this.props.scale = t, this.material.uniforms.config.value.w = this.props.scale);
  }
  appleProps() {
    this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.flowDirection.value = this.props.flowDirection, this.material.uniforms.config.value.w = this.props.scale, this.reflector.textureWidth = this.props.textureWidth, this.reflector.textureHeight = this.props.textureHeight, this.reflector.clipBias = this.props.clipBias, this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight);
  }
  clone(t) {
    const r = super.clone(t), n = this.props[kt], s = tr(n), o = r.props[kt];
    return nr(o, s), o.appleProps(), r;
  }
  serialize(t) {
    super.serialize(t), t.props = tr(this.props);
  }
  deserialize(t) {
    super.deserialize(t), t.props && (nr(this.props, t.props), this.appleProps());
  }
  dispose() {
    this.reflector.dispose(), this.refractor.dispose();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.reflector.geometry = this.geometry, this.refractor.geometry = this.geometry;
  }
  updateTextureMatrix(t) {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(t.projectionMatrix), this.textureMatrix.multiply(t.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld);
  }
  updateFlow() {
    const t = this.material.uniforms.config;
    t.value.x += this.props.flowSpeed * sn.delta, t.value.y = t.value.x + Yi, t.value.x >= xa ? (t.value.x = 0, t.value.y = Yi) : t.value.y >= xa && (t.value.y = t.value.y - xa);
  }
};
G(so, "WaterShader", {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new pt()
    }
  },
  vertexShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_vertex>
      #include <logdepthbuf_pars_vertex>
  
      uniform mat4 textureMatrix;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        vUv = uv;
        vCoord = textureMatrix * vec4( position, 1.0 );
  
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vToEye = cameraPosition - worldPosition.xyz;
  
        vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
        gl_Position = projectionMatrix * mvPosition;
  
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
  
      }`
  ),
  fragmentShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_fragment>
      #include <logdepthbuf_pars_fragment>
  
      uniform sampler2D tReflectionMap;
      uniform sampler2D tRefractionMap;
      uniform sampler2D tNormalMap0;
      uniform sampler2D tNormalMap1;
  
      #ifdef USE_FLOWMAP
        uniform sampler2D tFlowMap;
      #else
        uniform vec2 flowDirection;
      #endif
  
      uniform vec3 color;
      uniform float reflectivity;
      uniform vec4 config;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        #include <logdepthbuf_fragment>
  
        float flowMapOffset0 = config.x;
        float flowMapOffset1 = config.y;
        float halfCycle = config.z;
        float scale = config.w;
  
        vec3 toEye = normalize( vToEye );
  
        // determine flow direction
        vec2 flow;
        #ifdef USE_FLOWMAP
          flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
        #else
          flow = flowDirection;
        #endif
        flow.x *= - 1.0;
  
        // sample normal maps (distort uvs with flowdata)
        vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
        vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );
  
        // linear interpolate to get the final normal color
        float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
        vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );
  
        // calculate normal vector
        vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
  
        // calculate the fresnel term to blend reflection and refraction maps
        float theta = max( dot( toEye, normal ), 0.0 );
        float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );
  
        // calculate final uv coords
        vec3 coord = vCoord.xyz / vCoord.w;
        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;
  
        vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
        vec4 refractColor = texture2D( tRefractionMap, uv );
  
        // multiply water color with the mix of both textures
        gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );
  
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
  
      }`
  )
});
let Up = so;
const xl = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new ye() },
    up: { value: new ye(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
}, MA = new En();
class AA extends qt {
  constructor(t, r) {
    super(t || new Wa(1, 1, 1), r || new hs({
      name: "SkyShader",
      fragmentShader: xl.fragmentShader,
      vertexShader: xl.vertexShader,
      uniforms: rr.clone(xl.uniforms),
      side: gu,
      depthWrite: !1
    }));
    G(this, "isSkyBox", !0);
    G(this, "_renderTarget");
    G(this, "_pmremGenerator");
    G(this, "_sceneTmp", new Ha());
    G(this, "_sceneRoot");
    G(this, "_sun");
    G(this, "_sunPosition");
    this.type = "SkyBox", t || this.scale.multiplyScalar(1e3), r || (this.material.uniforms.turbidity.value = 10, this.material.uniforms.rayleigh.value = 2, this.material.uniforms.mieCoefficient.value = 5e-3, this.material.uniforms.mieDirectionalG.value = 0.8, this.material.uniforms.sunPosition.value.copy(this.calSunPosition(2, 180))), this._sunPosition = this.material.uniforms.sunPosition.value, this.onBeforeRender = async (n, s, o) => {
      this._sceneRoot = s, this._sun && typeof this._sun == "string" && (this._sun = s.getObjectByProperty("uuid", this._sun)), this._renderTarget || (this._renderTarget = 1, this._pmremGenerator = new tb(n), this.updateRenderTarget()), this._sun && !this._sun.position.equals(this._sunPosition) && this.updateSunPotision();
    };
  }
  get turbidity() {
    return this.material.uniforms.turbidity.value;
  }
  set turbidity(t) {
    this.material.uniforms.turbidity.value = t;
  }
  get rayleigh() {
    return this.material.uniforms.rayleigh.value;
  }
  set rayleigh(t) {
    this.material.uniforms.rayleigh.value = t;
  }
  get mieCoefficient() {
    return this.material.uniforms.mieCoefficient.value;
  }
  set mieCoefficient(t) {
    this.material.uniforms.mieCoefficient.value = t;
  }
  get mieDirectionalG() {
    return this.material.uniforms.mieDirectionalG.value;
  }
  set mieDirectionalG(t) {
    this.material.uniforms.mieDirectionalG.value = t;
  }
  get sunPosition() {
    return this.material.uniforms.sunPosition.value;
  }
  set sunPosition(t) {
    this.material.uniforms.sunPosition.value.copy(t);
  }
  get sun() {
    return MA;
  }
  set sun(t) {
    t instanceof pi && (this._sun = t, this.updateSunPotision());
  }
  calSunPosition(t, r) {
    const n = Zt.degToRad(90 - t), s = Zt.degToRad(r), o = new ye();
    return o.setFromSphericalCoords(1, n, s), o;
  }
  updateSunPotision() {
    typeof this._sun == "object" && (this.material.uniforms.sunPosition.value.copy(this._sun.position), this.updateRenderTarget());
  }
  updateRenderTarget() {
    if (this._renderTarget !== void 0 && typeof this._renderTarget == "object" && this._renderTarget.dispose(), !this._pmremGenerator)
      return;
    const t = this.parent, r = t ? t.children.indexOf(this) : -1;
    t && t.children.splice(r, 1), this._sceneTmp.children.push(this), this._renderTarget = this._pmremGenerator.fromScene(this._sceneTmp), t && (r !== -1 ? t.children.splice(r, 0, this) : t.children.push(this)), this._sceneRoot && (this._sceneRoot.background = this._renderTarget.texture, this._sceneRoot.environment = this._renderTarget.texture);
  }
  serialize(t) {
    t.scale = this.scale.toArray(), t.turbidity = this.turbidity, t.rayleigh = this.rayleigh, t.mieCoefficient = this.mieCoefficient, t.mieDirectionalG = this.mieDirectionalG, t.sunPosition = this.sunPosition.toArray(), this._sun && (t.sun = this._sun.uuid || this._sun);
  }
  deserialize(t) {
    this.scale.fromArray(t.scale), this.turbidity = t.turbidity, this.rayleigh = t.rayleigh, this.mieCoefficient = t.mieCoefficient, this.mieDirectionalG = t.mieDirectionalG, this.sunPosition.fromArray(t.sunPosition), t.sun && (this._sun = t.sun), this.updateRenderTarget();
  }
}
Je(
  "SkyBox",
  {
    members: {
      scale: "Vector3",
      turbidity: "Number",
      rayleigh: "Number",
      mieCoefficient: "Number",
      mieDirectionalG: "Number",
      sun: "Object3D"
    },
    proto: "Object3D",
    group: "Objects.Sky Box",
    icon: "box",
    create: ({ geometry: c, material: e } = {}) => new AA(c, e)
  }
);
Kn.prototype.computeBoundsTree = mb;
Kn.prototype.disposeBoundsTree = gb;
qt.prototype.raycast = yb;
class nn extends Le {
  constructor(t, r, n) {
    super("void");
    G(this, "isObjectNode", !0);
    G(this, "typesExtended", { in: {}, out: {} });
    G(this, "isObject3DNode");
    G(this, "eventDispatcher", null);
    G(this, "_object", null);
    G(this, "_objectRaw", null);
    this._inst = t, this.objectType = r, n && (this.object = n), this.updateType = "none", this.isObject3DNode = li(r, "Object3D"), this.initTypes();
  }
  get object() {
    return this._object;
  }
  set object(t) {
    if (typeof t != "object" || !dS(t, this.objectType))
      throw Be.panic(`type is not compitable, expected type is ${this.objectType}!`);
    this._objectRaw = t, this._object = new Proxy(t, {
      get(r, n, s) {
        if (n === kt)
          return r;
        if (typeof n != "string")
          return Reflect.get(r, n, s);
        const o = n.split(".");
        if (o.length > 1) {
          let i = Reflect.get(r, o[0], s);
          for (let a = 1; a < o.length; a++)
            i = i[o[a]];
          return i;
        }
        return Reflect.get(r, n, s);
      },
      set: (r, n, s, o) => {
        if (typeof n != "string")
          return Reflect.set(r, n, s, o);
        if (Reflect.get(r, n, o) === s)
          return !0;
        let a = !0;
        const l = n.split(".");
        if (l.length > 1) {
          let u = Reflect.get(r, l[0], o);
          const h = l.pop();
          for (let d = 1; d < l.length; d++)
            u = u[l[d]];
          if (u[h] === s)
            return !0;
          u[h] = s;
        } else
          a = Reflect.set(r, n, s, r);
        if (this.eventDispatcher) {
          const u = !!this.typesExtended.in[n];
          this.eventDispatcher.dispatchEvent({ type: u ? "nodeEventInputChanged" : "nodeEventOutputChanged", source: null, node: this, fields: [n] });
        }
        return a;
      }
    }), (t instanceof En || t instanceof M.Material) && (this.objectType = t.type, this.initTypes()), Object.defineProperty(this, "_object", {
      writable: !1
    });
  }
  getObjectsExtended() {
    return { in: this.object, out: this.object };
  }
  fill(t, r) {
    this._object && typeof this._object == "string" && (this.object = r[this._object] || t.getObjectByProperty("uuid", this._object));
  }
  dispose() {
    this._object && this._object instanceof Vn && this._object.dispose();
  }
  toJSON(t) {
    const r = super.toJSON(t);
    if (this._object instanceof Vn) {
      const n = this._object.toJSON(t);
      t.textures[this._object.uuid] = n;
    }
    return r;
  }
  serialize(t) {
    if (!this._object)
      throw Be.panic("object has not been set before serialize!");
    super.serialize(t), t._inst = this._inst, t.object = this._object.uuid, t.objectType = this.objectType;
  }
  deserialize(t) {
    if (!li(t.objectType, this.objectType))
      throw Be.panic(`type is not compitable, expected type is ${this.objectType}!`);
    super.deserialize(t), this._object = t.object, this.initTypes();
  }
  createDefault(t) {
    if (this.isObject3DNode)
      this.object = t, this.objectType = t.type, this.initTypes();
    else {
      const r = M[this.objectType];
      if (!r)
        throw Be.panic(`class[${this.objectType}] not found in THREE!`);
      this.object = new r();
    }
  }
  initTypes() {
    const t = Ua(this.objectType);
    if (!t)
      throw Be.panic(`class[${this.objectType}] not found!`);
    _s(this.typesExtended.in), Object.assign(this.typesExtended.in, t.in), _s(this.typesExtended.out), Object.assign(this.typesExtended.out, t.out);
  }
}
Fs(
  "ObjectNode",
  nn,
  {
    // @ts-expect-error
    object: "Object3D | Texture"
  },
  "",
  {
    object3DRef: { clsName: "ObjectNode", func: () => new nn("object3DRef", "Object3D"), group: "Objects.Object", icon: "box" },
    texture: { clsName: "ObjectNode", func: () => new nn("texture", "Texture"), group: "Inputs.Primitives.Texture", icon: "photo" }
    // cubeTexture: { clsName: 'CubeTexture', func: () => new ObjectNode('cubeTexture', 'CubeTexture'), group: 'Inputs.Primitives.Cube Texture', icon: 'photo' },
  }
);
const D1 = {
  Boolean: {
    fromJson: (c) => new Boolean(c),
    toJson: (c) => c
  },
  Number: {
    fromJson: (c) => c ?? 0,
    toJson: (c) => c
  },
  String: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Url: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Script: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Color: {
    fromJson: (c) => new Ve().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector2: {
    fromJson: (c) => new wt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector3: {
    fromJson: (c) => new ye().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector4: {
    fromJson: (c) => new pt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Euler: {
    fromJson: (c) => new Ss().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  // uniformNode for gpu
  bool: {
    label: "bool UniformNode",
    fromJson: function(c) {
      const e = new nt(!1, "bool");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  float: {
    label: "float UniformNode",
    fromJson: function(c) {
      const e = new nt(0, "float");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  color: {
    label: "color UniformNode",
    fromJson: function(c) {
      const e = new nt(new Ve(), "color");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec2: {
    label: "vec2 UniformNode",
    fromJson: function(c) {
      const e = new nt(new wt());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec3: {
    label: "vec3 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ye());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec4: {
    label: "vec4 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ye());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  int: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "int");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ws());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  code: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  uint: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "uint");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  void: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  property: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  sampler: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  cubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  ivec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "ivec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "uvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "bvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "ivec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "uvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ye(), "bvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "ivec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "uvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "bvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ws(), "imat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ws(), "umat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ws(), "bmat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "imat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "umat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "bmat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix3: {
    label: void 0,
    fromJson: (c) => new ws(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix4: {
    label: void 0,
    fromJson: (c) => new Ge(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Audio: {
    label: void 0,
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Image: {
    label: void 0,
    fromJson: function(c) {
      const e = document.createElement("img");
      return c != null && c.src && (e.src = c.src), e;
    },
    toJson: function(c) {
      return { src: c.src };
    }
  },
  Texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  CubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Material: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Object3D: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  }
};
function Ki(c, e) {
  return D1[c].fromJson(e);
}
function Dp(c, e) {
  return D1[c].toJson(e);
}
const CA = globalThis.AsyncFunction || (async (c) => c).constructor;
class ui extends nn {
  constructor(t, r, n = !0) {
    super(t, "Object3D", r);
    G(this, "isScriptNode", !0);
    G(this, "inputs");
    G(this, "outputs");
    G(this, "enabled", !1);
    G(this, "_parametersProps", ["params", "out", "THREE", "TSL", "world", "window", "document"]);
    G(this, "_parameters", [null, null, M, t1, sn, null, null]);
    G(this, "_code", "");
    // eslint-disable-next-line @typescript-eslint/ban-types
    G(this, "_main");
    this.editable = n, this.inputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this.outputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventOutputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this._parameters[0] = this.inputs, this._parameters[1] = this.outputs, this._main = this.compile();
  }
  get code() {
    return this._code;
  }
  set code(t) {
    this._code = t;
    try {
      this._main = this.compile();
    } catch (r) {
      console.warn(r);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this._code && this.object && await this._main.call(this._objectRaw, ...this._parameters);
  }
  getObjectsExtended() {
    return { in: this.inputs, out: this.outputs };
  }
  initTypes() {
  }
  addInput(t, r) {
    if (this.typesExtended.in[t])
      return;
    this.typesExtended.in[t] = { types: [r], direct: "in", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = Ki(r);
    return this.inputs[t] = n, n;
  }
  removeInput(t) {
    return this.typesExtended.in[t] ? (delete this.typesExtended.in[t], delete this.inputs[t], !0) : !1;
  }
  addOutput(t, r) {
    if (this.typesExtended.out[t])
      return;
    this.typesExtended.out[t] = { types: [r], direct: "out", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = Ki(r);
    return this.outputs[t] = n, n;
  }
  removeOutput(t) {
    return this.typesExtended.out[t] ? (delete this.typesExtended.out[t], delete this.outputs[t], !0) : !1;
  }
  serialize(t) {
    var r;
    super.serialize(t), t.object = (r = this.object) == null ? void 0 : r.uuid, t.types = { ...this.typesExtended }, t.enabled = this.enabled, t.inputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.in))
      t.inputs[n] = Dp(s.types[0], this.inputs[n]);
    t.outputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.out))
      t.outputs[n] = Dp(s.types[0], this.outputs[n]);
    t.code = this._code;
  }
  deserialize(t) {
    var r, n;
    super.deserialize(t), (r = t.types) != null && r.in && (_s(this.typesExtended.in), Object.assign(this.typesExtended.in, t.types.in));
    for (const [s, o] of Object.entries(this.typesExtended.in)) {
      const i = t.inputs ? t.inputs[s] : void 0;
      this.inputs[s] = Ki(o.types[0], i);
    }
    (n = t.types) != null && n.out && (_s(this.typesExtended.out), Object.assign(this.typesExtended.out, t.types.out));
    for (const [s, o] of Object.entries(this.typesExtended.out)) {
      const i = t.outputs ? t.outputs[s] : void 0;
      this.outputs[s] = Ki(o.types[0], i);
    }
    t.code !== void 0 && (this.code = t.code), this.enabled = t.enabled;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new CA(this._parametersProps, this._code);
  }
}
Fs(
  "ScriptNode",
  ui,
  {
    enabled: "Boolean",
    code: "Script"
  },
  "ObjectNode"
);
class Dn extends ui {
  constructor() {
    super(...arguments);
    G(this, "isScriptBlockNode", !0);
    G(this, "_prev");
    G(this, "_next");
  }
  get prev() {
    return this._prev;
  }
  set prev(t) {
    this._prev = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this.object && (this._code ? await this._main.call(this._objectRaw, ...this._parameters) : !0) !== !1 && this._next && await this._next.exec(t);
  }
  fill(t, r) {
    super.fill(t, r), this.prev && typeof this.prev == "string" && (this.prev = r[this.prev]), this.next && typeof this.next == "string" && (this.next = r[this.next]);
  }
  serialize(t) {
    var r, n;
    super.serialize(t), t.prev = (r = this.prev) == null ? void 0 : r.uuid, t.next = (n = this.next) == null ? void 0 : n.uuid;
  }
  deserialize(t) {
    super.deserialize(t), this.prev = t.prev, this.next = t.next;
  }
}
Fs("ScriptBlockNode", Dn, {}, "ScriptNode", {
  scriptBlock: { clsName: "UpdateNode", func: () => new Dn("scriptBlock"), group: "Scripts.Script Block", icon: "brand-javascript" }
});
class Ur extends Dn {
  constructor(t, r, n, s) {
    super(t, n);
    G(this, "isEventListenerNode", !0);
    G(this, "_event", "onBorn");
    G(this, "_eventSource");
    G(this, "_listener");
    r && (this._event = r), this._eventSource = s || this.object;
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t, this._eventSource || (this._eventSource = t), this.resetEventlisten(this._event);
  }
  get event() {
    return this._event;
  }
  set event(t) {
    this.resetEventlisten(t), this._event = t;
  }
  serialize(t) {
    super.serialize(t), t.event = this.event;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event;
  }
  resetEventlisten(t) {
    this.object === null || typeof this.object != "object" || (this._listener && this._eventSource.removeEventListener(this.event, this._listener), this._listener = (r) => {
      this.exec(r);
    }, this._eventSource.addEventListener(t, this._listener));
  }
  dispose() {
    super.dispose(), this._listener && typeof this.object == "object" && this._eventSource.removeEventListener(this.event, this._listener);
  }
}
Fs("EventListenerNode", Ur, {
  event: "String"
}, "ScriptBlockNode", {
  eventOnBorn: { clsName: "EventListenerNode", func: () => new Ur("eventOnBorn", "onBorn"), group: "Scripts.On Born", icon: "loader" },
  eventOnDead: { clsName: "EventListenerNode", func: () => new Ur("eventOnDead", "onDead"), group: "Scripts.On Dead", icon: "bell-off" },
  eventOnCollisionEnter: { clsName: "EventListenerNode", func: () => new Ur("eventOnCollisionEnter", "onCollisionEnter"), group: "Scripts.On Collision Enter", icon: "arrows-shuffle" },
  eventOnCollisionLeave: { clsName: "EventListenerNode", func: () => new Ur("eventOnCollisionLeave", "onCollisionLeave"), group: "Scripts.On Collision Leave", icon: "arrow-bounce" },
  eventCustom: { clsName: "EventListenerNode", func: () => new Ur("eventCustom", "onCustomEvent"), group: "Scripts.On Custom Event", icon: "calendar-event" }
});
class zp extends ui {
  constructor(t, r) {
    super(t, r);
    G(this, "isUpdateNode", !0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdate(t, r, n, s) {
    if (this.enabled && this._code && this.object)
      try {
        this._main.call(this._objectRaw, ...this._parameters, n, s);
      } catch (o) {
        console.error(o);
      }
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new Function(...this._parametersProps, "delta", "now", this._code);
  }
}
Fs("UpdateNode", zp, {}, "ScriptNode", {
  update: { clsName: "UpdateNode", func: () => new zp("update"), group: "Scripts.On Update", icon: "refresh" }
});
class Bp extends Dn {
  constructor(t, r) {
    super(t, r);
    G(this, "isKeyboardNode", !0);
    G(this, "event", "keydown");
    G(this, "key", "");
    G(this, "_listenerKeyDown");
    G(this, "_listenerKeyUp");
    G(this, "_listenerBorn");
    G(this, "_listenerDead");
    G(this, "_isActived", !1);
    this._listenerKeyDown = (s) => {
      this.exec(s);
    }, this._listenerKeyUp = (s) => {
      this.exec(s);
    }, this._listenerBorn = () => {
      this._isActived = !0;
    }, this._listenerDead = () => {
      this._isActived = !1;
    };
    const n = ["_listenerKeyDown", "_listenerKeyUp"];
    window.addEventListener("keydown", this._listenerKeyDown), window.addEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), n.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const s of n)
      Object.defineProperty(this, s, {
        writable: !1
      });
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t;
    const r = [];
    this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), r.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const n of r)
      Object.defineProperty(this, n, {
        writable: !1
      });
  }
  async exec(t) {
    if (this._isActived && !(t.type !== this.event || t.key !== this.key))
      return super.exec(t);
  }
  serialize(t) {
    super.serialize(t), t.event = this.event, t.key = this.key;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event, this.key = t.key;
  }
  dispose() {
    super.dispose(), window.removeEventListener("keydown", this._listenerKeyDown), window.removeEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.removeEventListener("onBorn", this._listenerBorn), this.object.removeEventListener("onDead", this._listenerDead));
  }
}
Fs("KeyboardNode", Bp, {
  event: '"keydown"|"keyup"',
  key: '"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"'
}, "ScriptBlockNode", {
  keyboardEvent: { clsName: "KeyboardNode", func: () => new Bp("keyboardEvent"), group: "Scripts.On Keyboard", icon: "keyboard" }
});
const EA = {
  lineBasicMaterial: { clsName: "LineBasicMaterial", func: () => new M.LineBasicMaterial(), group: "Material.Line Basic Material", icon: "brand-medium" },
  // lineBasicNodeMaterial: { clsName: 'LineBasicNodeMaterial', func: () => new Nodes.LineBasicNodeMaterial(), group: 'Material.Line Basic Material Node', icon: 'brand-medium' },
  meshBasicMaterial: { clsName: "MeshBasicMaterial", func: () => new M.MeshBasicMaterial(), group: "Material.Mesh Basic Material", icon: "brand-medium" },
  // meshBasicNodeMaterial: { clsName: 'MeshBasicNodeMaterial', func: () => new Nodes.MeshBasicNodeMaterial(), group: 'Material.Mesh Basic Material Node', icon: 'brand-medium' },
  meshPhysicalMaterial: { clsName: "MeshPhysicalMaterial", func: () => new M.MeshPhysicalMaterial({}), group: "Material.Mesh Physical Material", icon: "brand-medium" },
  // meshPhysicalNodeMaterial: { clsName: 'MeshPhysicalNodeMaterial', func: () => new Nodes.MeshPhysicalNodeMaterial({}), group: 'Material.Mesh Physical Material Node', icon: 'brand-medium' },
  meshStandardMaterial: { clsName: "MeshStandardMaterial", func: () => new M.MeshStandardMaterial(), group: "Material.Mesh Standard Material", icon: "brand-medium" },
  // meshStandardNodeMaterial: { clsName: 'MeshStandardNodeMaterial', func: () => new Nodes.MeshStandardNodeMaterial(), group: 'Material.Mesh Standard Material Node', icon: 'brand-medium' },
  pointsMaterial: { clsName: "PointsMaterial", func: () => new M.PointsMaterial(), group: "Material.Points Material", icon: "brand-medium" },
  // pointsNodeMaterial: { clsName: 'PointsNodeMaterial', func: () => new Nodes.PointsNodeMaterial(), group: 'Material.Points Material Node', icon: 'brand-medium' },
  spriteMaterial: { clsName: "SpriteMaterial", func: () => new M.SpriteMaterial(), group: "Material.Sprite Material", icon: "brand-medium" },
  // spriteNodeMaterial: { clsName: 'SpriteNodeMaterial', func: () => new Nodes.SpriteNodeMaterial(), group: 'Material.Sprite Material Node', icon: 'brand-medium' },
  pongMaterial: { clsName: "MeshPhongMaterial", func: () => new M.MeshPhongMaterial(), group: "Material.Phong Material", icon: "brand-medium" },
  toonMaterial: { clsName: "MeshToonMaterial", func: () => new M.MeshToonMaterial({ color: 16777215, refractionRatio: 0.98 }), group: "Material.Toon Material", icon: "brand-medium" },
  normalMaterial: { clsName: "MeshNormalMaterial", func: () => new M.MeshNormalMaterial(), group: "Material.Normal Material", icon: "brand-medium" },
  matcapMaterial: { clsName: "MeshMatcapMaterial", func: () => new M.MeshMatcapMaterial(), group: "Material.Matcap Material", icon: "brand-medium" },
  lambertMaterial: { clsName: "MeshLambertMaterial", func: () => new M.MeshLambertMaterial(), group: "Material.Lambert Material", icon: "brand-medium" },
  depthMaterial: { clsName: "MeshDepthMaterial", func: () => new M.MeshDepthMaterial(), group: "Material.Depth Material", icon: "brand-medium" }
};
for (const [c, e] of Object.entries(EA))
  bc(c, e);
function bl(c, e) {
  return c instanceof nn ? c : new Proxy(c, {
    get(t, r, n) {
      if (r === kt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      if (Reflect.has(t, `${r}Node`)) {
        const o = Reflect.get(t, `${r}Node`, n);
        if (o !== null)
          return o;
      }
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      let o = r;
      Reflect.has(t, `${r}Node`) && n && n.isNode && (o = `${r}Node`);
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else {
        if (Reflect.get(t, o, s) === n)
          return !0;
        i = Reflect.set(t, o, n, s);
      }
      return i && e.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: c, fields: [r] }), i;
    }
  });
}
class z1 extends Dn {
  constructor(t, r, n, s) {
    super(t, s, !1);
    G(this, "isEffectNode", !0);
    _s(this.typesExtended.in), _s(this.inputs);
    for (const [o, i] of Object.entries(r.in || {}))
      this.addInput(o, i);
    _s(this.typesExtended.out), _s(this.outputs);
    for (const [o, i] of Object.entries(r.out || {}))
      this.addOutput(o, i);
    n && (this.code = n);
  }
  serialize(t) {
    super.serialize(t), delete t.code, delete t.types;
  }
}
Fs("EffectNode", z1, {}, "ScriptBlockNode");
function B1(c, e, t, r) {
  return bc(c, {
    clsName: "EffectNode",
    func: () => new z1(c, t, r),
    group: `Effects.${e}`,
    icon: "polygon"
  });
}
B1(
  "FallingPoints",
  "Falling Points",
  {
    in: {
      speed: "Number",
      size: "Number",
      maxCount: "Number"
    }
  },
  `const worldPosition = this.getWorldPosition(new THREE.Vector3());
const initialPosition = world.combineBuffer(this, 'position', params.maxCount || 1000);
const geometry = new THREE.BufferGeometry();

this.traverse(function (child) {
  if (child.isMesh) {
    child.material.visible = false;
  }
} );

geometry.setAttribute( 'position', initialPosition.clone() );
geometry.attributes.position.setUsage( THREE.DynamicDrawUsage );

const size = params.size || 0.02;
const mesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size, color: 0xffffff } ) );
const positions = geometry.attributes.position;
const count = positions.count;
const speed = params.speed || 5;
const minY = -worldPosition.y;
let resolve;
const promise = new Promise((rslv) => resolve = rslv);

mesh.onBeforeRender = () => {
  const delta = world.delta;
  let verticesDown = 0;

  for ( let i = 0; i < count; i ++ ) {
    const px = positions.getX( i );
    const py = positions.getY( i );
    const pz = positions.getZ( i );

    if ( py > minY ) {
      positions.setXYZ(
        i,
        px + 1.5 * ( 0.50 - Math.random() ) * speed * delta,
        py + 3.0 * ( 0.25 - Math.random() ) * speed * delta,
        pz + 1.5 * ( 0.50 - Math.random() ) * speed * delta
      );
    } else {
      verticesDown += 1;
    }
  }

  // all vertices down
  if ( verticesDown >= count ) {
    resolve();
  }
  positions.needsUpdate = true;
};
this.add(mesh);
await promise;
this.removeFromParent();
`
);
class k1 extends En {
  constructor(t, r, n) {
    super();
    G(this, "isEffect", !0);
    G(this, "props");
    this.geometry = t, this.material = r, this.type = "Effect", this.props = Gd({ ...n }, (s, o) => {
      this.onPropsChanged([s], [o]);
    }), this.addEventListener("added", async () => {
      await this.onAttached();
    }), this.addEventListener("removed", async () => {
      await this.onDetached();
    });
  }
  async onAttached() {
    await this.build();
  }
  onPropsChanged(t, r) {
  }
  onDetached() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  async build() {
  }
  dispose() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  clone(t) {
    const r = super.clone(t), n = tr(this.props), s = r.props[kt];
    return nr(s, n), r;
  }
  serialize(t) {
    t.props = tr(this.props);
  }
  deserialize(t) {
    if (t.props) {
      const r = this.props[kt];
      nr(r, t.props), this.build();
    }
  }
}
Je(
  "Effect",
  {
    members: {},
    proto: "Object3D",
    group: "",
    icon: "",
    create: () => new k1()
  }
);
const lu = {};
function G1(c, e) {
  if (lu[c])
    throw Be.panic(`Class[${c}] aready exists`);
  return lu[c] = e, Je(c, e);
}
function RA(c, e) {
  const t = lu[c];
  if (!t)
    throw Be.panic(`Class[${c}] not found!`);
  return t.create(e);
}
sn.createEffect = RA;
class FA extends k1 {
  constructor() {
    super(void 0, void 0, { maxCount: 1e3, texture: "", lerpPosition: 0, intensity: 0.04, size: 4 });
    G(this, "isEffectBurning", !0);
    this.type = "EffectBurning";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPropsChanged(t, r) {
    const n = this.parent;
    if (!n || !(n instanceof qt))
      return;
    t.includes("maxCount") && (this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.build());
    let s = !1;
    if (t.includes("lerpPosition"))
      if (this.material) {
        const o = Ot("targetPosition", "vec3"), i = Ft(this.props.lerpPosition), a = on(bn, o, i);
        this.material.positionNode = a, this.material.uniformsNeedUpdate = !0;
      } else
        s = !0;
    t.includes("texture") && (s = !0), s && (this.material && (this.material.dispose(), this.material = void 0), this.build());
  }
  async buildMaterial() {
    if (!this.props.texture)
      return;
    const t = Ot("targetPosition", "vec3"), r = Ot("particleSize", "float"), n = Ft(this.props.lerpPosition), s = on(bn, t, n), o = await new Nu().loadAsync(this.props.texture);
    o.colorSpace = vn;
    const i = Ot("particleSpeed", "float"), a = Ot("particleIntensity", "float"), l = Yh(1), u = z0(
      st(6, 6),
      // count
      X0,
      // uv
      l.mul(i)
      // current frame
    ), d = en(o, u).mul(a), f = new Bd({
      depthWrite: !1,
      transparent: !0,
      sizeAttenuation: !0,
      blending: nb
    });
    f.colorNode = d, f.sizeNode = r, f.positionNode = s, this.material && this.material.dispose(), this.material = f;
  }
  buildGeometry() {
    const t = this.parent;
    if (!t || !(t instanceof qt))
      return;
    const r = new Kn(), n = [], s = [], o = [], i = sn.combineBuffer(t, "position", this.props.maxCount || 1e3), a = i.count;
    for (let l = 0; l < a; l++)
      n.push(20 + Math.random() * 50), s.push(Math.random() * this.props.intensity), o.push(this.props.size + Math.random() * this.props.size);
    r.setAttribute("position", i), r.setAttribute("targetPosition", i), r.setAttribute("particleSpeed", new yn(n, 1)), r.setAttribute("particleIntensity", new yn(s, 1)), r.setAttribute("particleSize", new yn(o, 1)), this.geometry && this.geometry.dispose(), this.geometry = r;
  }
  async build() {
    this.geometry || this.buildGeometry(), this.material || await this.buildMaterial(), this.geometry && this.material && (this.isPoints = !0, this.visible = !0);
  }
  toJSON(t) {
    const r = this.isPoints;
    delete this.isPoints;
    const n = super.toJSON(t);
    return this.isPoints = r, n;
  }
}
G1(
  "EffectBurning",
  {
    members: {
      "props.maxCount": "Number",
      "props.texture": "Url",
      "props.lerpPosition": "Number",
      "props.intensity": "Number",
      "props.size": "Number"
    },
    proto: "Effect",
    group: "Effects.Burning Effect",
    icon: "fireworks",
    create: () => new FA()
  }
);
B1(
  "Burning",
  "Burning Body",
  {
    in: {
      texture: "Url",
      lerpPosition: "Number",
      time: "Number",
      maxCount: "Number"
    }
  },
  `const effect = world.createEffect('EffectBurning');
effect.props.maxCount = params.maxCount || 1000;
effect.props.lerpPosition = params.lerpPosition;
effect.props.texture = params.texture;
this.add(effect);

// waits
if (params.time) {
  await world.wait(params.time);
  effect.removeFromParent();
}
`
);
class LA extends Le {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const dt = LA, ba = new Wh();
ba.camera = new br();
const kp = {
  LineBasicNodeMaterial: cs.basic,
  MeshBasicNodeMaterial: cs.basic,
  PointsNodeMaterial: cs.points,
  MeshStandardNodeMaterial: cs.standard,
  MeshPhysicalNodeMaterial: cs.physical,
  MeshPhongNodeMaterial: cs.phong
}, OA = {
  [ke.ATAN2]: "atan"
}, IA = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function ms(c) {
  return `#include <${c}>`;
}
function Do(c) {
  return `${c}Shader`;
}
class Gp extends S0 {
  constructor(e, t, r, n = null) {
    super(e, t, new Jv(), null, n), this.shader = r, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow();
  }
  getMethod(e) {
    return OA[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), kp[t] !== void 0) {
      const r = kp[t], n = this.shader;
      n.vertexShader = r.vertexShader, n.fragmentShader = r.fragmentShader, n.uniforms = rr.merge([r.uniforms, oo.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new dt({
      node: ds,
      nodeType: "vec3",
      source: ms("clipping_planes_fragment"),
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: ms("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new dt({
      node: e.opacityNode,
      nodeType: "float",
      source: ms("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new dt({
      node: e.normalNode,
      nodeType: "vec3",
      source: ms("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new dt({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: ms("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.metalnessNode,
      nodeType: "float",
      source: ms("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.roughnessNode,
      nodeType: "float",
      source: ms("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new dt({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new dt({
      node: e.positionNode,
      nodeType: "vec3",
      source: ms("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new dt({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  getTexture(e, t, r) {
    return e.isTextureCube ? `textureCube( ${t}, ${r} )` : `texture2D( ${t}, ${r} )`;
  }
  getTextureBias(e, t, r, n) {
    return this.material.extensions !== void 0 && (this.material.extensions.shaderTextureLOD = !0), `textureLod( ${t}, ${r}, ${n} )`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let r = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let s = null;
      n.type === "texture" ? s = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? s = `samplerCube ${n.name}; ` : s = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? s = "uniform " + IA[o] + " " + s : s = "uniform " + s, r += s;
    }
    return r;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const r = this.attributes;
      for (const n of r)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const r = this.varyings;
    if (e === "vertex")
      for (const n of r)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of r)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, r, n = this) {
    const s = Do(e);
    let o = n[s];
    const i = o.indexOf(t);
    if (i !== -1) {
      const a = o.substring(0, i + t.length), l = o.substring(i + t.length);
      o = `${a}
${r}
${l}`;
    }
    n[s] = o;
  }
  replaceCode(e, t, r, n = this) {
    const s = Do(e);
    n[s] = n[s].replaceAll(t, r);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of Jr) {
      const r = this.getUniforms(t), n = this.getAttributes(t), s = this.getVaryings(t), o = this.getVars(t), i = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${r}

// attributes
${n}

// varyings
${s}

// vars
${o}

// codes
${i}

// </node_builder>

${this.shader[Do(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const r of t) {
      const n = ms(r), s = Tm[r], o = Do(e);
      this.shader[o] = this.shader[o].replaceAll(n, s);
    }
  }
  _sortSlotsToFlow() {
    for (const e of Jr) {
      const t = this.shader[Do(e)], r = this.slots[e].sort((n, s) => t.indexOf(n.source) > t.indexOf(s.source) ? 1 : -1);
      for (const n of r)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of Jr) {
      for (const t of this.slots[e]) {
        const r = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, s = t.source, o = r.code + `
	` + t.target.replace("%RESULT%", r.result);
        n === "append" ? this.addCode(e, s, o) : n === "replace" ? this.replaceCode(e, s, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of Jr)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    ba.object = this.object, ba.renderer = this.renderer;
    for (const e of this.updateNodes)
      ba.updateNode(e);
  }
}
const uu = /* @__PURE__ */ new WeakMap(), qr = new Wh();
kn.prototype.onBuild = function(c, e, t) {
  if (Array.isArray(c.material))
    for (const r of c.material)
      r.isNodeMaterial === !0 && uu.set(r, new Gp(c, t, e, r).build());
  else
    c.material.isNodeMaterial === !0 && uu.set(c.material, new Gp(c, t, e).build());
};
kn.prototype.onBeforeRender = function(c, e, t, r, n) {
  const s = uu.get(this);
  if (s !== void 0) {
    qr.material = this, qr.camera = t, qr.object = n, qr.renderer = c;
    const o = s.updateNodes;
    if (o.length > 0) {
      c.state.useProgram(null);
      for (const i of o)
        qr.updateNode(i);
    }
  }
};
class PA {
  constructor(e, t, r) {
    this.variables = [], this.currentTextureIndex = 0;
    let n = zf;
    const s = new Ha(), o = new sb();
    o.position.z = 1;
    const i = {
      passThruTexture: { value: null }
    }, a = h(f(), i), l = new qt(new Sr(2, 2), a);
    s.add(l), this.setDataType = function(p) {
      return n = p, this;
    }, this.addVariable = function(p, m, g) {
      const b = this.createShaderMaterial(m), v = {
        name: p,
        initialValueTexture: g,
        material: b,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: Hs,
        magFilter: Hs
      };
      return this.variables.push(v), v;
    }, this.setVariableDependencies = function(p, m) {
      p.dependencies = m;
    }, this.init = function() {
      if (r.capabilities.isWebGL2 === !1 && r.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (r.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let p = 0; p < this.variables.length; p++) {
        const m = this.variables[p];
        m.renderTargets[0] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), m.renderTargets[1] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), this.renderTexture(m.initialValueTexture, m.renderTargets[0]), this.renderTexture(m.initialValueTexture, m.renderTargets[1]);
        const g = m.material, b = g.uniforms;
        if (m.dependencies !== null)
          for (let v = 0; v < m.dependencies.length; v++) {
            const y = m.dependencies[v];
            if (y.name !== m.name) {
              let x = !1;
              for (let N = 0; N < this.variables.length; N++)
                if (y.name === this.variables[N].name) {
                  x = !0;
                  break;
                }
              if (!x)
                return "Variable dependency not found. Variable=" + m.name + ", dependency=" + y.name;
            }
            b[y.name] = { value: null }, g.fragmentShader = `
uniform sampler2D ` + y.name + `;
` + g.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const p = this.currentTextureIndex, m = this.currentTextureIndex === 0 ? 1 : 0;
      for (let g = 0, b = this.variables.length; g < b; g++) {
        const v = this.variables[g];
        if (v.dependencies !== null) {
          const y = v.material.uniforms;
          for (let x = 0, N = v.dependencies.length; x < N; x++) {
            const w = v.dependencies[x];
            y[w.name].value = w.renderTargets[p].texture;
          }
        }
        this.doRenderTarget(v.material, v.renderTargets[m]);
      }
      this.currentTextureIndex = m;
    }, this.getCurrentRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.geometry.dispose(), l.material.dispose();
      const p = this.variables;
      for (let m = 0; m < p.length; m++) {
        const g = p[m];
        g.initialValueTexture && g.initialValueTexture.dispose();
        const b = g.renderTargets;
        for (let v = 0; v < b.length; v++)
          b[v].dispose();
      }
    };
    function u(p) {
      p.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function h(p, m) {
      m = m || {};
      const g = new hs({
        name: "GPUComputationShader",
        uniforms: m,
        vertexShader: d(),
        fragmentShader: p
      });
      return u(g), g;
    }
    this.createShaderMaterial = h, this.createRenderTarget = function(p, m, g, b, v, y) {
      return p = p || e, m = m || t, g = g || mo, b = b || mo, v = v || Hs, y = y || Hs, new Su(p, m, {
        wrapS: g,
        wrapT: b,
        minFilter: v,
        magFilter: y,
        format: Df,
        type: n,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const p = new Float32Array(e * t * 4), m = new da(p, e, t, Df, zf);
      return m.needsUpdate = !0, m;
    }, this.renderTexture = function(p, m) {
      i.passThruTexture.value = p, this.doRenderTarget(a, m), i.passThruTexture.value = null;
    }, this.doRenderTarget = function(p, m) {
      const g = r.getRenderTarget(), b = r.xr.enabled, v = r.shadowMap.autoUpdate;
      r.xr.enabled = !1, r.shadowMap.autoUpdate = !1, l.material = p, r.setRenderTarget(m), r.render(s, o), l.material = a, r.xr.enabled = b, r.shadowMap.autoUpdate = v, r.setRenderTarget(g);
    };
    function d() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function f() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const Nt = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function V1(c) {
  const e = await fetch(c);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function UA(c) {
  if (!c)
    throw new Error("No basePath supplied");
  return await V1(`${c}/profilesList.json`);
}
async function DA(c, e, t = null, r = !0) {
  if (!c)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await UA(e);
  let s;
  if (c.profiles.some((a) => {
    const l = n[a];
    return l && (s = {
      profileId: a,
      profilePath: `${e}/${l.path}`,
      deprecated: !!l.deprecated
    }), !!s;
  }), !s) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    s = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await V1(s.profilePath);
  let i;
  if (r) {
    let a;
    if (c.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[c.handedness], !a)
      throw new Error(
        `No matching handedness, ${c.handedness}, in profile ${s.profileId}`
      );
    a.assetPath && (i = s.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: i };
}
const zA = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Nt.ComponentState.DEFAULT
};
function BA(c = 0, e = 0) {
  let t = c, r = e;
  if (Math.sqrt(c * c + e * e) > 1) {
    const o = Math.atan2(e, c);
    t = Math.cos(o), r = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: r * 0.5 + 0.5
  };
}
class kA {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === Nt.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(zA);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: r,
    state: n
  }) {
    const { normalizedXAxis: s, normalizedYAxis: o } = BA(e, t);
    switch (this.componentProperty) {
      case Nt.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? s : 0.5;
        break;
      case Nt.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case Nt.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? r : 0;
        break;
      case Nt.ComponentProperty.STATE:
        this.valueNodeProperty === Nt.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class GA {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((r) => {
      const n = new kA(t.visualResponses[r]);
      this.visualResponses[r] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: Nt.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = Nt.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = Nt.ComponentState.PRESSED : (t.touched || this.values.button > Nt.ButtonTouchThreshold) && (this.values.state = Nt.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Nt.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Nt.AxisTouchThreshold && (this.values.state = Nt.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Nt.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Nt.AxisTouchThreshold && (this.values.state = Nt.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class VA {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, r) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = r, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const s = this.layoutDescription.components[n];
      this.components[n] = new GA(n, s);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const jA = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", WA = "generic-trigger";
class HA extends En {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((r) => {
        const { valueNode: n, minNode: s, maxNode: o, value: i, valueNodeProperty: a } = r;
        n && (a === Nt.VisualResponseProperty.VISIBILITY ? n.visible = i : a === Nt.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          s.quaternion,
          o.quaternion,
          i
        ), n.position.lerpVectors(
          s.position,
          o.position,
          i
        )));
      });
    }));
  }
}
function XA(c, e) {
  Object.values(c.components).forEach((t) => {
    const { type: r, touchPointNodeName: n, visualResponses: s } = t;
    if (r === Nt.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new $a(1e-3), i = new An({ color: 255 }), a = new qt(o, i);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(s).forEach((o) => {
      const { valueNodeName: i, minNodeName: a, maxNodeName: l, valueNodeProperty: u } = o;
      if (u === Nt.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(l), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${l} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(i), o.valueNode || console.warn(`Could not find ${i} in the model`);
    });
  });
}
function Vp(c, e) {
  XA(c.motionController, e), c.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = c.envMap, t.material.needsUpdate = !0);
  }), c.add(e);
}
class $A {
  constructor(e = null) {
    this.gltfLoader = e, this.path = jA, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new Wd());
  }
  createControllerModel(e) {
    const t = new HA();
    let r = null;
    return e.addEventListener("connected", (n) => {
      const s = n.data;
      s.targetRayMode !== "tracked-pointer" || !s.gamepad || DA(s, this.path, WA).then(({ profile: o, assetPath: i }) => {
        t.motionController = new VA(
          s,
          o,
          i
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          r = a.scene.clone(), Vp(t, r);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (l) => {
              this._assetCache[t.motionController.assetUrl] = l, r = l.scene.clone(), Vp(t, r);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(r), r = null;
    }), t;
  }
}
const qA = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class JA {
  constructor(e, t, r, n, s = null) {
    this.controller = t, this.handModel = e, this.bones = [], s === null && (s = new Wd(), s.setPath(r || qA)), s.load(`${n}.glb`, (o) => {
      const i = o.scene.children[0];
      this.handModel.add(i);
      const a = i.getObjectByProperty("type", "SkinnedMesh");
      a.frustumCulled = !1, a.castShadow = !0, a.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((u) => {
        const h = i.getObjectByName(u);
        h !== void 0 ? h.jointName = u : console.warn(`Couldn't find ${u} in ${n} hand mesh`), this.bones.push(h);
      });
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const r = this.bones[t];
      if (r) {
        const n = e[r.jointName];
        if (n.visible) {
          const s = n.position;
          r.position.copy(s), r.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const YA = 0.01, KA = "index-finger-tip";
class jp extends En {
  constructor(e, t = null) {
    super(), this.controller = e, this.motionController = null, this.envMap = null, this.loader = t, this.mesh = null, e.addEventListener("connected", (r) => {
      const n = r.data;
      n.hand && !this.motionController && (this.xrInputSource = n, this.motionController = new JA(this, e, this.path, n.handedness, this.loader));
    }), e.addEventListener("disconnected", () => {
      this.clear(), this.motionController = null;
    });
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && this.motionController.updateMesh();
  }
  getPointerPosition() {
    const e = this.controller.joints[KA];
    return e ? e.position : null;
  }
  intersectBoxObject(e) {
    const t = this.getPointerPosition();
    if (t) {
      const r = new yi(t, YA), n = new sr().setFromObject(e);
      return r.intersectsBox(n);
    } else
      return !1;
  }
  checkButton(e) {
    this.intersectBoxObject(e) ? e.onPress() : e.onClear(), e.isPressed() && e.whilePressed();
  }
}
class ZA extends o1 {
  constructor() {
    super(), this.name;
    const e = new Xa(-5, 5, 5, -5);
    e.near = 1e-4, e.far = 1e3, e.position.set(0, 0, 4), this.add(e);
    const t = new qt(new $a(0.5), new An({ color: 8947967, wireframe: !0 }));
    t.onBeforeRender = () => {
      t.rotation.y -= 4e-3;
    }, this.add(t);
    const r = new b1();
    r.text = "Loading...", r.color = 8947865, r.anchorX = "center", r.fontSize = 0.16, r.position.set(0, -0.6, 0), this.add(r);
  }
}
const Kt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], QA = Math.PI / 180;
function Xd() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Kt[c & 255] + Kt[c >> 8 & 255] + Kt[c >> 16 & 255] + Kt[c >> 24 & 255] + "-" + Kt[e & 255] + Kt[e >> 8 & 255] + "-" + Kt[e >> 16 & 15 | 64] + Kt[e >> 24 & 255] + "-" + Kt[t & 63 | 128] + Kt[t >> 8 & 255] + "-" + Kt[t >> 16 & 255] + Kt[t >> 24 & 255] + Kt[r & 255] + Kt[r >> 8 & 255] + Kt[r >> 16 & 255] + Kt[r >> 24 & 255]).toLowerCase();
}
function zn(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function zo(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return c / 4294967295;
    case Uint16Array:
      return c / 65535;
    case Uint8Array:
      return c / 255;
    case Int32Array:
      return Math.max(c / 2147483647, -1);
    case Int16Array:
      return Math.max(c / 32767, -1);
    case Int8Array:
      return Math.max(c / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function fn(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return Math.round(c * 4294967295);
    case Uint16Array:
      return Math.round(c * 65535);
    case Uint8Array:
      return Math.round(c * 255);
    case Int32Array:
      return Math.round(c * 2147483647);
    case Int16Array:
      return Math.round(c * 32767);
    case Int8Array:
      return Math.round(c * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class Ti {
  constructor(e = 0, t = 0, r = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = n;
  }
  static slerpFlat(e, t, r, n, s, o, i) {
    let a = r[n + 0], l = r[n + 1], u = r[n + 2], h = r[n + 3];
    const d = s[o + 0], f = s[o + 1], p = s[o + 2], m = s[o + 3];
    if (i === 0) {
      e[t + 0] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (i === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
      return;
    }
    if (h !== m || a !== d || l !== f || u !== p) {
      let g = 1 - i;
      const b = a * d + l * f + u * p + h * m, v = b >= 0 ? 1 : -1, y = 1 - b * b;
      if (y > Number.EPSILON) {
        const N = Math.sqrt(y), w = Math.atan2(N, b * v);
        g = Math.sin(g * w) / N, i = Math.sin(i * w) / N;
      }
      const x = i * v;
      if (a = a * g + d * x, l = l * g + f * x, u = u * g + p * x, h = h * g + m * x, g === 1 - i) {
        const N = 1 / Math.sqrt(a * a + l * l + u * u + h * h);
        a *= N, l *= N, u *= N, h *= N;
      }
    }
    e[t] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, r, n, s, o) {
    const i = r[n], a = r[n + 1], l = r[n + 2], u = r[n + 3], h = s[o], d = s[o + 1], f = s[o + 2], p = s[o + 3];
    return e[t] = i * p + u * h + a * f - l * d, e[t + 1] = a * p + u * d + l * h - i * f, e[t + 2] = l * p + u * f + i * d - a * h, e[t + 3] = u * p - i * h - a * d - l * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._order, i = Math.cos, a = Math.sin, l = i(r / 2), u = i(n / 2), h = i(s / 2), d = a(r / 2), f = a(n / 2), p = a(s / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "YZX":
        this._x = d * u * h + l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "XZY":
        this._x = d * u * h - l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], n = t[4], s = t[8], o = t[1], i = t[5], a = t[9], l = t[2], u = t[6], h = t[10], d = r + i + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - a) * f, this._y = (s - l) * f, this._z = (o - n) * f;
    } else if (r > i && r > h) {
      const f = 2 * Math.sqrt(1 + r - i - h);
      this._w = (u - a) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (s + l) / f;
    } else if (i > h) {
      const f = 2 * Math.sqrt(1 + i - r - h);
      this._w = (s - l) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (a + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - r - i);
      this._w = (o - n) / f, this._x = (s + l) / f, this._y = (a + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(zn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const n = Math.min(1, t / r);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._w, i = t._x, a = t._y, l = t._z, u = t._w;
    return this._x = r * u + o * i + n * l - s * a, this._y = n * u + o * a + s * i - r * l, this._z = s * u + o * l + r * a - n * i, this._w = o * u - r * i - n * a - s * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, n = this._y, s = this._z, o = this._w;
    let i = o * e._w + r * e._x + n * e._y + s * e._z;
    if (i < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, i = -i) : this.copy(e), i >= 1)
      return this._w = o, this._x = r, this._y = n, this._z = s, this;
    const a = 1 - i * i;
    if (a <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * r + t * this._x, this._y = f * n + t * this._y, this._z = f * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(a), u = Math.atan2(l, i), h = Math.sin((1 - t) * u) / l, d = Math.sin(t * u) / l;
    return this._w = o * h + this._w * d, this._x = r * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class V {
  constructor(e = 0, t = 0, r = 0) {
    V.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Wp.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Wp.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * n, this.y = s[1] * t + s[4] * r + s[7] * n, this.z = s[2] * t + s[5] * r + s[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * r + s[11] * n + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * n + s[12]) * o, this.y = (s[1] * t + s[5] * r + s[9] * n + s[13]) * o, this.z = (s[2] * t + s[6] * r + s[10] * n + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, n = this.z, s = e.x, o = e.y, i = e.z, a = e.w, l = a * t + o * n - i * r, u = a * r + i * t - s * n, h = a * n + s * r - o * t, d = -s * t - o * r - i * n;
    return this.x = l * a + d * -s + u * -i - h * -o, this.y = u * a + d * -o + h * -s - l * -i, this.z = h * a + d * -i + l * -o - u * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * n, this.y = s[1] * t + s[5] * r + s[9] * n, this.z = s[2] * t + s[6] * r + s[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, n = e.y, s = e.z, o = t.x, i = t.y, a = t.z;
    return this.x = n * a - s * i, this.y = s * o - r * a, this.z = r * i - n * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return Nl.copy(this).projectOnVector(e), this.sub(Nl);
  }
  reflect(e) {
    return this.sub(Nl.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(zn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Nl = /* @__PURE__ */ new V(), Wp = /* @__PURE__ */ new Ti();
class Ee {
  constructor(e = 0, t = 0) {
    Ee.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(zn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * r - o * n + e.x, this.y = s * n + o * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Si {
  constructor(e = new V(1 / 0, 1 / 0, 1 / 0), t = new V(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(ys.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(ys.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ys.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0)
      e.boundingBox === null && e.computeBoundingBox(), Dr.copy(e.boundingBox), Dr.applyMatrix4(e.matrixWorld), this.union(Dr);
    else {
      const n = e.geometry;
      if (n !== void 0)
        if (t && n.attributes !== void 0 && n.attributes.position !== void 0) {
          const s = n.attributes.position;
          for (let o = 0, i = s.count; o < i; o++)
            ys.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ys);
        } else
          n.boundingBox === null && n.computeBoundingBox(), Dr.copy(n.boundingBox), Dr.applyMatrix4(e.matrixWorld), this.union(Dr);
    }
    const r = e.children;
    for (let n = 0, s = r.length; n < s; n++)
      this.expandByObject(r[n], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ys), ys.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Bo), Zi.subVectors(this.max, Bo), zr.subVectors(e.a, Bo), Br.subVectors(e.b, Bo), kr.subVectors(e.c, Bo), Us.subVectors(Br, zr), Ds.subVectors(kr, Br), hr.subVectors(zr, kr);
    let t = [
      0,
      -Us.z,
      Us.y,
      0,
      -Ds.z,
      Ds.y,
      0,
      -hr.z,
      hr.y,
      Us.z,
      0,
      -Us.x,
      Ds.z,
      0,
      -Ds.x,
      hr.z,
      0,
      -hr.x,
      -Us.y,
      Us.x,
      0,
      -Ds.y,
      Ds.x,
      0,
      -hr.y,
      hr.x,
      0
    ];
    return !wl(t, zr, Br, kr, Zi) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !wl(t, zr, Br, kr, Zi)) ? !1 : (Qi.crossVectors(Us, Ds), t = [Qi.x, Qi.y, Qi.z], wl(t, zr, Br, kr, Zi));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ys).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ys).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (gs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), gs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), gs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), gs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), gs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), gs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), gs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), gs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(gs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const gs = [
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V(),
  /* @__PURE__ */ new V()
], ys = /* @__PURE__ */ new V(), Dr = /* @__PURE__ */ new Si(), zr = /* @__PURE__ */ new V(), Br = /* @__PURE__ */ new V(), kr = /* @__PURE__ */ new V(), Us = /* @__PURE__ */ new V(), Ds = /* @__PURE__ */ new V(), hr = /* @__PURE__ */ new V(), Bo = /* @__PURE__ */ new V(), Zi = /* @__PURE__ */ new V(), Qi = /* @__PURE__ */ new V(), dr = /* @__PURE__ */ new V();
function wl(c, e, t, r, n) {
  for (let s = 0, o = c.length - 3; s <= o; s += 3) {
    dr.fromArray(c, s);
    const i = n.x * Math.abs(dr.x) + n.y * Math.abs(dr.y) + n.z * Math.abs(dr.z), a = e.dot(dr), l = t.dot(dr), u = r.dot(dr);
    if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > i)
      return !1;
  }
  return !0;
}
class j1 {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const n = r.slice(0);
      for (let s = 0, o = n.length; s < o; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const eC = 1015, Hp = 35044, ea = 2e3, Xp = 2001, At = /* @__PURE__ */ new V(), ta = /* @__PURE__ */ new Ee();
class ho {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = Hp, this.updateRange = { offset: 0, count: -1 }, this.gpuType = eC, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        ta.fromBufferAttribute(this, t), ta.applyMatrix3(e), this.setXY(t, ta.x, ta.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        At.fromBufferAttribute(this, t), At.applyMatrix3(e), this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t), At.applyMatrix4(e), this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t), At.applyNormalMatrix(e), this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      At.fromBufferAttribute(this, t), At.transformDirection(e), this.setXYZ(t, At.x, At.y, At.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = zo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = fn(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, n) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, r, n, s) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array), s = fn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Hp && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class tC extends ho {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class nC extends ho {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class He extends ho {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
const sC = /* @__PURE__ */ new Si(), ko = /* @__PURE__ */ new V(), Tl = /* @__PURE__ */ new V();
class rC {
  constructor(e = new V(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : sC.setFromPoints(e).getCenter(r);
    let n = 0;
    for (let s = 0, o = e.length; s < o; s++)
      n = Math.max(n, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    ko.subVectors(e, this.center);
    const t = ko.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), n = (r - this.radius) * 0.5;
      this.center.addScaledVector(ko, n / r), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Tl.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(ko.copy(e.center).add(Tl)), this.expandByPoint(ko.copy(e.center).sub(Tl))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qn {
  constructor(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    Qn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g);
  }
  set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    const b = this.elements;
    return b[0] = e, b[4] = t, b[8] = r, b[12] = n, b[1] = s, b[5] = o, b[9] = i, b[13] = a, b[2] = l, b[6] = u, b[10] = h, b[14] = d, b[3] = f, b[7] = p, b[11] = m, b[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Qn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, n = 1 / Gr.setFromMatrixColumn(e, 0).length(), s = 1 / Gr.setFromMatrixColumn(e, 1).length(), o = 1 / Gr.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z, o = Math.cos(r), i = Math.sin(r), a = Math.cos(n), l = Math.sin(n), u = Math.cos(s), h = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = -a * h, t[8] = l, t[1] = f + p * l, t[5] = d - m * l, t[9] = -i * a, t[2] = m - d * l, t[6] = p + f * l, t[10] = o * a;
    } else if (e.order === "YXZ") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d + m * i, t[4] = p * i - f, t[8] = o * l, t[1] = o * h, t[5] = o * u, t[9] = -i, t[2] = f * i - p, t[6] = m + d * i, t[10] = o * a;
    } else if (e.order === "ZXY") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d - m * i, t[4] = -o * h, t[8] = p + f * i, t[1] = f + p * i, t[5] = o * u, t[9] = m - d * i, t[2] = -o * l, t[6] = i, t[10] = o * a;
    } else if (e.order === "ZYX") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = p * l - f, t[8] = d * l + m, t[1] = a * h, t[5] = m * l + d, t[9] = f * l - p, t[2] = -l, t[6] = i * a, t[10] = o * a;
    } else if (e.order === "YZX") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = m - d * h, t[8] = p * h + f, t[1] = h, t[5] = o * u, t[9] = -i * u, t[2] = -l * u, t[6] = f * h + p, t[10] = d - m * h;
    } else if (e.order === "XZY") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = -h, t[8] = l * u, t[1] = d * h + m, t[5] = o * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = i * u, t[10] = m * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(oC, e, iC);
  }
  lookAt(e, t, r) {
    const n = this.elements;
    return _n.subVectors(e, t), _n.lengthSq() === 0 && (_n.z = 1), _n.normalize(), zs.crossVectors(r, _n), zs.lengthSq() === 0 && (Math.abs(r.z) === 1 ? _n.x += 1e-4 : _n.z += 1e-4, _n.normalize(), zs.crossVectors(r, _n)), zs.normalize(), na.crossVectors(_n, zs), n[0] = zs.x, n[4] = na.x, n[8] = _n.x, n[1] = zs.y, n[5] = na.y, n[9] = _n.y, n[2] = zs.z, n[6] = na.z, n[10] = _n.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[4], a = r[8], l = r[12], u = r[1], h = r[5], d = r[9], f = r[13], p = r[2], m = r[6], g = r[10], b = r[14], v = r[3], y = r[7], x = r[11], N = r[15], w = n[0], T = n[4], _ = n[8], F = n[12], A = n[1], D = n[5], S = n[9], R = n[13], E = n[2], U = n[6], P = n[10], se = n[14], oe = n[3], H = n[7], X = n[11], C = n[15];
    return s[0] = o * w + i * A + a * E + l * oe, s[4] = o * T + i * D + a * U + l * H, s[8] = o * _ + i * S + a * P + l * X, s[12] = o * F + i * R + a * se + l * C, s[1] = u * w + h * A + d * E + f * oe, s[5] = u * T + h * D + d * U + f * H, s[9] = u * _ + h * S + d * P + f * X, s[13] = u * F + h * R + d * se + f * C, s[2] = p * w + m * A + g * E + b * oe, s[6] = p * T + m * D + g * U + b * H, s[10] = p * _ + m * S + g * P + b * X, s[14] = p * F + m * R + g * se + b * C, s[3] = v * w + y * A + x * E + N * oe, s[7] = v * T + y * D + x * U + N * H, s[11] = v * _ + y * S + x * P + N * X, s[15] = v * F + y * R + x * se + N * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], n = e[8], s = e[12], o = e[1], i = e[5], a = e[9], l = e[13], u = e[2], h = e[6], d = e[10], f = e[14], p = e[3], m = e[7], g = e[11], b = e[15];
    return p * (+s * a * h - n * l * h - s * i * d + r * l * d + n * i * f - r * a * f) + m * (+t * a * f - t * l * d + s * o * d - n * o * f + n * l * u - s * a * u) + g * (+t * l * h - t * i * f - s * o * h + r * o * f + s * i * u - r * l * u) + b * (-n * i * u - t * a * h + t * i * d + n * o * h - r * o * d + r * a * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = e[9], d = e[10], f = e[11], p = e[12], m = e[13], g = e[14], b = e[15], v = h * g * l - m * d * l + m * a * f - i * g * f - h * a * b + i * d * b, y = p * d * l - u * g * l - p * a * f + o * g * f + u * a * b - o * d * b, x = u * m * l - p * h * l + p * i * f - o * m * f - u * i * b + o * h * b, N = p * h * a - u * m * a - p * i * d + o * m * d + u * i * g - o * h * g, w = t * v + r * y + n * x + s * N;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / w;
    return e[0] = v * T, e[1] = (m * d * s - h * g * s - m * n * f + r * g * f + h * n * b - r * d * b) * T, e[2] = (i * g * s - m * a * s + m * n * l - r * g * l - i * n * b + r * a * b) * T, e[3] = (h * a * s - i * d * s - h * n * l + r * d * l + i * n * f - r * a * f) * T, e[4] = y * T, e[5] = (u * g * s - p * d * s + p * n * f - t * g * f - u * n * b + t * d * b) * T, e[6] = (p * a * s - o * g * s - p * n * l + t * g * l + o * n * b - t * a * b) * T, e[7] = (o * d * s - u * a * s + u * n * l - t * d * l - o * n * f + t * a * f) * T, e[8] = x * T, e[9] = (p * h * s - u * m * s - p * r * f + t * m * f + u * r * b - t * h * b) * T, e[10] = (o * m * s - p * i * s + p * r * l - t * m * l - o * r * b + t * i * b) * T, e[11] = (u * i * s - o * h * s - u * r * l + t * h * l + o * r * f - t * i * f) * T, e[12] = N * T, e[13] = (u * m * n - p * h * n + p * r * d - t * m * d - u * r * g + t * h * g) * T, e[14] = (p * i * n - o * m * n - p * r * a + t * m * a + o * r * g - t * i * g) * T, e[15] = (o * h * n - u * i * n + u * r * a - t * h * a - o * r * d + t * i * d) * T, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= s, t[1] *= r, t[5] *= n, t[9] *= s, t[2] *= r, t[6] *= n, t[10] *= s, t[3] *= r, t[7] *= n, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = 1 - r, o = e.x, i = e.y, a = e.z, l = s * o, u = s * i;
    return this.set(
      l * o + r,
      l * i - n * a,
      l * a + n * i,
      0,
      l * i + n * a,
      u * i + r,
      u * a - n * o,
      0,
      l * a - n * i,
      u * a + n * o,
      s * a * a + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, n, s, o) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const n = this.elements, s = t._x, o = t._y, i = t._z, a = t._w, l = s + s, u = o + o, h = i + i, d = s * l, f = s * u, p = s * h, m = o * u, g = o * h, b = i * h, v = a * l, y = a * u, x = a * h, N = r.x, w = r.y, T = r.z;
    return n[0] = (1 - (m + b)) * N, n[1] = (f + x) * N, n[2] = (p - y) * N, n[3] = 0, n[4] = (f - x) * w, n[5] = (1 - (d + b)) * w, n[6] = (g + v) * w, n[7] = 0, n[8] = (p + y) * T, n[9] = (g - v) * T, n[10] = (1 - (d + m)) * T, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, r) {
    const n = this.elements;
    let s = Gr.set(n[0], n[1], n[2]).length();
    const o = Gr.set(n[4], n[5], n[6]).length(), i = Gr.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], qn.copy(this);
    const l = 1 / s, u = 1 / o, h = 1 / i;
    return qn.elements[0] *= l, qn.elements[1] *= l, qn.elements[2] *= l, qn.elements[4] *= u, qn.elements[5] *= u, qn.elements[6] *= u, qn.elements[8] *= h, qn.elements[9] *= h, qn.elements[10] *= h, t.setFromRotationMatrix(qn), r.x = s, r.y = o, r.z = i, this;
  }
  makePerspective(e, t, r, n, s, o, i = ea) {
    const a = this.elements, l = 2 * s / (t - e), u = 2 * s / (r - n), h = (t + e) / (t - e), d = (r + n) / (r - n);
    let f, p;
    if (i === ea)
      f = -(o + s) / (o - s), p = -2 * o * s / (o - s);
    else if (i === Xp)
      f = -o / (o - s), p = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + i);
    return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = u, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, r, n, s, o, i = ea) {
    const a = this.elements, l = 1 / (t - e), u = 1 / (r - n), h = 1 / (o - s), d = (t + e) * l, f = (r + n) * u;
    let p, m;
    if (i === ea)
      p = (o + s) * h, m = -2 * h;
    else if (i === Xp)
      p = s * h, m = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + i);
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = m, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const Gr = /* @__PURE__ */ new V(), qn = /* @__PURE__ */ new Qn(), oC = /* @__PURE__ */ new V(0, 0, 0), iC = /* @__PURE__ */ new V(1, 1, 1), zs = /* @__PURE__ */ new V(), na = /* @__PURE__ */ new V(), _n = /* @__PURE__ */ new V(), $p = /* @__PURE__ */ new Qn(), qp = /* @__PURE__ */ new Ti();
class Sc {
  constructor(e = 0, t = 0, r = 0, n = Sc.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, n = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const n = e.elements, s = n[0], o = n[4], i = n[8], a = n[1], l = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(zn(i, -1, 1)), Math.abs(i) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-zn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(i, f), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(zn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, s));
        break;
      case "ZYX":
        this._y = Math.asin(-zn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(a, s)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(zn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(i, f));
        break;
      case "XZY":
        this._z = Math.asin(-zn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(i, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return $p.makeRotationFromQuaternion(e), this.setFromRotationMatrix($p, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return qp.setFromEuler(this), this.setFromQuaternion(qp, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Sc.DEFAULT_ORDER = "XYZ";
class aC {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class _i {
  constructor(e, t, r, n, s, o, i, a, l) {
    _i.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l);
  }
  set(e, t, r, n, s, o, i, a, l) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = i, u[3] = t, u[4] = s, u[5] = a, u[6] = r, u[7] = o, u[8] = l, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[3], a = r[6], l = r[1], u = r[4], h = r[7], d = r[2], f = r[5], p = r[8], m = n[0], g = n[3], b = n[6], v = n[1], y = n[4], x = n[7], N = n[2], w = n[5], T = n[8];
    return s[0] = o * m + i * v + a * N, s[3] = o * g + i * y + a * w, s[6] = o * b + i * x + a * T, s[1] = l * m + u * v + h * N, s[4] = l * g + u * y + h * w, s[7] = l * b + u * x + h * T, s[2] = d * m + f * v + p * N, s[5] = d * g + f * y + p * w, s[8] = d * b + f * x + p * T, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8];
    return t * o * u - t * i * l - r * s * u + r * i * a + n * s * l - n * o * a;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = u * o - i * l, d = i * a - u * s, f = l * s - o * a, p = t * h + r * d + n * f;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return e[0] = h * m, e[1] = (n * l - u * r) * m, e[2] = (i * r - n * o) * m, e[3] = d * m, e[4] = (u * t - n * a) * m, e[5] = (n * s - i * t) * m, e[6] = f * m, e[7] = (r * a - l * t) * m, e[8] = (o * t - r * s) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, n, s, o, i) {
    const a = Math.cos(s), l = Math.sin(s);
    return this.set(
      r * a,
      r * l,
      -r * (a * o + l * i) + o + e,
      -n * l,
      n * a,
      -n * (-l * o + a * i) + i + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Sl.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Sl.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Sl.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Sl = /* @__PURE__ */ new _i();
let cC = 0;
const Jp = /* @__PURE__ */ new V(), Vr = /* @__PURE__ */ new Ti(), vs = /* @__PURE__ */ new Qn(), sa = /* @__PURE__ */ new V(), Go = /* @__PURE__ */ new V(), lC = /* @__PURE__ */ new V(), uC = /* @__PURE__ */ new Ti(), Yp = /* @__PURE__ */ new V(1, 0, 0), Kp = /* @__PURE__ */ new V(0, 1, 0), Zp = /* @__PURE__ */ new V(0, 0, 1), hC = { type: "added" }, dC = { type: "removed" };
class Js extends j1 {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: cC++ }), this.uuid = Xd(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Js.DEFAULT_UP.clone();
    const e = new V(), t = new Sc(), r = new Ti(), n = new V(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Qn()
      },
      normalMatrix: {
        value: new _i()
      }
    }), this.matrix = new Qn(), this.matrixWorld = new Qn(), this.matrixAutoUpdate = Js.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Js.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new aC(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Vr.setFromAxisAngle(e, t), this.quaternion.multiply(Vr), this;
  }
  rotateOnWorldAxis(e, t) {
    return Vr.setFromAxisAngle(e, t), this.quaternion.premultiply(Vr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Yp, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Kp, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Zp, e);
  }
  translateOnAxis(e, t) {
    return Jp.copy(e).applyQuaternion(this.quaternion), this.position.add(Jp.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Yp, e);
  }
  translateY(e) {
    return this.translateOnAxis(Kp, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Zp, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(vs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? sa.copy(e) : sa.set(e, t, r);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), Go.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? vs.lookAt(Go, sa, this.up) : vs.lookAt(sa, Go, this.up), this.quaternion.setFromRotationMatrix(vs), n && (vs.extractRotation(n.matrixWorld), Vr.setFromRotationMatrix(vs), this.quaternion.premultiply(Vr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(hC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(dC)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), vs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), vs.multiply(e.parent.matrixWorld)), e.applyMatrix4(vs), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, n = this.children.length; r < n; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const o = this.children[n].getObjectsByProperty(e, t);
      o.length > 0 && (r = r.concat(o));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Go, e, lC), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Go, uC, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let s = 0, o = n.length; s < o; s++) {
        const i = n[s];
        i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function s(i, a) {
      return i[a.uuid] === void 0 && (i[a.uuid] = a.toJSON(e)), a.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const i = this.geometry.parameters;
      if (i !== void 0 && i.shapes !== void 0) {
        const a = i.shapes;
        if (Array.isArray(a))
          for (let l = 0, u = a.length; l < u; l++) {
            const h = a[l];
            s(e.shapes, h);
          }
        else
          s(e.shapes, a);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const i = [];
        for (let a = 0, l = this.material.length; a < l; a++)
          i.push(s(e.materials, this.material[a]));
        n.material = i;
      } else
        n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let i = 0; i < this.children.length; i++)
        n.children.push(this.children[i].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const a = this.animations[i];
        n.animations.push(s(e.animations, a));
      }
    }
    if (t) {
      const i = o(e.geometries), a = o(e.materials), l = o(e.textures), u = o(e.images), h = o(e.shapes), d = o(e.skeletons), f = o(e.animations), p = o(e.nodes);
      i.length > 0 && (r.geometries = i), a.length > 0 && (r.materials = a), l.length > 0 && (r.textures = l), u.length > 0 && (r.images = u), h.length > 0 && (r.shapes = h), d.length > 0 && (r.skeletons = d), f.length > 0 && (r.animations = f), p.length > 0 && (r.nodes = p);
    }
    return r.object = n, r;
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
}
Js.DEFAULT_UP = /* @__PURE__ */ new V(0, 1, 0);
Js.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Js.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
function fC(c) {
  if (c.length === 0)
    return 1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] < e && (e = c[t]);
  return e;
}
function pC(c) {
  if (c.length === 0)
    return -1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] > e && (e = c[t]);
  return e;
}
function W1(c) {
  for (let e = c.length - 1; e >= 0; --e)
    if (c[e] >= 65535)
      return !0;
  return !1;
}
const mC = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function gC(c, e) {
  return new mC[c](e);
}
function H1(c) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", c);
}
function yC() {
  const c = H1("canvas");
  return c.style.display = "block", c;
}
const Qp = {};
function vC(c) {
  c in Qp || (Qp[c] = !0, console.warn(c));
}
const xC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayMax: pC,
  arrayMin: fC,
  arrayNeedsUint32: W1,
  createCanvasElement: yC,
  createElementNS: H1,
  getTypedArray: gC,
  warnOnce: vC
}, Symbol.toStringTag, { value: "Module" }));
let bC = 0;
const Pn = /* @__PURE__ */ new Qn(), _l = /* @__PURE__ */ new Js(), jr = /* @__PURE__ */ new V(), Mn = /* @__PURE__ */ new Si(), Vo = /* @__PURE__ */ new Si(), Bt = /* @__PURE__ */ new V();
class Yt extends j1 {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: bC++ }), this.uuid = Xd(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (W1(e) ? nC : tC)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new _i().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Pn.makeRotationFromQuaternion(e), this.applyMatrix4(Pn), this;
  }
  rotateX(e) {
    return Pn.makeRotationX(e), this.applyMatrix4(Pn), this;
  }
  rotateY(e) {
    return Pn.makeRotationY(e), this.applyMatrix4(Pn), this;
  }
  rotateZ(e) {
    return Pn.makeRotationZ(e), this.applyMatrix4(Pn), this;
  }
  translate(e, t, r) {
    return Pn.makeTranslation(e, t, r), this.applyMatrix4(Pn), this;
  }
  scale(e, t, r) {
    return Pn.makeScale(e, t, r), this.applyMatrix4(Pn), this;
  }
  lookAt(e) {
    return _l.lookAt(e), _l.updateMatrix(), this.applyMatrix4(_l.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(jr).negate(), this.translate(jr.x, jr.y, jr.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, n = e.length; r < n; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new He(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Si());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new V(-1 / 0, -1 / 0, -1 / 0),
        new V(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, n = t.length; r < n; r++) {
          const s = t[r];
          Mn.setFromBufferAttribute(s), this.morphTargetsRelative ? (Bt.addVectors(this.boundingBox.min, Mn.min), this.boundingBox.expandByPoint(Bt), Bt.addVectors(this.boundingBox.max, Mn.max), this.boundingBox.expandByPoint(Bt)) : (this.boundingBox.expandByPoint(Mn.min), this.boundingBox.expandByPoint(Mn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rC());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new V(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (Mn.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s];
          Vo.setFromBufferAttribute(i), this.morphTargetsRelative ? (Bt.addVectors(Mn.min, Vo.min), Mn.expandByPoint(Bt), Bt.addVectors(Mn.max, Vo.max), Mn.expandByPoint(Bt)) : (Mn.expandByPoint(Vo.min), Mn.expandByPoint(Vo.max));
        }
      Mn.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Bt.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Bt));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s], a = this.morphTargetsRelative;
          for (let l = 0, u = i.count; l < u; l++)
            Bt.fromBufferAttribute(i, l), a && (jr.fromBufferAttribute(e, l), Bt.add(jr)), n = Math.max(n, r.distanceToSquared(Bt));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, n = t.position.array, s = t.normal.array, o = t.uv.array, i = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ho(new Float32Array(4 * i), 4));
    const a = this.getAttribute("tangent").array, l = [], u = [];
    for (let A = 0; A < i; A++)
      l[A] = new V(), u[A] = new V();
    const h = new V(), d = new V(), f = new V(), p = new Ee(), m = new Ee(), g = new Ee(), b = new V(), v = new V();
    function y(A, D, S) {
      h.fromArray(n, A * 3), d.fromArray(n, D * 3), f.fromArray(n, S * 3), p.fromArray(o, A * 2), m.fromArray(o, D * 2), g.fromArray(o, S * 2), d.sub(h), f.sub(h), m.sub(p), g.sub(p);
      const R = 1 / (m.x * g.y - g.x * m.y);
      isFinite(R) && (b.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(R), v.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(R), l[A].add(b), l[D].add(b), l[S].add(b), u[A].add(v), u[D].add(v), u[S].add(v));
    }
    let x = this.groups;
    x.length === 0 && (x = [{
      start: 0,
      count: r.length
    }]);
    for (let A = 0, D = x.length; A < D; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let U = R, P = R + E; U < P; U += 3)
        y(
          r[U + 0],
          r[U + 1],
          r[U + 2]
        );
    }
    const N = new V(), w = new V(), T = new V(), _ = new V();
    function F(A) {
      T.fromArray(s, A * 3), _.copy(T);
      const D = l[A];
      N.copy(D), N.sub(T.multiplyScalar(T.dot(D))).normalize(), w.crossVectors(_, D);
      const R = w.dot(u[A]) < 0 ? -1 : 1;
      a[A * 4] = N.x, a[A * 4 + 1] = N.y, a[A * 4 + 2] = N.z, a[A * 4 + 3] = R;
    }
    for (let A = 0, D = x.length; A < D; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let U = R, P = R + E; U < P; U += 3)
        F(r[U + 0]), F(r[U + 1]), F(r[U + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new ho(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let d = 0, f = r.count; d < f; d++)
          r.setXYZ(d, 0, 0, 0);
      const n = new V(), s = new V(), o = new V(), i = new V(), a = new V(), l = new V(), u = new V(), h = new V();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0), m = e.getX(d + 1), g = e.getX(d + 2);
          n.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), i.fromBufferAttribute(r, p), a.fromBufferAttribute(r, m), l.fromBufferAttribute(r, g), i.add(u), a.add(u), l.add(u), r.setXYZ(p, i.x, i.y, i.z), r.setXYZ(m, a.x, a.y, a.z), r.setXYZ(g, l.x, l.y, l.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), r.setXYZ(d + 0, u.x, u.y, u.z), r.setXYZ(d + 1, u.x, u.y, u.z), r.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Bt.fromBufferAttribute(e, t), Bt.normalize(), e.setXYZ(t, Bt.x, Bt.y, Bt.z);
  }
  toNonIndexed() {
    function e(i, a) {
      const l = i.array, u = i.itemSize, h = i.normalized, d = new l.constructor(a.length * u);
      let f = 0, p = 0;
      for (let m = 0, g = a.length; m < g; m++) {
        i.isInterleavedBufferAttribute ? f = a[m] * i.data.stride + i.offset : f = a[m] * u;
        for (let b = 0; b < u; b++)
          d[p++] = l[f++];
      }
      return new ho(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Yt(), r = this.index.array, n = this.attributes;
    for (const i in n) {
      const a = n[i], l = e(a, r);
      t.setAttribute(i, l);
    }
    const s = this.morphAttributes;
    for (const i in s) {
      const a = [], l = s[i];
      for (let u = 0, h = l.length; u < h; u++) {
        const d = l[u], f = e(d, r);
        a.push(f);
      }
      t.morphAttributes[i] = a;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let i = 0, a = o.length; i < a; i++) {
      const l = o[i];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const a = this.parameters;
      for (const l in a)
        a[l] !== void 0 && (e[l] = a[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const a in r) {
      const l = r[a];
      e.data.attributes[a] = l.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const a in this.morphAttributes) {
      const l = this.morphAttributes[a], u = [];
      for (let h = 0, d = l.length; h < d; h++) {
        const f = l[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[a] = u, s = !0);
    }
    s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const i = this.boundingSphere;
    return i !== null && (e.data.boundingSphere = {
      center: i.center.toArray(),
      radius: i.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const n = e.attributes;
    for (const l in n) {
      const u = n[l];
      this.setAttribute(l, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const u = [], h = s[l];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const i = e.boundingBox;
    i !== null && (this.boundingBox = i.clone());
    const a = e.boundingSphere;
    return a !== null && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class $d extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: n,
      heightSegments: s,
      depthSegments: o
    };
    const i = this;
    n = Math.floor(n), s = Math.floor(s), o = Math.floor(o);
    const a = [], l = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, r, t, e, o, s, 0), p("z", "y", "x", 1, -1, r, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, r, t, n, o, 2), p("x", "z", "y", 1, -1, e, r, -t, n, o, 3), p("x", "y", "z", 1, -1, e, t, r, n, s, 4), p("x", "y", "z", -1, -1, e, t, -r, n, s, 5), this.setIndex(a), this.setAttribute("position", new He(l, 3)), this.setAttribute("normal", new He(u, 3)), this.setAttribute("uv", new He(h, 2));
    function p(m, g, b, v, y, x, N, w, T, _, F) {
      const A = x / T, D = N / _, S = x / 2, R = N / 2, E = w / 2, U = T + 1, P = _ + 1;
      let se = 0, oe = 0;
      const H = new V();
      for (let X = 0; X < P; X++) {
        const C = X * D - R;
        for (let O = 0; O < U; O++) {
          const I = O * A - S;
          H[m] = I * v, H[g] = C * y, H[b] = E, l.push(H.x, H.y, H.z), H[m] = 0, H[g] = 0, H[b] = w > 0 ? 1 : -1, u.push(H.x, H.y, H.z), h.push(O / T), h.push(1 - X / _), se += 1;
        }
      }
      for (let X = 0; X < _; X++)
        for (let C = 0; C < T; C++) {
          const O = d + C + U * X, I = d + C + U * (X + 1), k = d + (C + 1) + U * (X + 1), z = d + (C + 1) + U * X;
          a.push(O, I, z), a.push(I, k, z), oe += 6;
        }
      i.addGroup(f, oe, F), f += oe, d += se;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new $d(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class ps {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, n = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      r = this.getPoint(o / e), s += r.distanceTo(n), t.push(s), n = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let n = 0;
    const s = r.length;
    let o;
    t ? o = t : o = e * r[s - 1];
    let i = 0, a = s - 1, l;
    for (; i <= a; )
      if (n = Math.floor(i + (a - i) / 2), l = r[n] - o, l < 0)
        i = n + 1;
      else if (l > 0)
        a = n - 1;
      else {
        a = n;
        break;
      }
    if (n = a, r[n] === o)
      return n / (s - 1);
    const u = r[n], d = r[n + 1] - u, f = (o - u) / d;
    return (n + f) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const o = this.getPoint(n), i = this.getPoint(s), a = t || (o.isVector2 ? new Ee() : new V());
    return a.copy(i).sub(o).normalize(), a;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new V(), n = [], s = [], o = [], i = new V(), a = new Qn();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      n[f] = this.getTangentAt(p, new V());
    }
    s[0] = new V(), o[0] = new V();
    let l = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= l && (l = u, r.set(1, 0, 0)), h <= l && (l = h, r.set(0, 1, 0)), d <= l && r.set(0, 0, 1), i.crossVectors(n[0], r).normalize(), s[0].crossVectors(n[0], i), o[0].crossVectors(n[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), i.crossVectors(n[f - 1], n[f]), i.length() > Number.EPSILON) {
        i.normalize();
        const p = Math.acos(zn(n[f - 1].dot(n[f]), -1, 1));
        s[f].applyMatrix4(a.makeRotationAxis(i, p));
      }
      o[f].crossVectors(n[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(zn(s[0].dot(s[e]), -1, 1));
      f /= e, n[0].dot(i.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        s[p].applyMatrix4(a.makeRotationAxis(n[p], f * p)), o[p].crossVectors(n[p], s[p]);
    }
    return {
      tangents: n,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class qd extends ps {
  constructor(e = 0, t = 0, r = 1, n = 1, s = 0, o = Math.PI * 2, i = !1, a = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = i, this.aRotation = a;
  }
  getPoint(e, t) {
    const r = t || new Ee(), n = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += n;
    for (; s > n; )
      s -= n;
    s < Number.EPSILON && (o ? s = 0 : s = n), this.aClockwise === !0 && !o && (s === n ? s = -n : s = s - n);
    const i = this.aStartAngle + e * s;
    let a = this.aX + this.xRadius * Math.cos(i), l = this.aY + this.yRadius * Math.sin(i);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = a - this.aX, f = l - this.aY;
      a = d * u - f * h + this.aX, l = d * h + f * u + this.aY;
    }
    return r.set(a, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class NC extends qd {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, r, n, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Jd() {
  let c = 0, e = 0, t = 0, r = 0;
  function n(s, o, i, a) {
    c = s, e = i, t = -3 * s + 3 * o - 2 * i - a, r = 2 * s - 2 * o + i + a;
  }
  return {
    initCatmullRom: function(s, o, i, a, l) {
      n(o, i, l * (i - s), l * (a - o));
    },
    initNonuniformCatmullRom: function(s, o, i, a, l, u, h) {
      let d = (o - s) / l - (i - s) / (l + u) + (i - o) / u, f = (i - o) / u - (a - o) / (u + h) + (a - i) / h;
      d *= u, f *= u, n(o, i, d, f);
    },
    calc: function(s) {
      const o = s * s, i = o * s;
      return c + e * s + t * o + r * i;
    }
  };
}
const ra = /* @__PURE__ */ new V(), Ml = /* @__PURE__ */ new Jd(), Al = /* @__PURE__ */ new Jd(), Cl = /* @__PURE__ */ new Jd();
class wC extends ps {
  constructor(e = [], t = !1, r = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
  }
  getPoint(e, t = new V()) {
    const r = t, n = this.points, s = n.length, o = (s - (this.closed ? 0 : 1)) * e;
    let i = Math.floor(o), a = o - i;
    this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / s) + 1) * s : a === 0 && i === s - 1 && (i = s - 2, a = 1);
    let l, u;
    this.closed || i > 0 ? l = n[(i - 1) % s] : (ra.subVectors(n[0], n[1]).add(n[0]), l = ra);
    const h = n[i % s], d = n[(i + 1) % s];
    if (this.closed || i + 2 < s ? u = n[(i + 2) % s] : (ra.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), u = ra), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(l.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), g = Math.pow(d.distanceToSquared(u), f);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Ml.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, p, m, g), Al.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, p, m, g), Cl.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, p, m, g);
    } else
      this.curveType === "catmullrom" && (Ml.initCatmullRom(l.x, h.x, d.x, u.x, this.tension), Al.initCatmullRom(l.y, h.y, d.y, u.y, this.tension), Cl.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
    return r.set(
      Ml.calc(a),
      Al.calc(a),
      Cl.calc(a)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new V().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function em(c, e, t, r, n) {
  const s = (r - e) * 0.5, o = (n - t) * 0.5, i = c * c, a = c * i;
  return (2 * t - 2 * r + s + o) * a + (-3 * t + 3 * r - 2 * s - o) * i + s * c + t;
}
function TC(c, e) {
  const t = 1 - c;
  return t * t * e;
}
function SC(c, e) {
  return 2 * (1 - c) * c * e;
}
function _C(c, e) {
  return c * c * e;
}
function Yo(c, e, t, r) {
  return TC(c, e) + SC(c, t) + _C(c, r);
}
function MC(c, e) {
  const t = 1 - c;
  return t * t * t * e;
}
function AC(c, e) {
  const t = 1 - c;
  return 3 * t * t * c * e;
}
function CC(c, e) {
  return 3 * (1 - c) * c * c * e;
}
function EC(c, e) {
  return c * c * c * e;
}
function Ko(c, e, t, r, n) {
  return MC(c, e) + AC(c, t) + CC(c, r) + EC(c, n);
}
class X1 extends ps {
  constructor(e = new Ee(), t = new Ee(), r = new Ee(), n = new Ee()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class RC extends ps {
  constructor(e = new V(), t = new V(), r = new V(), n = new V()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new V()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y),
      Ko(e, n.z, s.z, o.z, i.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class $1 extends ps {
  constructor(e = new Ee(), t = new Ee()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ee()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ee()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class FC extends ps {
  constructor(e = new V(), t = new V()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new V()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new V()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class q1 extends ps {
  constructor(e = new Ee(), t = new Ee(), r = new Ee()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class J1 extends ps {
  constructor(e = new V(), t = new V(), r = new V()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new V()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y),
      Yo(e, n.z, s.z, o.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Y1 extends ps {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Ee()) {
    const r = t, n = this.points, s = (n.length - 1) * e, o = Math.floor(s), i = s - o, a = n[o === 0 ? o : o - 1], l = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return r.set(
      em(i, a.x, l.x, u.x, h.x),
      em(i, a.y, l.y, u.y, h.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new Ee().fromArray(n));
    }
    return this;
  }
}
const Va = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: NC,
  CatmullRomCurve3: wC,
  CubicBezierCurve: X1,
  CubicBezierCurve3: RC,
  EllipseCurve: qd,
  LineCurve: $1,
  LineCurve3: FC,
  QuadraticBezierCurve: q1,
  QuadraticBezierCurve3: J1,
  SplineCurve: Y1
}, Symbol.toStringTag, { value: "Module" }));
class LC extends ps {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Va[r](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= r) {
        const o = n[s] - r, i = this.curves[s], a = i.getLength(), l = a === 0 ? 0 : 1 - o / a;
        return i.getPointAt(l, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let n = 0, s = this.curves; n < s.length; n++) {
      const o = s[n], i = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, a = o.getPoints(i);
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        r && r.equals(u) || (t.push(u), r = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(new Va[n.type]().fromJSON(n));
    }
    return this;
  }
}
class hu extends LC {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ee(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new $1(this.currentPoint.clone(), new Ee(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, n) {
    const s = new q1(
      this.currentPoint.clone(),
      new Ee(e, t),
      new Ee(r, n)
    );
    return this.curves.push(s), this.currentPoint.set(r, n), this;
  }
  bezierCurveTo(e, t, r, n, s, o) {
    const i = new X1(
      this.currentPoint.clone(),
      new Ee(e, t),
      new Ee(r, n),
      new Ee(s, o)
    );
    return this.curves.push(i), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new Y1(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, n, s, o) {
    const i = this.currentPoint.x, a = this.currentPoint.y;
    return this.absarc(
      e + i,
      t + a,
      r,
      n,
      s,
      o
    ), this;
  }
  absarc(e, t, r, n, s, o) {
    return this.absellipse(e, t, r, r, n, s, o), this;
  }
  ellipse(e, t, r, n, s, o, i, a) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, t + u, r, n, s, o, i, a), this;
  }
  absellipse(e, t, r, n, s, o, i, a) {
    const l = new qd(e, t, r, n, s, o, i, a);
    if (this.curves.length > 0) {
      const h = l.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class _c extends Yt {
  constructor(e = [new Ee(0, -0.5), new Ee(0.5, 0), new Ee(0, 0.5)], t = 12, r = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: n
    }, t = Math.floor(t), n = zn(n, 0, Math.PI * 2);
    const s = [], o = [], i = [], a = [], l = [], u = 1 / t, h = new V(), d = new Ee(), f = new V(), p = new V(), m = new V();
    let g = 0, b = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, m.copy(f), f.normalize(), a.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          a.push(m.x, m.y, m.z);
          break;
        default:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), a.push(f.x, f.y, f.z), m.copy(p);
      }
    for (let v = 0; v <= t; v++) {
      const y = r + v * u * n, x = Math.sin(y), N = Math.cos(y);
      for (let w = 0; w <= e.length - 1; w++) {
        h.x = e[w].x * x, h.y = e[w].y, h.z = e[w].x * N, o.push(h.x, h.y, h.z), d.x = v / t, d.y = w / (e.length - 1), i.push(d.x, d.y);
        const T = a[3 * w + 0] * x, _ = a[3 * w + 1], F = a[3 * w + 0] * N;
        l.push(T, _, F);
      }
    }
    for (let v = 0; v < t; v++)
      for (let y = 0; y < e.length - 1; y++) {
        const x = y + v * e.length, N = x, w = x + e.length, T = x + e.length + 1, _ = x + 1;
        s.push(N, w, _), s.push(T, _, w);
      }
    this.setIndex(s), this.setAttribute("position", new He(o, 3)), this.setAttribute("uv", new He(i, 2)), this.setAttribute("normal", new He(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _c(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Yd extends _c {
  constructor(e = 1, t = 1, r = 4, n = 8) {
    const s = new hu();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new Yd(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Kd extends Yt {
  constructor(e = 1, t = 32, r = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: n
    }, t = Math.max(3, t);
    const s = [], o = [], i = [], a = [], l = new V(), u = new Ee();
    o.push(0, 0, 0), i.push(0, 0, 1), a.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = r + h / t * n;
      l.x = e * Math.cos(f), l.y = e * Math.sin(f), o.push(l.x, l.y, l.z), i.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, a.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      s.push(h, h + 1, 0);
    this.setIndex(s), this.setAttribute("position", new He(o, 3)), this.setAttribute("normal", new He(i, 3)), this.setAttribute("uv", new He(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Kd(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Mc extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 32, s = 1, o = !1, i = 0, a = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: n,
      heightSegments: s,
      openEnded: o,
      thetaStart: i,
      thetaLength: a
    };
    const l = this;
    n = Math.floor(n), s = Math.floor(s);
    const u = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], g = r / 2;
    let b = 0;
    v(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new He(h, 3)), this.setAttribute("normal", new He(d, 3)), this.setAttribute("uv", new He(f, 2));
    function v() {
      const x = new V(), N = new V();
      let w = 0;
      const T = (t - e) / r;
      for (let _ = 0; _ <= s; _++) {
        const F = [], A = _ / s, D = A * (t - e) + e;
        for (let S = 0; S <= n; S++) {
          const R = S / n, E = R * a + i, U = Math.sin(E), P = Math.cos(E);
          N.x = D * U, N.y = -A * r + g, N.z = D * P, h.push(N.x, N.y, N.z), x.set(U, T, P).normalize(), d.push(x.x, x.y, x.z), f.push(R, 1 - A), F.push(p++);
        }
        m.push(F);
      }
      for (let _ = 0; _ < n; _++)
        for (let F = 0; F < s; F++) {
          const A = m[F][_], D = m[F + 1][_], S = m[F + 1][_ + 1], R = m[F][_ + 1];
          u.push(A, D, R), u.push(D, S, R), w += 6;
        }
      l.addGroup(b, w, 0), b += w;
    }
    function y(x) {
      const N = p, w = new Ee(), T = new V();
      let _ = 0;
      const F = x === !0 ? e : t, A = x === !0 ? 1 : -1;
      for (let S = 1; S <= n; S++)
        h.push(0, g * A, 0), d.push(0, A, 0), f.push(0.5, 0.5), p++;
      const D = p;
      for (let S = 0; S <= n; S++) {
        const E = S / n * a + i, U = Math.cos(E), P = Math.sin(E);
        T.x = F * P, T.y = g * A, T.z = F * U, h.push(T.x, T.y, T.z), d.push(0, A, 0), w.x = U * 0.5 + 0.5, w.y = P * 0.5 * A + 0.5, f.push(w.x, w.y), p++;
      }
      for (let S = 0; S < n; S++) {
        const R = N + S, E = D + S;
        x === !0 ? u.push(E, E + 1, R) : u.push(E + 1, E, R), _ += 3;
      }
      l.addGroup(b, _, x === !0 ? 1 : 2), b += _;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Zd extends Mc {
  constructor(e = 1, t = 1, r = 32, n = 1, s = !1, o = 0, i = Math.PI * 2) {
    super(0, e, t, r, n, s, o, i), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: n,
      openEnded: s,
      thetaStart: o,
      thetaLength: i
    };
  }
  static fromJSON(e) {
    return new Zd(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Cr extends Yt {
  constructor(e = [], t = [], r = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: n
    };
    const s = [], o = [];
    i(n), l(r), u(), this.setAttribute("position", new He(s, 3)), this.setAttribute("normal", new He(s.slice(), 3)), this.setAttribute("uv", new He(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function i(v) {
      const y = new V(), x = new V(), N = new V();
      for (let w = 0; w < t.length; w += 3)
        f(t[w + 0], y), f(t[w + 1], x), f(t[w + 2], N), a(y, x, N, v);
    }
    function a(v, y, x, N) {
      const w = N + 1, T = [];
      for (let _ = 0; _ <= w; _++) {
        T[_] = [];
        const F = v.clone().lerp(x, _ / w), A = y.clone().lerp(x, _ / w), D = w - _;
        for (let S = 0; S <= D; S++)
          S === 0 && _ === w ? T[_][S] = F : T[_][S] = F.clone().lerp(A, S / D);
      }
      for (let _ = 0; _ < w; _++)
        for (let F = 0; F < 2 * (w - _) - 1; F++) {
          const A = Math.floor(F / 2);
          F % 2 === 0 ? (d(T[_][A + 1]), d(T[_ + 1][A]), d(T[_][A])) : (d(T[_][A + 1]), d(T[_ + 1][A + 1]), d(T[_ + 1][A]));
        }
    }
    function l(v) {
      const y = new V();
      for (let x = 0; x < s.length; x += 3)
        y.x = s[x + 0], y.y = s[x + 1], y.z = s[x + 2], y.normalize().multiplyScalar(v), s[x + 0] = y.x, s[x + 1] = y.y, s[x + 2] = y.z;
    }
    function u() {
      const v = new V();
      for (let y = 0; y < s.length; y += 3) {
        v.x = s[y + 0], v.y = s[y + 1], v.z = s[y + 2];
        const x = g(v) / 2 / Math.PI + 0.5, N = b(v) / Math.PI + 0.5;
        o.push(x, 1 - N);
      }
      p(), h();
    }
    function h() {
      for (let v = 0; v < o.length; v += 6) {
        const y = o[v + 0], x = o[v + 2], N = o[v + 4], w = Math.max(y, x, N), T = Math.min(y, x, N);
        w > 0.9 && T < 0.1 && (y < 0.2 && (o[v + 0] += 1), x < 0.2 && (o[v + 2] += 1), N < 0.2 && (o[v + 4] += 1));
      }
    }
    function d(v) {
      s.push(v.x, v.y, v.z);
    }
    function f(v, y) {
      const x = v * 3;
      y.x = e[x + 0], y.y = e[x + 1], y.z = e[x + 2];
    }
    function p() {
      const v = new V(), y = new V(), x = new V(), N = new V(), w = new Ee(), T = new Ee(), _ = new Ee();
      for (let F = 0, A = 0; F < s.length; F += 9, A += 6) {
        v.set(s[F + 0], s[F + 1], s[F + 2]), y.set(s[F + 3], s[F + 4], s[F + 5]), x.set(s[F + 6], s[F + 7], s[F + 8]), w.set(o[A + 0], o[A + 1]), T.set(o[A + 2], o[A + 3]), _.set(o[A + 4], o[A + 5]), N.copy(v).add(y).add(x).divideScalar(3);
        const D = g(N);
        m(w, A + 0, v, D), m(T, A + 2, y, D), m(_, A + 4, x, D);
      }
    }
    function m(v, y, x, N) {
      N < 0 && v.x === 1 && (o[y] = v.x - 1), x.x === 0 && x.z === 0 && (o[y] = N / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function b(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cr(e.vertices, e.indices, e.radius, e.details);
  }
}
class Qd extends Cr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = 1 / r, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      // (1/, , 0)
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      0,
      // (, 0, 1/)
      -r,
      0,
      -n,
      r,
      0,
      -n,
      -r,
      0,
      n,
      r,
      0,
      n
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Qd(e.radius, e.detail);
  }
}
const Jn = /* @__PURE__ */ new V(), xs = /* @__PURE__ */ new V(), El = /* @__PURE__ */ new V(), bs = /* @__PURE__ */ new V(), Wr = /* @__PURE__ */ new V(), Hr = /* @__PURE__ */ new V(), tm = /* @__PURE__ */ new V(), Rl = /* @__PURE__ */ new V(), Fl = /* @__PURE__ */ new V(), Ll = /* @__PURE__ */ new V();
let oa = !1;
class Vs {
  constructor(e = new V(), t = new V(), r = new V()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, n) {
    n.subVectors(r, t), Jn.subVectors(e, t), n.cross(Jn);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, n, s) {
    Jn.subVectors(n, t), xs.subVectors(r, t), El.subVectors(e, t);
    const o = Jn.dot(Jn), i = Jn.dot(xs), a = Jn.dot(El), l = xs.dot(xs), u = xs.dot(El), h = o * l - i * i;
    if (h === 0)
      return s.set(-2, -1, -1);
    const d = 1 / h, f = (l * a - i * u) * d, p = (o * u - i * a) * d;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, r, n) {
    return this.getBarycoord(e, t, r, n, bs), bs.x >= 0 && bs.y >= 0 && bs.x + bs.y <= 1;
  }
  static getUV(e, t, r, n, s, o, i, a) {
    return oa === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), oa = !0), this.getInterpolation(e, t, r, n, s, o, i, a);
  }
  static getInterpolation(e, t, r, n, s, o, i, a) {
    return this.getBarycoord(e, t, r, n, bs), a.setScalar(0), a.addScaledVector(s, bs.x), a.addScaledVector(o, bs.y), a.addScaledVector(i, bs.z), a;
  }
  static isFrontFacing(e, t, r, n) {
    return Jn.subVectors(r, t), xs.subVectors(e, t), Jn.cross(xs).dot(n) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, r, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Jn.subVectors(this.c, this.b), xs.subVectors(this.a, this.b), Jn.cross(xs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Vs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Vs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, n, s) {
    return oa === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), oa = !0), Vs.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  getInterpolation(e, t, r, n, s) {
    return Vs.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  containsPoint(e) {
    return Vs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Vs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, n = this.b, s = this.c;
    let o, i;
    Wr.subVectors(n, r), Hr.subVectors(s, r), Rl.subVectors(e, r);
    const a = Wr.dot(Rl), l = Hr.dot(Rl);
    if (a <= 0 && l <= 0)
      return t.copy(r);
    Fl.subVectors(e, n);
    const u = Wr.dot(Fl), h = Hr.dot(Fl);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = a * h - u * l;
    if (d <= 0 && a >= 0 && u <= 0)
      return o = a / (a - u), t.copy(r).addScaledVector(Wr, o);
    Ll.subVectors(e, s);
    const f = Wr.dot(Ll), p = Hr.dot(Ll);
    if (p >= 0 && f <= p)
      return t.copy(s);
    const m = f * l - a * p;
    if (m <= 0 && l >= 0 && p <= 0)
      return i = l / (l - p), t.copy(r).addScaledVector(Hr, i);
    const g = u * p - f * h;
    if (g <= 0 && h - u >= 0 && f - p >= 0)
      return tm.subVectors(s, n), i = (h - u) / (h - u + (f - p)), t.copy(n).addScaledVector(tm, i);
    const b = 1 / (g + m + d);
    return o = m * b, i = d * b, t.copy(r).addScaledVector(Wr, o).addScaledVector(Hr, i);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ia = /* @__PURE__ */ new V(), aa = /* @__PURE__ */ new V(), Ol = /* @__PURE__ */ new V(), ca = /* @__PURE__ */ new Vs();
class OC extends Yt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), s = Math.cos(QA * t), o = e.getIndex(), i = e.getAttribute("position"), a = o ? o.count : i.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
      for (let p = 0; p < a; p += 3) {
        o ? (l[0] = o.getX(p), l[1] = o.getX(p + 1), l[2] = o.getX(p + 2)) : (l[0] = p, l[1] = p + 1, l[2] = p + 2);
        const { a: m, b: g, c: b } = ca;
        if (m.fromBufferAttribute(i, l[0]), g.fromBufferAttribute(i, l[1]), b.fromBufferAttribute(i, l[2]), ca.getNormal(Ol), h[0] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, h[1] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, h[2] = `${Math.round(b.x * n)},${Math.round(b.y * n)},${Math.round(b.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let v = 0; v < 3; v++) {
            const y = (v + 1) % 3, x = h[v], N = h[y], w = ca[u[v]], T = ca[u[y]], _ = `${x}_${N}`, F = `${N}_${x}`;
            F in d && d[F] ? (Ol.dot(d[F].normal) <= s && (f.push(w.x, w.y, w.z), f.push(T.x, T.y, T.z)), d[F] = null) : _ in d || (d[_] = {
              index0: l[v],
              index1: l[y],
              normal: Ol.clone()
            });
          }
      }
      for (const p in d)
        if (d[p]) {
          const { index0: m, index1: g } = d[p];
          ia.fromBufferAttribute(i, m), aa.fromBufferAttribute(i, g), f.push(ia.x, ia.y, ia.z), f.push(aa.x, aa.y, aa.z);
        }
      this.setAttribute("position", new He(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class K1 extends hu {
  constructor(e) {
    super(e), this.uuid = Xd(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(new hu().fromJSON(n));
    }
    return this;
  }
}
const IC = {
  triangulate: function(c, e, t = 2) {
    const r = e && e.length, n = r ? e[0] * t : c.length;
    let s = Z1(c, 0, n, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let i, a, l, u, h, d, f;
    if (r && (s = BC(c, e, s, t)), c.length > 80 * t) {
      i = l = c[0], a = u = c[1];
      for (let p = t; p < n; p += t)
        h = c[p], d = c[p + 1], h < i && (i = h), d < a && (a = d), h > l && (l = h), d > u && (u = d);
      f = Math.max(l - i, u - a), f = f !== 0 ? 32767 / f : 0;
    }
    return hi(s, o, t, i, a, f, 0), o;
  }
};
function Z1(c, e, t, r, n) {
  let s, o;
  if (n === YC(c, e, t, r) > 0)
    for (s = e; s < t; s += r)
      o = nm(s, c[s], c[s + 1], o);
  else
    for (s = t - r; s >= e; s -= r)
      o = nm(s, c[s], c[s + 1], o);
  return o && Ac(o, o.next) && (fi(o), o = o.next), o;
}
function Tr(c, e) {
  if (!c)
    return c;
  e || (e = c);
  let t = c, r;
  do
    if (r = !1, !t.steiner && (Ac(t, t.next) || xt(t.prev, t, t.next) === 0)) {
      if (fi(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function hi(c, e, t, r, n, s, o) {
  if (!c)
    return;
  !o && s && WC(c, r, n, s);
  let i = c, a, l;
  for (; c.prev !== c.next; ) {
    if (a = c.prev, l = c.next, s ? UC(c, r, n, s) : PC(c)) {
      e.push(a.i / t | 0), e.push(c.i / t | 0), e.push(l.i / t | 0), fi(c), c = l.next, i = l.next;
      continue;
    }
    if (c = l, c === i) {
      o ? o === 1 ? (c = DC(Tr(c), e, t), hi(c, e, t, r, n, s, 2)) : o === 2 && zC(c, e, t, r, n, s) : hi(Tr(c), e, t, r, n, s, 1);
      break;
    }
  }
}
function PC(c) {
  const e = c.prev, t = c, r = c.next;
  if (xt(e, t, r) >= 0)
    return !1;
  const n = e.x, s = t.x, o = r.x, i = e.y, a = t.y, l = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, h = i < a ? i < l ? i : l : a < l ? a : l, d = n > s ? n > o ? n : o : s > o ? s : o, f = i > a ? i > l ? i : l : a > l ? a : l;
  let p = r.next;
  for (; p !== e; ) {
    if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && no(n, i, s, a, o, l, p.x, p.y) && xt(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function UC(c, e, t, r) {
  const n = c.prev, s = c, o = c.next;
  if (xt(n, s, o) >= 0)
    return !1;
  const i = n.x, a = s.x, l = o.x, u = n.y, h = s.y, d = o.y, f = i < a ? i < l ? i : l : a < l ? a : l, p = u < h ? u < d ? u : d : h < d ? h : d, m = i > a ? i > l ? i : l : a > l ? a : l, g = u > h ? u > d ? u : d : h > d ? h : d, b = du(f, p, e, t, r), v = du(m, g, e, t, r);
  let y = c.prevZ, x = c.nextZ;
  for (; y && y.z >= b && x && x.z <= v; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && no(i, u, a, h, l, d, y.x, y.y) && xt(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && no(i, u, a, h, l, d, x.x, x.y) && xt(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= b; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && no(i, u, a, h, l, d, y.x, y.y) && xt(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= v; ) {
    if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && no(i, u, a, h, l, d, x.x, x.y) && xt(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function DC(c, e, t) {
  let r = c;
  do {
    const n = r.prev, s = r.next.next;
    !Ac(n, s) && Q1(n, r, r.next, s) && di(n, s) && di(s, n) && (e.push(n.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), fi(r), fi(r.next), r = c = s), r = r.next;
  } while (r !== c);
  return Tr(r);
}
function zC(c, e, t, r, n, s) {
  let o = c;
  do {
    let i = o.next.next;
    for (; i !== o.prev; ) {
      if (o.i !== i.i && $C(o, i)) {
        let a = ex(o, i);
        o = Tr(o, o.next), a = Tr(a, a.next), hi(o, e, t, r, n, s, 0), hi(a, e, t, r, n, s, 0);
        return;
      }
      i = i.next;
    }
    o = o.next;
  } while (o !== c);
}
function BC(c, e, t, r) {
  const n = [];
  let s, o, i, a, l;
  for (s = 0, o = e.length; s < o; s++)
    i = e[s] * r, a = s < o - 1 ? e[s + 1] * r : c.length, l = Z1(c, i, a, r, !1), l === l.next && (l.steiner = !0), n.push(XC(l));
  for (n.sort(kC), s = 0; s < n.length; s++)
    t = GC(n[s], t);
  return t;
}
function kC(c, e) {
  return c.x - e.x;
}
function GC(c, e) {
  const t = VC(c, e);
  if (!t)
    return e;
  const r = ex(t, c);
  return Tr(r, r.next), Tr(t, t.next);
}
function VC(c, e) {
  let t = e, r = -1 / 0, n;
  const s = c.x, o = c.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= s && d > r && (r = d, n = t.x < t.next.x ? t : t.next, d === s))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n)
    return null;
  const i = n, a = n.x, l = n.y;
  let u = 1 / 0, h;
  t = n;
  do
    s >= t.x && t.x >= a && s !== t.x && no(o < l ? s : r, o, a, l, o < l ? r : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), di(t, c) && (h < u || h === u && (t.x > n.x || t.x === n.x && jC(n, t))) && (n = t, u = h)), t = t.next;
  while (t !== i);
  return n;
}
function jC(c, e) {
  return xt(c.prev, c, e.prev) < 0 && xt(e.next, c, c.next) < 0;
}
function WC(c, e, t, r) {
  let n = c;
  do
    n.z === 0 && (n.z = du(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== c);
  n.prevZ.nextZ = null, n.prevZ = null, HC(n);
}
function HC(c) {
  let e, t, r, n, s, o, i, a, l = 1;
  do {
    for (t = c, c = null, s = null, o = 0; t; ) {
      for (o++, r = t, i = 0, e = 0; e < l && (i++, r = r.nextZ, !!r); e++)
        ;
      for (a = l; i > 0 || a > 0 && r; )
        i !== 0 && (a === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, i--) : (n = r, r = r.nextZ, a--), s ? s.nextZ = n : c = n, n.prevZ = s, s = n;
      t = r;
    }
    s.nextZ = null, l *= 2;
  } while (o > 1);
  return c;
}
function du(c, e, t, r, n) {
  return c = (c - t) * n | 0, e = (e - r) * n | 0, c = (c | c << 8) & 16711935, c = (c | c << 4) & 252645135, c = (c | c << 2) & 858993459, c = (c | c << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, c | e << 1;
}
function XC(c) {
  let e = c, t = c;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== c);
  return t;
}
function no(c, e, t, r, n, s, o, i) {
  return (n - o) * (e - i) >= (c - o) * (s - i) && (c - o) * (r - i) >= (t - o) * (e - i) && (t - o) * (s - i) >= (n - o) * (r - i);
}
function $C(c, e) {
  return c.next.i !== e.i && c.prev.i !== e.i && !qC(c, e) && // dones't intersect other edges
  (di(c, e) && di(e, c) && JC(c, e) && // locally visible
  (xt(c.prev, c, e.prev) || xt(c, e.prev, e)) || // does not create opposite-facing sectors
  Ac(c, e) && xt(c.prev, c, c.next) > 0 && xt(e.prev, e, e.next) > 0);
}
function xt(c, e, t) {
  return (e.y - c.y) * (t.x - e.x) - (e.x - c.x) * (t.y - e.y);
}
function Ac(c, e) {
  return c.x === e.x && c.y === e.y;
}
function Q1(c, e, t, r) {
  const n = ua(xt(c, e, t)), s = ua(xt(c, e, r)), o = ua(xt(t, r, c)), i = ua(xt(t, r, e));
  return !!(n !== s && o !== i || n === 0 && la(c, t, e) || s === 0 && la(c, r, e) || o === 0 && la(t, c, r) || i === 0 && la(t, e, r));
}
function la(c, e, t) {
  return e.x <= Math.max(c.x, t.x) && e.x >= Math.min(c.x, t.x) && e.y <= Math.max(c.y, t.y) && e.y >= Math.min(c.y, t.y);
}
function ua(c) {
  return c > 0 ? 1 : c < 0 ? -1 : 0;
}
function qC(c, e) {
  let t = c;
  do {
    if (t.i !== c.i && t.next.i !== c.i && t.i !== e.i && t.next.i !== e.i && Q1(t, t.next, c, e))
      return !0;
    t = t.next;
  } while (t !== c);
  return !1;
}
function di(c, e) {
  return xt(c.prev, c, c.next) < 0 ? xt(c, e, c.next) >= 0 && xt(c, c.prev, e) >= 0 : xt(c, e, c.prev) < 0 || xt(c, c.next, e) < 0;
}
function JC(c, e) {
  let t = c, r = !1;
  const n = (c.x + e.x) / 2, s = (c.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== c);
  return r;
}
function ex(c, e) {
  const t = new fu(c.i, c.x, c.y), r = new fu(e.i, e.x, e.y), n = c.next, s = e.prev;
  return c.next = e, e.prev = c, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function nm(c, e, t, r) {
  const n = new fu(c, e, t);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function fi(c) {
  c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
}
function fu(c, e, t) {
  this.i = c, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function YC(c, e, t, r) {
  let n = 0;
  for (let s = e, o = t - r; s < t; s += r)
    n += (c[o] - c[s]) * (c[s + 1] + c[o + 1]), o = s;
  return n;
}
class Ys {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let n = t - 1, s = 0; s < t; n = s++)
      r += e[n].x * e[s].y - e[s].x * e[n].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Ys.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], n = [], s = [];
    sm(e), rm(r, e);
    let o = e.length;
    t.forEach(sm);
    for (let a = 0; a < t.length; a++)
      n.push(o), o += t[a].length, rm(r, t[a]);
    const i = IC.triangulate(r, n);
    for (let a = 0; a < i.length; a += 3)
      s.push(i.slice(a, a + 3));
    return s;
  }
}
function sm(c) {
  const e = c.length;
  e > 2 && c[e - 1].equals(c[0]) && c.pop();
}
function rm(c, e) {
  for (let t = 0; t < e.length; t++)
    c.push(e[t].x), c.push(e[t].y);
}
class ef extends Yt {
  constructor(e = new K1([new Ee(0.5, 0.5), new Ee(-0.5, 0.5), new Ee(-0.5, -0.5), new Ee(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, n = [], s = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i];
      o(l);
    }
    this.setAttribute("position", new He(n, 3)), this.setAttribute("uv", new He(s, 2)), this.computeVertexNormals();
    function o(i) {
      const a = [], l = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, p = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const b = t.extrudePath, v = t.UVGenerator !== void 0 ? t.UVGenerator : KC;
      let y, x = !1, N, w, T, _;
      b && (y = b.getSpacedPoints(u), x = !0, d = !1, N = b.computeFrenetFrames(u, !1), w = new V(), T = new V(), _ = new V()), d || (g = 0, f = 0, p = 0, m = 0);
      const F = i.extractPoints(l);
      let A = F.shape;
      const D = F.holes;
      if (!Ys.isClockWise(A)) {
        A = A.reverse();
        for (let L = 0, te = D.length; L < te; L++) {
          const Z = D[L];
          Ys.isClockWise(Z) && (D[L] = Z.reverse());
        }
      }
      const R = Ys.triangulateShape(A, D), E = A;
      for (let L = 0, te = D.length; L < te; L++) {
        const Z = D[L];
        A = A.concat(Z);
      }
      function U(L, te, Z) {
        return te || console.error("THREE.ExtrudeGeometry: vec does not exist"), L.clone().addScaledVector(te, Z);
      }
      const P = A.length, se = R.length;
      function oe(L, te, Z) {
        let Y, ee, fe;
        const ne = L.x - te.x, ue = L.y - te.y, de = Z.x - L.x, K = Z.y - L.y, _e = ne * ne + ue * ue, pe = ne * K - ue * de;
        if (Math.abs(pe) > Number.EPSILON) {
          const xe = Math.sqrt(_e), he = Math.sqrt(de * de + K * K), $e = te.x - ue / xe, ce = te.y + ne / xe, be = Z.x - K / he, ge = Z.y + de / he, Te = ((be - $e) * K - (ge - ce) * de) / (ne * K - ue * de);
          Y = $e + ne * Te - L.x, ee = ce + ue * Te - L.y;
          const Pe = Y * Y + ee * ee;
          if (Pe <= 2)
            return new Ee(Y, ee);
          fe = Math.sqrt(Pe / 2);
        } else {
          let xe = !1;
          ne > Number.EPSILON ? de > Number.EPSILON && (xe = !0) : ne < -Number.EPSILON ? de < -Number.EPSILON && (xe = !0) : Math.sign(ue) === Math.sign(K) && (xe = !0), xe ? (Y = -ue, ee = ne, fe = Math.sqrt(_e)) : (Y = ne, ee = ue, fe = Math.sqrt(_e / 2));
        }
        return new Ee(Y / fe, ee / fe);
      }
      const H = [];
      for (let L = 0, te = E.length, Z = te - 1, Y = L + 1; L < te; L++, Z++, Y++)
        Z === te && (Z = 0), Y === te && (Y = 0), H[L] = oe(E[L], E[Z], E[Y]);
      const X = [];
      let C, O = H.concat();
      for (let L = 0, te = D.length; L < te; L++) {
        const Z = D[L];
        C = [];
        for (let Y = 0, ee = Z.length, fe = ee - 1, ne = Y + 1; Y < ee; Y++, fe++, ne++)
          fe === ee && (fe = 0), ne === ee && (ne = 0), C[Y] = oe(Z[Y], Z[fe], Z[ne]);
        X.push(C), O = O.concat(C);
      }
      for (let L = 0; L < g; L++) {
        const te = L / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, fe = E.length; ee < fe; ee++) {
          const ne = U(E[ee], H[ee], Y);
          j(ne.x, ne.y, -Z);
        }
        for (let ee = 0, fe = D.length; ee < fe; ee++) {
          const ne = D[ee];
          C = X[ee];
          for (let ue = 0, de = ne.length; ue < de; ue++) {
            const K = U(ne[ue], C[ue], Y);
            j(K.x, K.y, -Z);
          }
        }
      }
      const I = p + m;
      for (let L = 0; L < P; L++) {
        const te = d ? U(A[L], O[L], I) : A[L];
        x ? (T.copy(N.normals[0]).multiplyScalar(te.x), w.copy(N.binormals[0]).multiplyScalar(te.y), _.copy(y[0]).add(T).add(w), j(_.x, _.y, _.z)) : j(te.x, te.y, 0);
      }
      for (let L = 1; L <= u; L++)
        for (let te = 0; te < P; te++) {
          const Z = d ? U(A[te], O[te], I) : A[te];
          x ? (T.copy(N.normals[L]).multiplyScalar(Z.x), w.copy(N.binormals[L]).multiplyScalar(Z.y), _.copy(y[L]).add(T).add(w), j(_.x, _.y, _.z)) : j(Z.x, Z.y, h / u * L);
        }
      for (let L = g - 1; L >= 0; L--) {
        const te = L / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, fe = E.length; ee < fe; ee++) {
          const ne = U(E[ee], H[ee], Y);
          j(ne.x, ne.y, h + Z);
        }
        for (let ee = 0, fe = D.length; ee < fe; ee++) {
          const ne = D[ee];
          C = X[ee];
          for (let ue = 0, de = ne.length; ue < de; ue++) {
            const K = U(ne[ue], C[ue], Y);
            x ? j(K.x, K.y + y[u - 1].y, y[u - 1].x + Z) : j(K.x, K.y, h + Z);
          }
        }
      }
      k(), z();
      function k() {
        const L = n.length / 3;
        if (d) {
          let te = 0, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[2] + Z, ee[1] + Z, ee[0] + Z);
          }
          te = u + g * 2, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[0] + Z, ee[1] + Z, ee[2] + Z);
          }
        } else {
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[2], Z[1], Z[0]);
          }
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[0] + P * u, Z[1] + P * u, Z[2] + P * u);
          }
        }
        r.addGroup(L, n.length / 3 - L, 0);
      }
      function z() {
        const L = n.length / 3;
        let te = 0;
        Q(E, te), te += E.length;
        for (let Z = 0, Y = D.length; Z < Y; Z++) {
          const ee = D[Z];
          Q(ee, te), te += ee.length;
        }
        r.addGroup(L, n.length / 3 - L, 1);
      }
      function Q(L, te) {
        let Z = L.length;
        for (; --Z >= 0; ) {
          const Y = Z;
          let ee = Z - 1;
          ee < 0 && (ee = L.length - 1);
          for (let fe = 0, ne = u + g * 2; fe < ne; fe++) {
            const ue = P * fe, de = P * (fe + 1), K = te + Y + ue, _e = te + ee + ue, pe = te + ee + de, xe = te + Y + de;
            ie(K, _e, pe, xe);
          }
        }
      }
      function j(L, te, Z) {
        a.push(L), a.push(te), a.push(Z);
      }
      function q(L, te, Z) {
        ae(L), ae(te), ae(Z);
        const Y = n.length / 3, ee = v.generateTopUV(r, n, Y - 3, Y - 2, Y - 1);
        $(ee[0]), $(ee[1]), $(ee[2]);
      }
      function ie(L, te, Z, Y) {
        ae(L), ae(te), ae(Y), ae(te), ae(Z), ae(Y);
        const ee = n.length / 3, fe = v.generateSideWallUV(r, n, ee - 6, ee - 3, ee - 2, ee - 1);
        $(fe[0]), $(fe[1]), $(fe[3]), $(fe[1]), $(fe[2]), $(fe[3]);
      }
      function ae(L) {
        n.push(a[L * 3 + 0]), n.push(a[L * 3 + 1]), n.push(a[L * 3 + 2]);
      }
      function $(L) {
        s.push(L.x), s.push(L.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return ZC(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const i = t[e.shapes[s]];
      r.push(i);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Va[n.type]().fromJSON(n)), new ef(r, e.options);
  }
}
const KC = {
  generateTopUV: function(c, e, t, r, n) {
    const s = e[t * 3], o = e[t * 3 + 1], i = e[r * 3], a = e[r * 3 + 1], l = e[n * 3], u = e[n * 3 + 1];
    return [
      new Ee(s, o),
      new Ee(i, a),
      new Ee(l, u)
    ];
  },
  generateSideWallUV: function(c, e, t, r, n, s) {
    const o = e[t * 3], i = e[t * 3 + 1], a = e[t * 3 + 2], l = e[r * 3], u = e[r * 3 + 1], h = e[r * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], p = e[n * 3 + 2], m = e[s * 3], g = e[s * 3 + 1], b = e[s * 3 + 2];
    return Math.abs(i - u) < Math.abs(o - l) ? [
      new Ee(o, 1 - a),
      new Ee(l, 1 - h),
      new Ee(d, 1 - p),
      new Ee(m, 1 - b)
    ] : [
      new Ee(i, 1 - a),
      new Ee(u, 1 - h),
      new Ee(f, 1 - p),
      new Ee(g, 1 - b)
    ];
  }
};
function ZC(c, e, t) {
  if (t.shapes = [], Array.isArray(c))
    for (let r = 0, n = c.length; r < n; r++) {
      const s = c[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(c.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class tf extends Cr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new tf(e.radius, e.detail);
  }
}
class nf extends Cr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new nf(e.radius, e.detail);
  }
}
class sf extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: n
    };
    const s = e / 2, o = t / 2, i = Math.floor(r), a = Math.floor(n), l = i + 1, u = a + 1, h = e / i, d = t / a, f = [], p = [], m = [], g = [];
    for (let b = 0; b < u; b++) {
      const v = b * d - o;
      for (let y = 0; y < l; y++) {
        const x = y * h - s;
        p.push(x, -v, 0), m.push(0, 0, 1), g.push(y / i), g.push(1 - b / a);
      }
    }
    for (let b = 0; b < a; b++)
      for (let v = 0; v < i; v++) {
        const y = v + l * b, x = v + l * (b + 1), N = v + 1 + l * (b + 1), w = v + 1 + l * b;
        f.push(y, x, w), f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new He(p, 3)), this.setAttribute("normal", new He(m, 3)), this.setAttribute("uv", new He(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sf(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class rf extends Yt {
  constructor(e = 0.5, t = 1, r = 32, n = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: n,
      thetaStart: s,
      thetaLength: o
    }, r = Math.max(3, r), n = Math.max(1, n);
    const i = [], a = [], l = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new V(), p = new Ee();
    for (let m = 0; m <= n; m++) {
      for (let g = 0; g <= r; g++) {
        const b = s + g / r * o;
        f.x = h * Math.cos(b), f.y = h * Math.sin(b), a.push(f.x, f.y, f.z), l.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, u.push(p.x, p.y);
      }
      h += d;
    }
    for (let m = 0; m < n; m++) {
      const g = m * (r + 1);
      for (let b = 0; b < r; b++) {
        const v = b + g, y = v, x = v + r + 1, N = v + r + 2, w = v + 1;
        i.push(y, x, w), i.push(x, N, w);
      }
    }
    this.setIndex(i), this.setAttribute("position", new He(a, 3)), this.setAttribute("normal", new He(l, 3)), this.setAttribute("uv", new He(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new rf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class of extends Yt {
  constructor(e = new K1([new Ee(0, 0.5), new Ee(-0.5, -0.5), new Ee(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], n = [], s = [], o = [];
    let i = 0, a = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(i, a, u), i += a, a = 0;
    this.setIndex(r), this.setAttribute("position", new He(n, 3)), this.setAttribute("normal", new He(s, 3)), this.setAttribute("uv", new He(o, 2));
    function l(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      Ys.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        Ys.isClockWise(v) === !0 && (p[g] = v.reverse());
      }
      const m = Ys.triangulateShape(f, p);
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        f = f.concat(v);
      }
      for (let g = 0, b = f.length; g < b; g++) {
        const v = f[g];
        n.push(v.x, v.y, 0), s.push(0, 0, 1), o.push(v.x, v.y);
      }
      for (let g = 0, b = m.length; g < b; g++) {
        const v = m[g], y = v[0] + h, x = v[1] + h, N = v[2] + h;
        r.push(y, x, N), a += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return QC(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let n = 0, s = e.shapes.length; n < s; n++) {
      const o = t[e.shapes[n]];
      r.push(o);
    }
    return new of(r, e.curveSegments);
  }
}
function QC(c, e) {
  if (e.shapes = [], Array.isArray(c))
    for (let t = 0, r = c.length; t < r; t++) {
      const n = c[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(c.uuid);
  return e;
}
class af extends Yt {
  constructor(e = 1, t = 32, r = 16, n = 0, s = Math.PI * 2, o = 0, i = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: n,
      phiLength: s,
      thetaStart: o,
      thetaLength: i
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const a = Math.min(o + i, Math.PI);
    let l = 0;
    const u = [], h = new V(), d = new V(), f = [], p = [], m = [], g = [];
    for (let b = 0; b <= r; b++) {
      const v = [], y = b / r;
      let x = 0;
      b === 0 && o === 0 ? x = 0.5 / t : b === r && a === Math.PI && (x = -0.5 / t);
      for (let N = 0; N <= t; N++) {
        const w = N / t;
        h.x = -e * Math.cos(n + w * s) * Math.sin(o + y * i), h.y = e * Math.cos(o + y * i), h.z = e * Math.sin(n + w * s) * Math.sin(o + y * i), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), g.push(w + x, 1 - y), v.push(l++);
      }
      u.push(v);
    }
    for (let b = 0; b < r; b++)
      for (let v = 0; v < t; v++) {
        const y = u[b][v + 1], x = u[b][v], N = u[b + 1][v], w = u[b + 1][v + 1];
        (b !== 0 || o > 0) && f.push(y, x, w), (b !== r - 1 || a < Math.PI) && f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new He(p, 3)), this.setAttribute("normal", new He(m, 3)), this.setAttribute("uv", new He(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new af(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class cf extends Cr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new cf(e.radius, e.detail);
  }
}
class lf extends Yt {
  constructor(e = 1, t = 0.4, r = 12, n = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: n,
      arc: s
    }, r = Math.floor(r), n = Math.floor(n);
    const o = [], i = [], a = [], l = [], u = new V(), h = new V(), d = new V();
    for (let f = 0; f <= r; f++)
      for (let p = 0; p <= n; p++) {
        const m = p / n * s, g = f / r * Math.PI * 2;
        h.x = (e + t * Math.cos(g)) * Math.cos(m), h.y = (e + t * Math.cos(g)) * Math.sin(m), h.z = t * Math.sin(g), i.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), d.subVectors(h, u).normalize(), a.push(d.x, d.y, d.z), l.push(p / n), l.push(f / r);
      }
    for (let f = 1; f <= r; f++)
      for (let p = 1; p <= n; p++) {
        const m = (n + 1) * f + p - 1, g = (n + 1) * (f - 1) + p - 1, b = (n + 1) * (f - 1) + p, v = (n + 1) * f + p;
        o.push(m, g, v), o.push(g, b, v);
      }
    this.setIndex(o), this.setAttribute("position", new He(i, 3)), this.setAttribute("normal", new He(a, 3)), this.setAttribute("uv", new He(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new lf(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class uf extends Yt {
  constructor(e = 1, t = 0.4, r = 64, n = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: n,
      p: s,
      q: o
    }, r = Math.floor(r), n = Math.floor(n);
    const i = [], a = [], l = [], u = [], h = new V(), d = new V(), f = new V(), p = new V(), m = new V(), g = new V(), b = new V();
    for (let y = 0; y <= r; ++y) {
      const x = y / r * s * Math.PI * 2;
      v(x, s, o, e, f), v(x + 0.01, s, o, e, p), g.subVectors(p, f), b.addVectors(p, f), m.crossVectors(g, b), b.crossVectors(m, g), m.normalize(), b.normalize();
      for (let N = 0; N <= n; ++N) {
        const w = N / n * Math.PI * 2, T = -t * Math.cos(w), _ = t * Math.sin(w);
        h.x = f.x + (T * b.x + _ * m.x), h.y = f.y + (T * b.y + _ * m.y), h.z = f.z + (T * b.z + _ * m.z), a.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), l.push(d.x, d.y, d.z), u.push(y / r), u.push(N / n);
      }
    }
    for (let y = 1; y <= r; y++)
      for (let x = 1; x <= n; x++) {
        const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
        i.push(N, w, _), i.push(w, T, _);
      }
    this.setIndex(i), this.setAttribute("position", new He(a, 3)), this.setAttribute("normal", new He(l, 3)), this.setAttribute("uv", new He(u, 2));
    function v(y, x, N, w, T) {
      const _ = Math.cos(y), F = Math.sin(y), A = N / x * y, D = Math.cos(A);
      T.x = w * (2 + D) * 0.5 * _, T.y = w * (2 + D) * F * 0.5, T.z = w * Math.sin(A) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class hf extends Yt {
  constructor(e = new J1(new V(-1, -1, 0), new V(-1, 1, 0), new V(1, 1, 0)), t = 64, r = 1, n = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: n,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const i = new V(), a = new V(), l = new Ee();
    let u = new V();
    const h = [], d = [], f = [], p = [];
    m(), this.setIndex(p), this.setAttribute("position", new He(h, 3)), this.setAttribute("normal", new He(d, 3)), this.setAttribute("uv", new He(f, 2));
    function m() {
      for (let y = 0; y < t; y++)
        g(y);
      g(s === !1 ? t : 0), v(), b();
    }
    function g(y) {
      u = e.getPointAt(y / t, u);
      const x = o.normals[y], N = o.binormals[y];
      for (let w = 0; w <= n; w++) {
        const T = w / n * Math.PI * 2, _ = Math.sin(T), F = -Math.cos(T);
        a.x = F * x.x + _ * N.x, a.y = F * x.y + _ * N.y, a.z = F * x.z + _ * N.z, a.normalize(), d.push(a.x, a.y, a.z), i.x = u.x + r * a.x, i.y = u.y + r * a.y, i.z = u.z + r * a.z, h.push(i.x, i.y, i.z);
      }
    }
    function b() {
      for (let y = 1; y <= t; y++)
        for (let x = 1; x <= n; x++) {
          const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
          p.push(N, w, _), p.push(w, T, _);
        }
    }
    function v() {
      for (let y = 0; y <= t; y++)
        for (let x = 0; x <= n; x++)
          l.x = y / t, l.y = x / n, f.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new hf(
      new Va[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class eE extends Yt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), n = new V(), s = new V();
      if (e.index !== null) {
        const o = e.attributes.position, i = e.index;
        let a = e.groups;
        a.length === 0 && (a = [{ start: 0, count: i.count, materialIndex: 0 }]);
        for (let l = 0, u = a.length; l < u; ++l) {
          const h = a[l], d = h.start, f = h.count;
          for (let p = d, m = d + f; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const b = i.getX(p + g), v = i.getX(p + (g + 1) % 3);
              n.fromBufferAttribute(o, b), s.fromBufferAttribute(o, v), om(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let i = 0, a = o.count / 3; i < a; i++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * i + l, h = 3 * i + (l + 1) % 3;
            n.fromBufferAttribute(o, u), s.fromBufferAttribute(o, h), om(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new He(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function om(c, e, t) {
  const r = `${c.x},${c.y},${c.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${c.x},${c.y},${c.z}`;
  return t.has(r) === !0 || t.has(n) === !0 ? !1 : (t.add(r), t.add(n), !0);
}
const im = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BoxGeometry: $d,
  CapsuleGeometry: Yd,
  CircleGeometry: Kd,
  ConeGeometry: Zd,
  CylinderGeometry: Mc,
  DodecahedronGeometry: Qd,
  EdgesGeometry: OC,
  ExtrudeGeometry: ef,
  IcosahedronGeometry: tf,
  LatheGeometry: _c,
  OctahedronGeometry: nf,
  PlaneGeometry: sf,
  PolyhedronGeometry: Cr,
  RingGeometry: rf,
  ShapeGeometry: of,
  SphereGeometry: af,
  TetrahedronGeometry: cf,
  TorusGeometry: lf,
  TorusKnotGeometry: uf,
  TubeGeometry: hf,
  WireframeGeometry: eE
}, Symbol.toStringTag, { value: "Module" }));
class ja extends pu {
  constructor(t) {
    super();
    G(this, "nodes", []);
    G(this, "isLocked", !1);
    this.object = t, t.graph || (t.graph = this), this.addEventListener("nodeEventOutputChanged", ({ node: r, fields: n }) => {
      for (const s of n)
        this.applyNodePins(r._parentGraphNode, s, "out");
    });
  }
  newGraphNode(t, r) {
    const n = new Proxy({ x: 0, y: 0 }, {
      set: (o, i, a, l) => {
        if (a === Reflect.get(o, i))
          return !0;
        const u = Reflect.set(o, i, a, l);
        return u && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s] }), u;
      }
    }), s = {
      name: r,
      scoped: bl(t, this),
      anchor: n,
      bounds: {},
      outs: {}
    };
    return t._parentGraphNode = s, s;
  }
  add(t) {
    if (this.nodes.indexOf(t) !== -1)
      throw Be.panic(`Graph Node[${t.scoped.uuid}] aready exists`);
    t.scoped instanceof nn && (t.scoped.eventDispatcher = this), this.nodes.push(t), this.dispatchEvent({ type: "graphAdded", soure: this, nodes: [t] });
  }
  remove(t) {
    const r = this.nodes.indexOf(t);
    if (r === -1)
      return !1;
    this.nodes.splice(r, 1), t.scoped instanceof nn && (t.scoped.eventDispatcher = null);
    for (const n of Object.keys(t.bounds))
      this.disconnect({ node: t, field: n }, !0);
    for (const n of Object.values(t.outs))
      for (const s of [...n])
        this.disconnect({ node: s.node, field: s.field }, !0);
    t.scoped.dispose && t.scoped.dispose(), this.dispatchEvent({ type: "graphRemoved", soure: this, nodes: [t] });
  }
  get(t) {
    return this.nodes.find((r) => r.scoped.uuid === t);
  }
  update(t, r, n, s) {
    for (const o of this.nodes)
      o.scoped.onUpdate && o.scoped.onUpdate(t, r, n, s);
  }
  connect(t, r, n) {
    if (!t.field && t.node.scoped instanceof Dn || !t.field && r.node.scoped instanceof Dn) {
      if (t.node.scoped instanceof Dn != r.node.scoped instanceof Dn) {
        if (n)
          return 0;
        throw Be.panic("not supported");
      }
      if (!(t.node.scoped instanceof Dn) || !(r.node.scoped instanceof Dn)) {
        if (n)
          return 0;
        throw Be.panic("not supported");
      }
      if (t.node.scoped.next === r.node.scoped) {
        if (n)
          return 3;
      } else if (t.node.scoped.next || r.node.scoped.prev) {
        if (n)
          return 0;
        throw Be.panic("not supported");
      }
      return n || (t.node.scoped.next = r.node.scoped, r.node.scoped.prev = t.node.scoped, this.dispatchEvent({ type: "graphModified", soure: this, nodes: [t.node, r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node })), 3;
    }
    if (!r.field) {
      if (n)
        return 0;
      throw Be.panic("not supported");
    }
    const s = r.node.bounds[r.field];
    if (s) {
      if (s.node === t.node && s.field === t.field)
        return s.type;
      if (n)
        return 0;
      throw Be.panic(`field[${r.field}] has been bound`);
    }
    const o = t.node.scoped instanceof nn ? t.node.scoped.objectType : sp(t.node.name), i = sp(r.node.name), { out: a } = t.node.scoped.typesExtended || Ua(o), { in: l } = r.node.scoped.typesExtended || Ua(i), u = t.field ? a[t.field] : { types: [o] }, h = r.field ? l[r.field] : { types: [i] };
    if (t.field) {
      if (!hS(u.types, h.types)) {
        if (n)
          return 0;
        throw Be.panic("type mismatched");
      }
    } else if (!fS(o, h.types)) {
      if (n)
        return 0;
      throw Be.panic("type mismatched");
    }
    const f = u.types.findIndex((g) => xc(g)) !== -1 ? 1 : 2;
    if (n)
      return f;
    r.node.bounds[r.field] = { node: t.node, type: f, field: t.field };
    const p = t.field || "$";
    return (t.node.outs[p] || (t.node.outs[p] = [])).push({ node: r.node, type: f, field: r.field }), this.applyNodeBounds(r.node), this.dispatchEvent({ type: "graphModified", soure: this, nodes: [r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node }), f;
  }
  disconnect(t, r) {
    if (!t.field && t.node.scoped instanceof Dn) {
      if (!t.node.scoped.prev)
        throw Be.panic("state error");
      t.node.scoped.prev.next = void 0, t.node.scoped.prev = void 0;
      return;
    }
    if (!t.field)
      throw Be.panic("not allowed");
    const n = t.node.bounds[t.field];
    if (n === void 0)
      return;
    const s = n.node, o = n.field || "$", i = s.outs[o];
    if (!i)
      throw Be.panic(`bound list not found for node[field=${t.field}]`);
    const a = t.node.scoped, l = i.findIndex((f) => f.node === t.node && f.field === t.field);
    if (l === -1)
      return;
    delete t.node.bounds[t.field], i.splice(l, 1);
    const u = a instanceof nn ? a.getObjectsExtended().in : a, h = u[t.field];
    if (h instanceof kn)
      u[t.field] = new An();
    else {
      const f = `${t.field}Node`;
      Object.hasOwn(u, f) ? u[f] = null : h && (h.isNode || h.isMaterial) && (u[t.field] = null), u instanceof kn && (u.needsUpdate = !0, u instanceof hs && (u.uniformsNeedUpdate = !0));
    }
    r || (this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s, t.node] }), this.dispatchEvent({ type: "graphDisconnected", soure: this, from: s, to: t.node }));
  }
  clear() {
    for (const t of this.nodes)
      t.scoped.dispose && t.scoped.dispose();
    this.nodes.length = 0;
  }
  clone(t, r) {
    const n = r.get(this.object);
    if (!n)
      throw Be.panic(`object[${this.object.uuid}] is not found in list being transfered`);
    const s = {};
    for (const i of this.nodes) {
      const a = i.scoped;
      let l;
      const u = {};
      if (a instanceof nn) {
        l = eu(i.name), a.serialize(u), l.deserialize(u), a.object instanceof Vn && (s[a.object.uuid] = a.object);
        const h = a.object[kt], d = r.get(h);
        d && (s[h.uuid] = d);
      } else
        a.clone ? l = a.clone(!0) : l = eu(i.name, a);
      s[l.uuid] = l, s[a.uuid] = l;
    }
    const o = new ja(n);
    for (const i of Object.values(this.nodes)) {
      let a = s[i.scoped.uuid];
      a instanceof nn ? (a.fill(t, s), a.eventDispatcher = o) : a[kt] || (a = bl(Ae(a), o));
      const l = new Proxy({ ...i.anchor }, {
        set: (h, d, f, p) => {
          if (f === Reflect.get(h, d))
            return !0;
          const m = Reflect.set(h, d, f, p);
          return m && o.dispatchEvent({ type: "graphModified", soure: o, nodes: [u] }), m;
        }
      }), u = {
        name: i.name,
        scoped: a,
        anchor: l,
        bounds: {},
        outs: {}
      };
      a._parentGraphNode = u;
      for (const [h, d] of Object.entries(i.bounds)) {
        const { node: f, type: p, field: m } = d, g = s[f.scoped.uuid];
        if (!g)
          throw Be.panic(`node[${f.scoped.uuid}] not found`);
        u.bounds[h] = { type: p, node: g, field: m };
      }
      for (const [h, d] of Object.entries(i.outs || {})) {
        const f = u.outs[h] || (u.outs[h] = []);
        for (const p of d) {
          const { node: m, type: g, field: b } = p, v = s[m.scoped.uuid];
          if (!v)
            throw Be.panic(`node[${m.scoped.uuid}] not found`);
          f.push({ node: v, type: g, field: b });
        }
      }
      o.nodes.push(u);
    }
    for (const i of o.nodes) {
      for (const a of Object.values(i.bounds)) {
        const l = o.nodes.find((u) => u.scoped.uuid === a.node.uuid);
        l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
      }
      for (const a of Object.values(i.outs))
        for (const l of a) {
          const u = o.nodes.find((h) => h.scoped.uuid === l.node.uuid);
          u || console.error(`node[${l.node.uuid}] not found!`), l.node = u;
        }
    }
    for (const i of o.nodes)
      o.applyNodeBounds(i);
    return o;
  }
  serialize(t) {
    const r = {
      isGraph: !0,
      nodes: []
    };
    for (const n of this.nodes) {
      t.nodes[n.scoped.uuid] || (t.nodes[n.scoped.uuid] = n.scoped.toJSON(t));
      const s = {};
      Object.entries(n.outs).forEach(([i, a]) => {
        s[i] = a.map((l) => ({ n: l.node.scoped.uuid, f: l.field, t: l.type }));
      });
      const o = {
        name: n.name,
        node: n.scoped.uuid,
        anchor: { ...n.anchor },
        bounds: Object.fromEntries(Object.entries(n.bounds).map((i) => [i[0], { t: i[1].type, n: i[1].node.scoped.uuid, f: i[1].field }])),
        outs: s
      };
      r.nodes.push(o);
    }
    return r;
  }
  deserialize(t, r, n) {
    if (!t || !t.isGraph)
      return;
    if (!Array.isArray(t.nodes))
      throw Be.panic("not node info found");
    this.clear();
    const s = { ...r, ...n };
    for (const o of t.nodes) {
      let i = r[o.node];
      if (!i)
        throw Be.panic(`node[${o.node}] not found`);
      i instanceof nn ? (i.fill(this.object, s), i.eventDispatcher = this) : i = bl(Ae(i), this);
      const a = new Proxy(o.anchor, {
        set: (u, h, d, f) => {
          if (d === Reflect.get(u, h))
            return !0;
          const p = Reflect.set(u, h, d, f);
          return p && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [l] }), p;
        }
      }), l = {
        name: o.name,
        scoped: i,
        anchor: a,
        bounds: {},
        outs: {}
      };
      i._parentGraphNode = l;
      for (const [u, h] of Object.entries(o.bounds)) {
        const { n: d, t: f, f: p } = h, m = r[d];
        if (!m)
          throw Be.panic(`node[${d}] not found`);
        l.bounds[u] = { type: f, node: m, field: p };
      }
      for (const [u, h] of Object.entries(o.outs || {})) {
        const d = l.outs[u] || (l.outs[u] = []);
        for (const f of h) {
          const { n: p, t: m, f: g } = f, b = r[p];
          if (!b)
            throw Be.panic(`node[${p}] not found`);
          d.push({ node: b, type: m, field: g });
        }
      }
      this.nodes.push(l);
    }
    for (const o of this.nodes) {
      for (const i of Object.values(o.bounds)) {
        const a = this.nodes.find((l) => l.scoped.uuid === i.node.uuid);
        a || console.error(`node[${i.node.uuid}] not found!`), i.node = a;
      }
      for (const i of Object.values(o.outs))
        for (const a of i) {
          const l = this.nodes.find((u) => u.scoped.uuid === a.node.uuid);
          l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
        }
    }
    for (const o of this.nodes)
      this.applyNodeBounds(o);
  }
  applyNodeBounds(t, r) {
    for (const [n, s] of Object.entries(t.bounds)) {
      if (r && !r.includes(n))
        continue;
      const { node: o, type: i, field: a } = s, l = o.outs[a || "$"];
      if (!l)
        throw Be.panic(`bound list not found for node[field=${n}]`);
      if (!l.find((m) => m.node === t && m.field === n))
        throw Be.panic(`bound slot not found for node[field=${n}]`);
      const h = o.scoped instanceof nn ? o.scoped.getObjectsExtended().out : o.scoped;
      let d = a ? h[a] : h;
      const f = t.scoped instanceof nn ? t.scoped.getObjectsExtended().in : t.scoped, p = f[n];
      if (typeof d == "object" && (d = d[kt] || d), d !== p) {
        if (i === 1) {
          typeof p == "object" && p.dispose && p.dispose(), f[n] = d;
          continue;
        }
        typeof d == "object" ? !p || p === null ? f[n] = d : typeof p.copy == "function" ? p.copy(d) : typeof d.clone == "function" ? f[n] = d.clone() : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d) : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d);
      }
    }
    t.scoped instanceof kn && (t.scoped.needsUpdate = !0, t.scoped instanceof hs && (t.scoped.uniformsNeedUpdate = !0));
  }
  applyNodePins(t, r, n) {
    if (n === "in")
      t.scoped instanceof kn ? (t.scoped.needsUpdate = !0, t.scoped instanceof hs && (t.scoped.uniformsNeedUpdate = !0)) : t.scoped instanceof nn && t.scoped.object instanceof Vn && (t.scoped.object.needsUpdate = !0);
    else {
      const s = t.outs[r];
      if (!s)
        return;
      for (const o of s)
        o.type === 1 ? this.applyNodePins(o.node, o.field, "in") : this.applyNodeBounds(o.node, [o.field]);
    }
  }
  addType(t, r, n, s) {
    return r ? /^[a-z][a-z0-9_]*$/i.test(r) ? t.scoped instanceof ui ? (s === "in" ? t.scoped.addInput : t.scoped.addOutput).call(t.scoped, r, n) ? !0 : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: `Failed to create field[${r}] as type[${n}]!` }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "It is not a ScriptNode!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Illegal name!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Empty name!" }), !1);
  }
  removeType(t, r, n) {
    if (!(t.scoped instanceof ui) || !(n === "in" ? t.scoped.removeInput : t.scoped.removeOutput).call(t.scoped, r))
      return !1;
    if (n === "in")
      this.disconnect({ node: t, field: r, io: n });
    else {
      const o = t.outs[r];
      if (o)
        for (const i of [...o])
          this.disconnect({ node: i.node, field: i.field });
    }
    return !0;
  }
}
const { getTypedArray: am } = xC, { createNodeFromType: tE } = t1;
class nE extends xr {
  constructor(t) {
    super(t);
    G(this, "_textures");
    G(this, "_listeners", {});
    G(this, "_nodes");
    G(this, "_nodesJSON");
  }
  load(t, r, n, s) {
    const o = this, i = this.path === "" ? po.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new Ks(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(l) {
      let u = null;
      try {
        u = JSON.parse(l);
      } catch (d) {
        s !== void 0 && s(d), console.error("THREE:ObjectLoader: Can't parse " + t + ".", d.message);
        return;
      }
      const h = u.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + t)), console.error("THREE.ObjectLoader: Can't load " + t);
        return;
      }
      o.parse(u, r);
    }, n, s);
  }
  async loadAsync(t, r) {
    const n = this, s = this.path === "" ? po.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new Ks(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const i = await o.loadAsync(t, r), a = JSON.parse(i), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + t);
    return await n.parseAsync(a);
  }
  parse(t, r) {
    this._nodesJSON = t.nodes;
    const n = this.parseAnimations(t.animations), s = this.parseShapes(t.shapes), o = this.parseGeometries(t.geometries, s), i = this.parseImages(t.images, function() {
      r !== void 0 && r(u);
    }), a = this.parseTextures(t.textures, i), l = this.parseMaterials(t.materials, a);
    if (t.listeners)
      for (const d of t.listeners) {
        const f = this.parseObject(d, o, l, a, n);
        this._listeners[f.uuid] = f;
      }
    const u = this.parseObject(t.object, o, l, a, n), h = this.parseSkeletons(t.skeletons, u);
    if (this.bindSkeletons(u, h), r !== void 0) {
      let d = !1;
      for (const f in i)
        if (i[f].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && r(u);
    }
    this._nodesJSON = null, u.traverse((d) => {
      d.userData.graph && new ja(d).deserialize(d.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const d of Object.values(this._nodes || {}))
      d.fill && d.fill(u, this._nodes || {}, this._textures || {});
    return u;
  }
  async parseAsync(t) {
    this._nodesJSON = t.nodes;
    const r = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes), s = this.parseGeometries(t.geometries, n), o = await this.parseImagesAsync(t.images), i = this.parseTextures(t.textures, o), a = this.parseMaterials(t.materials, i);
    if (t.listeners)
      for (const h of t.listeners) {
        const d = this.parseObject(h, s, a, i, r);
        this._listeners[d.uuid] = d;
      }
    const l = this.parseObject(t.object, s, a, i, r), u = this.parseSkeletons(t.skeletons, l);
    this.bindSkeletons(l, u), this._nodesJSON = null, l.traverse((h) => {
      h.userData.graph && new ja(h).deserialize(h.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const h of Object.values(this._nodes || {}))
      h.fill && h.fill(l, this._nodes || {}, this._textures || {});
    return l;
  }
  parseShapes(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0, s = t.length; n < s; n++) {
        const o = new bo().fromJSON(t[n]);
        r[o.uuid] = o;
      }
    return r;
  }
  parseSkeletons(t, r) {
    const n = {}, s = {};
    if (r.traverse(function(o) {
      o.isBone && (s[o.uuid] = o);
    }), t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = new wu();
        a.fromJSON(t[o], s), n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(t, r) {
    const n = {};
    if (t !== void 0) {
      const s = new rb();
      for (let o = 0, i = t.length; o < i; o++) {
        let a;
        const l = t[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = s.parse(l);
            break;
          default:
            l.type in im ? a = im[l.type].fromJSON(l, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(t, r) {
    const n = {};
    if (this._textures = r, t !== void 0) {
      const s = this.parseNodes(this._nodesJSON, r);
      this._nodes = s;
      const o = new Ia();
      o.setTextures(r), o.setNodes(s);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = s[l.uuid];
        u ? n[l.uuid] = u : n[l.uuid] = o.parse(l);
      }
    } else
      this._nodesJSON && (this._nodes = this.parseNodes(this._nodesJSON, r));
    return n;
  }
  parseAnimations(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0; n < t.length; n++) {
        const s = t[n], o = Tu.parse(s);
        r[o.uuid] = o;
      }
    return r;
  }
  parseImages(t, r) {
    const n = this, s = {};
    let o;
    function i(l) {
      return n.manager.itemStart(l), o.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
        return i(h);
      } else
        return l.data ? {
          data: am(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      const l = new ob(r);
      o = new Bf(l), o.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = t.length; u < h; u++) {
        const d = t[u], f = d.url;
        if (Array.isArray(f)) {
          const p = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const b = f[m], v = a(b);
            v !== null && (v instanceof HTMLImageElement ? p.push(v) : p.push(new da(v.data, v.width, v.height)));
          }
          s[d.uuid] = new Bi(p);
        } else {
          const p = a(d.url);
          s[d.uuid] = new Bi(p);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(t) {
    const r = this, n = {};
    let s;
    async function o(i) {
      if (typeof i == "string" && i) {
        const a = i, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : r.resourcePath + a;
        return await s.loadAsync(l);
      } else
        return i.data ? {
          data: am(i.type, i.data),
          width: i.width,
          height: i.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      s = new Bf(this.manager), s.setCrossOrigin(this.crossOrigin);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, f = u.length; d < f; d++) {
            const p = u[d], m = await o(p);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new da(m.data, m.width, m.height)));
          }
          n[l.uuid] = new Bi(h);
        } else {
          const h = await o(l.url);
          n[l.uuid] = new Bi(h);
        }
      }
    }
    return n;
  }
  parseTextures(t, r) {
    function n(o, i) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), i[o]);
    }
    const s = {};
    if (t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = t[o];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), r[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = r[a.image], u = l.data;
        let h;
        Array.isArray(u) ? (h = new ib(), u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new da() : h = new Vn(), u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = n(a.mapping, sE)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = n(a.wrap[0], cm), h.wrapT = n(a.wrap[1], cm)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, lm)), a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, lm)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), s[a.uuid] = h;
      }
    return s;
  }
  parseObject(t, r, n, s, o) {
    var m;
    function i(g) {
      return r[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", g), r[g];
    }
    function a(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const b = [];
          for (let v = 0, y = g.length; v < y; v++) {
            const x = g[v];
            n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), b.push(n[x]);
          }
          return b;
        }
        return n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), n[g];
      }
    }
    function l(g) {
      return s[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", g), s[g];
    }
    if (this._listeners[t.uuid]) {
      const g = this._listeners[t.uuid];
      if (t.children !== void 0) {
        const b = t.children;
        for (let v = 0; v < b.length; v++)
          g.add(this.parseObject(b[v], r, n, s, o));
      }
      return g;
    }
    const u = t.geometry ? i(t.geometry) : void 0, h = t.material ? a(t.material) : void 0;
    (u || h) && (t = { ...t, geometry: u, material: h });
    const d = ((m = t.userData) == null ? void 0 : m.extend) || t.type;
    if (d === "PositionalAudio2" && t.listener) {
      const g = this._listeners[t.listener];
      t = { ...t, listener: g };
    }
    const f = SS(d, t);
    switch (s1(d)) {
      case "Scene":
        t.background !== void 0 && (Number.isInteger(t.background) ? f.background = new Ve(t.background) : f.background = l(t.background)), t.environment !== void 0 && (f.environment = l(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? f.fog = new ab(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (f.fog = new cb(t.fog.color, t.fog.density)), t.fog.name !== "" && (f.fog.name = t.fog.name)), t.backgroundBlurriness !== void 0 && (f.backgroundBlurriness = t.backgroundBlurriness), t.backgroundIntensity !== void 0 && (f.backgroundIntensity = t.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        t.focus !== void 0 && (f.focus = t.focus), t.zoom !== void 0 && (f.zoom = t.zoom), t.filmGauge !== void 0 && (f.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (f.filmOffset = t.filmOffset), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        t.zoom !== void 0 && (f.zoom = t.zoom), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "SkinnedMesh":
        t.bindMode !== void 0 && (f.bindMode = t.bindMode), t.bindMatrix !== void 0 && f.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (f.skeleton = t.skeleton);
        break;
    }
    if (f.uuid = t.uuid, t.name !== void 0 && (f.name = t.name), t.matrix !== void 0 ? (f.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (f.matrixAutoUpdate = t.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (t.position !== void 0 && f.position.fromArray(t.position), t.rotation !== void 0 && f.rotation.fromArray(t.rotation), t.quaternion !== void 0 && f.quaternion.fromArray(t.quaternion), t.scale !== void 0 && f.scale.fromArray(t.scale)), t.up !== void 0 && f.up.fromArray(t.up), t.castShadow !== void 0 && (f.castShadow = t.castShadow), t.receiveShadow !== void 0 && (f.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (f.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (f.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (f.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && f.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (f.shadow.camera = this.parseObject(t.shadow.camera, r, n, s, o))), t.visible !== void 0 && (f.visible = t.visible), t.frustumCulled !== void 0 && (f.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (f.renderOrder = t.renderOrder), t.userData !== void 0 && (f.userData = t.userData), t.layers !== void 0 && (f.layers.mask = t.layers), t.children !== void 0) {
      const g = t.children;
      for (let b = 0; b < g.length; b++)
        f.add(this.parseObject(g[b], r, n, s, o));
    }
    if (t.animations !== void 0) {
      const g = t.animations;
      for (let b = 0; b < g.length; b++) {
        const v = g[b];
        f.animations.push(o[v]);
      }
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (f.autoUpdate = t.autoUpdate);
      const g = t.levels;
      for (let b = 0; b < g.length; b++) {
        const v = g[b], y = f.getObjectByProperty("uuid", v.object);
        y !== void 0 && f.addLevel(y, v.distance, v.hysteresis);
      }
    }
    return f.deserialize && f.deserialize(t), f;
  }
  bindSkeletons(t, r) {
    Object.keys(r).length !== 0 && t.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const s = r[n.skeleton];
        s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix);
      }
    });
  }
  parseNodes(t, r) {
    if (t !== void 0) {
      const n = {}, s = new Ia();
      for (const i of t) {
        const { uuid: a, type: l, _inst: u } = i;
        if (/Material$/.test(l)) {
          const f = s.parse(i);
          f.uuid = a, n[a] = f;
          continue;
        }
        const d = u ? eu(u) : tE(l);
        n[a] = d, n[a].uuid = a;
      }
      const o = { nodes: n, textures: r };
      for (const i of t) {
        i.meta = o;
        const a = n[i.uuid];
        a.isMaterial || (a.deserialize(i), delete i.meta);
      }
      return n;
    }
    return {};
  }
}
const sE = {
  UVMapping: lb,
  CubeReflectionMapping: ub,
  CubeRefractionMapping: hb,
  EquirectangularReflectionMapping: Im,
  EquirectangularRefractionMapping: db,
  CubeUVReflectionMapping: fb
}, cm = {
  RepeatWrapping: Zs,
  ClampToEdgeWrapping: mo,
  MirroredRepeatWrapping: Om
}, lm = {
  NearestFilter: Hs,
  NearestMipmapNearestFilter: Rm,
  NearestMipmapLinearFilter: Lm,
  LinearFilter: fo,
  LinearMipmapNearestFilter: Fm,
  LinearMipmapLinearFilter: xo
};
async function rE(c) {
  window.import || (window.import = new Function("path", "return import(path)"));
  try {
    return await window.import(c);
  } catch (e) {
    console.error(e);
  }
}
const um = {
  resolution: "auto",
  toneMapping: pm,
  toneMappingExposure: 1,
  shadowMap: {
    enabled: !0,
    type: pb
  },
  vrEnable: !1
};
class hE extends M.EventDispatcher {
  constructor(t) {
    super();
    G(this, "renderer");
    G(this, "clock");
    G(this, "size", { width: 2048, height: 2048 });
    G(this, "uuid", M.MathUtils.generateUUID());
    G(this, "defaultScene", new ZA());
    G(this, "currentScene");
    G(this, "currentCamera");
    G(this, "defaultCamera");
    // vr
    G(this, "vrSession");
    /** left, right */
    G(this, "hands", []);
    G(this, "handsConllisionMap", /* @__PURE__ */ new Set());
    G(this, "working", !1);
    // for app
    G(this, "settings", { ...um });
    G(this, "scenes", []);
    G(this, "spawns");
    this.context = t, Object.assign(sn, {
      navigateTo: this.navigateTo.bind(this),
      setCamera: this.setCamera.bind(this),
      spawn: this.createObjectFromSpawn.bind(this)
    }), this.renderer = new M.WebGLRenderer({
      canvas: this.context,
      antialias: !0
    }), this.renderer.outputColorSpace = M.SRGBColorSpace, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.autoUpdate = !0, this.renderer.shadowMap.type = M.PCFSoftShadowMap, this.renderer.autoClear = !1, this.renderer.toneMapping = M.ACESFilmicToneMapping, this.renderer.setClearColor(16777215), sn.gpuComputeRender = new PA(CS, ES, this.renderer), this.clock = new M.Clock(), this.currentScene = this.defaultScene, this.defaultCamera = new M.PerspectiveCamera(50, 1, 1e-3, 1e3), this.defaultCamera.name = "Perspective", this.defaultCamera.position.set(4, 3, 8), this.defaultCamera.lookAt(0, 0, 0);
    const r = this.currentScene.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.currentCamera = r, this.resize(this.size.width, this.size.height, 1);
  }
  resize(t, r, n) {
    if (!this.context)
      return;
    const s = Math.max(n, 1), o = t / r;
    this.size.width = t * s, this.size.height = r * s, this.renderer.setSize(this.size.width, this.size.height, !1), this.currentCamera && (this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = o, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / o, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix()));
  }
  navigateTo(t) {
    const r = this.scenes.find((s) => s.uuid === t || s.name === t);
    if (!r) {
      console.error(`Scene[${t}] not found`);
      return;
    }
    if (this.currentScene === r)
      return;
    this.currentScene && this.currentScene.deactive(), this.currentScene = r, this.currentScene.active();
    const n = r.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.setCamera(n), this.settings.vrEnable && (this.currentScene.getObjectByName("vr-controller0") || this.setupVr(r), this.vrSession || this.startVR());
  }
  createObjectFromSpawn(t) {
    if (!this.spawns)
      return;
    const r = this.spawns.children.find((n) => n.name === t);
    if (r)
      return Nb(r, !0, this.spawns);
  }
  setCamera(t) {
    if (this.currentCamera !== t && (this.currentCamera = t, this.currentCamera)) {
      const r = this.size.width / this.size.height;
      this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = r, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / r, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix());
    }
  }
  async load(t) {
    const r = new nE(), s = await (await fetch(t)).json();
    if (s.project.plugins)
      try {
        const l = await Promise.all(s.project.plugins.map((u) => rE(u)));
        for (const u in l) {
          l[u].pluginInstall(
            Je,
            G1,
            Fs,
            bc
          );
          const d = s.project.plugins[u].split("/").pop();
          Be.notice(`Plugin ${d} has been installed successfully!`);
        }
      } catch (l) {
        console.error(l);
      }
    const o = await r.parseAsync(s), { project: i } = s;
    i.world && (_s(this.settings), Object.assign(this.settings, { ...um, ...i.world })), this.settings.resolution || (this.settings.resolution = "auto"), this.settings.vrEnable && (this.renderer.xr.enabled = !0), this.scenes.length = 0;
    for (const l of o.children)
      l.name === "[Spawns]" ? this.spawns = l : this.scenes.push(l);
    const a = this.scenes.find((l) => l.name === "index") || this.scenes[0] || this.defaultScene;
    this.navigateTo(a.uuid);
  }
  setupVr(t) {
    const r = this.renderer.xr.getController(0);
    r.name = "vr-controller0", t.add(r);
    const n = this.renderer.xr.getController(1);
    t.add(n);
    const s = new $A(), o = this.renderer.xr.getControllerGrip(0);
    o.add(s.createControllerModel(o)), t.add(o);
    const i = this.renderer.xr.getHand(0);
    this.hands[0] || (this.hands[0] = new jp(i), this.hands[0].name = "left"), i.add(this.hands[0]), t.add(i);
    const a = this.renderer.xr.getControllerGrip(1);
    a.add(s.createControllerModel(a)), t.add(a);
    const l = this.renderer.xr.getHand(1);
    this.hands[1] || (this.hands[1] = new jp(l), this.hands[1].name = "right"), l.add(this.hands[1]), t.add(l);
  }
  async startVR() {
    if (!navigator.xr || !await navigator.xr.isSessionSupported("immersive-vr"))
      return Be.error("Your browser is not currently supported VR!"), !1;
    if (this.vrSession)
      return Be.warn("VR has already been started!"), !1;
    let r;
    const n = new Promise((i) => r = i), s = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
    this.vrSession = await navigator.xr.requestSession("immersive-vr", s), await this.renderer.xr.setSession(this.vrSession);
    const o = () => {
      this.vrSession && (this.vrSession.removeEventListener("end", o), this.vrSession = null, this.currentCamera = this.defaultCamera, Be.debug("VR has been exited successfully!")), r(!0);
    };
    return this.vrSession.addEventListener("end", o), this.currentCamera = this.defaultCamera, n;
  }
  stopVR() {
    this.vrSession && this.vrSession.end();
  }
  updateVR() {
    this.renderer.xr.updateCamera(this.currentCamera);
    for (const t of this.hands)
      if (t)
        for (const r of this.currentScene.children) {
          if (r.bodyType === Nc.Ghost)
            continue;
          const n = `${t.name}:${r.uuid}`;
          t.intersectBoxObject(r) ? this.handsConllisionMap.has(n) || (this.handsConllisionMap.add(n), r.dispatchEvent({ type: "onCollisionEnter", target: t })) : this.handsConllisionMap.has(n) && (this.handsConllisionMap.delete(n), r.dispatchEvent({ type: "onCollisionLeave", target: t }));
        }
  }
  render(t, r) {
    sn.delta = t, sn.now = r, this.currentScene.update(this.renderer, this.currentCamera, t, r), qr.update(), this.renderer.xr.enabled && this.updateVR(), this.renderer.render(this.currentScene, this.currentCamera);
  }
  async run() {
    if (this.working)
      throw Be.panic("already working");
    this.working = !0, this.clock.start();
    const t = (r, n) => {
      if (!this.working) {
        this.renderer.setAnimationLoop(null);
        return;
      }
      const s = this.clock.getDelta(), o = this.clock.oldTime;
      this.render(s, o);
    };
    this.renderer.setAnimationLoop(t);
  }
  dispose() {
    this.clock.stop(), this.renderer.dispose();
  }
}
const dE = "[Spawns]", fE = "__isHidden";
export {
  CA as AsyncFunction,
  iM as AudioListener2,
  PS as BezierLine,
  ka as BezierLineMaterial,
  US as Box,
  fE as BuiltinObjectKeyHidden,
  dE as BuiltinSceneSpawns,
  DS as Capsule,
  TA as Character,
  zS as Cone,
  BS as Cylinder,
  z1 as EffectNode,
  gE as EventDispatcher,
  Ur as EventListenerNode,
  Hd as Model3D,
  _A as Particles,
  o1 as PhysicalScene,
  WS as Plane,
  aM as PositionalAudio2,
  U1 as Reflector,
  Dn as ScriptBlockNode,
  ui as ScriptNode,
  JS as ShapeArc,
  qS as ShapeCircle,
  $S as ShapeRounded,
  XS as ShapeSquare,
  HS as ShapeTriangle,
  AA as SkyBox,
  kS as Sphere,
  wA as StaticMesh,
  oM as Text3D,
  b1 as TextMesh,
  GS as Torus,
  VS as TorusKnot,
  hE as U3JsRuntime,
  Up as WaterPlane,
  B1 as addEffectNode,
  Nb as clone,
  xb as cloneTracingBegin,
  bb as cloneTracingEnd,
  Be as logger,
  bl as nodeProxy,
  go as objectsTransferred,
  Ga as textMembers
};
