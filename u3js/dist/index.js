var Yx = Object.defineProperty;
var Kx = (c, e, t) => e in c ? Yx(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var G = (c, e, t) => (Kx(c, typeof e != "symbol" ? e + "" : e, t), t);
import * as M from "three";
import { Color as je, Vector2 as wt, Vector3 as ve, Vector4 as pt, Matrix3 as Ns, Matrix4 as Ge, EventDispatcher as Ha, MathUtils as Zt, LinearSRGBColorSpace as En, SRGBColorSpace as yn, StaticDrawUsage as Zx, InterleavedBuffer as bm, InterleavedBufferAttribute as Gs, DynamicDrawUsage as gu, InstancedInterleavedBuffer as Ma, DepthTexture as Nm, NearestFilter as Vs, LessCompare as Qx, WebGPUCoordinateSystem as eb, ShaderMaterial as hs, NoColorSpace as wm, Material as zn, WebGLCubeRenderTarget as tb, BoxGeometry as Xa, BackSide as yu, NoBlending as nb, Mesh as qt, Scene as $a, LinearMipmapLinearFilter as bo, LinearFilter as uo, CubeCamera as sb, RenderTarget as rb, sRGBEncoding as ob, LinearEncoding as ib, Float16BufferAttribute as ab, REVISION as cb, TangentSpaceNormalMap as jf, ObjectSpaceNormalMap as lb, NoToneMapping as Wf, LinearToneMapping as ub, ReinhardToneMapping as hb, CineonToneMapping as db, ACESFilmicToneMapping as Tm, FramebufferTexture as Sm, UnsignedIntType as fb, DepthFormat as pb, PointLight as Zo, DirectionalLight as gi, SpotLight as yi, AmbientLight as vu, HemisphereLight as _m, Loader as wr, FileLoader as qs, PointsMaterial as xu, LineBasicMaterial as bu, LineDashedMaterial as Mm, MeshNormalMaterial as mb, MeshBasicMaterial as An, MeshLambertMaterial as Am, MeshPhongMaterial as ga, MeshStandardMaterial as Gn, MeshPhysicalMaterial as As, SpriteMaterial as gb, MaterialLoader as vi, ObjectLoader as yb, Object3D as vn, BufferAttribute as ro, BufferGeometry as Jn, Box3 as er, InstancedBufferGeometry as Cm, Float32BufferAttribute as gn, WireframeGeometry as vb, Sphere as xi, UniformsLib as oo, ShaderLib as as, UniformsUtils as tr, Line3 as xb, CubicBezierCurve3 as bb, PerspectiveCamera as Tr, OrthographicCamera as qa, CapsuleGeometry as Em, ConeGeometry as Nb, CylinderGeometry as wb, SphereGeometry as Ja, TorusGeometry as Tb, TorusKnotGeometry as Sb, ExtrudeGeometry as Rm, PlaneGeometry as Ar, ShapePath as Nu, Shape as No, Path as _b, MeshDepthMaterial as Mb, RGBADepthPacking as Ab, MeshDistanceMaterial as Cb, ShaderChunk as Lm, DoubleSide as wu, InstancedBufferAttribute as Fm, FrontSide as Om, Texture as kn, AudioListener as Eb, PositionalAudio as Rb, AudioLoader as Lb, TrianglesDrawMode as Fb, TriangleFanDrawMode as Pl, TriangleStripDrawMode as Im, LoaderUtils as ho, Quaternion as dr, InstancedMesh as Ob, TextureLoader as Tu, ImageBitmapLoader as Ib, RepeatWrapping as Js, PropertyBinding as Qo, SkinnedMesh as Pm, LineSegments as Pb, Line as Dm, LineLoop as Db, Points as Um, Group as io, Skeleton as Su, AnimationClip as _u, Bone as Dl, InterpolateLinear as zm, ColorManagement as Hf, NearestMipmapNearestFilter as Bm, LinearMipmapNearestFilter as km, NearestMipmapLinearFilter as Gm, ClampToEdgeWrapping as fo, MirroredRepeatWrapping as Vm, InterpolateDiscrete as Ub, VectorKeyframeTrack as Ul, NumberKeyframeTrack as zl, QuaternionKeyframeTrack as Bl, Interpolant as zb, Curve as Bb, EquirectangularReflectionMapping as jm, Uint16BufferAttribute as kb, Euler as ws, AnimationMixer as Gb, LoopRepeat as Vb, LoopOnce as jb, Plane as kl, WebGLRenderTarget as Mu, HalfFloatType as Wm, PMREMGenerator as Wb, AdditiveBlending as Hb, Camera as Xb, RGBAFormat as Xf, DataTexture as ya, FloatType as $f, BufferGeometryLoader as $b, LoadingManager as qb, ImageLoader as qf, Source as ji, CubeTexture as Jb, Fog as Yb, FogExp2 as Kb, UVMapping as Zb, CubeReflectionMapping as Qb, CubeRefractionMapping as eN, EquirectangularRefractionMapping as tN, CubeUVReflectionMapping as nN, PCFSoftShadowMap as sN } from "three";
import { EventDispatcher as OE } from "three";
import { computeBoundsTree as rN, disposeBoundsTree as oN, acceleratedRaycast as iN } from "three-mesh-bvh";
const Gl = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, ut = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, aN = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
}, Yr = ["fragment", "vertex"], Vl = ["setup", "analyze", "generate"], Hm = [...Yr, "compute"], Ya = ["x", "y", "z", "w"];
function Ka(c) {
  let e = "{";
  c.isNode === !0 && (e += `uuid:"${c.uuid}"`);
  for (const { property: t, index: r, childNode: n } of ei(c)) {
    let s = Ka(n);
    s.includes(",") || (s = s.slice(s.indexOf('"'), s.indexOf("}"))), e += `,${t}${r !== void 0 ? "/" + r : ""}:${s}`;
  }
  return e += "}", e;
}
function* ei(c, e = !1) {
  for (const t in c) {
    if (t.startsWith("_") === !0)
      continue;
    const r = c[t];
    if (Array.isArray(r) === !0)
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
    else if (r && r.isNode === !0)
      yield { property: t, childNode: r };
    else if (typeof r == "object")
      for (const n in r) {
        const s = r[n];
        s && (s.isNode === !0 || e && typeof s.toJSON == "function") && (yield { property: t, index: n, childNode: s });
      }
  }
}
function js(c) {
  if (c == null)
    return null;
  const e = typeof c;
  return c.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : c.isVector2 === !0 ? "vec2" : c.isVector3 === !0 ? "vec3" : c.isVector4 === !0 ? "vec4" : c.isMatrix3 === !0 ? "mat3" : c.isMatrix4 === !0 ? "mat4" : c.isColor === !0 ? "color" : c instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function Au(c, ...e) {
  const t = c ? c.slice(-4) : void 0;
  return e.length === 1 && (t === "vec2" ? e = [e[0], e[0]] : t === "vec3" ? e = [e[0], e[0], e[0]] : t === "vec4" && (e = [e[0], e[0], e[0], e[0]])), c === "color" ? new je(...e) : t === "vec2" ? new wt(...e) : t === "vec3" ? new ve(...e) : t === "vec4" ? new pt(...e) : t === "mat3" ? new Ns(...e) : t === "mat4" ? new Ge(...e) : c === "bool" ? e[0] || !1 : c === "float" || c === "int" || c === "uint" ? e[0] || 0 : c === "string" ? e[0] || "" : c === "ArrayBuffer" ? Eu(e[0]) : null;
}
function Cu(c) {
  let e = "";
  const t = new Uint8Array(c);
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function Eu(c) {
  return Uint8Array.from(atob(c), (e) => e.charCodeAt(0)).buffer;
}
const cN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayBufferToBase64: Cu,
  base64ToArrayBuffer: Eu,
  getCacheKey: Ka,
  getNodeChildren: ei,
  getValueFromType: Au,
  getValueType: js
}, Symbol.toStringTag, { value: "Module" })), jl = /* @__PURE__ */ new Map();
let lN = 0, uN = class extends Ha {
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = ut.NONE, this.updateBeforeType = ut.NONE, this.uuid = Zt.generateUUID(), this.isNode = !0, Object.defineProperty(this, "id", { value: lN++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    for (const { childNode: e } of ei(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const t of this.getChildren())
      t.traverse(e);
  }
  getCacheKey() {
    return Ka(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    for (const r of this.getChildren())
      t["_node" + r.id] = r;
    return null;
  }
  construct(e) {
    return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."), this.setup(e);
  }
  analyze(e) {
    const t = e.getDataFromNode(this);
    if (t.dependenciesCount = t.dependenciesCount === void 0 ? 1 : t.dependenciesCount + 1, t.dependenciesCount === 1) {
      const r = e.getNodeProperties(this);
      for (const n of Object.values(r))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    if (r && r.isNode === !0)
      return r.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const r = this.getShared(e);
    if (this !== r)
      return r.build(e, t);
    e.addNode(this), e.addChain(this);
    let n = null;
    const s = e.getBuildStage();
    if (s === "setup") {
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0 || e.context.tempRead === !1) {
        const i = e.stack.nodes.length;
        o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length !== i && (o.outputNode = e.stack);
        for (const a of Object.values(o))
          a && a.isNode === !0 && a.build(e);
      }
    } else if (s === "analyze")
      this.analyze(e);
    else if (s === "generate")
      if (this.generate.length === 1) {
        const i = this.getNodeType(e), a = e.getDataFromNode(this);
        n = a.snippet, n === void 0 && (n = this.generate(e) || "", a.snippet = n), n = e.format(n, i, t);
      } else
        n = this.generate(e, t) || "";
    return e.removeChain(this), n;
  }
  getSerializeChildren() {
    return ei(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(), r = {};
    for (const { property: n, index: s, childNode: o } of t)
      s !== void 0 ? (r[n] === void 0 && (r[n] = Number.isInteger(s) ? [] : {}), r[n][s] = o.toJSON(e.meta).uuid) : r[n] = o.toJSON(e.meta).uuid;
    Object.keys(r).length > 0 && (e.inputNodes = r);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const r in e.inputNodes)
        if (Array.isArray(e.inputNodes[r])) {
          const n = [];
          for (const s of e.inputNodes[r])
            n.push(t[s]);
          this[r] = n;
        } else if (typeof e.inputNodes[r] == "object") {
          const n = {};
          for (const s in e.inputNodes[r]) {
            const o = e.inputNodes[r][s];
            n[s] = t[o];
          }
          this[r] = n;
        } else {
          const n = e.inputNodes[r];
          this[r] = t[n];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: r } = this, n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let s = e.nodes[t];
    s === void 0 && (s = {
      uuid: t,
      type: r,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, n !== !0 && (e.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
    if (n) {
      const i = o(e.textures), a = o(e.images), l = o(e.nodes);
      i.length > 0 && (s.textures = i), a.length > 0 && (s.images = a), l.length > 0 && (s.nodes = l);
    }
    return s;
  }
};
const Fe = uN;
function re(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node class ${c} is not a class`);
  if (jl.has(c))
    throw new Error(`Redefinition of node class ${c}`);
  jl.set(c, e), e.type = c;
}
function Wl(c) {
  const e = jl.get(c);
  if (e !== void 0)
    return new e();
}
class Xm extends Fe {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node.build(e), r = this.indexNode.build(e, "uint");
    return `${t}[ ${r} ]`;
  }
}
const Za = Xm;
re("ArrayElementNode", Xm);
class $m extends Fe {
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let r = null;
    for (const n of this.convertTo.split("|"))
      (r === null || e.getTypeLength(t) === e.getTypeLength(n)) && (r = n);
    return r;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const r = this.node, n = this.getNodeType(e), s = r.build(e, n);
    return e.format(s, n, t);
  }
}
const Qa = $m;
re("ConvertNode", $m);
class qm extends Fe {
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).dependenciesCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, t)), s = e.getDataFromNode(this);
      if (e.context.tempRead !== !1 && s.propertyName !== void 0)
        return e.format(s.propertyName, n, t);
      if (e.context.tempWrite !== !1 && n !== "void" && t !== "void" && this.hasDependencies(e)) {
        const o = super.build(e, n), i = e.getVarFromNode(this, null, n), a = e.getPropertyName(i);
        return e.addLineFlowCode(`${a} = ${o}`), s.snippet = o, s.propertyName = a, e.format(s.propertyName, n, t);
      }
    }
    return super.build(e, t);
  }
}
const Tt = qm;
re("TempNode", qm);
class Jm extends Tt {
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, r) => t + e.getTypeLength(r.getNodeType(e)), 0));
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.nodes, s = e.getPrimitiveType(r), o = [];
    for (const a of n) {
      let l = a.build(e);
      const u = e.getPrimitiveType(a.getNodeType(e));
      u !== s && (l = e.format(l, u, s)), o.push(l);
    }
    const i = `${e.getType(r)}( ${o.join(", ")} )`;
    return e.format(i, r, t);
  }
}
const Ym = Jm;
re("JoinNode", Jm);
const hN = Ya.join("");
class Km extends Fe {
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(Ya.indexOf(t) + 1, e);
    return e;
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length);
  }
  generate(e, t) {
    const r = this.node, n = e.getTypeLength(r.getNodeType(e));
    let s = null;
    if (n > 1) {
      let o = null;
      this.getVectorLength() >= n && (o = e.getTypeFromLength(this.getVectorLength()));
      const a = r.build(e, o);
      this.components.length === n && this.components === hN.slice(0, this.components.length) ? s = e.format(a, o, t) : s = e.format(`${a}.${this.components}`, this.getNodeType(e), t);
    } else
      s = r.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
const Aa = Km;
re("SplitNode", Km);
class Zm extends Tt {
  constructor(e, t, r) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = r;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: r, targetNode: n } = this, s = this.getNodeType(e), o = e.getTypeFromLength(r.length), i = n.build(e, o), a = t.build(e, s), l = e.getTypeLength(s), u = [];
    for (let h = 0; h < l; h++) {
      const d = Ya[h];
      d === r[0] ? (u.push(i), h += r.length - 1) : u.push(a + "." + d);
    }
    return `${e.getType(s)}( ${u.join(", ")} )`;
  }
}
const Qm = Zm;
re("SetNode", Zm);
class eg extends Fe {
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? js(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = js(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = Cu(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? Au(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const Ru = eg;
re("InputNode", eg);
class tg extends Ru {
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.getConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const r = this.getNodeType(e);
    return e.format(this.generateConst(e), r, t);
  }
}
const Ln = tg;
re("ConstNode", tg);
let po = null;
const Kr = /* @__PURE__ */ new Map();
function V(c, e) {
  if (Kr.has(c))
    throw new Error(`Redefinition of node element ${c}`);
  if (typeof e != "function")
    throw new Error(`Node element ${c} is not a function`);
  Kr.set(c, e);
}
const Jf = (c) => c.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), ng = {
  setup(c, e) {
    const t = e.shift();
    return c(bi(t), ...e);
  },
  get(c, e, t) {
    if (typeof e == "string" && c[e] === void 0) {
      if (c.isStackNode !== !0 && e === "assign")
        return (...r) => po.assign(t, ...r);
      if (Kr.has(e)) {
        const r = Kr.get(e);
        return c.isStackNode ? (...n) => t.add(r(...n)) : (...n) => r(t, ...n);
      } else {
        if (e === "self")
          return c;
        if (e.endsWith("Assign") && Kr.has(e.slice(0, e.length - 6))) {
          const r = Kr.get(e.slice(0, e.length - 6));
          return c.isStackNode ? (...n) => t.assign(n[0], r(...n)) : (...n) => t.assign(r(t, ...n));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = Jf(e), Me(new Aa(t, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = Jf(e.slice(3).toLowerCase()), e = e.split("").sort().join(""), (r) => Me(new Qm(c, e, r));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), Me(new Aa(c, e));
          if (/^\d+$/.test(e) === !0)
            return Me(new Za(t, new Ln(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(c, e, t);
  },
  set(c, e, t, r) {
    return typeof e == "string" && c[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (r[e].assign(t), !0) : Reflect.set(c, e, t, r);
  }
}, Yc = /* @__PURE__ */ new WeakMap(), Yf = /* @__PURE__ */ new WeakMap(), dN = function(c, e = null) {
  const t = js(c);
  if (t === "node") {
    let r = Yc.get(c);
    return r === void 0 && (r = new Proxy(c, ng), Yc.set(c, r), Yc.set(r, r)), r;
  } else {
    if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string")
      return Me(Hl(c, e));
    if (t === "shader")
      return Ve(c);
  }
  return c;
}, fN = function(c, e = null) {
  for (const t in c)
    c[t] = Me(c[t], e);
  return c;
}, pN = function(c, e = null) {
  const t = c.length;
  for (let r = 0; r < t; r++)
    c[r] = Me(c[r], e);
  return c;
}, mN = function(c, e = null, t = null, r = null) {
  const n = (s) => Me(r !== null ? Object.assign(s, r) : s);
  return e === null ? (...s) => n(new c(...gr(s))) : t !== null ? (t = Me(t), (...s) => n(new c(e, ...gr(s), t))) : (...s) => n(new c(e, ...gr(s)));
}, gN = function(c, ...e) {
  return Me(new c(...gr(e)));
};
class yN extends Fe {
  constructor(e, t) {
    super(), this.shaderNode = e, this.inputNodes = t;
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  call(e) {
    const { shaderNode: t, inputNodes: r } = this;
    if (t.layout) {
      let o = Yf.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), Yf.set(e.constructor, o));
      let i = o.get(t);
      return i === void 0 && (i = Me(e.buildFunctionNode(t)), o.set(t, i)), Me(i.call(r));
    }
    const n = t.jsFunc, s = r !== null ? n(r, e.stack, e) : n(e.stack, e);
    return Me(s);
  }
  setup(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    return r === null ? this.call(e).build(e, t) : super.generate(e, t);
  }
}
class vN extends Fe {
  constructor(e) {
    super(), this.jsFunc = e, this.layout = null;
  }
  get isArrayInput() {
    return /^\(\s+?\[/.test(this.jsFunc.toString());
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return bi(e), Me(new yN(this, e));
  }
  setup() {
    return this.call();
  }
}
const xN = [!1, !0], bN = [0, 1, 2, 3], NN = [-1, -2], sg = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], Lu = /* @__PURE__ */ new Map();
for (const c of xN)
  Lu.set(c, new Ln(c));
const Fu = /* @__PURE__ */ new Map();
for (const c of bN)
  Fu.set(c, new Ln(c, "uint"));
const Ou = new Map([...Fu].map((c) => new Ln(c.value, "int")));
for (const c of NN)
  Ou.set(c, new Ln(c, "int"));
const ec = new Map([...Ou].map((c) => new Ln(c.value)));
for (const c of sg)
  ec.set(c, new Ln(c));
for (const c of sg)
  ec.set(-c, new Ln(-c));
const tc = { bool: Lu, uint: Fu, ints: Ou, float: ec }, Kf = new Map([...Lu, ...ec]), Hl = (c, e) => Kf.has(c) ? Kf.get(c) : c.isNode === !0 ? c : new Ln(c, e), wN = (c) => {
  try {
    return c.getNodeType();
  } catch {
    return;
  }
}, mt = function(c, e = null) {
  return (...t) => {
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(c) && t.every((n) => typeof n != "object")) && (t = [Au(c, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return Me(e.get(t[0]));
    if (t.length === 1) {
      const n = Hl(t[0], c);
      return wN(n) === c ? Me(n) : Me(new Qa(n, c));
    }
    const r = t.map((n) => Hl(n));
    return Me(new Ym(r, c));
  };
}, rg = (c) => c != null ? c.nodeType || c.convertTo || (typeof c == "string" ? c : null) : null;
function mr(c) {
  return new Proxy(new vN(c), ng);
}
const Me = (c, e = null) => (
  /* new */
  dN(c, e)
), bi = (c, e = null) => new fN(c, e), gr = (c, e = null) => new pN(c, e), J = (...c) => new mN(...c), ue = (...c) => new gN(...c), TN = (c) => (console.warn("TSL: shader() is deprecated. Use tslFn() instead."), new mr(c)), Ve = (c) => {
  const e = new mr(c), t = (...r) => {
    let n;
    return bi(r), r[0] && r[0].isNode ? n = [...r] : n = r[0], e.call(n);
  };
  return t.shaderNode = e, t.setLayout = (r) => (e.setLayout(r), t), t;
};
re("ShaderNode", mr);
const ti = (c) => po = c, Iu = () => po, ur = (...c) => po.if(...c);
function og(c) {
  return po && po.add(c), c;
}
V("append", og);
const ig = new mt("color"), Se = new mt("float", tc.float), Ca = new mt("int", tc.int), ag = new mt("uint", tc.uint), cg = new mt("bool", tc.bool), rt = new mt("vec2"), lg = new mt("ivec2"), ug = new mt("uvec2"), hg = new mt("bvec2"), Ce = new mt("vec3"), dg = new mt("ivec3"), fg = new mt("uvec3"), pg = new mt("bvec3"), st = new mt("vec4"), mg = new mt("ivec4"), gg = new mt("uvec4"), yg = new mt("bvec4"), Ss = new mt("mat3"), vg = new mt("imat3"), xg = new mt("umat3"), bg = new mt("bmat3"), Pu = new mt("mat4"), Ng = new mt("imat4"), wg = new mt("umat4"), Tg = new mt("bmat4"), Sg = (c = "") => Me(new Ln(c, "string")), _g = (c) => Me(new Ln(c, "ArrayBuffer"));
V("color", ig);
V("float", Se);
V("int", Ca);
V("uint", ag);
V("bool", cg);
V("vec2", rt);
V("ivec2", lg);
V("uvec2", ug);
V("bvec2", hg);
V("vec3", Ce);
V("ivec3", dg);
V("uvec3", fg);
V("bvec3", pg);
V("vec4", st);
V("ivec4", mg);
V("uvec4", gg);
V("bvec4", yg);
V("mat3", Ss);
V("imat3", vg);
V("umat3", xg);
V("bmat3", bg);
V("mat4", Pu);
V("imat4", Ng);
V("umat4", wg);
V("bmat4", Tg);
V("string", Sg);
V("arrayBuffer", _g);
const Mg = J(Za), Ag = (c, e) => Me(new Qa(Me(c), e)), SN = (c, e) => Me(new Aa(Me(c), e));
V("element", Mg);
V("convert", Ag);
class Du extends Fe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: t, name: r } = this, n = e.getVarFromNode(this, r, e.getVectorType(this.getNodeType(e))), s = e.getPropertyName(n), o = t.build(e, n.type);
    return e.addLineFlowCode(`${s} = ${o}`), s;
  }
}
const Cg = Du, mo = J(Du);
V("temp", mo);
V("toVar", (...c) => mo(...c).append());
re("VarNode", Du);
class Uu extends Ru {
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.getUniformHash(e);
    let s = e.getNodeFromHash(n);
    s === void 0 && (e.setHashNode(this, n), s = this);
    const o = s.getInputType(e), i = e.getUniformFromNode(s, o, e.shaderStage, e.context.label), a = e.getPropertyName(i);
    return e.context.label !== void 0 && delete e.context.label, e.format(a, r, t);
  }
}
const nt = Uu, Ft = (c, e) => {
  const t = rg(e || c), r = c && c.isNode === !0 ? c.node && c.node.value || c.value : c;
  return Me(new Uu(r, t));
};
re("UniformNode", Uu);
class Eg extends nt {
  constructor(e = []) {
    super(), this.isArrayUniformNode = !0, this.nodes = e;
  }
  getNodeType(e) {
    return this.nodes[0].getNodeType(e);
  }
}
const Rg = Eg;
re("ArrayUniformNode", Eg);
class zu extends Tt {
  constructor(e, t) {
    super(), this.targetNode = e, this.sourceNode = t;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, t) {
    return t !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  generate(e, t) {
    const r = this.targetNode, n = this.sourceNode, s = r.getNodeType(e), o = r.build(e), i = n.build(e, s), a = `${o} = ${i}`;
    if (t === "void") {
      e.addLineFlowCode(a);
      return;
    } else
      return n.getNodeType(e) === "void" ? (e.addLineFlowCode(a), o) : e.format(a, s, t);
  }
}
const _N = zu, Lg = J(zu);
re("AssignNode", zu);
V("assign", Lg);
class Bu extends Fe {
  constructor(e, t = null) {
    super(), this.node = e, this.name = t, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: r } = this, n = this.getNodeType(e), s = e.getVaryingFromNode(this, n);
    s.needsInterpolation || (s.needsInterpolation = e.shaderStage === "fragment"), t !== null && (s.name = t);
    const o = e.getPropertyName(s, Gl.VERTEX);
    return e.flowNodeFromShaderStage(Gl.VERTEX, r, n, o), e.getPropertyName(s);
  }
}
const Fg = Bu, ct = J(Bu);
V("varying", ct);
re("VaryingNode", Bu);
class ku extends Fe {
  constructor(e, t = null) {
    super(t), this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (t === null) {
      const r = this.getAttributeName(e);
      if (e.hasGeometryAttribute(r)) {
        const n = e.geometry.getAttribute(r);
        t = e.getTypeFromAttribute(n);
      } else
        t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), r = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t), o = e.getTypeFromAttribute(s), i = e.getAttribute(t, o);
      return e.shaderStage === "vertex" ? e.format(i.name, o, r) : ct(this).build(e, r);
    } else
      return console.warn(`AttributeNode: Attribute "${t}" not found.`), e.getConst(r);
  }
}
const Gu = ku, _t = (c, e) => Me(new ku(c, e));
re("AttributeNode", ku);
class Vu extends Fe {
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const Og = Vu, ju = J(Vu);
V("bypass", ju);
re("BypassNode", Vu);
let MN = 0;
class AN {
  constructor() {
    this.id = MN++, this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
}
const nc = AN;
class Wu extends Fe {
  constructor(e, t = new nc()) {
    super(), this.isCacheNode = !0, this.node = e, this.cache = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const r = e.getCache();
    e.setCache(this.cache);
    const n = this.node.build(e, ...t);
    return e.setCache(r), n;
  }
}
const Ig = Wu, Ea = J(Wu);
V("cache", Ea);
re("CacheNode", Wu);
class Hu extends Fe {
  constructor(e, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.context = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const r = this.node.build(e);
    return e.setContext(t), r;
  }
  generate(e, t) {
    const r = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const n = this.node.build(e, t);
    return e.setContext(r), n;
  }
}
const Xu = Hu, Yn = J(Hu), $u = (c, e) => Yn(c, { label: e });
V("context", Yn);
V("label", $u);
re("ContextNode", Hu);
class Zn extends Fe {
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), r = this.scope;
    let n;
    if (r === Zn.VERTEX)
      n = e.getVertexIndex();
    else if (r === Zn.INSTANCE)
      n = e.getInstanceIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + r);
    let s;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? s = n : s = ct(this).build(e, t), s;
  }
}
Zn.VERTEX = "vertex";
Zn.INSTANCE = "instance";
const CN = Zn, EN = ue(Zn, Zn.VERTEX), Pg = ue(Zn, Zn.INSTANCE);
re("IndexNode", Zn);
class RN {
  start() {
  }
  finish() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
}
const qu = RN;
class LN {
  constructor(e, t, r = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = r;
  }
}
const Ra = LN;
class FN {
  constructor(e, t, r, n = void 0) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = r.getSelf(), this.needsUpdate = n;
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
}
const Ju = FN;
class ON {
  constructor(e, t) {
    this.isNodeVar = !0, this.name = e, this.type = t;
  }
}
const sc = ON;
class IN extends sc {
  constructor(e, t) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
const Yu = IN;
class PN {
  constructor(e, t, r = "") {
    this.name = e, this.type = t, this.code = r, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
const Ku = PN;
class DN {
  constructor() {
    this.keywords = [], this.nodes = [], this.keywordsCallback = {};
  }
  getNode(e) {
    let t = this.nodes[e];
    return t === void 0 && this.keywordsCallback[e] !== void 0 && (t = this.keywordsCallback[e](e), this.nodes[e] = t), t;
  }
  addKeyword(e, t) {
    return this.keywords.push(e), this.keywordsCallback[e] = t, this;
  }
  parse(e) {
    const t = this.keywords, r = new RegExp(`\\b${t.join("\\b|\\b")}\\b`, "g"), n = e.match(r), s = [];
    if (n !== null)
      for (const o of n) {
        const i = this.getNode(o);
        i !== void 0 && s.indexOf(i) === -1 && s.push(i);
      }
    return s;
  }
  include(e, t) {
    const r = this.parse(t);
    for (const n of r)
      n.build(e);
  }
}
const Zu = DN;
class Ut extends Fe {
  constructor(e, t = null) {
    super(e), this.name = t, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    return e.getPropertyName(e.getVarFromNode(this, this.name));
  }
}
const Qu = Ut, Mn = (c, e) => Me(new Ut(c, e)), $t = ue(Ut, "vec4", "DiffuseColor"), ao = ue(Ut, "float", "Roughness"), Dg = ue(Ut, "float", "Metalness"), La = ue(Ut, "float", "Clearcoat"), ni = ue(Ut, "float", "ClearcoatRoughness"), fr = ue(Ut, "vec3", "Sheen"), rc = ue(Ut, "float", "SheenRoughness"), oc = ue(Ut, "float", "Iridescence"), eh = ue(Ut, "float", "IridescenceIOR"), th = ue(Ut, "float", "IridescenceThickness"), cs = ue(Ut, "color", "SpecularColor"), Fa = ue(Ut, "float", "Shininess"), Ug = ue(Ut, "vec4", "Output"), yr = ue(Ut, "float", "dashSize"), si = ue(Ut, "float", "gapSize"), UN = ue(Ut, "float", "pointWidth");
re("PropertyNode", Ut);
class nh extends Qu {
  constructor(e, t = null) {
    super(e, t), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const Xl = nh, zN = (c, e) => Me(new nh(c, e));
re("ParameterNode", nh);
class sh extends Gu {
  constructor(e = 0) {
    super(null, "vec2"), this.isUVNode = !0, this.index = e;
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const zg = sh, gt = (...c) => Me(new sh(...c));
re("UVNode", sh);
class Bg extends Fe {
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const r = this.textureNode.build(e, "property"), n = this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${r}, ${n} )`, this.getNodeType(e), t);
  }
}
const kg = J(Bg);
V("textureSize", kg);
re("TextureSizeNode", Bg);
class bt extends Tt {
  constructor(e, t, r, ...n) {
    if (super(), this.op = e, n.length > 0) {
      let s = r;
      for (let o = 0; o < n.length; o++)
        s = new bt(e, s, n[o]);
      r = s;
    }
    this.aNode = t, this.bNode = r;
  }
  getNodeType(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = n.getNodeType(e), i = s.getNodeType(e);
    if (o === "void" || i === "void")
      return "void";
    if (r === "%")
      return o;
    if (r === "&" || r === "|" || r === "^" || r === ">>" || r === "<<")
      return e.getIntegerType(o);
    if (r === "==" || r === "&&" || r === "||" || r === "^^")
      return "bool";
    if (r === "<" || r === ">" || r === "<=" || r === ">=") {
      const a = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(o), e.getTypeLength(i));
      return a > 1 ? `bvec${a}` : "bool";
    } else
      return o === "float" && e.isMatrix(i) ? i : e.isMatrix(o) && e.isVector(i) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(i) ? e.getVectorFromMatrix(i) : e.getTypeLength(i) > e.getTypeLength(o) ? i : o;
  }
  generate(e, t) {
    const r = this.op, n = this.aNode, s = this.bNode, o = this.getNodeType(e, t);
    let i = null, a = null;
    o !== "void" ? (i = n.getNodeType(e), a = s.getNodeType(e), r === "<" || r === ">" || r === "<=" || r === ">=" || r === "==" ? e.isVector(i) ? a = i : i = a = "float" : r === ">>" || r === "<<" ? (i = o, a = e.changeComponentType(a, "uint")) : e.isMatrix(i) && e.isVector(a) ? a = e.getVectorFromMatrix(i) : e.isVector(i) && e.isMatrix(a) ? i = e.getVectorFromMatrix(a) : i = a = o) : i = a = o;
    const l = n.build(e, i), u = s.build(e, a), h = e.getTypeLength(t);
    if (t !== "void")
      return r === "<" && h > 1 ? e.format(`${e.getMethod("lessThan")}( ${l}, ${u} )`, o, t) : r === "<=" && h > 1 ? e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${u} )`, o, t) : r === ">" && h > 1 ? e.format(`${e.getMethod("greaterThan")}( ${l}, ${u} )`, o, t) : r === ">=" && h > 1 ? e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${u} )`, o, t) : e.format(`( ${l} ${this.op} ${u} )`, o, t);
    if (i !== "void")
      return e.format(`${l} ${this.op} ${u}`, o, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Gg = bt, Qn = J(bt, "+"), Oa = J(bt, "-"), Qt = J(bt, "*"), go = J(bt, "/"), Vg = J(bt, "%"), jg = J(bt, "=="), BN = J(bt, "!="), Wg = J(bt, "<"), Hg = J(bt, ">"), Xg = J(bt, "<="), $g = J(bt, ">="), qg = J(bt, "&&"), Jg = J(bt, "||"), Yg = J(bt, "^^"), Kg = J(bt, "&"), Zg = J(bt, "|"), Qg = J(bt, "^"), ey = J(bt, "<<"), ty = J(bt, ">>");
V("add", Qn);
V("sub", Oa);
V("mul", Qt);
V("div", go);
V("remainder", Vg);
V("equal", jg);
V("notEqual", BN);
V("lessThan", Wg);
V("greaterThan", Hg);
V("lessThanEqual", Xg);
V("greaterThanEqual", $g);
V("and", qg);
V("or", Jg);
V("xor", Yg);
V("bitAnd", Kg);
V("bitOr", Zg);
V("bitXor", Qg);
V("shiftLeft", ey);
V("shiftRight", ty);
re("OperatorNode", bt);
class B extends Tt {
  constructor(e, t, r = null, n = null) {
    super(), this.method = e, this.aNode = t, this.bNode = r, this.cNode = n;
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e), r = this.bNode ? this.bNode.getNodeType(e) : null, n = this.cNode ? this.cNode.getNodeType(e) : null, s = e.isMatrix(t) ? 0 : e.getTypeLength(t), o = e.isMatrix(r) ? 0 : e.getTypeLength(r), i = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return s > o && s > i ? t : o > i ? r : i > s ? n : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === B.LENGTH || t === B.DISTANCE || t === B.DOT ? "float" : t === B.CROSS ? "vec3" : this.getInputType(e);
  }
  generate(e, t) {
    const r = this.method, n = this.getNodeType(e), s = this.getInputType(e), o = this.aNode, i = this.bNode, a = this.cNode, l = e.renderer.isWebGLRenderer === !0;
    if (r === B.TRANSFORM_DIRECTION) {
      let u = o, h = i;
      e.isMatrix(u.getNodeType(e)) ? h = st(Ce(h), 0) : u = st(Ce(u), 0);
      const d = Qt(u, h).xyz;
      return Rn(d).build(e, t);
    } else {
      if (r === B.NEGATE)
        return e.format("( - " + o.build(e, s) + " )", n, t);
      if (r === B.ONE_MINUS)
        return Oa(1, o).build(e, t);
      if (r === B.RECIPROCAL)
        return go(1, o).build(e, t);
      if (r === B.DIFFERENCE)
        return ih(Oa(o, i)).build(e, t);
      {
        const u = [];
        return r === B.CROSS ? u.push(
          o.build(e, n),
          i.build(e, n)
        ) : r === B.STEP ? u.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : s),
          i.build(e, s)
        ) : l && (r === B.MIN || r === B.MAX) || r === B.MOD ? u.push(
          o.build(e, s),
          i.build(e, e.getTypeLength(i.getNodeType(e)) === 1 ? "float" : s)
        ) : r === B.REFRACT ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, "float")
        ) : r === B.MIX ? u.push(
          o.build(e, s),
          i.build(e, s),
          a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : s)
        ) : (u.push(o.build(e, s)), i !== null && u.push(i.build(e, s)), a !== null && u.push(a.build(e, s))), e.format(`${e.getMethod(r)}( ${u.join(", ")} )`, n, t);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
B.RADIANS = "radians";
B.DEGREES = "degrees";
B.EXP = "exp";
B.EXP2 = "exp2";
B.LOG = "log";
B.LOG2 = "log2";
B.SQRT = "sqrt";
B.INVERSE_SQRT = "inversesqrt";
B.FLOOR = "floor";
B.CEIL = "ceil";
B.NORMALIZE = "normalize";
B.FRACT = "fract";
B.SIN = "sin";
B.COS = "cos";
B.TAN = "tan";
B.ASIN = "asin";
B.ACOS = "acos";
B.ATAN = "atan";
B.ABS = "abs";
B.SIGN = "sign";
B.LENGTH = "length";
B.NEGATE = "negate";
B.ONE_MINUS = "oneMinus";
B.DFDX = "dFdx";
B.DFDY = "dFdy";
B.ROUND = "round";
B.RECIPROCAL = "reciprocal";
B.TRUNC = "trunc";
B.FWIDTH = "fwidth";
B.ATAN2 = "atan2";
B.MIN = "min";
B.MAX = "max";
B.MOD = "mod";
B.STEP = "step";
B.REFLECT = "reflect";
B.DISTANCE = "distance";
B.DIFFERENCE = "difference";
B.DOT = "dot";
B.CROSS = "cross";
B.POW = "pow";
B.TRANSFORM_DIRECTION = "transformDirection";
B.MIX = "mix";
B.CLAMP = "clamp";
B.REFRACT = "refract";
B.SMOOTHSTEP = "smoothstep";
B.FACEFORWARD = "faceforward";
const ke = B, rh = Se(1e-6), kN = Se(1e6), ny = J(B, B.RADIANS), sy = J(B, B.DEGREES), ry = J(B, B.EXP), oy = J(B, B.EXP2), iy = J(B, B.LOG), ay = J(B, B.LOG2), cy = J(B, B.SQRT), ly = J(B, B.INVERSE_SQRT), ic = J(B, B.FLOOR), oh = J(B, B.CEIL), Rn = J(B, B.NORMALIZE), ac = J(B, B.FRACT), uy = J(B, B.SIN), hy = J(B, B.COS), dy = J(B, B.TAN), fy = J(B, B.ASIN), py = J(B, B.ACOS), my = J(B, B.ATAN), ih = J(B, B.ABS), gy = J(B, B.SIGN), yy = J(B, B.LENGTH), vy = J(B, B.NEGATE), xy = J(B, B.ONE_MINUS), by = J(B, B.DFDX), Ny = J(B, B.DFDY), wy = J(B, B.ROUND), Ty = J(B, B.RECIPROCAL), Sy = J(B, B.TRUNC), _y = J(B, B.FWIDTH), My = J(B, B.ATAN2), Ay = J(B, B.MIN), Cy = J(B, B.MAX), Ey = J(B, B.MOD), Ry = J(B, B.STEP), Ly = J(B, B.REFLECT), Fy = J(B, B.DISTANCE), Oy = J(B, B.DIFFERENCE), ah = J(B, B.DOT), Iy = J(B, B.CROSS), ch = J(B, B.POW), Py = J(B, B.POW, 2), Dy = J(B, B.POW, 3), Uy = J(B, B.POW, 4), zy = J(B, B.TRANSFORM_DIRECTION), xn = J(B, B.MIX), lh = (c, e = 0, t = 1) => Me(new B(B.CLAMP, Me(c), Me(e), Me(t))), By = (c) => lh(c), ky = J(B, B.REFRACT), _s = J(B, B.SMOOTHSTEP), Gy = J(B, B.FACEFORWARD), GN = (c, e, t) => xn(e, t, c), VN = (c, e, t) => _s(e, t, c);
V("radians", ny);
V("degrees", sy);
V("exp", ry);
V("exp2", oy);
V("log", iy);
V("log2", ay);
V("sqrt", cy);
V("inverseSqrt", ly);
V("floor", ic);
V("ceil", oh);
V("normalize", Rn);
V("fract", ac);
V("sin", uy);
V("cos", hy);
V("tan", dy);
V("asin", fy);
V("acos", py);
V("atan", my);
V("abs", ih);
V("sign", gy);
V("length", yy);
V("negate", vy);
V("oneMinus", xy);
V("dFdx", by);
V("dFdy", Ny);
V("round", wy);
V("reciprocal", Ty);
V("trunc", Sy);
V("fwidth", _y);
V("atan2", My);
V("min", Ay);
V("max", Cy);
V("mod", Ey);
V("step", Ry);
V("reflect", Ly);
V("distance", Fy);
V("dot", ah);
V("cross", Iy);
V("pow", ch);
V("pow2", Py);
V("pow3", Dy);
V("pow4", Uy);
V("transformDirection", zy);
V("mix", GN);
V("clamp", lh);
V("refract", ky);
V("smoothstep", VN);
V("faceForward", Gy);
V("difference", Oy);
V("saturate", By);
re("MathNode", B);
const jN = Ve((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.mul(0.9478672986).add(0.0521327014).pow(2.4), n = t.mul(0.0773993808), s = t.lessThanEqual(0.04045), o = xn(r, n, s);
  return st(o, e.a);
}), WN = Ve((c) => {
  const { value: e } = c, { rgb: t } = e, r = t.pow(0.41666).mul(1.055).sub(0.055), n = t.mul(12.92), s = t.lessThanEqual(31308e-7), o = xn(r, n, s);
  return st(o, e.a);
}), Zf = (c) => {
  let e = null;
  return c === En ? e = "Linear" : c === yn && (e = "sRGB"), e;
}, Vy = (c, e) => Zf(c) + "To" + Zf(e);
class on extends Tt {
  constructor(e, t) {
    super("vec4"), this.method = e, this.node = t;
  }
  setup() {
    const { method: e, node: t } = this;
    return e === on.LINEAR_TO_LINEAR ? t : HN[e]({ value: t });
  }
}
on.LINEAR_TO_LINEAR = "LinearToLinear";
on.LINEAR_TO_sRGB = "LinearTosRGB";
on.sRGB_TO_LINEAR = "sRGBToLinear";
const HN = {
  [on.LINEAR_TO_sRGB]: WN,
  [on.sRGB_TO_LINEAR]: jN
}, jo = on, jy = (c, e) => Me(new on(Vy(En, e), Me(c))), cc = (c, e) => Me(new on(Vy(e, En), Me(c))), Wy = J(on, on.LINEAR_TO_sRGB), Hy = J(on, on.sRGB_TO_LINEAR);
V("linearTosRGB", Wy);
V("sRGBToLinear", Hy);
V("linearToColorSpace", jy);
V("colorSpaceToLinear", cc);
re("ColorSpaceNode", on);
class uh extends Fe {
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const r = this.getNodeType(e), n = this.snippet;
    if (r === "void")
      e.addLineFlowCode(n);
    else
      return e.format(`( ${n} )`, r, t);
  }
}
const Xy = uh, Ni = J(uh);
re("ExpressionNode", uh);
class hh extends nt {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = r, this.compareNode = n, this.updateMatrix = !1, this.updateType = ut.NONE, this.setUpdateMatrix(t === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return gt(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    const t = this.value;
    return Ft(t.matrix).mul(Ce(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? ut.FRAME : ut.NONE, this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let r = this.uvNode;
    (r === null || e.context.forceUVContext === !0) && e.context.getUVNode && (r = e.context.getUVNode(this)), r || (r = this.getDefaultUV()), this.updateMatrix === !0 && (r = this.getTransformedUV(r));
    let n = this.levelNode;
    n === null && e.context.getSamplerLevelNode && (n = e.context.getSamplerLevelNode(this)), t.uvNode = r, t.levelNode = n ? e.context.getMIPLevelAlgorithmNode(this, n) : null;
  }
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.compareNode, o = this.value;
    if (!o || o.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const i = super.generate(e, "property");
    if (t === "sampler")
      return i + "_sampler";
    if (e.isReference(t))
      return i;
    {
      const a = e.getDataFromNode(this);
      let l = a.propertyName;
      if (l === void 0) {
        const d = r.build(e, "vec2"), f = e.getVarFromNode(this);
        l = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(o, i, d, m);
        } else if (s !== null) {
          const m = s.build(e, "float");
          p = e.getTextureCompare(o, i, d, m);
        } else
          p = e.getTexture(o, i, d);
        e.addLineFlowCode(`${l} = ${p}`), e.context.tempWrite !== !1 && (a.snippet = p, a.propertyName = l);
      }
      let u = l;
      const h = this.getNodeType(e);
      return e.needsColorSpaceToLinear(this.value) && (u = cc(Ni(u, h), this.value.colorSpace).setup(e).build(e, h)), e.format(u, h, t);
    }
  }
  uv(e) {
    const t = this.clone();
    return t.uvNode = e, Me(t);
  }
  level(e) {
    const t = this.clone();
    return t.levelNode = e, Yn(t, {
      getMIPLevelAlgorithmNode: (r, n) => n
    });
  }
  size(e) {
    return kg(this, e);
  }
  compare(e) {
    const t = this.clone();
    return t.compareNode = Me(e), Me(t);
  }
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value];
  }
  update() {
    const e = this.value;
    e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
}
const wi = hh, Cn = J(hh), XN = (c) => (c.isNode === !0 ? c : Cn(c)).convert("sampler");
V("texture", Cn);
re("TextureNode", hh);
class dh extends Fe {
  constructor(e, t, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = r, this.reference = null, this.node = null, this.updateType = ut.OBJECT, this.setNodeType(t);
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setNodeType(e) {
    let t = null;
    e === "texture" ? t = Cn(null) : t = Ft(e), this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  update() {
    this.node.value = this.reference[this.property];
  }
  setup() {
    return this.node;
  }
}
const lc = dh, Ms = (c, e, t) => Me(new dh(c, e, t));
re("ReferenceNode", dh);
class fh extends lc {
  constructor(e, t, r = null) {
    super(e, t, r), this.material = r, this.updateType = ut.RENDER;
  }
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
  setup(e) {
    const t = this.material !== null ? this.material : e.material;
    return this.node.value = t[this.property], super.setup(e);
  }
}
const $y = fh, qy = (c, e, t) => Me(new fh(c, e, t));
re("MaterialReferenceNode", fh);
class Be extends Fe {
  constructor(e = Be.VIEW_MATRIX, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = ut.OBJECT, this._uniformNode = new nt(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === Be.WORLD_MATRIX || e === Be.VIEW_MATRIX)
      return "mat4";
    if (e === Be.NORMAL_MATRIX)
      return "mat3";
    if (e === Be.POSITION || e === Be.VIEW_POSITION || e === Be.DIRECTION || e === Be.SCALE)
      return "vec3";
  }
  update(e) {
    const t = this.object3d, r = this._uniformNode, n = this.scope;
    if (n === Be.VIEW_MATRIX)
      r.value = t.modelViewMatrix;
    else if (n === Be.NORMAL_MATRIX)
      r.value = t.normalMatrix;
    else if (n === Be.WORLD_MATRIX)
      r.value = t.matrixWorld;
    else if (n === Be.POSITION)
      r.value = r.value || new ve(), r.value.setFromMatrixPosition(t.matrixWorld);
    else if (n === Be.SCALE)
      r.value = r.value || new ve(), r.value.setFromMatrixScale(t.matrixWorld);
    else if (n === Be.DIRECTION)
      r.value = r.value || new ve(), t.getWorldDirection(r.value);
    else if (n === Be.VIEW_POSITION) {
      const s = e.camera;
      r.value = r.value || new ve(), r.value.setFromMatrixPosition(t.matrixWorld), r.value.applyMatrix4(s.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return t === Be.WORLD_MATRIX || t === Be.VIEW_MATRIX ? this._uniformNode.nodeType = "mat4" : t === Be.NORMAL_MATRIX ? this._uniformNode.nodeType = "mat3" : (t === Be.POSITION || t === Be.VIEW_POSITION || t === Be.DIRECTION || t === Be.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Be.VIEW_MATRIX = "viewMatrix";
Be.NORMAL_MATRIX = "normalMatrix";
Be.WORLD_MATRIX = "worldMatrix";
Be.POSITION = "position";
Be.SCALE = "scale";
Be.VIEW_POSITION = "viewPosition";
Be.DIRECTION = "direction";
const mn = Be, $N = J(Be, Be.DIRECTION), qN = J(Be, Be.VIEW_MATRIX), JN = J(Be, Be.NORMAL_MATRIX), YN = J(Be, Be.WORLD_MATRIX), Ia = J(Be, Be.POSITION), KN = J(Be, Be.SCALE), ph = J(Be, Be.VIEW_POSITION);
re("Object3DNode", Be);
class it extends mn {
  constructor(e = it.POSITION) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? "mat4" : t === it.NEAR || t === it.FAR ? "float" : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera, r = this._uniformNode, n = this.scope;
    n === it.VIEW_MATRIX ? r.value = t.matrixWorldInverse : n === it.PROJECTION_MATRIX ? r.value = t.projectionMatrix : n === it.NEAR ? r.value = t.near : n === it.FAR ? r.value = t.far : (this.object3d = t, super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return t === it.PROJECTION_MATRIX ? this._uniformNode.nodeType = "mat4" : (t === it.NEAR || t === it.FAR) && (this._uniformNode.nodeType = "float"), super.generate(e);
  }
}
it.PROJECTION_MATRIX = "projectionMatrix";
it.NEAR = "near";
it.FAR = "far";
const mh = it, ls = $u(ue(it, it.PROJECTION_MATRIX), "projectionMatrix"), va = ue(it, it.NEAR), xa = ue(it, it.FAR), Cs = ue(it, it.VIEW_MATRIX), ZN = ue(it, it.NORMAL_MATRIX), QN = ue(it, it.WORLD_MATRIX), ew = ue(it, it.POSITION);
re("CameraNode", it);
class Vt extends mn {
  constructor(e = Vt.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
const tw = Vt, nw = ue(Vt, Vt.DIRECTION), Ys = ue(Vt, Vt.VIEW_MATRIX).temp("ModelViewMatrix"), gh = ue(Vt, Vt.NORMAL_MATRIX), ri = ue(Vt, Vt.WORLD_MATRIX), sw = ue(Vt, Vt.POSITION), rw = ue(Vt, Vt.SCALE), ow = ue(Vt, Vt.VIEW_POSITION);
re("ModelNode", Vt);
class Et extends Fe {
  constructor(e = Et.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Et.GEOMETRY)
      r = _t("normal", "vec3");
    else if (t === Et.LOCAL)
      r = ct(oi);
    else if (t === Et.VIEW) {
      const n = gh.mul(Sr);
      r = Rn(ct(n));
    } else if (t === Et.WORLD) {
      const n = ds.transformDirection(Cs);
      r = Rn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Et.GEOMETRY = "geometry";
Et.LOCAL = "local";
Et.VIEW = "view";
Et.WORLD = "world";
const Wo = Et, oi = ue(Et, Et.GEOMETRY), Sr = ue(Et, Et.LOCAL).temp("Normal"), ds = ue(Et, Et.VIEW), uc = ue(Et, Et.WORLD), At = Mn("vec3", "TransformedNormalView"), Jy = At.transformDirection(Cs).normalize(), pr = Mn("vec3", "TransformedClearcoatNormalView");
re("NormalNode", Et);
const Qf = /* @__PURE__ */ new Map();
class ce extends Fe {
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, t) {
    let r = Qf.get(e);
    return r === void 0 && (r = qy(e, t), Qf.set(e, r)), r;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const t = e.context.material, r = this.scope;
    let n = null;
    if (r === ce.COLOR) {
      const s = this.getColor(r);
      t.map && t.map.isTexture === !0 ? n = s.mul(this.getTexture("map")) : n = s;
    } else if (r === ce.OPACITY) {
      const s = this.getFloat(r);
      t.alphaMap && t.alphaMap.isTexture === !0 ? n = s.mul(this.getTexture("alpha")) : n = s;
    } else if (r === ce.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? n = this.getTexture(r).r : n = Se(1);
    else if (r === ce.ROUGHNESS) {
      const s = this.getFloat(r);
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).g) : n = s;
    } else if (r === ce.METALNESS) {
      const s = this.getFloat(r);
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).b) : n = s;
    } else if (r === ce.EMISSIVE) {
      const s = this.getColor(r);
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? n = s.mul(this.getTexture(r)) : n = s;
    } else if (r === ce.NORMAL)
      t.normalMap ? n = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2")) : t.bumpMap ? n = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")) : n = ds;
    else if (r === ce.CLEARCOAT) {
      const s = this.getFloat(r);
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? n = s.mul(this.getTexture(r).r) : n = s;
    } else if (r === ce.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat(r);
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).r) : n = s;
    } else if (r === ce.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap ? n = this.getTexture(r).normalMap(this.getCache(r + "Scale", "vec2")) : n = ds;
    else if (r === ce.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? n = s.mul(this.getTexture("sheenColor").rgb) : n = s;
    } else if (r === ce.SHEEN_ROUGHNESS) {
      const s = this.getFloat(r);
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? n = s.mul(this.getTexture(r).a) : n = s, n = n.clamp(0.07, 1);
    } else if (r === ce.IRIDESCENCE_THICKNESS) {
      const s = Ms(1, "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = Ms(0, "float", t.iridescenceThicknessRange);
        n = s.sub(o).mul(this.getTexture(r).g).add(o);
      } else
        n = s;
    } else {
      const s = this.getNodeType(e);
      n = this.getCache(r, s);
    }
    return n;
  }
}
ce.ALPHA_TEST = "alphaTest";
ce.COLOR = "color";
ce.OPACITY = "opacity";
ce.SHININESS = "shininess";
ce.SPECULAR_COLOR = "specular";
ce.SPECULAR_STRENGTH = "specularStrength";
ce.REFLECTIVITY = "reflectivity";
ce.ROUGHNESS = "roughness";
ce.METALNESS = "metalness";
ce.NORMAL = "normal";
ce.CLEARCOAT = "clearcoat";
ce.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
ce.CLEARCOAT_NORMAL = "clearcoatNormal";
ce.EMISSIVE = "emissive";
ce.ROTATION = "rotation";
ce.SHEEN = "sheen";
ce.SHEEN_ROUGHNESS = "sheenRoughness";
ce.IRIDESCENCE = "iridescence";
ce.IRIDESCENCE_IOR = "iridescenceIOR";
ce.IRIDESCENCE_THICKNESS = "iridescenceThickness";
ce.LINE_SCALE = "scale";
ce.LINE_DASH_SIZE = "dashSize";
ce.LINE_GAP_SIZE = "gapSize";
ce.LINE_WIDTH = "linewidth";
ce.LINE_DASH_OFFSET = "dashOffset";
ce.POINT_WIDTH = "pointWidth";
const bs = ce, Yy = ue(ce, ce.ALPHA_TEST), yo = ue(ce, ce.COLOR), Ky = ue(ce, ce.SHININESS), Zy = ue(ce, ce.EMISSIVE), yh = ue(ce, ce.OPACITY), Qy = ue(ce, ce.SPECULAR_COLOR), e0 = ue(ce, ce.SPECULAR_STRENGTH), iw = ue(ce, ce.REFLECTIVITY), t0 = ue(ce, ce.ROUGHNESS), n0 = ue(ce, ce.METALNESS), s0 = ue(ce, ce.NORMAL), r0 = ue(ce, ce.CLEARCOAT), o0 = ue(ce, ce.CLEARCOAT_ROUGHNESS), i0 = ue(ce, ce.CLEARCOAT_NORMAL), a0 = ue(ce, ce.ROTATION), c0 = ue(ce, ce.SHEEN), l0 = ue(ce, ce.SHEEN_ROUGHNESS), u0 = ue(ce, ce.IRIDESCENCE), h0 = ue(ce, ce.IRIDESCENCE_IOR), d0 = ue(ce, ce.IRIDESCENCE_THICKNESS), Pa = ue(ce, ce.LINE_SCALE), vh = ue(ce, ce.LINE_DASH_SIZE), xh = ue(ce, ce.LINE_GAP_SIZE), $r = ue(ce, ce.LINE_WIDTH), $l = ue(ce, ce.LINE_DASH_OFFSET), f0 = ue(ce, ce.POINT_WIDTH);
re("MaterialNode", ce);
class lt extends Fe {
  constructor(e = lt.LOCAL) {
    super("vec3"), this.scope = e;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === lt.GEOMETRY)
      r = _t("position", "vec3");
    else if (t === lt.LOCAL)
      r = ct(en);
    else if (t === lt.WORLD) {
      const n = ri.mul(sn);
      r = ct(n);
    } else if (t === lt.VIEW) {
      const n = Ys.mul(sn);
      r = ct(n);
    } else if (t === lt.VIEW_DIRECTION) {
      const n = es.negate();
      r = Rn(ct(n));
    } else if (t === lt.WORLD_DIRECTION) {
      const n = sn.transformDirection(ri);
      r = Rn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
lt.GEOMETRY = "geometry";
lt.LOCAL = "local";
lt.WORLD = "world";
lt.WORLD_DIRECTION = "worldDirection";
lt.VIEW = "view";
lt.VIEW_DIRECTION = "viewDirection";
const Us = lt, en = ue(lt, lt.GEOMETRY), sn = ue(lt, lt.LOCAL).temp("Position"), bh = ue(lt, lt.WORLD), Nh = ue(lt, lt.WORLD_DIRECTION), es = ue(lt, lt.VIEW), It = ue(lt, lt.VIEW_DIRECTION);
re("PositionNode", lt);
class wh extends Tt {
  constructor(e = sn) {
    super("vec4"), this.positionNode = e;
  }
  setup() {
    return ls.mul(Ys).mul(this.positionNode);
  }
}
const p0 = wh, m0 = J(wh);
re("ModelViewProjectionNode", wh);
class Th extends Ru {
  constructor(e, t = null, r = 0, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = r, this.bufferOffset = n, this.usage = Zx, this.instanced = !1, this.attribute = null, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null)
      return;
    const t = this.getNodeType(e), r = this.value, n = e.getTypeLength(t), s = this.bufferStride || n, o = this.bufferOffset, i = r.isInterleavedBuffer === !0 ? r : new bm(r, s), a = new Gs(i, n, o);
    i.setUsage(this.usage), this.attribute = a, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const t = this.getNodeType(e), r = e.getBufferAttributeFromNode(this, t), n = e.getPropertyName(r);
    let s = null;
    return e.shaderStage === "vertex" ? s = n : s = ct(this).build(e, t), s;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const aw = Th, Ti = (c, e, t, r) => Me(new Th(c, e, t, r)), g0 = (c, e, t, r) => Ti(c, e, t, r).setUsage(gu), y0 = (c, e, t, r) => Ti(c, e, t, r).setInstanced(!0), v0 = (c, e, t, r) => g0(c, e, t, r).setInstanced(!0);
V("toAttribute", (c) => Ti(c.value));
re("BufferAttributeNode", Th);
class Sh extends Fe {
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null;
  }
  setup() {
    let e = this.instanceMatrixNode;
    if (e === null) {
      const i = this.instanceMesh.instanceMatrix, a = new Ma(i.array, 16, 1), l = i.usage === gu ? v0 : y0, u = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        l(a, "vec4", 16, 0),
        l(a, "vec4", 16, 4),
        l(a, "vec4", 16, 8),
        l(a, "vec4", 16, 12)
      ];
      e = Pu(...u), this.instanceMatrixNode = e;
    }
    const t = e.mul(sn).xyz, r = Ss(e[0].xyz, e[1].xyz, e[2].xyz), n = Sr.div(Ce(r[0].dot(r[0]), r[1].dot(r[1]), r[2].dot(r[2]))), s = r.mul(n).xyz;
    sn.assign(t), Sr.assign(s);
  }
}
const cw = Sh, x0 = J(Sh);
re("InstanceNode", Sh);
class _h extends nt {
  constructor(e, t, r = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = r;
  }
  getInputType() {
    return "buffer";
  }
}
const Mh = _h, Ah = (c, e, t) => Me(new _h(c, e, t));
re("BufferNode", _h);
class Mt extends Fe {
  constructor(e = Mt.LOCAL) {
    super(), this.scope = e;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === Mt.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Mt.GEOMETRY)
      r = _t("tangent", "vec4");
    else if (t === Mt.LOCAL)
      r = ct(ii.xyz);
    else if (t === Mt.VIEW) {
      const n = Ys.mul(hc).xyz;
      r = Rn(ct(n));
    } else if (t === Mt.WORLD) {
      const n = Si.transformDirection(Cs);
      r = Rn(ct(n));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Mt.GEOMETRY = "geometry";
Mt.LOCAL = "local";
Mt.VIEW = "view";
Mt.WORLD = "world";
const Zr = Mt, ii = ue(Mt, Mt.GEOMETRY), hc = ue(Mt, Mt.LOCAL), Si = ue(Mt, Mt.VIEW), b0 = ue(Mt, Mt.WORLD), Ch = mo(Si, "TransformedTangentView"), lw = Rn(Ch.transformDirection(Cs));
re("TangentNode", Mt);
class Eh extends Fe {
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = ut.OBJECT, this.skinIndexNode = _t("skinIndex", "uvec4"), this.skinWeightNode = _t("skinWeight", "vec4"), this.bindMatrixNode = Ft(e.bindMatrix, "mat4"), this.bindMatrixInverseNode = Ft(e.bindMatrixInverse, "mat4"), this.boneMatricesNode = Ah(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length);
  }
  setup(e) {
    const { skinIndexNode: t, skinWeightNode: r, bindMatrixNode: n, bindMatrixInverseNode: s, boneMatricesNode: o } = this, i = o.element(t.x), a = o.element(t.y), l = o.element(t.z), u = o.element(t.w), h = n.mul(sn), d = Qn(
      i.mul(r.x).mul(h),
      a.mul(r.y).mul(h),
      l.mul(r.z).mul(h),
      u.mul(r.w).mul(h)
    ), f = s.mul(d).xyz;
    let p = Qn(
      r.x.mul(i),
      r.y.mul(a),
      r.z.mul(l),
      r.w.mul(u)
    );
    p = s.mul(p).mul(n);
    const m = p.transformDirection(Sr).xyz;
    sn.assign(f), Sr.assign(m), e.hasGeometryAttribute("tangent") && hc.assign(m);
  }
  generate(e, t) {
    if (t !== "void")
      return sn.build(e, t);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const N0 = Eh, w0 = J(Eh);
re("SkinningNode", Eh);
class Rh extends Fe {
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Ft(1), this.updateType = ut.OBJECT;
  }
  setupAttribute(e, t = sn) {
    const r = this.mesh, n = r.geometry.morphAttributes[e];
    t.mulAssign(this.morphBaseInfluence);
    for (let s = 0; s < n.length; s++) {
      const o = n[s], i = Ti(o.array, "vec3"), a = Ms(s, "float", r.morphTargetInfluences);
      t.addAssign(i.mul(a));
    }
  }
  setup() {
    this.setupAttribute("position");
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, r) => t + r, 0);
  }
}
const uw = Rh, T0 = J(Rh);
re("MorphNode", Rh);
class Lh extends Fe {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return It.negate().reflect(At).transformDirection(Cs);
  }
}
const S0 = Lh, _0 = ue(Lh);
re("ReflectVectorNode", Lh);
class Fh extends wi {
  constructor(e, t = null, r = null) {
    super(e, t, r), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return _0;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generate(e, t) {
    const { uvNode: r, levelNode: n } = e.getNodeProperties(this), s = this.value;
    if (!s || s.isCubeTexture !== !0)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const o = nt.prototype.generate.call(this, e, "cubeTexture");
    if (t === "sampler")
      return o + "_sampler";
    if (e.isReference(t))
      return o;
    {
      const i = e.getDataFromNode(this);
      let a = i.propertyName;
      if (a === void 0) {
        const d = Ce(r.x.negate(), r.yz).build(e, "vec3"), f = e.getVarFromNode(this);
        a = e.getPropertyName(f);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(e, "float");
          p = e.getTextureLevel(this, o, d, m);
        } else
          p = e.getTexture(this, o, d);
        e.addLineFlowCode(`${a} = ${p}`), e.context.tempWrite !== !1 && (i.snippet = p, i.propertyName = a);
      }
      let l = a;
      const u = this.getNodeType(e);
      return e.needsColorSpaceToLinear(this.value) && (l = cc(Ni(l, u), this.value.colorSpace).setup(e).build(e, u)), e.format(l, u, t);
    }
  }
}
const M0 = Fh, dc = J(Fh);
V("cubeTexture", dc);
re("CubeTextureNode", Fh);
class A0 extends Fe {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const _i = A0;
re("LightingNode", A0);
let Kc = null;
class C0 extends _i {
  constructor(e = null) {
    super(), this.updateType = ut.FRAME, this.light = e, this.rtt = null, this.shadowNode = null, this.color = new je(), this.colorNode = Ft(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    let t = this.shadowNode;
    if (t === null) {
      Kc === null && (Kc = e.createNodeMaterial("MeshBasicNodeMaterial"));
      const r = this.light.shadow, n = e.getRenderTarget(r.mapSize.width, r.mapSize.height), s = new Nm();
      s.minFilter = Vs, s.magFilter = Vs, s.image.width = r.mapSize.width, s.image.height = r.mapSize.height, s.compareFunction = Qx, n.depthTexture = s, r.camera.updateProjectionMatrix();
      const o = Ms("bias", "float", r), i = Ms("normalBias", "float", r);
      let a = Ft(r.matrix).mul(bh.add(uc.mul(i)));
      a = a.xyz.div(a.w);
      const l = a.x.greaterThanEqual(0).and(a.x.lessThanEqual(1)).and(a.y.greaterThanEqual(0)).and(a.y.lessThanEqual(1)).and(a.z.lessThanEqual(1));
      e.renderer.coordinateSystem === eb ? a = Ce(
        a.x,
        a.y.oneMinus(),
        // WebGPU: Flip Y
        a.z.add(o).mul(2).sub(1)
        // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
      ) : a = Ce(
        a.x,
        a.y,
        a.z.add(o)
      ), t = ((h, d, f) => Cn(h, d).compare(f))(s, a.xy, a.z), this.rtt = n, this.colorNode = this.colorNode.mul(l.mix(1, t)), this.shadowNode = t, this.updateBeforeType = ut.RENDER;
    }
  }
  setup(e) {
    this.light.castShadow && this.setupShadow(e);
  }
  updateShadow(e) {
    const { rtt: t, light: r } = this, { renderer: n, scene: s } = e;
    s.overrideMaterial = Kc, t.setSize(r.shadow.mapSize.width, r.shadow.mapSize.height), r.shadow.updateMatrices(r), n.setRenderTarget(t), n.render(s, r.shadow.camera), n.setRenderTarget(null), s.overrideMaterial = null;
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const nr = C0;
re("AnalyticLightNode", C0);
const Da = /* @__PURE__ */ new WeakMap(), hw = (c) => c.sort((e, t) => e.id - t.id);
class Oh extends Fe {
  constructor(e = []) {
    super("vec3"), this.totalDiffuseNode = Ce().temp("totalDiffuse"), this.totalSpecularNode = Ce().temp("totalSpecular"), this.outgoingLightNode = Ce().temp("outgoingLight"), this.lightNodes = e, this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  setup(e) {
    const t = e.context, r = t.lightingModel;
    let n = this.outgoingLightNode;
    if (r) {
      const { lightNodes: s, totalDiffuseNode: o, totalSpecularNode: i } = this;
      t.outgoingLight = n;
      const a = e.addStack();
      r.start(t, a, e);
      for (const g of s)
        g.build(e);
      r.indirectDiffuse(t, a, e), r.indirectSpecular(t, a, e), r.ambientOcclusion(t, a, e);
      const { backdrop: l, backdropAlpha: u } = t, { directDiffuse: h, directSpecular: d, indirectDiffuse: f, indirectSpecular: p } = t.reflectedLight;
      let m = h.add(f);
      l !== null && (m = Ce(u !== null ? u.mix(m, l) : l)), o.assign(m), i.assign(d.add(p)), n.assign(o.add(i)), r.finish(t, a, e), n = n.bypass(e.removeStack());
    }
    return n;
  }
  getHash(e) {
    if (this._hash === null) {
      let t = "";
      const r = this.lightNodes;
      for (const n of r)
        t += n.getHash(e) + " ";
      this._hash = t;
    }
    return this._hash;
  }
  getLightNodeByHash(e) {
    const t = this.lightNodes;
    for (const r of t)
      if (r.light.uuid === e)
        return r;
    return null;
  }
  fromLights(e = []) {
    const t = [];
    e = hw(e);
    for (const r of e) {
      let n = this.getLightNodeByHash(r.uuid);
      if (n === null) {
        const s = r.constructor, o = Da.has(s) ? Da.get(s) : nr;
        n = Me(new o(r));
      }
      t.push(n);
    }
    return this.lightNodes = t, this._hash = null, this;
  }
}
const E0 = Oh, dw = (c) => Me(new Oh().fromLights(c)), R0 = J(Oh);
function Cr(c, e) {
  if (Da.has(c))
    throw new Error(`Redefinition of light node ${e.type}`);
  if (typeof c != "function")
    throw new Error(`Light ${c.name} is not a class`);
  if (typeof e != "function" || !e.type)
    throw new Error(`Light node ${e.type} is not a class`);
  Da.set(c, e);
}
class L0 extends _i {
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    const r = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(r);
  }
}
const Ih = L0;
re("AONode", L0);
class Ph extends Xu {
  constructor(e, t = null, r = null, n = null) {
    super(e), this.lightingModel = t, this.backdropNode = r, this.backdropAlphaNode = n, this._context = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this, r = Ce().temp("directDiffuse"), n = Ce().temp("directSpecular"), s = Ce().temp("indirectDiffuse"), o = Ce().temp("indirectSpecular"), i = {
      directDiffuse: r,
      directSpecular: n,
      indirectDiffuse: s,
      indirectSpecular: o
    };
    return {
      radiance: Ce().temp("radiance"),
      irradiance: Ce().temp("irradiance"),
      iblIrradiance: Ce().temp("iblIrradiance"),
      ambientOcclusion: Se(1).temp("ambientOcclusion"),
      reflectedLight: i,
      backdrop: e,
      backdropAlpha: t
    };
  }
  setup(e) {
    return this.context = this._context || (this._context = this.getContext()), this.context.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const fw = Ph, Dh = J(Ph);
V("lightingContext", Dh);
re("LightingContextNode", Ph);
class Uh extends Tt {
  constructor(e = Nh) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, t = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), r = e.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return rt(t, r);
  }
}
const F0 = Uh, fc = J(Uh);
re("EquirectUVNode", Uh);
class zh extends nt {
  constructor(e) {
    super(0), this.textureNode = e, this.updateType = ut.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, r = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (r && r.width !== void 0) {
      const { width: n, height: s } = r;
      this.value = Math.log2(Math.max(n, s));
    }
  }
}
const O0 = zh, Bh = J(zh);
re("MaxMipLevelNode", zh);
class kh extends Fe {
  constructor(e, t = null) {
    super("float"), this.textureNode = e, this.roughnessNode = t;
  }
  setup() {
    const { textureNode: e, roughnessNode: t } = this, r = Bh(e), n = t.mul(t).mul(Math.PI).div(t.add(1));
    return r.add(n.log2()).clamp(0, r);
  }
}
const I0 = kh, Gh = J(kh);
re("SpecularMIPLevelNode", kh);
const ep = /* @__PURE__ */ new WeakMap();
class P0 extends _i {
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    let t = this.envNode;
    if (t.isTextureNode && t.value.isCubeTexture !== !0) {
      let a = ep.get(t.value);
      if (a === void 0) {
        const l = t.value, u = e.renderer, h = e.getCubeRenderTarget(512).fromEquirectangularTexture(u, l);
        a = dc(h.texture), ep.set(t.value, a);
      }
      t = a;
    }
    const r = Ms("envMapIntensity", "float", e.material), n = Yn(t, tp(ao, At)).mul(r), s = Yn(t, pw(Jy)).mul(Math.PI).mul(r), o = Ea(n);
    e.context.radiance.addAssign(o), e.context.iblIrradiance.addAssign(s);
    const i = e.context.lightingModel.clearcoatRadiance;
    if (i) {
      const a = Yn(t, tp(ni, pr)).mul(r), l = Ea(a);
      i.addAssign(l);
    }
  }
}
const tp = (c, e) => {
  let t = null, r = null;
  return {
    getUVNode: (n) => {
      let s = null;
      return t === null && (t = It.negate().reflect(e), t = c.mul(c).mix(t, e).normalize(), t = t.transformDirection(Cs)), n.isCubeTextureNode ? s = t : n.isTextureNode && (r === null && (r = fc(t)), s = r), s;
    },
    getSamplerLevelNode: () => c,
    getMIPLevelAlgorithmNode: (n, s) => Gh(n, s)
  };
}, pw = (c) => {
  let e = null;
  return {
    getUVNode: (t) => {
      let r = null;
      return t.isCubeTextureNode ? r = c : t.isTextureNode && (e === null && (e = fc(c), e = rt(e.x, e.y.oneMinus())), r = e), r;
    },
    getSamplerLevelNode: () => Se(1),
    getMIPLevelAlgorithmNode: (t, r) => Gh(t, r)
  };
}, Vh = P0;
re("EnvironmentNode", P0);
const ql = /* @__PURE__ */ new Map();
class Jt extends hs {
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.unlit = this.constructor === Jt.prototype.constructor, this.fog = !0, this.lights = !0, this.normals = !0, this.colorSpace = !0, this.lightsNode = null, this.envNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.outputNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + Ka(this);
  }
  build(e) {
    this.setup(e);
  }
  setup(e) {
    e.addStack(), e.stack.outputNode = this.setupPosition(e), e.addFlow("vertex", e.removeStack()), e.addStack();
    let t;
    if (this.unlit === !1) {
      this.normals === !0 && this.setupNormal(e), this.setupDiffuseColor(e), this.setupVariants(e);
      const r = this.setupLighting(e);
      t = this.setupOutput(e, st(r, $t.a)), Ug.assign(t), this.outputNode !== null && (t = this.outputNode);
    } else
      t = this.setupOutput(e, this.outputNode || st(0, 0, 0, 1));
    e.stack.outputNode = t, e.addFlow("fragment", e.removeStack());
  }
  setupPosition(e) {
    const t = e.object, r = t.geometry;
    return e.addStack(), (r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color) && T0(t).append(), t.isSkinnedMesh === !0 && w0(t).append(), t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && e.isAvailable("instance") === !0 && x0(t).append(), this.positionNode !== null && sn.assign(this.positionNode), e.context.vertex = e.removeStack(), this.vertexNode || m0();
  }
  setupDiffuseColor({ geometry: e }) {
    let t = this.colorNode ? st(this.colorNode) : yo;
    this.vertexColors === !0 && e.hasAttribute("color") && (t = st(t.xyz.mul(_t("color")), t.a)), $t.assign(t);
    const r = this.opacityNode ? Se(this.opacityNode) : yh;
    if ($t.a.assign($t.a.mul(r)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const n = this.alphaTestNode !== null ? Se(this.alphaTestNode) : Yy;
      $t.a.lessThanEqual(n).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === !0) {
      const e = es.dFdx().cross(es.dFdy()).normalize();
      At.assign(e);
    } else {
      const e = this.normalNode ? Ce(this.normalNode) : s0;
      At.assign(e);
    }
  }
  getEnvNode(e) {
    let t = null;
    return this.envNode ? t = this.envNode : this.envMap ? t = this.envMap.isCubeTexture ? dc(this.envMap) : Cn(this.envMap) : e.environmentNode && (t = e.environmentNode), t;
  }
  setupLights(e) {
    const t = this.getEnvNode(e), r = [];
    t && r.push(new Vh(t)), e.material.aoMap && r.push(new Ih(Cn(e.material.aoMap)));
    let n = this.lightsNode || e.lightsNode;
    return r.length > 0 && (n = R0([...n.lightNodes, ...r])), n;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: t } = e, { backdropNode: r, backdropAlphaNode: n, emissiveNode: s } = this, i = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let a = $t.rgb;
    if (i && i.hasLight !== !1) {
      const l = this.setupLightingModel(e);
      a = Dh(i, l, r, n);
    } else
      r !== null && (a = Ce(n !== null ? xn(a, r, n) : r));
    return (s && s.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (a = a.add(Ce(s || Zy))), a;
  }
  setupOutput(e, t) {
    const r = e.renderer, n = e.toneMappingNode;
    if (n && (t = st(n.context({ color: t.rgb }), t.a)), this.fog === !0) {
      const s = e.fogNode;
      s && (t = st(s.mixAssign(t.rgb), t.a));
    }
    if (this.colorSpace === !0) {
      const s = r.getRenderTarget();
      let o;
      s !== null ? Array.isArray(s.texture) ? o = s.texture[0].colorSpace : o = s.texture.colorSpace : o = r.outputColorSpace, o !== En && o !== wm && (t = t.linearToColorSpace(o));
    }
    return t;
  }
  setDefaultValues(e) {
    for (const r in e) {
      const n = e[r];
      this[r] === void 0 && (this[r] = n, n && n.clone && (this[r] = n.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const r in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, r) === void 0 && t[r].get !== void 0 && Object.defineProperty(this.constructor.prototype, r, t[r]);
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const r = zn.prototype.toJSON.call(this, e), n = ei(this);
    r.inputNodes = {};
    for (const { property: o, childNode: i } of n)
      r.inputNodes[o] = i.toJSON(e).uuid;
    function s(o) {
      const i = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, i.push(l);
      }
      return i;
    }
    if (t) {
      const o = s(e.textures), i = s(e.images), a = s(e.nodes);
      o.length > 0 && (r.textures = o), i.length > 0 && (r.images = i), a.length > 0 && (r.nodes = a);
    }
    return r;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.outputNode = e.outputNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
  static fromMaterial(e) {
    if (e.isNodeMaterial === !0)
      return e;
    const t = e.type.replace("Material", "NodeMaterial"), r = wo(t);
    if (r === void 0)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const n in e)
      r[n] = e[n];
    return r;
  }
}
function an(c, e) {
  if (typeof e != "function" || !c)
    throw new Error(`Node material ${c} is not a class`);
  if (ql.has(c))
    throw new Error(`Redefinition of node material ${c}`);
  ql.set(c, e), e.type = c;
}
function wo(c) {
  const e = ql.get(c);
  if (e !== void 0)
    return new e();
}
an("NodeMaterial", Jt);
const mw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addNodeMaterial: an,
  createNodeMaterialFromType: wo,
  default: Jt
}, Symbol.toStringTag, { value: "Module" }));
class Er {
  constructor(e, t = null) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class gw extends Er {
  constructor(e, t = 0) {
    super(e, t), this.isFloatUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class yw extends Er {
  constructor(e, t = new wt()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class vw extends Er {
  constructor(e, t = new ve()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class xw extends Er {
  constructor(e, t = new pt()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class bw extends Er {
  constructor(e, t = new je()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class Nw extends Er {
  constructor(e, t = new Ns()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class ww extends Er {
  constructor(e, t = new Ge()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class Tw extends gw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Sw extends yw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class _w extends vw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Mw extends xw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Aw extends bw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Cw extends Nw {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Ew extends ww {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class jh extends Fe {
  constructor(e, t, r = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = r;
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const r = this.elseNode.getNodeType(e);
      if (e.getTypeLength(r) > e.getTypeLength(t))
        return r;
    }
    return t;
  }
  generate(e) {
    const t = this.getNodeType(e), r = { tempWrite: !1 }, { ifNode: n, elseNode: s } = this, o = n.getNodeType(e) !== "void" || s && s.getNodeType(e) !== "void", i = o ? Mn(t).build(e) : "", a = Yn(
      this.condNode
      /*, context*/
    ).build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${a} ) {

`).addFlowTab();
    let l = Yn(this.ifNode, r).build(e, t);
    if (l = o ? i + " = " + l + ";" : l, e.removeFlowTab().addFlowCode(e.tab + "	" + l + `

` + e.tab + "}"), s !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let u = Yn(s, r).build(e, t);
      u = i ? i + " = " + u + ";" : u, e.removeFlowTab().addFlowCode(e.tab + "	" + u + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return i;
  }
}
const Wh = jh, vr = J(jh);
V("cond", vr);
re("CondNode", jh);
class Hh extends Fe {
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  if(e, t) {
    const r = new mr(t);
    return this._currentCond = vr(e, r), this.add(this._currentCond);
  }
  elseif(e, t) {
    const r = new mr(t), n = vr(e, r);
    return this._currentCond.elseNode = n, this._currentCond = n, this;
  }
  else(e) {
    return this._currentCond.elseNode = new mr(e), this;
  }
  build(e, ...t) {
    const r = Iu();
    ti(this);
    for (const n of this.nodes)
      n.build(e, "void");
    return ti(r), this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
  }
}
const Rw = Hh, Jl = J(Hh);
re("StackNode", Hh);
class Lw extends tb {
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, t) {
    const r = t.minFilter, n = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const s = new Xa(5, 5, 5), o = fc(Nh), i = wo("MeshBasicNodeMaterial");
    i.colorNode = Cn(t, o, 0), i.side = yu, i.blending = nb;
    const a = new qt(s, i), l = new $a();
    return l.add(a), t.minFilter === bo && (t.minFilter = uo), new sb(1, 10, this).update(e, l), t.minFilter = r, t.currentGenerateMipmaps = n, a.geometry.dispose(), a.material.dispose(), this;
  }
}
const Fw = Lw, Ow = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), Iw = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), Pw = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]), Wi = (c) => (c = Number(c), c + (c % 1 ? "" : ".0"));
class Dw {
  constructor(e, t, r, n = null, s = null) {
    this.object = e, this.material = s || e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = r, this.scene = n, this.nodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.hashNodes = {}, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.toneMappingNode = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: [] }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: [], fragment: [], compute: [] }, this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }, this.bindingsArray = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = Jl(), this.stacks = [], this.tab = "	", this.context = {
      keywords: new Zu(),
      material: this.material,
      getMIPLevelAlgorithmNode: (o, i) => i.mul(Bh(o))
    }, this.cache = new nc(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  getRenderTarget(e, t, r) {
    return new rb(e, t, r);
  }
  getCubeRenderTarget(e, t) {
    return new Fw(e, t);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  getBindings() {
    let e = this.bindingsArray;
    if (e === null) {
      const t = this.bindings;
      this.bindingsArray = e = this.material !== null ? [...t.vertex, ...t.fragment] : t.compute;
    }
    return e;
  }
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  buildUpdateNodes() {
    for (const e of this.nodes) {
      const t = e.getUpdateType(), r = e.getUpdateBeforeType();
      t !== ut.NONE && this.updateNodes.push(e.getSelf()), r !== ut.NONE && this.updateBeforeNodes.push(e);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new je() : e === "vec2" ? t = new wt() : e === "vec3" ? t = new ve() : e === "vec4" && (t = new pt())), e === "float")
      return Wi(t);
    if (e === "int")
      return `${Math.round(t)}`;
    if (e === "uint")
      return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool")
      return t ? "true" : "false";
    if (e === "color")
      return `${this.getType("vec3")}( ${Wi(t.r)}, ${Wi(t.g)}, ${Wi(t.b)} )`;
    const r = this.getTypeLength(e), n = this.getComponentType(e), s = (o) => this.getConst(n, o);
    if (r === 2)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (r === 3)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (r === 4)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (r > 4 && t && (t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (r > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  generateMethod(e) {
    return e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, t) {
    const r = this.attributes;
    for (const s of r)
      if (s.name === e)
        return s;
    const n = new Ra(e, t);
    return r.push(n), n;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(e) {
    return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."), this.getTextureColorSpaceFromMap(e) === yn ? ob : ib;
  }
  getTextureColorSpaceFromMap(e) {
    let t;
    return e && e.isTexture ? t = e.colorSpace : e && e.isWebGLRenderTarget ? t = e.texture.colorSpace : t = wm, t;
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint")
      return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" ? "vec4" : e;
  }
  getTypeFromLength(e, t = "float") {
    if (e === 1)
      return t;
    const r = Ow.get(e);
    return (t === "float" ? "" : t[0]) + r;
  }
  getTypeFromArray(e) {
    return Iw.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const r = t.array, n = Pw.has(r.constructor) ? e.itemSize : t.stride || e.itemSize, s = e.normalized;
    let o;
    return !(e instanceof ab) && s !== !0 && (o = this.getTypeFromArray(r)), this.getTypeFromLength(n, o);
  }
  getTypeLength(e) {
    const t = this.getVectorType(e), r = /vec([2-4])/.exec(t);
    return r !== null ? Number(r[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = Jl(this.stack), this.stacks.push(Iu() || this.stack), ti(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, ti(this.stacks.pop()), e;
  }
  getDataFromNode(e, t = this.shaderStage) {
    const r = e.isGlobal(this) ? this.globalCache : this.cache;
    let n = r.getNodeData(e);
    return n === void 0 && (n = {}, r.setNodeData(e, n)), n[t] === void 0 && (n[t] = {}), n[t];
  }
  getNodeProperties(e, t = "any") {
    const r = this.getDataFromNode(e, t);
    return r.properties || (r.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, t) {
    const r = this.getDataFromNode(e);
    let n = r.bufferAttribute;
    if (n === void 0) {
      const s = this.uniforms.index++;
      n = new Ra("nodeAttribute" + s, t, e), this.bufferAttributes.push(n), r.bufferAttribute = n;
    }
    return n;
  }
  getStructTypeFromNode(e, t = this.shaderStage, r = null) {
    const n = this.getDataFromNode(e, t);
    if (n.structType === void 0) {
      const o = this.structs.index++;
      e.name = `StructType${o}`, this.structs[t].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, t, r = this.shaderStage, n = null) {
    const s = this.getDataFromNode(e, r);
    let o = s.uniform;
    if (o === void 0) {
      const i = this.uniforms.index++;
      o = new Ju(n || "nodeUniform" + i, t, e), this.uniforms[r].push(o), s.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, t = null, r = e.getNodeType(this), n = this.shaderStage) {
    const s = this.getDataFromNode(e, n);
    let o = s.variable;
    if (o === void 0) {
      const i = this.vars[n] || (this.vars[n] = []);
      t === null && (t = "nodeVar" + i.length), o = new sc(t, r), i.push(o), s.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, t) {
    const r = this.getDataFromNode(e, "any");
    let n = r.varying;
    if (n === void 0) {
      const s = this.varyings, o = s.length;
      n = new Yu("nodeVarying" + o, t), s.push(n), r.varying = n;
    }
    return n;
  }
  getCodeFromNode(e, t, r = this.shaderStage) {
    const n = this.getDataFromNode(e);
    let s = n.code;
    if (s === void 0) {
      const o = this.codes[r] || (this.codes[r] = []), i = o.length;
      s = new Ku("nodeCode" + i, t), o.push(s), n.code = s;
    }
    return s;
  }
  addLineFlowCode(e) {
    return e === "" ? this : (e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const t = e.getNodeType(this), r = this.flowChildNode(e, t);
    return this.flowsData.set(e, r), r;
  }
  flowShaderNode(e) {
    const t = e.layout;
    let r;
    if (e.isArrayInput) {
      r = [];
      for (const o of t.inputs)
        r.push(new Xl(o.type, o.name));
    } else {
      r = {};
      for (const o of t.inputs)
        r[o.name] = new Xl(o.type, o.name);
    }
    e.layout = null;
    const n = e.call(r), s = this.flowStagesNode(n, t.type);
    return e.layout = t, s;
  }
  flowStagesNode(e, t = null) {
    const r = this.flow, n = this.vars, s = this.buildStage, o = {
      code: ""
    };
    this.flow = o, this.vars = {};
    for (const i of Vl)
      this.setBuildStage(i), o.result = e.build(this, t);
    return o.vars = this.getVars(this.shaderStage), this.flow = r, this.vars = n, this.setBuildStage(s), o;
  }
  flowChildNode(e, t = null) {
    const r = this.flow, n = {
      code: ""
    };
    return this.flow = n, n.result = e.build(this, t), this.flow = r, n;
  }
  flowNodeFromShaderStage(e, t, r = null, n = null) {
    const s = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(t, r);
    return n !== null && (o.code += `${this.tab + n} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(s), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, t) {
    return `${this.getType(e)} ${t}`;
  }
  getVars(e) {
    let t = "";
    const r = this.vars[e];
    if (r !== void 0)
      for (const n of r)
        t += `${this.getVar(n.type, n.name)}; `;
    return t;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const t = this.codes[e];
    let r = "";
    if (t !== void 0)
      for (const n of t)
        r += n.code + `
`;
    return r;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const e of Vl) {
      this.setBuildStage(e), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const t of Hm) {
        this.setShaderStage(t);
        const r = this.flowNodes[t];
        for (const n of r)
          e === "generate" ? this.flowNode(n) : n.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, t) {
    if (t === "float")
      return new Tw(e);
    if (t === "vec2")
      return new Sw(e);
    if (t === "vec3")
      return new _w(e);
    if (t === "vec4")
      return new Mw(e);
    if (t === "color")
      return new Aw(e);
    if (t === "mat3")
      return new Cw(e);
    if (t === "mat4")
      return new Ew(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  createNodeMaterial(e) {
    return wo(e);
  }
  getPrimitiveType(e) {
    let t;
    return e[0] === "i" ? t = "int" : e[0] === "u" ? t = "uint" : t = "float", t;
  }
  format(e, t, r) {
    if (t = this.getVectorType(t), r = this.getVectorType(r), t === r || r === null || this.isReference(r))
      return e;
    const n = this.getTypeLength(t), s = this.getTypeLength(r);
    return n > 4 || s > 4 || s === 0 ? e : n === s ? `${this.getType(r)}( ${e} )` : n > s ? this.format(`${e}.${"xyz".slice(0, s)}`, this.getTypeFromLength(s, this.getComponentType(t)), r) : s === 4 && n > 1 ? `${this.getType(r)}( ${this.format(e, t, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(r)}( ${this.format(e, t, "vec2")}, 0.0 )` : (n === 1 && s > 1 && t[0] !== r[0] && (e = `${this.getType(this.getPrimitiveType(r))}( ${e} )`), `${this.getType(r)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${cb} - NodeMaterial System
`;
  }
}
const D0 = Dw;
class Uw {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, t) {
    let r = e.get(t);
    return r === void 0 && (r = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(t, r)), r;
  }
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateBeforeMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.updateBefore(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.updateBefore(this)) : t === ut.OBJECT && e.updateBefore(this);
  }
  updateNode(e) {
    const t = e.getUpdateType(), r = e.updateReference(this), { frameMap: n, renderMap: s } = this._getMaps(this.updateMap, r);
    t === ut.FRAME ? n.get(e) !== this.frameId && (n.set(e, this.frameId), e.update(this)) : t === ut.RENDER ? (s.get(e) !== this.renderId || n.get(e) !== this.frameId) && (s.set(e, this.renderId), n.set(e, this.frameId), e.update(this)) : t === ut.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
const Xh = Uw;
class U0 {
  constructor(e, t, r = null, n = "", s = !1) {
    this.type = e, this.name = t, this.count = r, this.qualifier = n, this.isConst = s;
  }
}
U0.isNodeFunctionInput = !0;
const $h = U0;
class z0 extends Fe {
  constructor(e) {
    super(), this.types = e, this.isStructTypeNode = !0;
  }
  getMemberTypes() {
    return this.types;
  }
}
const zw = z0;
re("StructTypeNode", z0);
class qh extends Fe {
  constructor(...e) {
    super(), this.isOutputStructNode = !0, this.members = e;
  }
  setup(e) {
    super.setup(e);
    const t = this.members, r = [];
    for (let n = 0; n < t.length; n++)
      r.push(t[n].getNodeType(e));
    this.nodeType = e.getStructTypeFromNode(new zw(r)).name;
  }
  generate(e, t) {
    const r = e.getVarFromNode(this);
    r.isOutputStructVar = !0;
    const n = e.getPropertyName(r), s = this.members, o = n !== "" ? n + "." : "";
    for (let i = 0; i < s.length; i++) {
      const a = s[i].build(e, t);
      e.addLineFlowCode(`${o}m${i} = ${a}`);
    }
    return n;
  }
}
const Bw = qh, kw = J(qh);
re("OutputStructNode", qh);
class Jh extends Fe {
  constructor(e) {
    super(), this.seedNode = e;
  }
  setup() {
    const e = this.seedNode.uint().mul(747796405).add(2891336453), t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
    return t.shiftRight(22).bitXor(t).float().mul(1 / 2 ** 32);
  }
}
const Gw = Jh, B0 = J(Jh);
V("hash", B0);
re("HashNode", Jh);
let Zc;
class Yh extends Wh {
  constructor(e) {
    Zc = Zc || Ni("discard"), super(e, Zc);
  }
}
const Vw = Yh, jw = J(Yh), k0 = (c) => jw(c).append();
V("discard", k0);
re("DiscardNode", Yh);
class Kh extends Fe {
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode("i".charCodeAt() + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0)
      return t;
    const r = {};
    for (let n = 0, s = this.params.length - 1; n < s; n++) {
      const o = this.params[n], i = o.isNode !== !0 && o.name || this.getVarName(n), a = o.isNode !== !0 && o.type || "int";
      r[i] = Ni(i, a);
    }
    return t.returnsNode = this.params[this.params.length - 1](r, e.addStack(), e), t.stackNode = e.removeStack(), t;
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e), r = { tempWrite: !1 }, n = this.params, s = t.stackNode;
    for (let a = 0, l = n.length - 1; a < l; a++) {
      const u = n[a];
      let h = null, d = null, f = null, p = null, m = null, g = null;
      u.isNode ? (p = "int", f = this.getVarName(a), h = "0", d = u.build(e, p), m = "<") : (p = u.type || "int", f = u.name || this.getVarName(a), h = u.start, d = u.end, m = u.condition, g = u.update, typeof h == "number" ? h = h.toString() : h && h.isNode && (h = h.build(e, p)), typeof d == "number" ? d = d.toString() : d && d.isNode && (d = d.build(e, p)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const b = { start: h, end: d, condition: m }, v = b.start, y = b.end;
      let x = "", N = "", w = "";
      g || (p === "int" ? m.includes("<") ? g = "++" : g = "--" : m.includes("<") ? g = "+= 1" : g = "-= 1"), x += e.getVar(p, f) + " = " + v, N += f + " " + m + " " + y, w += f + " " + g;
      const T = `for ( ${x}; ${N}; ${w} )`;
      e.addFlowCode((a === 0 ? `
` : "") + e.tab + T + ` {

`).addFlowTab();
    }
    const o = Yn(s, r).build(e, "void"), i = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + o);
    for (let a = 0, l = this.params.length - 1; a < l; a++)
      e.addFlowCode((a === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), i;
  }
}
const Ww = Kh, G0 = (...c) => Me(new Kh(gr(c, "int"))).append();
V("loop", (c, ...e) => ju(c, G0(...e)));
re("LoopNode", Kh);
class Zh extends Tt {
  constructor() {
    super("vec2");
  }
  setup() {
    const e = Ce(It.z, 0, It.x.negate()).normalize(), t = It.cross(e);
    return rt(e.dot(At), t.dot(At)).mul(0.495).add(0.5);
  }
}
const V0 = Zh, Hw = ue(Zh);
re("MatcapUVNode", Zh);
class Pt extends nt {
  constructor(e = Pt.LOCAL, t = 1, r = 0) {
    super(r), this.scope = e, this.scale = t, this.updateType = ut.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(e) {
    const t = this.scope, r = this.scale;
    t === Pt.LOCAL ? this.value += e.deltaTime * r : t === Pt.DELTA ? this.value = e.deltaTime * r : t === Pt.FRAME ? this.value = e.frameId : this.value = e.time * r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope, e.scale = this.scale;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope, this.scale = e.scale;
  }
}
Pt.LOCAL = "local";
Pt.GLOBAL = "global";
Pt.DELTA = "delta";
Pt.FRAME = "frame";
const j0 = Pt, Qh = (c, e = 0) => Me(new Pt(Pt.LOCAL, c, e)), Xw = (c, e = 0) => Me(new Pt(Pt.GLOBAL, c, e)), $w = (c, e = 0) => Me(new Pt(Pt.DELTA, c, e)), qw = ue(Pt, Pt.FRAME).uint();
re("TimerNode", Pt);
class Rt extends Fe {
  constructor(e = Rt.SINE, t = Qh()) {
    super(), this.method = e, this.timeNode = t;
  }
  getNodeType(e) {
    return this.timeNode.getNodeType(e);
  }
  setup() {
    const e = this.method, t = Me(this.timeNode);
    let r = null;
    return e === Rt.SINE ? r = t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5) : e === Rt.SQUARE ? r = t.fract().round() : e === Rt.TRIANGLE ? r = t.add(0.5).fract().mul(2).sub(1).abs() : e === Rt.SAWTOOTH && (r = t.fract()), r;
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Rt.SINE = "sine";
Rt.SQUARE = "square";
Rt.TRIANGLE = "triangle";
Rt.SAWTOOTH = "sawtooth";
const Qr = Rt, Jw = J(Rt, Rt.SINE), Yw = J(Rt, Rt.SQUARE), Kw = J(Rt, Rt.TRIANGLE), Zw = J(Rt, Rt.SAWTOOTH);
re("OscNode", Rt);
class ts extends Tt {
  constructor(e, t) {
    super(), this.scope = e, this.node = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup() {
    const { scope: e, node: t } = this;
    let r = null;
    return e === ts.DIRECTION_TO_COLOR ? r = t.mul(0.5).add(0.5) : e === ts.COLOR_TO_DIRECTION && (r = t.mul(2).sub(1)), r;
  }
}
ts.DIRECTION_TO_COLOR = "directionToColor";
ts.COLOR_TO_DIRECTION = "colorToDirection";
const Qw = ts, ed = J(ts, ts.DIRECTION_TO_COLOR), W0 = J(ts, ts.COLOR_TO_DIRECTION);
V("directionToColor", ed);
V("colorToDirection", W0);
re("PackingNode", ts);
class pc extends Fe {
  constructor(e, t, r, n, s) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = r, this.outLowNode = n, this.outHighNode = s, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: r, outLowNode: n, outHighNode: s, doClamp: o } = this;
    let i = e.sub(t).div(r.sub(t));
    return o === !0 && (i = i.clamp()), i.mul(s.sub(n)).add(n);
  }
}
const H0 = pc, X0 = J(pc, null, null, { doClamp: !1 }), $0 = J(pc);
V("remap", X0);
V("remapClamp", $0);
re("RemapNode", pc);
class td extends Tt {
  constructor(e, t, r = rt(0.5)) {
    super("vec2"), this.uvNode = e, this.rotationNode = t, this.centerNode = r;
  }
  setup() {
    const { uvNode: e, rotationNode: t, centerNode: r } = this, n = t.cos(), s = t.sin(), o = e.sub(r);
    return rt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      rt(n, s).dot(o),
      rt(s.negate(), n).dot(o)
    ).add(r);
  }
}
const q0 = td, J0 = J(td);
V("rotateUV", J0);
re("RotateUVNode", td);
class nd extends Fe {
  constructor(e, t = gt(), r = Se(0)) {
    super("vec2"), this.countNode = e, this.uvNode = t, this.frameNode = r;
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: r } = this, { width: n, height: s } = r, o = e.mod(n.mul(s)).floor(), i = o.mod(n), a = s.sub(o.add(1).div(n).ceil()), l = r.reciprocal(), u = rt(i, a);
    return t.add(u).mul(l);
  }
}
const Y0 = nd, K0 = J(nd);
re("SpriteSheetUVNode", nd);
class sd extends Fe {
  constructor(e, t = null, r = null, n = Se(1), s = bh, o = uc) {
    super("vec4"), this.textureXNode = e, this.textureYNode = t, this.textureZNode = r, this.scaleNode = n, this.positionNode = s, this.normalNode = o;
  }
  setup() {
    const { textureXNode: e, textureYNode: t, textureZNode: r, scaleNode: n, positionNode: s, normalNode: o } = this;
    let i = o.abs().normalize();
    i = i.div(i.dot(Ce(1)));
    const a = s.yz.mul(n), l = s.zx.mul(n), u = s.xy.mul(n), h = e.value, d = t !== null ? t.value : h, f = r !== null ? r.value : h, p = Cn(h, a).mul(i.x), m = Cn(d, l).mul(i.y), g = Cn(f, u).mul(i.z);
    return Qn(p, m, g);
  }
}
const Z0 = sd, Q0 = J(sd), ev = (...c) => Q0(...c);
V("triplanarTexture", ev);
re("TriplanarTexturesNode", sd);
class Lt extends Fe {
  constructor(e = Lt.LOCAL) {
    super("vec3"), this.scope = e;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r;
    t === Lt.GEOMETRY ? r = oi.cross(ii) : t === Lt.LOCAL ? r = Sr.cross(hc) : t === Lt.VIEW ? r = ds.cross(Si) : t === Lt.WORLD && (r = uc.cross(b0));
    const n = r.mul(ii.w).xyz;
    return Rn(ct(n)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Lt.GEOMETRY = "geometry";
Lt.LOCAL = "local";
Lt.VIEW = "view";
Lt.WORLD = "world";
const eo = Lt, e2 = ue(Lt, Lt.GEOMETRY), t2 = ue(Lt, Lt.LOCAL), tv = ue(Lt, Lt.VIEW), n2 = ue(Lt, Lt.WORLD), nv = Rn(At.cross(Ch).mul(ii.w)), s2 = Rn(nv.transformDirection(Cs));
re("BitangentNode", Lt);
const mc = 1 / 6, sv = (c) => Qt(mc, Qt(c, Qt(c, c.negate().add(3)).sub(3)).add(1)), Yl = (c) => Qt(mc, Qt(c, Qt(c, Qt(3, c).sub(6))).add(4)), rv = (c) => Qt(mc, Qt(c, Qt(c, Qt(-3, c).add(3)).add(3)).add(1)), Kl = (c) => Qt(mc, ch(c, 3)), np = (c) => sv(c).add(Yl(c)), sp = (c) => rv(c).add(Kl(c)), rp = (c) => Qn(-1, Yl(c).div(sv(c).add(Yl(c)))), op = (c) => Qn(1, Kl(c).div(rv(c).add(Kl(c)))), ip = (c, e, t) => {
  const r = c.uvNode, n = Qt(r, e.zw).add(0.5), s = ic(n), o = ac(n), i = np(o.x), a = sp(o.x), l = rp(o.x), u = op(o.x), h = rp(o.y), d = op(o.y), f = rt(s.x.add(l), s.y.add(h)).sub(0.5).mul(e.xy), p = rt(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy), m = rt(s.x.add(l), s.y.add(d)).sub(0.5).mul(e.xy), g = rt(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy), b = np(o.y).mul(Qn(i.mul(c.uv(f).level(t)), a.mul(c.uv(p).level(t)))), v = sp(o.y).mul(Qn(i.mul(c.uv(m).level(t)), a.mul(c.uv(g).level(t))));
  return b.add(v);
}, r2 = (c, e) => {
  const t = rt(c.size(Ca(e))), r = rt(c.size(Ca(e.add(1)))), n = go(1, t), s = go(1, r), o = ip(c, st(n, t), ic(e)), i = ip(c, st(s, r), oh(e));
  return ac(e).mix(o, i);
};
class rd extends Tt {
  constructor(e, t = Se(3)) {
    super("vec4"), this.textureNode = e, this.blurNode = t;
  }
  setup() {
    return r2(this.textureNode, this.blurNode);
  }
}
const o2 = rd, ov = J(rd);
V("bicubic", ov);
re("TextureBicubicNode", rd);
class od extends Fe {
  constructor() {
    super("vec2"), this.isPointUVNode = !0;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const iv = od, av = ue(od);
re("PointUVNode", od);
class Bn extends Fe {
  constructor(e = Bn.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  setup(e) {
    const t = this.scope, r = this.scene !== null ? this.scene : e.scene;
    let n;
    return t === Bn.BACKGROUND_BLURRINESS ? n = Ms("backgroundBlurriness", "float", r) : t === Bn.BACKGROUND_INTENSITY ? n = Ms("backgroundIntensity", "float", r) : console.error("THREE.SceneNode: Unknown scope:", t), n;
  }
}
Bn.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Bn.BACKGROUND_INTENSITY = "backgroundIntensity";
const i2 = Bn, a2 = ue(Bn, Bn.BACKGROUND_BLURRINESS), c2 = ue(Bn, Bn.BACKGROUND_INTENSITY);
re("SceneNode", Bn);
class id extends Mh {
  constructor(e, t, r = 0) {
    super(e, t, r), this.isStorageBufferNode = !0;
  }
  getInputType() {
    return "storageBuffer";
  }
}
const l2 = id, u2 = (c, e, t) => Me(new id(c, e, t));
re("StorageBufferNode", id);
class ad extends wi {
  constructor(e, t, r = null) {
    super(e, t), this.storeNode = r, this.isStoreTextureNode = !0;
  }
  getNodeType() {
    return "void";
  }
}
const h2 = ad, d2 = J(ad);
re("TextureStoreNode", ad);
class cd extends lc {
  constructor(e, t, r = null) {
    super(e, t, r), this.userData = r;
  }
  update(e) {
    this.reference = this.userData !== null ? this.userData : e.object.userData, super.update(e);
  }
}
const f2 = cd, p2 = (c, e, t) => Me(new cd(c, e, t));
re("UserDataNode", cd);
const m2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => e[r].lessThan(rh).cond(e[r], c[r].oneMinus().div(e[r]).oneMinus().max(0));
  return Ce(t("x"), t("y"), t("z"));
}), g2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => e[r].equal(1).cond(e[r], c[r].div(e[r].oneMinus()).max(0));
  return Ce(t("x"), t("y"), t("z"));
}), y2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => c[r].oneMinus().mul(e[r].oneMinus()).oneMinus();
  return Ce(t("x"), t("y"), t("z"));
}), v2 = Ve(({ base: c, blend: e }) => {
  const t = (r) => c[r].lessThan(0.5).cond(c[r].mul(e[r], 2), c[r].oneMinus().mul(e[r].oneMinus()).oneMinus());
  return Ce(t("x"), t("y"), t("z"));
});
class Dt extends Tt {
  constructor(e, t, r) {
    super(), this.blendMode = e, this.baseNode = t, this.blendNode = r;
  }
  setup() {
    const { blendMode: e, baseNode: t, blendNode: r } = this, n = { base: t, blend: r };
    let s = null;
    return e === Dt.BURN ? s = m2(n) : e === Dt.DODGE ? s = g2(n) : e === Dt.SCREEN ? s = y2(n) : e === Dt.OVERLAY && (s = v2(n)), s;
  }
}
Dt.BURN = "burn";
Dt.DODGE = "dodge";
Dt.SCREEN = "screen";
Dt.OVERLAY = "overlay";
const to = Dt, cv = J(Dt, Dt.BURN), lv = J(Dt, Dt.DODGE), uv = J(Dt, Dt.OVERLAY), hv = J(Dt, Dt.SCREEN);
V("burn", cv);
V("dodge", lv);
V("overlay", uv);
V("screen", hv);
re("BlendModeNode", Dt);
class ld extends Fe {
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    return e.getFrontFacing();
  }
}
const dv = ld, fv = ue(ld), ud = Se(fv).mul(2).sub(1);
re("FrontFacingNode", ld);
const x2 = Ve(({ textureNode: c, bumpScale: e }) => {
  let t = c;
  if (t.isTextureNode !== !0 && t.traverse((o) => {
    o.isTextureNode === !0 && (t = o);
  }), t.isTextureNode !== !0)
    throw new Error("THREE.TSL: dHdxy_fwd() requires a TextureNode.");
  const r = Se(c), n = t.uvNode || gt(), s = (o) => c.cache().context({ getUVNode: () => o, forceUVContext: !0 });
  return rt(
    Se(s(n.add(n.dFdx()))).sub(r),
    Se(s(n.add(n.dFdy()))).sub(r)
  ).mul(e);
}), b2 = Ve((c) => {
  const { surf_pos: e, surf_norm: t, dHdxy: r } = c, n = e.dFdx().normalize(), s = e.dFdy().normalize(), o = t, i = s.cross(o), a = o.cross(n), l = n.dot(i).mul(ud), u = l.sign().mul(r.x.mul(i).add(r.y.mul(a)));
  return l.abs().mul(t).sub(u).normalize();
});
class hd extends Tt {
  constructor(e, t = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = x2({ textureNode: this.textureNode, bumpScale: e });
    return b2({
      surf_pos: es,
      surf_norm: ds,
      dHdxy: t
    });
  }
}
const N2 = hd, pv = J(hd);
V("bumpMap", pv);
re("BumpMapNode", hd);
const w2 = Ve(({ color: c, adjustment: e }) => e.mix(xv(c), c)), T2 = Ve(({ color: c, adjustment: e }) => {
  const t = Qn(c.r, c.g, c.b).div(3), r = c.r.max(c.g.max(c.b)), n = r.sub(t).mul(e).mul(-3);
  return xn(c, r, n);
}), S2 = Ve(({ color: c, adjustment: e }) => {
  const t = Ss(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135), r = Ss(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046), n = t.mul(c), s = n.z.atan2(n.y).add(e), o = n.yz.length();
  return r.mul(Ce(n.x, o.mul(s.cos()), o.mul(s.sin())));
});
class rn extends Tt {
  constructor(e, t, r = Se(1)) {
    super("vec3"), this.method = e, this.colorNode = t, this.adjustmentNode = r;
  }
  setup() {
    const { method: e, colorNode: t, adjustmentNode: r } = this, n = { color: t, adjustment: r };
    let s = null;
    return e === rn.SATURATION ? s = w2(n) : e === rn.VIBRANCE ? s = T2(n) : e === rn.HUE ? s = S2(n) : console.error(`${this.type}: Method "${this.method}" not supported!`), s;
  }
}
rn.SATURATION = "saturation";
rn.VIBRANCE = "vibrance";
rn.HUE = "hue";
const Ho = rn, mv = J(rn, rn.SATURATION), gv = J(rn, rn.VIBRANCE), yv = J(rn, rn.HUE), vv = Ce(0.2125, 0.7154, 0.0721), xv = (c, e = vv) => ah(c, e);
V("saturation", mv);
V("vibrance", gv);
V("hue", yv);
re("ColorAdjustmentNode", rn);
const _2 = Ve((c) => {
  const { eye_pos: e, surf_norm: t, mapN: r, uv: n } = c, s = e.dFdx(), o = e.dFdy(), i = n.dFdx(), a = n.dFdy(), l = t, u = o.cross(l), h = l.cross(s), d = u.mul(i.x).add(h.mul(a.x)), f = u.mul(i.y).add(h.mul(a.y)), p = d.dot(d).max(f.dot(f)), m = ud.mul(p.inverseSqrt());
  return Qn(d.mul(r.x, m), f.mul(r.y, m), l.mul(r.z)).normalize();
});
class dd extends Tt {
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = jf;
  }
  setup(e) {
    const { normalMapType: t, scaleNode: r } = this;
    let n = this.node.mul(2).sub(1);
    r !== null && (n = Ce(n.xy.mul(r), n.z));
    let s = null;
    return t === lb ? s = gh.mul(n).normalize() : t === jf && (e.hasGeometryAttribute("tangent") === !0 ? s = wv.mul(n).normalize() : s = _2({
      eye_pos: es,
      surf_norm: ds,
      mapN: n,
      uv: gt()
    })), s;
  }
}
const bv = dd, Nv = J(dd), wv = Ss(Si, tv, ds);
V("normalMap", Nv);
re("NormalMapNode", dd);
class fd extends Tt {
  constructor(e, t) {
    super(), this.sourceNode = e, this.stepsNode = t;
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const Tv = fd, Sv = J(fd);
V("posterize", Sv);
re("PosterizeNode", fd);
const M2 = Ve(({ color: c, exposure: e }) => c.mul(e).clamp()), A2 = Ve(({ color: c, exposure: e }) => (c = c.mul(e), c.div(c.add(1)).clamp())), C2 = Ve(({ color: c, exposure: e }) => {
  c = c.mul(e), c = c.sub(4e-3).max(0);
  const t = c.mul(c.mul(6.2).add(0.5)), r = c.mul(c.mul(6.2).add(1.7)).add(0.06);
  return t.div(r).pow(2.2);
}), E2 = Ve(({ color: c }) => {
  const e = c.mul(c.add(0.0245786)).sub(90537e-9), t = c.mul(c.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), R2 = Ve(({ color: c, exposure: e }) => {
  const t = Ss(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), r = Ss(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return c = c.mul(e).div(0.6), c = t.mul(c), c = E2({ color: c }), c = r.mul(c), c.clamp();
}), L2 = {
  [ub]: M2,
  [hb]: A2,
  [db]: C2,
  [Tm]: R2
};
class pd extends Tt {
  constructor(e = Wf, t = Se(1), r = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = r;
  }
  getCacheKey() {
    let e = super.getCacheKey();
    return e = "{toneMapping:" + this.toneMapping + ",nodes:" + e + "}", e;
  }
  setup(e) {
    const t = this.colorNode || e.context.color, r = this.toneMapping;
    if (r === Wf)
      return t;
    const n = { exposure: this.exposureNode, color: t }, s = L2[r];
    let o = null;
    return s ? o = s(n) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", r), o = t), o;
  }
}
const _v = pd, F2 = (c, e, t) => Me(new pd(c, Me(e), Me(t)));
re("ToneMappingNode", pd);
let Qc, el;
class Ze extends Fe {
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Ze.COORDINATE || this.scope === Ze.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = ut.NONE;
    return (this.scope === Ze.RESOLUTION || this.scope === Ze.VIEWPORT) && (e = ut.FRAME), this.updateType = e, e;
  }
  update({ renderer: e }) {
    this.scope === Ze.VIEWPORT ? e.getViewport(el) : e.getDrawingBufferSize(Qc);
  }
  setup(e) {
    const t = this.scope;
    if (t === Ze.COORDINATE)
      return;
    let r = null;
    if (t === Ze.RESOLUTION)
      r = Ft(Qc || (Qc = new wt()));
    else if (t === Ze.VIEWPORT)
      r = Ft(el || (el = new pt()));
    else {
      const n = rt(new Ze(Ze.COORDINATE)), s = new Ze(Ze.RESOLUTION);
      r = n.div(s);
      let o = r.x, i = r.y;
      /bottom/i.test(t) && (i = i.oneMinus()), /right/i.test(t) && (o = o.oneMinus()), r = rt(o, i);
    }
    return r;
  }
  generate(e) {
    if (this.scope === Ze.COORDINATE) {
      let t = e.getFragCoord();
      if (e.isFlipY()) {
        const r = Mv.build(e);
        t = `${e.getType("vec2")}( ${t}.x, ${r}.y - ${t}.y )`;
      }
      return t;
    }
    return super.generate(e);
  }
}
Ze.COORDINATE = "coordinate";
Ze.RESOLUTION = "resolution";
Ze.VIEWPORT = "viewport";
Ze.TOP_LEFT = "topLeft";
Ze.BOTTOM_LEFT = "bottomLeft";
Ze.TOP_RIGHT = "topRight";
Ze.BOTTOM_RIGHT = "bottomRight";
const zs = Ze, O2 = ue(Ze, Ze.COORDINATE), Mv = ue(Ze, Ze.RESOLUTION), xr = ue(Ze, Ze.VIEWPORT), gc = ue(Ze, Ze.TOP_LEFT), I2 = ue(Ze, Ze.BOTTOM_LEFT), P2 = ue(Ze, Ze.TOP_RIGHT), D2 = ue(Ze, Ze.BOTTOM_RIGHT);
re("ViewportNode", Ze);
const Oo = new wt();
class yc extends wi {
  constructor(e = gc, t = null, r = null) {
    r === null && (r = new Sm(), r.minFilter = bo), super(r, e, t), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = ut.FRAME;
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(Oo);
    const r = this.value;
    (r.image.width !== Oo.width || r.image.height !== Oo.height) && (r.image.width = Oo.width, r.image.height = Oo.height, r.needsUpdate = !0);
    const n = r.generateMipmaps;
    r.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(r), r.generateMipmaps = n;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
}
const md = yc, Av = J(yc), Cv = J(yc, null, null, { generateMipmaps: !0 });
V("viewportTexture", Av);
V("viewportMipTexture", Cv);
re("ViewportTextureNode", yc);
let tl = null;
class gd extends md {
  constructor(e = gc, t = null) {
    tl === null && (tl = new Sm()), super(e, t, tl);
  }
}
const U2 = gd, Ev = J(gd);
V("viewportSharedTexture", Ev);
re("ViewportSharedTextureNode", gd);
let Dr = null;
class yd extends md {
  constructor(e = gc, t = null) {
    Dr === null && (Dr = new Nm(), Dr.minFilter = bo, Dr.type = fb, Dr.format = pb), super(e, t, Dr);
  }
}
const z2 = yd, vd = J(yd);
V("viewportDepthTexture", vd);
re("ViewportDepthTextureNode", yd);
class ns extends Fe {
  constructor(e, t = null) {
    super("float"), this.scope = e, this.textureNode = t, this.isViewportDepthNode = !0;
  }
  setup() {
    const { scope: e } = this;
    let t = null;
    if (e === ns.DEPTH)
      t = Zl(es.z, va, xa);
    else if (e === ns.DEPTH_TEXTURE) {
      const r = this.textureNode || vd(), n = Rv(r, va, xa);
      t = Zl(n, va, xa);
    }
    return t;
  }
}
const Zl = (c, e, t) => c.add(e).div(e.sub(t)), B2 = (c, e, t) => e.sub(t).mul(c).sub(e), k2 = (c, e, t) => e.add(c).mul(t).div(e.sub(t).mul(c)), Rv = (c, e, t) => e.mul(t).div(t.sub(e).mul(c).sub(t));
ns.DEPTH = "depth";
ns.DEPTH_TEXTURE = "depthTexture";
const G2 = ns, V2 = ue(ns, ns.DEPTH), j2 = J(ns, ns.DEPTH_TEXTURE);
re("ViewportDepthNode", ns);
class xd extends Fe {
  constructor(e = "", t = [], r = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = r, this._includes = t;
  }
  setIncludes(e) {
    return this._includes = e, this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const n of t)
      n.build(e);
    const r = e.getCodeFromNode(this, this.getNodeType(e));
    return r.code = this.code, r.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
const bd = xd, vc = J(xd), W2 = (c, e) => vc(c, e, "js"), H2 = (c, e) => vc(c, e, "wgsl"), Nd = (c, e) => vc(c, e, "glsl");
re("CodeNode", xd);
class wd extends Tt {
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [], r = this.functionNode, n = r.getInputs(e), s = this.parameters;
    if (Array.isArray(s))
      for (let i = 0; i < s.length; i++) {
        const a = n[i], l = s[i];
        t.push(l.build(e, a.type));
      }
    else
      for (const i of n) {
        const a = s[i.name];
        if (a !== void 0)
          t.push(a.build(e, i.type));
        else
          throw new Error(`FunctionCallNode: Input '${i.name}' not found in FunctionNode.`);
      }
    return `${r.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const X2 = wd, Lv = (c, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? gr(e) : bi(e[0]), Me(new wd(Me(c), e)));
V("call", Lv);
re("FunctionCallNode", wd);
class Td extends bd {
  constructor(e = "", t = [], r = "") {
    super(e, t, r), this.keywords = {};
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let r = t.nodeFunction;
    return r === void 0 && (r = e.parser.parseFunction(this.code), t.nodeFunction = r), r;
  }
  generate(e, t) {
    super.generate(e);
    const r = this.getNodeFunction(e), n = r.name, s = r.type, o = e.getCodeFromNode(this, s);
    n !== "" && (o.name = n);
    const i = e.getPropertyName(o);
    let a = this.getNodeFunction(e).getCode(i);
    const l = this.keywords, u = Object.keys(l);
    if (u.length > 0)
      for (const h of u) {
        const d = new RegExp(`\\b${h}\\b`, "g"), f = l[h].build(e, "property");
        a = a.replace(d, f);
      }
    return o.code = a + `
`, t === "property" ? i : e.format(`${i}()`, s, t);
  }
}
const Fv = Td, Ov = (c, e = [], t = "") => {
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof o == "function" && (e[s] = o.functionNode);
  }
  const r = Me(new Td(c, e, t)), n = (...s) => r.call(...s);
  return n.functionNode = r, n;
}, cn = (c, e) => Ov(c, e, "glsl"), $2 = (c, e) => Ov(c, e, "wgsl");
re("FunctionNode", Td);
class Sd extends Fe {
  constructor(e = null) {
    super(), this._value = e, this._cache = null, this.inputType = null, this.outpuType = null, this.events = new Ha(), this.isScriptableValueNode = !0;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e && (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer && (URL.revokeObjectURL(this._cache), this._cache = null), this._value = e, this.events.dispatchEvent({ type: "change" }), this.refresh());
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const e = this.value;
    if (e && this._cache === null && this.inputType === "URL" && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (e && e.value !== null && e.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof e.value == "string" || this.inputType === "Number" && typeof e.value == "number" || this.inputType === "Vector2" && e.value.isVector2 || this.inputType === "Vector3" && e.value.isVector3 || this.inputType === "Vector4" && e.value.isVector4 || this.inputType === "Color" && e.value.isColor || this.inputType === "Matrix3" && e.value.isMatrix3 || this.inputType === "Matrix4" && e.value.isMatrix4))
      return e.value;
    return this._cache || e;
  }
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : Se();
  }
  serialize(e) {
    super.serialize(e), this.value !== null ? this.inputType === "ArrayBuffer" ? e.value = Cu(this.value) : e.value = this.value ? this.value.toJSON(e.meta).uuid : null : e.value = null, e.inputType = this.inputType, e.outputType = this.outputType;
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null && (e.inputType === "ArrayBuffer" ? t = Eu(e.value) : e.inputType === "Texture" ? t = e.meta.textures[e.value] : t = e.meta.nodes[e.value] || null), this.value = t, this.inputType = e.inputType, this.outputType = e.outputType;
  }
}
const q2 = Sd, Xo = J(Sd);
V("scriptableValue", Xo);
re("ScriptableValueNode", Sd);
class Iv extends Map {
  get(e, t = null, ...r) {
    if (this.has(e))
      return super.get(e);
    if (t !== null) {
      const n = t(...r);
      return this.set(e, n), n;
    }
  }
}
class J2 {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const ba = new Iv();
class _d extends Fe {
  constructor(e = null, t = {}) {
    super(), this.codeNode = e, this.parameters = t, this._local = new Iv(), this._output = Xo(), this._outputs = {}, this._source = this.source, this._method = null, this._object = null, this._value = null, this._needsOutputUpdate = !0, this.onRefresh = this.onRefresh.bind(this), this.isScriptableNode = !0;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  getLocal(e) {
    return this._local.get(e);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e))
        return t;
  }
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e))
        return t;
  }
  setOutput(e, t) {
    const r = this._outputs;
    return r[e] === void 0 ? r[e] = Xo(t) : r[e].value = t, this;
  }
  getOutput(e) {
    return this._outputs[e];
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    const r = this.parameters;
    return t && t.isScriptableNode ? (this.deleteParameter(e), r[e] = t, r[e].getDefaultOutput().events.addEventListener("refresh", this.onRefresh)) : t && t.isScriptableValueNode ? (this.deleteParameter(e), r[e] = t, r[e].events.addEventListener("refresh", this.onRefresh)) : r[e] === void 0 ? (r[e] = Xo(t), r[e].events.addEventListener("refresh", this.onRefresh)) : r[e].value = t, this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(e) {
    let t = this.parameters[e];
    return t && (t.isScriptableNode && (t = t.getDefaultOutput()), t.events.removeEventListener("refresh", this.onRefresh)), this;
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters))
      this.deleteParameter(e);
    return this.needsUpdate = !0, this;
  }
  call(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n(...t);
  }
  async callAsync(e, ...t) {
    const n = this.getObject()[e];
    if (typeof n == "function")
      return n.constructor.name === "AsyncFunction" ? await n(...t) : n(...t);
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  getObject() {
    if (this.needsUpdate && this.dispose(), this._object !== null)
      return this._object;
    const e = () => this.refresh(), t = (l, u) => this.setOutput(l, u), r = new J2(this), n = ba.get("THREE"), s = ba.get("TSL"), o = this.getMethod(this.codeNode), i = [r, this._local, ba, e, t, n, s];
    this._object = o(...i);
    const a = this._object.layout;
    if (a && (a.cache === !1 && this._local.clear(), this._output.outputType = a.outputType || null, Array.isArray(a.elements)))
      for (const l of a.elements) {
        const u = l.id || l.name;
        l.inputType && (this.getParameter(u) === void 0 && this.setParameter(u, null), this.getParameter(u).inputType = l.inputType), l.outputType && (this.getOutput(u) === void 0 && this.setOutput(u, null), this.getOutput(u).outputType = l.outputType);
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let r = this.parameters[t];
      r.isScriptableNode && (r = r.getDefaultOutput()), r.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : Se();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate && this.dispose(), this._method !== null)
      return this._method;
    const e = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"], r = ["layout", "init", "main", "dispose"].join(", "), n = "var " + r + `; var output = {};
`, s = `
return { ...output, ` + r + " };", o = n + this.codeNode.code + s;
    return this._method = new Function(...e, o), this._method;
  }
  dispose() {
    this._method !== null && (this._object && typeof this._object.dispose == "function" && this._object.dispose(), this._method = null, this._object = null, this._source = null, this._value = null, this._needsOutputUpdate = !0, this._output.value = null, this._outputs = {});
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    return this.codeNode === null ? this : (this._needsOutputUpdate === !0 && (this._value = this.call("main"), this._needsOutputUpdate = !1), this._output.value = this._value, this);
  }
  _refresh() {
    this.needsUpdate = !0, this._exec(), this._output.refresh();
  }
}
const Y2 = _d, Pv = J(_d);
V("scriptable", Pv);
re("ScriptableNode", _d);
class Md extends Fe {
  constructor(e, t) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = t;
  }
  mixAssign(e) {
    return this.mix(e, this.colorNode);
  }
  setup() {
    return this.factorNode;
  }
}
const xc = Md, Dv = J(Md);
V("fog", Dv);
re("FogNode", Md);
class Ad extends xc {
  constructor(e, t, r) {
    super(e), this.isFogRangeNode = !0, this.nearNode = t, this.farNode = r;
  }
  setup() {
    return _s(this.nearNode, this.farNode, es.z.negate());
  }
}
const Uv = Ad, zv = J(Ad);
V("rangeFog", zv);
re("FogRangeNode", Ad);
class Cd extends xc {
  constructor(e, t) {
    super(e), this.isFogExp2Node = !0, this.densityNode = t;
  }
  setup() {
    const e = es.z.negate(), t = this.densityNode;
    return t.mul(t, e, e).negate().exp().oneMinus();
  }
}
const Bv = Cd, kv = J(Cd);
V("densityFog", kv);
re("FogExp2Node", Cd);
let sr = null, rr = null;
class Ed extends Fe {
  constructor(e = Se(), t = Se()) {
    super(), this.minNode = e, this.maxNode = t;
  }
  getVectorLength(e) {
    const t = e.getTypeLength(js(this.minNode.value)), r = e.getTypeLength(js(this.maxNode.value));
    return t > r ? t : r;
  }
  getNodeType(e) {
    return e.object.isInstancedMesh === !0 ? e.getTypeFromLength(this.getVectorLength(e)) : "float";
  }
  setup(e) {
    const t = e.object;
    let r = null;
    if (t.isInstancedMesh === !0) {
      const n = this.minNode.value, s = this.maxNode.value, o = e.getTypeLength(js(n)), i = e.getTypeLength(js(s));
      sr = sr || new pt(), rr = rr || new pt(), sr.setScalar(0), rr.setScalar(0), o === 1 ? sr.setScalar(n) : n.isColor ? sr.set(n.r, n.g, n.b) : sr.set(n.x, n.y, n.z || 0, n.w || 0), i === 1 ? rr.setScalar(s) : s.isColor ? rr.set(s.r, s.g, s.b) : rr.set(s.x, s.y, s.z || 0, s.w || 0);
      const a = 4, l = a * t.count, u = new Float32Array(l);
      for (let d = 0; d < l; d++) {
        const f = d % a, p = sr.getComponent(f), m = rr.getComponent(f);
        u[d] = Zt.lerp(p, m, Math.random());
      }
      const h = this.getNodeType(e);
      r = Ah(u, "vec4", t.count).element(Pg).convert(h);
    } else
      r = Se(0);
    return r;
  }
}
const Gv = Ed, K2 = J(Ed);
re("RangeNode", Ed);
class Rd extends Fe {
  constructor(e, t, r = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = t, this.workgroupSize = r, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = ut.OBJECT, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let r = t[0];
    for (let n = 1; n < t.length; n++)
      r *= t[n];
    this.dispatchCount = Math.ceil(e / r);
  }
  onInit() {
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: t } = e;
    if (t === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r);
    }
  }
}
const Vv = Rd, jv = (c, e, t) => Me(new Rd(Me(c), e, t));
V("compute", jv);
re("ComputeNode", Rd);
class Ks extends Fe {
  constructor(e = Ks.TARGET_DIRECTION, t = null) {
    super(), this.scope = e, this.light = t;
  }
  setup() {
    const { scope: e, light: t } = this;
    let r = null;
    return e === Ks.TARGET_DIRECTION && (r = Cs.transformDirection(Ia(t).sub(Ia(t.target)))), r;
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
Ks.TARGET_DIRECTION = "targetDirection";
const Z2 = Ks, Ld = J(Ks, Ks.TARGET_DIRECTION);
re("LightNode", Ks);
const Fd = Ve((c) => {
  const { lightDistance: e, cutoffDistance: t, decayExponent: r } = c, n = e.pow(r).max(0.01).reciprocal();
  return t.greaterThan(0).cond(
    n.mul(e.div(t).pow4().oneMinus().clamp().pow2()),
    n
  );
});
class Od extends nr {
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  setup(e) {
    const { colorNode: t, cutoffDistanceNode: r, decayExponentNode: n, light: s } = this, o = e.context.lightingModel, i = ph(s).sub(es), a = i.normalize(), l = i.length(), u = Fd({
      lightDistance: l,
      cutoffDistance: r,
      decayExponent: n
    }), h = t.mul(u), d = e.context.reflectedLight;
    o.direct({
      lightDirection: a,
      lightColor: h,
      reflectedLight: d
    }, e.stack, e);
  }
}
const Wv = Od;
re("PointLightNode", Od);
Cr(Zo, Od);
class Id extends nr {
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, r = this.colorNode, n = Ld(this.light), s = e.context.reflectedLight;
    t.direct({
      lightDirection: n,
      lightColor: r,
      reflectedLight: s
    }, e.stack, e);
  }
}
const Q2 = Id;
re("DirectionalLightNode", Id);
Cr(gi, Id);
class Pd extends nr {
  constructor(e = null) {
    super(e), this.coneCosNode = Ft(0), this.penumbraCosNode = Ft(0), this.cutoffDistanceNode = Ft(0), this.decayExponentNode = Ft(0);
  }
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: t, penumbraCosNode: r } = this;
    return _s(t, r, e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel, { colorNode: r, cutoffDistanceNode: n, decayExponentNode: s, light: o } = this, i = ph(o).sub(es), a = i.normalize(), l = a.dot(Ld(o)), u = this.getSpotAttenuation(l), h = i.length(), d = Fd({
      lightDistance: h,
      cutoffDistance: n,
      decayExponent: s
    }), f = r.mul(u).mul(d), p = e.context.reflectedLight;
    t.direct({
      lightDirection: a,
      lightColor: f,
      reflectedLight: p
    }, e.stack, e);
  }
}
const Hv = Pd;
re("SpotLightNode", Pd);
Cr(yi, Pd);
class eT extends yi {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, n, s, o), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
const tT = eT;
class Dd extends Hv {
  getSpotAttenuation(e) {
    const t = this.light.iesMap;
    let r = null;
    if (t && t.isTexture === !0) {
      const n = e.acos().mul(1 / Math.PI);
      r = Cn(t, rt(n, 0), 0).r;
    } else
      r = super.getSpotAttenuation(e);
    return r;
  }
}
const nT = Dd;
re("IESSpotLightNode", Dd);
Cr(tT, Dd);
class Ud extends nr {
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
const sT = Ud;
re("AmbientLightNode", Ud);
Cr(vu, Ud);
class zd extends nr {
  constructor(e = null) {
    super(e), this.lightPositionNode = Ia(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Ft(new je());
  }
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: r, lightDirectionNode: n } = this, o = ds.dot(n).mul(0.5).add(0.5), i = xn(r, t, o);
    e.context.irradiance.addAssign(i);
  }
}
const Xv = zd;
re("HemisphereLightNode", zd);
Cr(_m, zd);
const rT = Ve((c) => {
  const e = c.uv.mul(2), t = e.x.floor(), r = e.y.floor();
  return t.add(r).mod(2).sign();
});
class Bd extends Tt {
  constructor(e = gt()) {
    super("float"), this.uvNode = e;
  }
  setup() {
    return rT({ uv: this.uvNode });
  }
}
const $v = Bd, qv = J(Bd);
V("checker", qv);
re("CheckerNode", Bd);
class oT extends wr {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, n) {
    const s = new qs(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      try {
        t(this.parse(JSON.parse(o)));
      } catch (i) {
        n ? n(i) : console.error(i), this.manager.itemError(e);
      }
    }, r, n);
  }
  parseNodes(e) {
    const t = {};
    if (e !== void 0) {
      for (const n of e) {
        const { uuid: s, type: o } = n;
        t[s] = Me(Wl(o)), t[s].uuid = s;
      }
      const r = { nodes: t, textures: this.textures };
      for (const n of e)
        n.meta = r, t[n.uuid].deserialize(n), delete n.meta;
    }
    return t;
  }
  parse(e) {
    const t = Me(Wl(e.type));
    t.uuid = e.uuid;
    const n = { nodes: this.parseNodes(e.nodes), textures: this.textures };
    return e.meta = n, t.deserialize(e), delete e.meta, t;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
const Jv = oT, iT = new xu();
class Yv extends Jt {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.pointWidth = 1, this.pointColorNode = null, this.setDefaultValues(iT), this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor;
    this.vertexNode = Ve(() => {
      ct(rt(), "vUv").assign(gt());
      const r = _t("instancePosition"), n = Mn("vec4", "mvPos");
      n.assign(Ys.mul(st(r, 1)));
      const s = xr.z.div(xr.w), o = ls.mul(n), i = Mn("vec2", "offset");
      return i.assign(en.xy), i.assign(i.mul(f0)), i.assign(i.div(xr.z)), i.y.assign(i.y.mul(s)), i.assign(i.mul(o.w)), o.assign(o.add(st(i, 0, 0))), o;
    })(), this.colorNode = Ve(() => {
      const r = ct(rt(), "vUv"), n = Mn("float", "alpha");
      n.assign(1);
      const s = r.x, o = r.y, i = s.mul(s).add(o.mul(o));
      if (e) {
        const l = Mn("float", "dlen");
        l.assign(i.fwidth()), n.assign(_s(l.oneMinus(), l.add(1), i).oneMinus());
      } else
        i.greaterThan(1).discard();
      let a;
      return this.pointColorNode ? a = this.pointColorNode : t ? a = _t("instanceColor").mul(yo) : a = yo, st(a, n);
    })(), this.needsUpdate = !0;
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const aT = Yv;
an("InstancedPointsNodeMaterial", Yv);
const cT = new bu();
class Kv extends Jt {
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(cT), this.setValues(e);
  }
}
const Zv = Kv;
an("LineBasicNodeMaterial", Kv);
const lT = new Mm();
class Qv extends Jt {
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.normals = !1, this.setDefaultValues(lT), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, t = this.dashScaleNode ? Se(this.dashScaleNode) : Pa, r = this.dashSizeNode ? Se(this.dashSizeNode) : vh, n = this.dashSizeNode ? Se(this.dashGapNode) : xh;
    yr.assign(r), si.assign(n);
    const s = ct(_t("lineDistance").mul(t));
    (e ? s.add(e) : s).mod(yr.add(si)).greaterThan(yr).discard();
  }
}
const uT = Qv;
an("LineDashedNodeMaterial", Qv);
const hT = new Mm();
class e1 extends Jt {
  constructor(e = {}) {
    super(), this.normals = !1, this.lights = !1, this.setDefaultValues(hT), this.useAlphaToCoverage = !0, this.useColor = e.vertexColors, this.useDash = e.dashed, this.useWorldUnits = !1, this.dashOffset = 0, this.lineWidth = 1, this.lineColorNode = null, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setupShaders(), this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage, t = this.useColor, r = this.dashed, n = this.worldUnits, s = Ve(({ start: i, end: a }) => {
      const l = ls.element(2).element(2), d = ls.element(3).element(2).mul(-0.5).div(l).sub(i.z).div(a.z.sub(i.z));
      return st(xn(i.xyz, a.xyz, d), a.w);
    });
    this.vertexNode = Ve(() => {
      ct(rt(), "vUv").assign(gt());
      const i = _t("instanceStart"), a = _t("instanceEnd"), l = Mn("vec4", "start"), u = Mn("vec4", "end");
      l.assign(Ys.mul(st(i, 1))), u.assign(Ys.mul(st(a, 1))), n && (ct(Ce(), "worldStart").assign(l.xyz), ct(Ce(), "worldEnd").assign(u.xyz));
      const h = xr.z.div(xr.w), d = ls.element(2).element(3).equal(-1);
      ur(d, () => {
        ur(l.z.lessThan(0).and(u.z.greaterThan(0)), () => {
          u.assign(s({ start: l, end: u }));
        }).elseif(u.z.lessThan(0).and(l.z.greaterThanEqual(0)), () => {
          l.assign(s({ start: u, end: l }));
        });
      });
      const f = ls.mul(l), p = ls.mul(u), m = f.xyz.div(f.w), g = p.xyz.div(p.w), b = g.xy.sub(m.xy).temp();
      b.x.assign(b.x.mul(h)), b.assign(b.normalize());
      const v = mo(st());
      if (n) {
        const y = u.xyz.sub(l.xyz).normalize(), x = en.y.lessThan(0.5).cond(
          l.xyz.cross(y).normalize(),
          u.xyz.cross(y).normalize()
        );
        x.assign(en.x.lessThan(0).cond(x.negate(), x));
        const N = y.dot(Ce(0, 0, 1));
        r || (l.assign(l.sub(st(y.mul($r).mul(0.5), 0))), u.assign(u.add(st(y.mul($r).mul(0.5), 0))), x.assign(x.sub(Ce(b.mul(N), 0))), x.z.assign(x.z.add(0.5))), ur(en.y.greaterThan(1).or(en.y.lessThan(0)), () => {
          x.assign(x.add(Ce(b.mul(2).mul(N), 0)));
        }), x.assign(x.mul($r).mul(0.5));
        const w = ct(st(), "worldPos");
        w.assign(en.y.lessThan(0.5).cond(l, u)), w.assign(w.add(st(x, 0))), v.assign(ls.mul(w));
        const T = mo(Ce());
        T.assign(en.y.lessThan(0.5).cond(m, g)), v.z.assign(T.z.mul(v.w));
      } else {
        const y = Mn("vec2", "offset");
        y.assign(rt(b.y, b.x.negate())), b.x.assign(b.x.div(h)), y.x.assign(y.x.div(h)), y.assign(en.x.lessThan(0).cond(y.negate(), y)), ur(en.y.lessThan(0), () => {
          y.assign(y.sub(b));
        }).elseif(en.y.greaterThan(1), () => {
          y.assign(y.add(b));
        }), y.assign(y.mul($r)), y.assign(y.div(xr.w)), v.assign(en.y.lessThan(0.5).cond(f, p)), y.assign(y.mul(v.w)), v.assign(v.add(st(y, 0, 0)));
      }
      return v;
    })();
    const o = Ve(({ p1: i, p2: a, p3: l, p4: u }) => {
      const h = i.sub(l), d = u.sub(l), f = a.sub(i), p = h.dot(d), m = d.dot(f), g = h.dot(f), b = d.dot(d), y = f.dot(f).mul(b).sub(m.mul(m)), N = p.mul(m).sub(g.mul(b)).div(y).clamp(), w = p.add(m.mul(N)).div(b).clamp();
      return rt(N, w);
    });
    this.colorNode = Ve(() => {
      const i = ct(rt(), "vUv");
      if (r) {
        const u = this.offsetNode ? Se(this.offsetNodeNode) : $l, h = this.dashScaleNode ? Se(this.dashScaleNode) : Pa, d = this.dashSizeNode ? Se(this.dashSizeNode) : vh, f = this.dashSizeNode ? Se(this.dashGapNode) : xh;
        yr.assign(d), si.assign(f);
        const p = _t("instanceDistanceStart"), m = _t("instanceDistanceEnd"), g = en.y.lessThan(0.5).cond(h.mul(p), Pa.mul(m)), b = ct(g.add($l)), v = u ? b.add(u) : b;
        i.y.lessThan(-1).or(i.y.greaterThan(1)).discard(), v.mod(yr.add(si)).greaterThan(yr).discard();
      }
      const a = Mn("float", "alpha");
      if (a.assign(1), n) {
        const u = ct(Ce(), "worldStart"), h = ct(Ce(), "worldEnd"), d = ct(st(), "worldPos").xyz.normalize().mul(1e5), f = h.sub(u), p = o({ p1: u, p2: h, p3: Ce(0, 0, 0), p4: d }), m = u.add(f.mul(p.x)), g = d.mul(p.y), y = m.sub(g).length().div($r);
        if (!r)
          if (e) {
            const x = y.fwidth();
            a.assign(_s(x.negate().add(0.5), x.add(0.5), y).oneMinus());
          } else
            y.greaterThan(0.5).discard();
      } else if (e) {
        const u = i.x, h = i.y.greaterThan(0).cond(i.y.sub(1), i.y.add(1)), d = u.mul(u).add(h.mul(h)), f = Mn("float", "dlen");
        f.assign(d.fwidth()), ur(i.y.abs().greaterThan(1), () => {
          a.assign(_s(f.oneMinus(), f.add(1), d).oneMinus());
        });
      } else
        ur(i.y.abs().greaterThan(1), () => {
          const u = i.x, h = i.y.greaterThan(0).cond(i.y.sub(1), i.y.add(1));
          u.mul(u).add(h.mul(h)).greaterThan(1).discard();
        });
      let l;
      if (this.lineColorNode)
        l = this.lineColorNode;
      else if (t) {
        const u = _t("instanceColorStart"), h = _t("instanceColorEnd");
        l = en.y.lessThan(0.5).cond(u, h).mul(yo);
      } else
        l = yo;
      return st(l, a);
    })(), this.needsUpdate = !0;
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(e) {
    this.useWorldUnits !== e && (this.useWorldUnits = e, this.setupShaders());
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(e) {
    this.useDash !== e && (this.useDash = e, this.setupShaders());
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e && (this.useAlphaToCoverage = e, this.setupShaders());
  }
}
const dT = e1;
an("Line2NodeMaterial", e1);
const fT = new mb();
class t1 extends Jt {
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.colorSpace = !1, this.setDefaultValues(fT), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? Se(this.opacityNode) : yh;
    $t.assign(st(ed(At), e));
  }
}
const pT = t1;
an("MeshNormalNodeMaterial", t1);
const mT = new An();
class n1 extends Jt {
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(mT), this.setValues(e);
  }
}
const s1 = n1;
an("MeshBasicNodeMaterial", n1);
const gT = Ve(({ f0: c, f90: e, dotVH: t }) => {
  const r = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return c.mul(r.oneMinus()).add(e.mul(r));
}), vo = gT, yT = Ve((c) => c.diffuseColor.mul(1 / Math.PI)), ai = yT, vT = () => Se(0.25), xT = Ve(({ dotNH: c }) => Fa.mul(0.5 / Math.PI).add(1).mul(c.pow(Fa))), bT = Ve(({ lightDirection: c }) => {
  const e = c.add(It).normalize(), t = At.dot(e).clamp(), r = It.dot(e).clamp(), n = vo({ f0: cs, f90: 1, dotVH: r }), s = vT(), o = xT({ dotNH: t });
  return n.mul(s).mul(o);
});
class NT extends qu {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = At.dot(e).clamp().mul(t);
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: $t.rgb }))), this.specular === !0 && r.directSpecular.addAssign(s.mul(bT({ lightDirection: e })).mul(e0));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: $t })));
  }
}
const kd = NT, wT = new Am();
class r1 extends Jt {
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(wT), this.setValues(e);
  }
  setupLightingModel() {
    return new kd(!1);
  }
}
const TT = r1;
an("MeshLambertNodeMaterial", r1);
const ST = new ga();
class o1 extends Jt {
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(ST), this.setValues(e);
  }
  setupLightingModel() {
    return new kd();
  }
  setupVariants() {
    const e = (this.shininessNode ? Se(this.shininessNode) : Ky).max(1e-4);
    Fa.assign(e);
    const t = this.specularNode || Qy;
    cs.assign(t);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const _T = o1;
an("MeshPhongNodeMaterial", o1);
const MT = Ve(() => {
  const c = oi.dFdx().abs().max(oi.dFdy().abs());
  return c.x.max(c.y).max(c.z);
}), i1 = MT, AT = Ve((c) => {
  const { roughness: e } = c, t = i1();
  let r = e.max(0.0525);
  return r = r.add(t), r = r.min(1), r;
}), a1 = AT, CT = Ve((c) => {
  const { alpha: e, dotNL: t, dotNV: r } = c, n = e.pow2(), s = t.mul(n.add(n.oneMinus().mul(r.pow2())).sqrt()), o = r.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt());
  return go(0.5, s.add(o).max(rh));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), c1 = CT, ET = Ve(({ alpha: c, dotNH: e }) => {
  const t = c.pow2(), r = e.pow2().mul(t.oneMinus()).oneMinus();
  return t.div(r.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), l1 = ET, RT = Ve((c) => {
  const { lightDirection: e, f0: t, f90: r, roughness: n, iridescenceFresnel: s } = c, o = c.normalView || At, i = n.pow2(), a = e.add(It).normalize(), l = o.dot(e).clamp(), u = o.dot(It).clamp(), h = o.dot(a).clamp(), d = It.dot(a).clamp();
  let f = vo({ f0: t, f90: r, dotVH: d });
  s && (f = oc.mix(f, s));
  const p = c1({ alpha: i, dotNL: l, dotNV: u }), m = l1({ alpha: i, dotNH: h });
  return f.mul(p).mul(m);
}), Ql = RT, LT = Ve(({ roughness: c, dotNV: e }) => {
  const t = st(-1, -0.0275, -0.572, 0.022), r = st(1, 0.0425, 1.04, -0.04), n = c.mul(t).add(r), s = n.x.mul(n.x).min(e.mul(-9.28).exp2()).mul(n.x).add(n.y);
  return rt(-1.04, 1.04).mul(s).add(n.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), Gd = LT, FT = Ve((c) => {
  const { dotNV: e, specularColor: t, specularF90: r, roughness: n } = c, s = Gd({ dotNV: e, roughness: n });
  return t.mul(s.x).add(r.mul(s.y));
}), OT = FT, IT = Ve(({ f: c, f90: e, dotVH: t }) => {
  const r = t.oneMinus().saturate(), n = r.mul(r), s = r.mul(n, n).clamp(0, 0.9999);
  return c.sub(Ce(e).mul(s)).div(s.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), u1 = IT, PT = Ve(({ roughness: c, dotNH: e }) => {
  const t = c.pow2(), r = Se(1).div(t), s = e.pow2().oneMinus().max(78125e-7);
  return Se(2).add(r).mul(s.pow(r.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), DT = Ve(({ dotNV: c, dotNL: e }) => Se(1).div(Se(4).mul(e.add(c).sub(e.mul(c))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), UT = Ve(({ lightDirection: c }) => {
  const e = c.add(It).normalize(), t = At.dot(c).clamp(), r = At.dot(It).clamp(), n = At.dot(e).clamp(), s = PT({ roughness: rc, dotNH: n }), o = DT({ dotNV: r, dotNL: t });
  return fr.mul(s).mul(o);
}), zT = UT, BT = Ss(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), kT = (c) => {
  const e = c.sqrt();
  return Ce(1).add(e).div(Ce(1).sub(e));
}, ap = (c, e) => c.sub(e).div(c.add(e)).pow2(), GT = (c, e) => {
  const t = c.mul(2 * Math.PI * 1e-9), r = Ce(54856e-17, 44201e-17, 52481e-17), n = Ce(1681e3, 1795300, 2208400), s = Ce(43278e5, 93046e5, 66121e5), o = Se(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let i = r.mul(s.mul(2 * Math.PI).sqrt()).mul(n.mul(t).add(e).cos()).mul(t.pow2().negate().mul(s).exp());
  return i = Ce(i.x.add(o), i.y, i.z).div(10685e-11), BT.mul(i);
}, VT = Ve(({ outsideIOR: c, eta2: e, cosTheta1: t, thinFilmThickness: r, baseF0: n }) => {
  const s = xn(c, e, _s(0, 0.03, r)), o = c.div(s).pow2().mul(Se(1).sub(t.pow2())), a = Se(1).sub(o).sqrt(), l = ap(s, c), u = vo({ f0: l, f90: 1, dotVH: t }), h = u.oneMinus(), d = s.lessThan(c).cond(Math.PI, 0), f = Se(Math.PI).sub(d), p = kT(n.clamp(0, 0.9999)), m = ap(p, s.vec3()), g = vo({ f0: m, f90: 1, dotVH: a }), b = Ce(
    p.x.lessThan(s).cond(Math.PI, 0),
    p.y.lessThan(s).cond(Math.PI, 0),
    p.z.lessThan(s).cond(Math.PI, 0)
  ), v = s.mul(r, a, 2), y = Ce(f).add(b), x = u.mul(g).clamp(1e-5, 0.9999), N = x.sqrt(), w = h.pow2().mul(g).div(Ce(1).sub(x));
  let _ = u.add(w), L = w.sub(h);
  for (let A = 1; A <= 2; ++A) {
    L = L.mul(N);
    const U = GT(Se(A).mul(v), Se(A).mul(y)).mul(2);
    _ = _.add(L.mul(U));
  }
  return _.max(Ce(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), jT = Ve(({ normal: c, viewDir: e, roughness: t }) => {
  const r = c.dot(e).saturate(), n = t.pow2(), s = vr(
    t.lessThan(0.25),
    Se(-339.2).mul(n).add(Se(161.4).mul(t)).sub(25.9),
    Se(-8.48).mul(n).add(Se(14.3).mul(t)).sub(9.95)
  ), o = vr(
    t.lessThan(0.25),
    Se(44).mul(n).sub(Se(23.7).mul(t)).add(3.26),
    Se(1.97).mul(n).sub(Se(3.27).mul(t)).add(0.72)
  );
  return vr(t.lessThan(0.25), 0, Se(0.1).mul(t).sub(0.025)).add(s.mul(r).add(o).exp()).mul(1 / Math.PI).saturate();
}), nl = Ce(0.04), sl = Ce(1);
class WT extends qu {
  constructor(e = !1, t = !1, r = !1) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = r, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start() {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = Ce().temp("clearcoatRadiance"), this.clearcoatSpecularDirect = Ce().temp("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = Ce().temp("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = Ce().temp("sheenSpecularDirect"), this.sheenSpecularIndirect = Ce().temp("sheenSpecularIndirect")), this.iridescence === !0) {
      const e = At.dot(It).clamp();
      this.iridescenceFresnel = VT({
        outsideIOR: Se(1),
        eta2: eh,
        cosTheta1: e,
        thinFilmThickness: th,
        baseF0: cs
      }), this.iridescenceF0 = u1({ f: this.iridescenceFresnel, f90: 1, dotVH: e });
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, r = Se(1)) {
    const n = At.dot(It).clamp(), s = Gd({ roughness: ao, dotNV: n }), i = (this.iridescenceF0 ? oc.mix(cs, this.iridescenceF0) : cs).mul(s.x).add(r.mul(s.y)), l = s.x.add(s.y).oneMinus(), u = cs.add(cs.oneMinus().mul(0.047619)), h = i.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(i), t.addAssign(h.mul(l));
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = At.dot(e).clamp().mul(t);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(zT({ lightDirection: e }))), this.clearcoat === !0) {
      const i = pr.dot(e).clamp().mul(t);
      this.clearcoatSpecularDirect.addAssign(i.mul(Ql({ lightDirection: e, f0: nl, f90: sl, roughness: ni, normalView: pr })));
    }
    r.directDiffuse.addAssign(s.mul(ai({ diffuseColor: $t.rgb }))), r.directSpecular.addAssign(s.mul(Ql({ lightDirection: e, f0: cs, f90: 1, roughness: ao, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(ai({ diffuseColor: $t })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: r }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(t.mul(
      fr,
      jT({
        normal: At,
        viewDir: It,
        roughness: rc
      })
    )), this.clearcoat === !0) {
      const l = pr.dot(It).clamp(), u = OT({
        dotNV: l,
        specularColor: nl,
        specularF90: sl,
        roughness: ni
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(u));
    }
    const n = Ce().temp("singleScattering"), s = Ce().temp("multiScattering"), o = t.mul(1 / Math.PI);
    this.computeMultiscattering(n, s);
    const i = n.add(s), a = $t.mul(i.r.max(i.g).max(i.b).oneMinus());
    r.indirectSpecular.addAssign(e.mul(n)), r.indirectSpecular.addAssign(s.mul(o)), r.indirectDiffuse.addAssign(a.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
    const n = At.dot(It).clamp().add(e), s = ao.mul(-16).oneMinus().negate().exp2(), o = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), t.indirectDiffuse.mulAssign(e), t.indirectSpecular.mulAssign(o);
  }
  finish(e) {
    const { outgoingLight: t } = e;
    if (this.clearcoat === !0) {
      const r = pr.dot(It).clamp(), n = vo({
        dotVH: r,
        f0: nl,
        f90: sl
      }), s = t.mul(La.mul(n).oneMinus()).add(this.clearcoatSpecularDirect, this.clearcoatSpecularIndirect).mul(La);
      t.assign(s);
    }
    if (this.sheen === !0) {
      const r = fr.r.max(fr.g).max(fr.b).mul(0.157).oneMinus(), n = t.mul(r).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      t.assign(n);
    }
  }
}
const Vd = WT, HT = new Gn();
class h1 extends Jt {
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(HT), this.setValues(e);
  }
  setupLightingModel() {
    return new Vd();
  }
  setupVariants() {
    const e = this.metalnessNode ? Se(this.metalnessNode) : n0;
    Dg.assign(e);
    let t = this.roughnessNode ? Se(this.roughnessNode) : t0;
    t = a1({ roughness: t }), ao.assign(t);
    const r = xn(Ce(0.04), $t.rgb, e);
    cs.assign(r), $t.assign(st($t.rgb.mul(e.oneMinus()), $t.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const jd = h1;
an("MeshStandardNodeMaterial", h1);
const XT = new As();
class d1 extends jd {
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.setDefaultValues(XT), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  setupLightingModel() {
    return new Vd(this.useClearcoat, this.useSheen, this.useIridescence);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const t = this.clearcoatNode ? Se(this.clearcoatNode) : r0, r = this.clearcoatRoughnessNode ? Se(this.clearcoatRoughnessNode) : o0;
      La.assign(t), ni.assign(r);
    }
    if (this.useSheen) {
      const t = this.sheenNode ? Ce(this.sheenNode) : c0, r = this.sheenRoughnessNode ? Se(this.sheenRoughnessNode) : l0;
      fr.assign(t), rc.assign(r);
    }
    if (this.useIridescence) {
      const t = this.iridescenceNode ? Se(this.iridescenceNode) : u0, r = this.iridescenceIORNode ? Se(this.iridescenceIORNode) : h0, n = this.iridescenceThicknessNode ? Se(this.iridescenceThicknessNode) : d0;
      oc.assign(t), eh.assign(r), th.assign(n);
    }
  }
  setupNormal(e) {
    super.setupNormal(e);
    const t = this.clearcoatNormalNode ? Ce(this.clearcoatNormalNode) : i0;
    pr.assign(t);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, super.copy(e);
  }
}
const f1 = d1;
an("MeshPhysicalNodeMaterial", d1);
const $T = new xu();
class p1 extends Jt {
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.normals = !1, this.transparent = !0, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.sizeNode = null, this.positionNode = null, this.setDefaultValues($T), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
const Wd = p1;
an("PointsNodeMaterial", p1);
const qT = new gb();
class m1 extends Jt {
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this.normals = !1, this.colorNode = null, this.opacityNode = null, this.alphaTestNode = null, this.lightNode = null, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(qT), this.setValues(e);
  }
  setupPosition({ object: e, context: t }) {
    const { positionNode: r, rotationNode: n, scaleNode: s } = this, o = sn;
    let i = Ys.mul(Ce(r || 0)), a = rt(ri[0].xyz.length(), ri[1].xyz.length());
    s !== null && (a = a.mul(s));
    let l = o.xy;
    e.center && e.center.isVector2 === !0 && (l = l.sub(Ft(e.center).sub(0.5))), l = l.mul(a);
    const u = Se(n || a0), h = u.cos(), d = u.sin(), f = rt(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      rt(h, d.negate()).dot(l),
      rt(d, h).dot(l)
    );
    i = st(i.xy.add(f), i.zw);
    const p = ls.mul(i);
    return t.vertex = o, p;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
}
const g1 = m1;
an("SpriteNodeMaterial", m1);
const JT = vi.createMaterialFromType;
vi.createMaterialFromType = function(c) {
  const e = wo(c);
  return e !== void 0 ? e : JT.call(this, c);
};
class YT extends vi {
  constructor(e) {
    super(e), this.nodes = {};
  }
  parse(e) {
    const t = super.parse(e), r = this.nodes, n = e.inputNodes;
    for (const s in n) {
      const o = n[s];
      t[s] = r[o];
    }
    return t;
  }
  setNodes(e) {
    return this.nodes = e, this;
  }
}
const Ua = YT;
class KT extends yb {
  constructor(e) {
    super(e), this._nodesJSON = null;
  }
  parse(e, t) {
    this._nodesJSON = e.nodes;
    const r = super.parse(e, t);
    return this._nodesJSON = null, r;
  }
  parseNodes(e, t) {
    if (e !== void 0) {
      const r = new Jv();
      return r.setTextures(t), r.parseNodes(e);
    }
    return {};
  }
  parseMaterials(e, t) {
    const r = {};
    if (e !== void 0) {
      const n = this.parseNodes(this._nodesJSON, t), s = new Ua();
      s.setTextures(t), s.setNodes(n);
      for (let o = 0, i = e.length; o < i; o++) {
        const a = e[o];
        r[a.uuid] = s.parse(a);
      }
    }
    return r;
  }
}
const ZT = KT;
class QT {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
const eS = QT;
class y1 {
  constructor(e, t, r = "", n = "") {
    this.type = e, this.inputs = t, this.name = r, this.presicion = n;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
y1.isNodeFunction = !0;
const tS = y1, nS = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, sS = /[a-z_0-9]+/ig, cp = "#pragma main", rS = (c) => {
  c = c.trim();
  const e = c.indexOf(cp), t = e !== -1 ? c.slice(e + cp.length) : c, r = t.match(nS);
  if (r !== null && r.length === 5) {
    const n = r[4], s = [];
    let o = null;
    for (; (o = sS.exec(n)) !== null; )
      s.push(o);
    const i = [];
    let a = 0;
    for (; a < s.length; ) {
      const p = s[a][0] === "const";
      p === !0 && a++;
      let m = s[a][0];
      m === "in" || m === "out" || m === "inout" ? a++ : m = "";
      const g = s[a++][0];
      let b = Number.parseInt(s[a][0]);
      Number.isNaN(b) === !1 ? a++ : b = null;
      const v = s[a++][0];
      i.push(new $h(g, v, b, m, p));
    }
    const l = t.substring(r[0].length), u = r[3] !== void 0 ? r[3] : "", h = r[2], d = r[1] !== void 0 ? r[1] : "", f = e !== -1 ? c.slice(0, e) : "";
    return {
      type: h,
      inputs: i,
      name: u,
      presicion: d,
      inputsCode: n,
      blockCode: l,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class oS extends tS {
  constructor(e) {
    const { type: t, inputs: r, name: n, presicion: s, inputsCode: o, blockCode: i, headerCode: a } = rS(e);
    super(t, r, n, s), this.inputsCode = o, this.blockCode = i, this.headerCode = a;
  }
  getCode(e = this.name) {
    let t;
    const r = this.blockCode;
    if (r !== "") {
      const { type: n, inputsCode: s, headerCode: o, presicion: i } = this;
      let a = `${n} ${e} ( ${s.trim()} )`;
      i !== "" && (a = `${i} ${a}`), t = o + a + r;
    } else
      t = "";
    return t;
  }
}
const iS = oS;
class aS extends eS {
  parseFunction(e) {
    return new iS(e);
  }
}
const v1 = aS, cS = Nd(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`), ss = [cS], x1 = cn("float mx_perlin_noise_float( any p )", ss), lS = cn("vec2 mx_perlin_noise_vec2( any p )", ss), b1 = cn("vec3 mx_perlin_noise_vec3( any p )", ss), uS = cn("float mx_cell_noise_float( vec3 p )", ss), hS = cn("float mx_worley_noise_float( any p, float jitter, int metric )", ss), dS = cn("vec2 mx_worley_noise_vec2( any p, float jitter, int metric )", ss), fS = cn("vec3 mx_worley_noise_vec3( any p, float jitter, int metric )", ss), pS = cn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", ss), mS = cn("vec2 mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", ss), gS = cn("vec3 mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", ss), yS = cn("vec4 mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", ss), vS = cn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`), xS = cn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`), bS = Nd(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`), NS = [bS], wS = cn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", NS), N1 = (c, e) => {
  c = Se(c), e = Se(e);
  const t = rt(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476);
  return _s(c.sub(t), c.add(t), e);
}, w1 = (c, e, t, r) => xn(c, e, t[r].clamp()), TS = (c, e, t = gt()) => w1(c, e, t, "x"), SS = (c, e, t = gt()) => w1(c, e, t, "y"), T1 = (c, e, t, r, n) => xn(c, e, N1(t, r[n])), _S = (c, e, t, r = gt()) => T1(c, e, t, r, "x"), MS = (c, e, t, r = gt()) => T1(c, e, t, r, "y"), AS = (c = 1, e = 0, t = gt()) => t.mul(c).add(e), CS = (c, e = 1) => (c = Se(c), c.abs().pow(e).mul(c.sign())), ES = (c, e = 1, t = 0.5) => Se(c).sub(t).mul(e).add(t), RS = (c = gt(), e = 1, t = 0) => x1(c.convert("vec2|vec3")).mul(e).add(t), LS = (c = gt(), e = 1, t = 0) => lS(c.convert("vec2|vec3")).mul(e).add(t), FS = (c = gt(), e = 1, t = 0) => b1(c.convert("vec2|vec3")).mul(e).add(t), OS = (c = gt(), e = 1, t = 0) => (c = c.convert("vec2|vec3"), st(b1(c), x1(c.add(rt(19, 73)))).mul(e).add(t)), IS = (c = gt(), e = 1) => hS(c.convert("vec2|vec3"), e, 1), PS = (c = gt(), e = 1) => dS(c.convert("vec2|vec3"), e, 1), DS = (c = gt(), e = 1) => fS(c.convert("vec2|vec3"), e, 1), US = (c = gt()) => uS(c.convert("vec2|vec3")), zS = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => pS(c, e, t, r).mul(n), BS = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => mS(c, e, t, r).mul(n), kS = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => gS(c, e, t, r).mul(n), GS = (c = gt(), e = 3, t = 2, r = 0.5, n = 1) => yS(c, e, t, r).mul(n), S1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AONode: Ih,
  AmbientLightNode: sT,
  AnalyticLightNode: nr,
  ArrayElementNode: Za,
  ArrayUniformNode: Rg,
  AssignNode: _N,
  AttributeNode: Gu,
  BRDF_GGX: Ql,
  BRDF_Lambert: ai,
  BitangentNode: eo,
  BlendModeNode: to,
  BufferAttributeNode: aw,
  BufferNode: Mh,
  BumpMapNode: N2,
  BypassNode: Og,
  CacheNode: Ig,
  CameraNode: mh,
  CheckerNode: $v,
  CodeNode: bd,
  ColorAdjustmentNode: Ho,
  ColorSpaceNode: jo,
  ComputeNode: Vv,
  CondNode: Wh,
  ConstNode: Ln,
  ContextNode: Xu,
  ConvertNode: Qa,
  CubeTextureNode: M0,
  DFGApprox: Gd,
  D_GGX: l1,
  DirectionalLightNode: Q2,
  DiscardNode: Vw,
  EPSILON: rh,
  EnvironmentNode: Vh,
  EquirectUVNode: F0,
  ExpressionNode: Xy,
  F_Schlick: vo,
  FogExp2Node: Bv,
  FogNode: xc,
  FogRangeNode: Uv,
  FrontFacingNode: dv,
  FunctionCallNode: X2,
  FunctionNode: Fv,
  GLSLNodeParser: v1,
  HashNode: Gw,
  HemisphereLightNode: Xv,
  IESSpotLightNode: nT,
  INFINITY: kN,
  If: ur,
  IndexNode: CN,
  InstanceNode: cw,
  InstancedPointsNodeMaterial: aT,
  JoinNode: Ym,
  LightNode: Z2,
  LightingContextNode: fw,
  LightingModel: qu,
  LightingNode: _i,
  LightsNode: E0,
  Line2NodeMaterial: dT,
  LineBasicNodeMaterial: Zv,
  LineDashedNodeMaterial: uT,
  LoopNode: Ww,
  MatcapUVNode: V0,
  MaterialNode: bs,
  MaterialReferenceNode: $y,
  MathNode: ke,
  MaxMipLevelNode: O0,
  MeshBasicNodeMaterial: s1,
  MeshLambertNodeMaterial: TT,
  MeshNormalNodeMaterial: pT,
  MeshPhongNodeMaterial: _T,
  MeshPhysicalNodeMaterial: f1,
  MeshStandardNodeMaterial: jd,
  ModelNode: tw,
  ModelViewProjectionNode: p0,
  MorphNode: uw,
  Node: Fe,
  NodeAttribute: Ra,
  NodeBuilder: D0,
  NodeCache: nc,
  NodeCode: Ku,
  NodeFrame: Xh,
  NodeFunctionInput: $h,
  NodeKeywords: Zu,
  NodeLoader: Jv,
  NodeMaterial: Jt,
  NodeMaterialLoader: Ua,
  NodeObjectLoader: ZT,
  NodeShaderStage: Gl,
  NodeType: aN,
  NodeUniform: Ju,
  NodeUpdateType: ut,
  NodeUtils: cN,
  NodeVar: sc,
  NodeVarying: Yu,
  NormalMapNode: bv,
  NormalNode: Wo,
  Object3DNode: mn,
  OperatorNode: Gg,
  OscNode: Qr,
  OutputStructNode: Bw,
  PackingNode: Qw,
  ParameterNode: Xl,
  PhongLightingModel: kd,
  PhysicalLightingModel: Vd,
  PointLightNode: Wv,
  PointUVNode: iv,
  PointsNodeMaterial: Wd,
  PositionNode: Us,
  PosterizeNode: Tv,
  PropertyNode: Qu,
  RangeNode: Gv,
  ReferenceNode: lc,
  ReflectVectorNode: S0,
  RemapNode: H0,
  RotateUVNode: q0,
  SceneNode: i2,
  Schlick_to_F0: u1,
  ScriptableNode: Y2,
  ScriptableValueNode: q2,
  SetNode: Qm,
  ShaderNode: mr,
  SkinningNode: N0,
  SpecularMIPLevelNode: I0,
  SplitNode: Aa,
  SpotLightNode: Hv,
  SpriteNodeMaterial: g1,
  SpriteSheetUVNode: Y0,
  StackNode: Rw,
  StorageBufferNode: l2,
  TBNViewMatrix: wv,
  TangentNode: Zr,
  TempNode: Tt,
  TextureBicubicNode: o2,
  TextureNode: wi,
  TextureStoreNode: h2,
  TimerNode: j0,
  ToneMappingNode: _v,
  TriplanarTexturesNode: Z0,
  UVNode: zg,
  UniformNode: nt,
  UserDataNode: f2,
  V_GGX_SmithCorrelated: c1,
  VarNode: Cg,
  VaryingNode: Fg,
  ViewportDepthNode: G2,
  ViewportDepthTextureNode: z2,
  ViewportNode: zs,
  ViewportSharedTextureNode: U2,
  ViewportTextureNode: md,
  abs: ih,
  acos: py,
  add: Qn,
  addLightNode: Cr,
  addNodeClass: re,
  addNodeElement: V,
  addNodeMaterial: an,
  and: qg,
  append: og,
  arrayBuffer: _g,
  asin: fy,
  assign: Lg,
  atan: my,
  atan2: My,
  attribute: _t,
  backgroundBlurriness: a2,
  backgroundIntensity: c2,
  bitAnd: Kg,
  bitOr: Zg,
  bitXor: Qg,
  bitangentGeometry: e2,
  bitangentLocal: t2,
  bitangentView: tv,
  bitangentWorld: n2,
  bmat3: bg,
  bmat4: Tg,
  bool: cg,
  buffer: Ah,
  bufferAttribute: Ti,
  bumpMap: pv,
  burn: cv,
  bvec2: hg,
  bvec3: pg,
  bvec4: yg,
  bypass: ju,
  cache: Ea,
  call: Lv,
  cameraFar: xa,
  cameraNear: va,
  cameraNormalMatrix: ZN,
  cameraPosition: ew,
  cameraProjectionMatrix: ls,
  cameraViewMatrix: Cs,
  cameraWorldMatrix: QN,
  ceil: oh,
  checker: qv,
  clamp: lh,
  clearcoat: La,
  clearcoatRoughness: ni,
  code: vc,
  color: ig,
  colorSpaceToLinear: cc,
  colorToDirection: W0,
  compute: jv,
  cond: vr,
  context: Yn,
  convert: Ag,
  cos: hy,
  createNodeFromType: Wl,
  createNodeMaterialFromType: wo,
  cross: Iy,
  cubeTexture: dc,
  dFdx: by,
  dFdy: Ny,
  dashSize: yr,
  defaultBuildStages: Vl,
  defaultShaderStages: Yr,
  degrees: sy,
  densityFog: kv,
  depth: V2,
  depthTexture: j2,
  difference: Oy,
  diffuseColor: $t,
  directionToColor: ed,
  discard: k0,
  distance: Fy,
  div: go,
  dodge: lv,
  dot: ah,
  dynamicBufferAttribute: g0,
  element: Mg,
  equal: jg,
  equirectUV: fc,
  exp: ry,
  exp2: oy,
  expression: Ni,
  faceDirection: ud,
  faceForward: Gy,
  float: Se,
  floor: ic,
  fog: Dv,
  fract: ac,
  frameId: qw,
  frontFacing: fv,
  fwidth: _y,
  gapSize: si,
  getConstNodeType: rg,
  getCurrentStack: Iu,
  getDistanceAttenuation: Fd,
  getGeometryRoughness: i1,
  getRoughness: a1,
  global: ba,
  glsl: Nd,
  glslFn: cn,
  greaterThan: Hg,
  greaterThanEqual: $g,
  hash: B0,
  hue: yv,
  imat3: vg,
  imat4: Ng,
  instance: x0,
  instanceIndex: Pg,
  instancedBufferAttribute: y0,
  instancedDynamicBufferAttribute: v0,
  int: Ca,
  inverseSqrt: ly,
  iridescence: oc,
  iridescenceIOR: eh,
  iridescenceThickness: th,
  ivec2: lg,
  ivec3: dg,
  ivec4: mg,
  js: W2,
  label: $u,
  length: yy,
  lessThan: Wg,
  lessThanEqual: Xg,
  lightTargetDirection: Ld,
  lightingContext: Dh,
  lights: dw,
  lightsWithoutWrap: R0,
  linearToColorSpace: jy,
  linearTosRGB: Wy,
  log: iy,
  log2: ay,
  loop: G0,
  lumaCoeffs: vv,
  luminance: xv,
  mat3: Ss,
  mat4: Pu,
  matcapUV: Hw,
  materialAlphaTest: Yy,
  materialClearcoat: r0,
  materialClearcoatNormal: i0,
  materialClearcoatRoughness: o0,
  materialColor: yo,
  materialEmissive: Zy,
  materialIridescence: u0,
  materialIridescenceIOR: h0,
  materialIridescenceThickness: d0,
  materialLineDashOffset: $l,
  materialLineDashSize: vh,
  materialLineGapSize: xh,
  materialLineScale: Pa,
  materialLineWidth: $r,
  materialMetalness: n0,
  materialNormal: s0,
  materialOpacity: yh,
  materialPointWidth: f0,
  materialReference: qy,
  materialReflectivity: iw,
  materialRotation: a0,
  materialRoughness: t0,
  materialSheen: c0,
  materialSheenRoughness: l0,
  materialShininess: Ky,
  materialSpecularColor: Qy,
  materialSpecularStrength: e0,
  max: Cy,
  maxMipLevel: Bh,
  metalness: Dg,
  min: Ay,
  mix: xn,
  mod: Ey,
  modelDirection: nw,
  modelNormalMatrix: gh,
  modelPosition: sw,
  modelScale: rw,
  modelViewMatrix: Ys,
  modelViewPosition: ow,
  modelViewProjection: m0,
  modelWorldMatrix: ri,
  morph: T0,
  mul: Qt,
  mx_aastep: N1,
  mx_cell_noise_float: US,
  mx_contrast: ES,
  mx_fractal_noise_float: zS,
  mx_fractal_noise_vec2: BS,
  mx_fractal_noise_vec3: kS,
  mx_fractal_noise_vec4: GS,
  mx_hsvtorgb: vS,
  mx_noise_float: RS,
  mx_noise_vec2: LS,
  mx_noise_vec3: FS,
  mx_noise_vec4: OS,
  mx_ramplr: TS,
  mx_ramptb: SS,
  mx_rgbtohsv: xS,
  mx_safepower: CS,
  mx_splitlr: _S,
  mx_splittb: MS,
  mx_srgb_texture_to_lin_rec709: wS,
  mx_transform_uv: AS,
  mx_worley_noise_float: IS,
  mx_worley_noise_vec2: PS,
  mx_worley_noise_vec3: DS,
  negate: vy,
  nodeArray: gr,
  nodeImmutable: ue,
  nodeObject: Me,
  nodeObjects: bi,
  nodeProxy: J,
  normalGeometry: oi,
  normalLocal: Sr,
  normalMap: Nv,
  normalView: ds,
  normalWorld: uc,
  normalize: Rn,
  objectDirection: $N,
  objectNormalMatrix: JN,
  objectPosition: Ia,
  objectScale: KN,
  objectViewMatrix: qN,
  objectViewPosition: ph,
  objectWorldMatrix: YN,
  oneMinus: xy,
  or: Jg,
  orthographicDepthToViewZ: B2,
  oscSawtooth: Zw,
  oscSine: Jw,
  oscSquare: Yw,
  oscTriangle: Kw,
  output: Ug,
  outputStruct: kw,
  overlay: uv,
  parameter: zN,
  perspectiveDepthToViewZ: Rv,
  pointUV: av,
  pointWidth: UN,
  positionGeometry: en,
  positionLocal: sn,
  positionView: es,
  positionViewDirection: It,
  positionWorld: bh,
  positionWorldDirection: Nh,
  posterize: Sv,
  pow: ch,
  pow2: Py,
  pow3: Dy,
  pow4: Uy,
  property: Mn,
  radians: ny,
  range: K2,
  rangeFog: zv,
  reciprocal: Ty,
  reference: Ms,
  reflect: Ly,
  reflectVector: _0,
  refract: ky,
  remainder: Vg,
  remap: X0,
  remapClamp: $0,
  rotateUV: J0,
  roughness: ao,
  round: wy,
  sRGBToLinear: Hy,
  sampler: XN,
  saturate: By,
  saturation: mv,
  screen: hv,
  scriptable: Pv,
  scriptableValue: Xo,
  setCurrentStack: ti,
  shader: TN,
  shaderStages: Hm,
  sheen: fr,
  sheenRoughness: rc,
  shiftLeft: ey,
  shiftRight: ty,
  shininess: Fa,
  sign: gy,
  sin: uy,
  skinning: w0,
  smoothstep: _s,
  specularColor: cs,
  specularMIPLevel: Gh,
  split: SN,
  spritesheetUV: K0,
  sqrt: cy,
  stack: Jl,
  step: Ry,
  storage: u2,
  string: Sg,
  sub: Oa,
  tan: dy,
  tangentGeometry: ii,
  tangentLocal: hc,
  tangentView: Si,
  tangentWorld: b0,
  temp: mo,
  texture: Cn,
  textureBicubic: ov,
  textureStore: d2,
  timerDelta: $w,
  timerGlobal: Xw,
  timerLocal: Qh,
  toneMapping: F2,
  transformDirection: zy,
  transformedBitangentView: nv,
  transformedBitangentWorld: s2,
  transformedClearcoatNormalView: pr,
  transformedNormalView: At,
  transformedNormalWorld: Jy,
  transformedTangentView: Ch,
  transformedTangentWorld: lw,
  triplanarTexture: ev,
  triplanarTextures: Q0,
  trunc: Sy,
  tslFn: Ve,
  uint: ag,
  umat3: xg,
  umat4: wg,
  uniform: Ft,
  userData: p2,
  uv: gt,
  uvec2: ug,
  uvec3: fg,
  uvec4: gg,
  varying: ct,
  vec2: rt,
  vec3: Ce,
  vec4: st,
  vectorComponents: Ya,
  vertexIndex: EN,
  vibrance: gv,
  viewZToOrthographicDepth: Zl,
  viewZToPerspectiveDepth: k2,
  viewport: xr,
  viewportBottomLeft: I2,
  viewportBottomRight: D2,
  viewportCoordinate: O2,
  viewportDepthTexture: vd,
  viewportMipTexture: Cv,
  viewportResolution: Mv,
  viewportSharedTexture: Ev,
  viewportTexture: Av,
  viewportTopLeft: gc,
  viewportTopRight: P2,
  wgsl: H2,
  wgslFn: $2,
  xor: Yg
}, Symbol.toStringTag, { value: "Module" })), _r = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new Set(), VS = vn.prototype.clone;
vn.prototype.clone = function(c) {
  const e = VS.call(this, c);
  return _r.set(this, e), e;
};
function _1() {
  for (const c of za)
    _r.delete(c);
  za.clear();
}
function M1() {
  for (const c of za)
    _r.delete(c);
  za.clear();
}
function A1(c, e, t) {
  _1();
  const r = c.clone(e);
  return c.traverse((n) => {
    if (!n.graph)
      return;
    const s = _r.get(n);
    s && (s.graph = n.graph.clone(t || c, _r));
  }), M1(), r;
}
const C1 = {
  BitangentNodeScope: {
    LOCAL: eo.LOCAL,
    VIEW: eo.VIEW,
    WORLD: eo.WORLD,
    GEOMETRY: eo.GEOMETRY
  },
  Blending: { AdditiveBlending: M.AdditiveBlending, CustomBlending: M.CustomBlending, MultiplyBlending: M.MultiplyBlending, NoBlending: M.NoBlending, NormalBlending: M.NormalBlending, SubtractiveBlending: M.SubtractiveBlending },
  BlendingDstFactor: { DstAlphaFactor: M.DstAlphaFactor, DstColorFactor: M.DstColorFactor, OneFactor: M.OneFactor, OneMinusDstAlphaFactor: M.OneMinusDstAlphaFactor, OneMinusDstColorFactor: M.OneMinusDstColorFactor, OneMinusSrcAlphaFactor: M.OneMinusSrcAlphaFactor, OneMinusSrcColorFactor: M.OneMinusSrcColorFactor, SrcAlphaFactor: M.SrcAlphaFactor, SrcColorFactor: M.SrcColorFactor, ZeroFactor: M.ZeroFactor },
  BlendingSrcFactor: { SrcAlphaSaturateFactor: M.SrcAlphaSaturateFactor },
  BlendingEquation: { AddEquation: M.AddEquation, MaxEquation: M.MaxEquation, MinEquation: M.MinEquation, ReverseSubtractEquation: M.ReverseSubtractEquation, SubtractEquation: M.SubtractEquation },
  BlendMode: {
    BURN: to.BURN,
    DODGE: to.DODGE,
    SCREEN: to.SCREEN,
    OVERLAY: to.OVERLAY
  },
  CameraNodeScope: {
    VIEW_MATRIX: mn.VIEW_MATRIX,
    NORMAL_MATRIX: mn.NORMAL_MATRIX,
    WORLD_MATRIX: mn.WORLD_MATRIX,
    POSITION: mn.POSITION,
    VIEW_POSITION: mn.VIEW_POSITION,
    PROJECTION_MATRIX: mh.PROJECTION_MATRIX
  },
  ColorAdjustmentMethod: {
    SATURATION: Ho.SATURATION,
    VIBRANCE: Ho.VIBRANCE,
    HUE: Ho.HUE
  },
  ColorSpace: { DisplayP3ColorSpace: M.DisplayP3ColorSpace, LinearDisplayP3ColorSpace: M.LinearDisplayP3ColorSpace, LinearSRGBColorSpace: M.LinearSRGBColorSpace, NoColorSpace: M.NoColorSpace, SRGBColorSpace: M.SRGBColorSpace },
  ColorSpaceNodeMethod: {
    LINEAR_TO_LINEAR: jo.LINEAR_TO_LINEAR,
    LINEAR_TO_sRGB: jo.LINEAR_TO_sRGB,
    sRGB_TO_LINEAR: jo.sRGB_TO_LINEAR
  },
  Combine: { AddOperation: M.AddOperation, MixOperation: M.MixOperation, MultiplyOperation: M.MultiplyOperation },
  CompressedPixelFormat: { RED_GREEN_RGTC2_Format: M.RED_GREEN_RGTC2_Format, RED_RGTC1_Format: M.RED_RGTC1_Format, RGBA_ASTC_10x10_Format: M.RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format: M.RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format: M.RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format: M.RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format: M.RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format: M.RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format: M.RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format: M.RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format: M.RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format: M.RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format: M.RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format: M.RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format: M.RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format: M.RGBA_ASTC_8x8_Format, RGBA_BPTC_Format: M.RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: M.RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format: M.RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format: M.RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format: M.RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format: M.RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format: M.RGBA_S3TC_DXT5_Format, RGB_BPTC_SIGNED_Format: M.RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format: M.RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format: M.RGB_ETC1_Format, RGB_ETC2_Format: M.RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format: M.RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format: M.RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: M.RGB_S3TC_DXT1_Format, SIGNED_RED_GREEN_RGTC2_Format: M.SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format: M.SIGNED_RED_RGTC1_Format },
  CoordinateSystem: { WebGLCoordinateSystem: M.WebGLCoordinateSystem, WebGPUCoordinateSystem: M.WebGPUCoordinateSystem },
  CubeTextureMapping: { CubeReflectionMapping: M.CubeReflectionMapping, CubeRefractionMapping: M.CubeRefractionMapping, CubeUVReflectionMapping: M.CubeUVReflectionMapping },
  DeepTexturePixelFormat: { DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat },
  DepthModes: { AlwaysDepth: M.AlwaysDepth, EqualDepth: M.EqualDepth, GreaterDepth: M.GreaterDepth, GreaterEqualDepth: M.GreaterEqualDepth, LessDepth: M.LessDepth, LessEqualDepth: M.LessEqualDepth, NeverDepth: M.NeverDepth, NotEqualDepth: M.NotEqualDepth },
  DepthPackingStrategies: { BasicDepthPacking: M.BasicDepthPacking, RGBADepthPacking: M.RGBADepthPacking },
  GLSLVersion: { GLSL1: M.GLSL1, GLSL3: M.GLSL3 },
  MagnificationTextureFilter: { LinearFilter: M.LinearFilter, NearestFilter: M.NearestFilter },
  Mapping: { EquirectangularReflectionMapping: M.EquirectangularReflectionMapping, EquirectangularRefractionMapping: M.EquirectangularRefractionMapping, UVMapping: M.UVMapping },
  MaterialNodeScope: {
    ALPHA_TEST: bs.ALPHA_TEST,
    COLOR: bs.COLOR,
    OPACITY: bs.OPACITY,
    ROUGHNESS: bs.ROUGHNESS,
    METALNESS: bs.METALNESS,
    EMISSIVE: bs.EMISSIVE,
    ROTATION: bs.ROTATION
  },
  MathNodeMethod1: {
    RADIANS: ke.RADIANS,
    DEGREES: ke.DEGREES,
    EXP: ke.EXP,
    EXP2: ke.EXP2,
    LOG: ke.LOG,
    LOG2: ke.LOG2,
    SQRT: ke.SQRT,
    INVERSE_SQRT: ke.INVERSE_SQRT,
    FLOOR: ke.FLOOR,
    CEIL: ke.CEIL,
    NORMALIZE: ke.NORMALIZE,
    FRACT: ke.FRACT,
    SIN: ke.SIN,
    COS: ke.COS,
    TAN: ke.TAN,
    ASIN: ke.ASIN,
    ACOS: ke.ACOS,
    ATAN: ke.ATAN,
    ABS: ke.ABS,
    SIGN: ke.SIGN,
    LENGTH: ke.LENGTH,
    NEGATE: ke.NEGATE,
    ONE_MINUS: ke.ONE_MINUS,
    DFDX: ke.DFDX,
    DFDY: ke.DFDY,
    ROUND: ke.ROUND
  },
  MathNodeMethod2: {
    ATAN2: ke.ATAN2,
    MIN: ke.MIN,
    MAX: ke.MAX,
    MOD: ke.MOD,
    STEP: ke.STEP,
    REFLECT: ke.REFLECT,
    DISTANCE: ke.DISTANCE,
    DOT: ke.DOT,
    CROSS: ke.CROSS,
    POW: ke.POW,
    TRANSFORM_DIRECTION: ke.TRANSFORM_DIRECTION
  },
  MathNodeMethod3: {
    MIX: ke.MIX,
    CLAMP: ke.CLAMP,
    REFRACT: ke.REFRACT,
    SMOOTHSTEP: ke.SMOOTHSTEP,
    FACEFORWARD: ke.FACEFORWARD
  },
  MinificationTextureFilter: { LinearFilter: M.LinearFilter, LinearMipMapLinearFilter: M.LinearMipMapLinearFilter, LinearMipMapNearestFilter: M.LinearMipMapNearestFilter, LinearMipmapLinearFilter: M.LinearMipmapLinearFilter, LinearMipmapNearestFilter: M.LinearMipmapNearestFilter, NearestFilter: M.NearestFilter, NearestMipMapLinearFilter: M.NearestMipMapLinearFilter, NearestMipMapNearestFilter: M.NearestMipMapNearestFilter, NearestMipmapLinearFilter: M.NearestMipmapLinearFilter, NearestMipmapNearestFilter: M.NearestMipmapNearestFilter },
  NodeTypeOption: "void,bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","),
  NormalMapTypes: { ObjectSpaceNormalMap: M.ObjectSpaceNormalMap, TangentSpaceNormalMap: M.TangentSpaceNormalMap },
  NormalNodeScope: {
    GEOMETRY: Wo.GEOMETRY,
    LOCAL: Wo.LOCAL,
    VIEW: Wo.VIEW
  },
  Object3DNodeScope: {
    VIEW_MATRIX: mn.VIEW_MATRIX,
    NORMAL_MATRIX: mn.NORMAL_MATRIX,
    WORLD_MATRIX: mn.WORLD_MATRIX,
    POSITION: mn.POSITION,
    VIEW_POSITION: mn.VIEW_POSITION
  },
  OperatorNodeOp: ["=", "%", "&", "|", "^", ">>", "<<", "==", "&&", "||", "^^", "<", ">", "<=", ">=", "+", "-", "*", "/"],
  OscNodeMethod: {
    SINE: Qr.SINE,
    SQUARE: Qr.SQUARE,
    TRIANGLE: Qr.TRIANGLE,
    SAWTOOTH: Qr.SAWTOOTH
  },
  PixelFormatGPU: ["ALPHA", "DEPTH24_STENCIL8", "DEPTH32F_STENCIL8", "DEPTH_COMPONENT16", "DEPTH_COMPONENT24", "DEPTH_COMPONENT32F", "LUMINANCE", "LUMINANCE_ALPHA", "R11F_G11F_B10F", "R16F", "R16I", "R16UI", "R32F", "R32I", "R32UI", "R8", "R8I", "R8UI", "R8_SNORM", "RED_INTEGER", "RG16F", "RG16I", "RG16UI", "RG32F", "RG32I", "RG32UI", "RG8", "RG8I", "RG8UI", "RG8_SNORM", "RGB", "RGB10_A2", "RGB10_A2UI", "RGB16F", "RGB16I", "RGB16UI", "RGB32F", "RGB32I", "RGB32UI", "RGB565", "RGB5_A1", "RGB8", "RGB8I", "RGB8UI", "RGB8_SNORM", "RGB9_E5", "RGBA", "RGBA16F", "RGBA16I", "RGBA16UI", "RGBA32F", "RGBA32I", "RGBA32UI", "RGBA4", "RGBA8", "RGBA8I", "RGBA8UI", "RGBA8_SNORM", "SRGB8", "SRGB8_ALPHA8"],
  PositionNodeScope: {
    GEOMETRY: Us.GEOMETRY,
    LOCAL: Us.LOCAL,
    WORLD: Us.WORLD,
    WORLD_DIRECTION: Us.WORLD_DIRECTION,
    VIEW: Us.VIEW,
    VIEW_DIRECTION: Us.VIEW_DIRECTION
  },
  Precision: ["highp", "mediump", "lowp"],
  Side: { BackSide: M.BackSide, DoubleSide: M.DoubleSide, FrontSide: M.FrontSide, TwoPassDoubleSide: M.TwoPassDoubleSide },
  StencilFunc: { AlwaysStencilFunc: M.AlwaysStencilFunc, EqualStencilFunc: M.EqualStencilFunc, GreaterEqualStencilFunc: M.GreaterEqualStencilFunc, GreaterStencilFunc: M.GreaterStencilFunc, LessEqualStencilFunc: M.LessEqualStencilFunc, LessStencilFunc: M.LessStencilFunc, NeverStencilFunc: M.NeverStencilFunc, NotEqualStencilFunc: M.NotEqualStencilFunc },
  StencilOp: { DecrementStencilOp: M.DecrementStencilOp, DecrementWrapStencilOp: M.DecrementWrapStencilOp, IncrementStencilOp: M.IncrementStencilOp, IncrementWrapStencilOp: M.IncrementWrapStencilOp, InvertStencilOp: M.InvertStencilOp, KeepStencilOp: M.KeepStencilOp, ReplaceStencilOp: M.ReplaceStencilOp, ZeroStencilOp: M.ZeroStencilOp },
  TangentNodeScope: {
    LOCAL: Zr.LOCAL,
    VIEW: Zr.VIEW,
    WORLD: Zr.WORLD,
    GEOMETRY: Zr.GEOMETRY
  },
  TextureComparisonFunction: { AlwaysCompare: M.AlwaysCompare, EqualCompare: M.EqualCompare, GreaterCompare: M.GreaterCompare, GreaterEqualCompare: M.GreaterEqualCompare, LessCompare: M.LessCompare, LessEqualCompare: M.LessEqualCompare, NeverCompare: M.NeverCompare, NotEqualCompare: M.NotEqualCompare },
  TextureDataType: { ByteType: M.ByteType, FloatType: M.FloatType, HalfFloatType: M.HalfFloatType, IntType: M.IntType, ShortType: M.ShortType, UnsignedByteType: M.UnsignedByteType, UnsignedInt248Type: M.UnsignedInt248Type, UnsignedIntType: M.UnsignedIntType, UnsignedShort4444Type: M.UnsignedShort4444Type, UnsignedShort5551Type: M.UnsignedShort5551Type, UnsignedShortType: M.UnsignedShortType },
  TextureEncoding: { LinearEncoding: M.LinearEncoding, sRGBEncoding: M.sRGBEncoding },
  ToneMapping: {
    NoToneMapping: M.NoToneMapping,
    LinearToneMapping: M.LinearToneMapping,
    ReinhardToneMapping: M.ReinhardToneMapping,
    CineonToneMapping: M.CineonToneMapping,
    ACESFilmicToneMapping: M.ACESFilmicToneMapping,
    CustomToneMapping: M.CustomToneMapping
  },
  ViewportNodeScope: {
    COORDINATE: zs.COORDINATE,
    RESOLUTION: zs.RESOLUTION,
    TOP_LEFT: zs.TOP_LEFT,
    BOTTOM_LEFT: zs.BOTTOM_LEFT,
    TOP_RIGHT: zs.TOP_RIGHT,
    BOTTOM_RIGHT: zs.BOTTOM_RIGHT
  },
  WebGL1PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGFormat: M.RGFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  WebGL2PixelFormat: { AlphaFormat: M.AlphaFormat, DepthFormat: M.DepthFormat, DepthStencilFormat: M.DepthStencilFormat, LuminanceAlphaFormat: M.LuminanceAlphaFormat, LuminanceFormat: M.LuminanceFormat, RGBAFormat: M.RGBAFormat, RGBAIntegerFormat: M.RGBAIntegerFormat, RGFormat: M.RGFormat, RGIntegerFormat: M.RGIntegerFormat, RedFormat: M.RedFormat, RedIntegerFormat: M.RedIntegerFormat, _SRGBAFormat: M._SRGBAFormat },
  Wrapping: { ClampToEdgeWrapping: M.ClampToEdgeWrapping, MirroredRepeatWrapping: M.MirroredRepeatWrapping, RepeatWrapping: M.RepeatWrapping }
}, Ba = {
  AmbientLight: {
    cls: M.AmbientLight,
    isAmbientLight: !0,
    members: {
      // type: "string | 'AmbientLight'"
    },
    proto: "Light"
  },
  AmbientLightProbe: {
    // cls: THREE.AmbientLightProbe,
    isAmbientLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  ArrayCamera: {
    cls: M.ArrayCamera,
    isArrayCamera: !0,
    members: { cameras: "PerspectiveCamera[]" },
    proto: "PerspectiveCamera"
  },
  Audio: {
    cls: M.Audio,
    members: {},
    proto: "Object3D"
  },
  AudioListener: {
    cls: M.AudioListener,
    members: {},
    proto: "Object3D"
  },
  Camera: {
    cls: M.Camera,
    isCamera: !0,
    members: {
      coordinateSystem: "types.CoordinateSystem",
      // layers: 'Layers',
      matrixWorldInverse: "Matrix4",
      projectionMatrix: "Matrix4",
      projectionMatrixInverse: "Matrix4"
      // type: "string | 'Camera'"
    },
    proto: "Object3D"
  },
  CanvasTexture: {
    cls: M.CanvasTexture,
    isCanvasTexture: !0,
    members: {},
    proto: "Texture"
  },
  CompressedArrayTexture: {
    cls: M.CompressedArrayTexture,
    isCompressedArrayTexture: !0,
    members: { wrapR: "types.Wrapping" },
    proto: "CompressedTexture"
  },
  CompressedTexture: {
    cls: M.CompressedTexture,
    isCompressedTexture: !0,
    members: {
      flipY: "boolean",
      format: "types.CompressedPixelFormat",
      generateMipmaps: "boolean"
      // mipmaps: 'ImageData[]'
    },
    proto: "Texture"
  },
  CubeCamera: {
    cls: M.CubeCamera,
    members: {
      coordinateSystem: "types.CoordinateSystem"
      // renderTarget: 'WebGLCubeRenderTarget',
      // type: "string | 'CubeCamera'"
    },
    proto: "Object3D"
  },
  CubeTexture: {
    cls: M.CubeTexture,
    isCubeTexture: !0,
    members: {
      flipY: "boolean",
      mapping: "types.CubeTextureMapping"
    },
    proto: "Texture"
  },
  Data3DTexture: {
    cls: M.Data3DTexture,
    isData3DTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "types.Wrapping"
    },
    proto: "Texture"
  },
  DataArrayTexture: {
    cls: M.DataArrayTexture,
    isDataArrayTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number",
      wrapR: "boolean"
    },
    proto: "Texture"
  },
  DataTexture: {
    cls: M.DataTexture,
    isDataTexture: !0,
    members: {
      flipY: "boolean",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      unpackAlignment: "number"
    },
    proto: "Texture"
  },
  DepthTexture: {
    cls: M.DepthTexture,
    isDepthTexture: !0,
    members: {
      compareFunction: "types.TextureComparisonFunction | null",
      flipY: "boolean",
      format: "types.DeepTexturePixelFormat",
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter",
      type: "types.TextureDataType"
    },
    proto: "Texture"
  },
  DirectionalLight: {
    cls: M.DirectionalLight,
    isDirectionalLight: !0,
    members: {
      castShadow: "boolean",
      position: "Vector3",
      // shadow: 'DirectionalLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'DirectionalLight'"
    },
    proto: "Light"
  },
  DirectionalLightShadow: {
    cls: M.DirectionalLightShadow,
    isDirectionalLightShadow: !0,
    members: {
      camera: "OrthographicCamera"
    },
    proto: "LightShadow"
  },
  Fog: {
    cls: M.Fog,
    isFog: !0,
    members: {
      color: "Color",
      far: "number",
      // name: 'string',
      near: "number"
    },
    proto: "FogBase"
  },
  FogExp2: {
    cls: M.FogExp2,
    isFogExp2: !0,
    members: {
      color: "Color",
      density: "number"
      // name: 'string'
    },
    proto: "FogBase"
  },
  FramebufferTexture: {
    cls: M.FramebufferTexture,
    isFramebufferTexture: !0,
    members: {
      generateMipmaps: "boolean",
      magFilter: "types.MagnificationTextureFilter",
      minFilter: "types.MinificationTextureFilter"
    },
    proto: "Texture"
  },
  HemisphereLight: {
    cls: M.HemisphereLight,
    isHemisphereLight: !0,
    members: {
      color: "Color",
      groundColor: "Color",
      position: "Vector3"
      // type: "string | 'HemisphereLight'"
    },
    proto: "Light"
  },
  HemisphereLightProbe: {
    // cls: THREE.HemisphereLightProbe,
    isHemisphereLightProbe: !0,
    members: {},
    proto: "LightProbe"
  },
  InstancedMesh: {
    cls: M.InstancedMesh,
    members: {
      count: "number"
    },
    proto: "Mesh"
  },
  Light: {
    cls: M.Light,
    isLight: !0,
    members: {
      color: "Color",
      intensity: "number",
      shadow: "LightShadow"
      // type: "string | 'Light'"
    },
    proto: "Object3D"
  },
  LightProbe: {
    cls: M.LightProbe,
    isLightProbe: !0,
    members: {
      sh: "SphericalHarmonics3"
    },
    proto: "Light"
  },
  LightShadow: {
    cls: M.LightShadow,
    members: {
      // autoUpdate: 'boolean',
      bias: "number",
      blurSamples: "number",
      camera: "Camera",
      // map: 'WebGLRenderTarget | null',
      // mapPass: 'WebGLRenderTarget | null',
      mapSize: "Vector2",
      matrix: "Matrix4",
      // needsUpdate: 'boolean',
      normalBias: "number",
      radius: "number"
    }
  },
  LineBasicMaterial: {
    cls: M.LineBasicMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      linecap: "string",
      linejoin: "string",
      linewidth: "number",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  LineDashedMaterial: {
    cls: M.LineDashedMaterial,
    isLineDashedMaterial: !0,
    members: {
      dashSize: "number",
      gapSize: "number",
      scale: "number"
      // type: 'string'
    },
    proto: "LineBasicMaterial"
  },
  Material: {
    cls: M.Material,
    isMaterial: !0,
    members: {
      alphaHash: "boolean",
      // alphaTest: 'number',
      // alphaToCoverage: 'boolean',
      // blendDst: 'types.BlendingDstFactor',
      // blendDstAlpha: 'number | null',
      // blendEquation: 'types.BlendingEquation',
      // blendEquationAlpha: 'number | null',
      blendSrc: "types.BlendingSrcFactor | types.BlendingDstFactor",
      blendSrcAlpha: "number | null",
      blending: "types.Blending",
      // clipIntersection: 'boolean',
      // clipShadows: 'boolean',
      // clippingPlanes: 'Plane[]',
      // colorWrite: 'boolean',
      // defines: 'undefined | { [key: string]: any }',
      depthFunc: "types.DepthModes",
      depthTest: "boolean",
      depthWrite: "boolean",
      // dithering: 'boolean',
      // forceSinglePass: 'boolean',
      // id: 'number',
      // name: 'string',
      // needsUpdate: 'boolean',
      opacity: "number",
      // polygonOffset: 'boolean',
      // polygonOffsetFactor: 'number',
      // polygonOffsetUnits: 'number',
      precision: "types.Precision | null",
      premultipliedAlpha: "boolean",
      shadowSide: "types.Side | null",
      side: "types.Side",
      stencilFail: "types.StencilOp",
      stencilFunc: "types.StencilFunc",
      stencilFuncMask: "number",
      stencilRef: "number",
      stencilWrite: "boolean",
      stencilWriteMask: "number",
      stencilZFail: "types.StencilOp",
      stencilZPass: "types.StencilOp",
      toneMapped: "boolean",
      transparent: "boolean",
      // type: 'string',
      // userData: 'any',
      // uuid: 'string',
      // version: 'number',
      // vertexColors: 'boolean',
      visible: "boolean"
    },
    proto: "EventDispatcher"
  },
  Mesh: {
    cls: M.Mesh,
    members: {
      castShadow: "boolean",
      receiveShadow: "boolean",
      material: "Material"
    },
    proto: "Object3D"
  },
  MeshBasicMaterial: {
    cls: M.MeshBasicMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      color: "Color",
      combine: "types.Combine",
      envMap: "Texture | null",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDepthMaterial: {
    cls: M.MeshDepthMaterial,
    members: {
      alphaMap: "Texture | null",
      depthPacking: "types.DepthPackingStrategies",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshDistanceMaterial: {
    cls: M.MeshDistanceMaterial,
    members: {
      alphaMap: "Texture | null",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      fog: "boolean",
      map: "Texture | null"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshLambertMaterial: {
    cls: M.MeshLambertMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshMatcapMaterial: {
    cls: M.MeshMatcapMaterial,
    members: {
      alphaMap: "Texture | null",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      fog: "boolean",
      map: "Texture | null",
      matcap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2"
      // type: 'string'
    },
    proto: "Material"
  },
  MeshNormalMaterial: {
    cls: M.MeshNormalMaterial,
    members: {
      bumpMap: "Texture | null",
      bumpScale: "number",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      flatShading: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhongMaterial: {
    cls: M.MeshPhongMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      combine: "types.Combine",
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metal: "boolean",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      reflectivity: "number",
      refractionRatio: "number",
      shininess: "number",
      specular: "Color",
      specularMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshPhysicalMaterial: {
    cls: M.MeshPhysicalMaterial,
    members: {
      anisotropy: "number",
      anisotropyMap: "Texture | null",
      anisotropyRotation: "number",
      attenuationColor: "Color",
      attenuationDistance: "number",
      clearcoat: "number",
      clearcoatMap: "Texture | null",
      clearcoatNormalMap: "Texture | null",
      clearcoatNormalScale: "Vector2",
      clearcoatRoughness: "number",
      clearcoatRoughnessMap: "Texture | null",
      // defines: '{ [key: string]: any }',
      ior: "number",
      iridescence: "number",
      iridescenceIOR: "number",
      iridescenceMap: "Texture | null",
      iridescenceThicknessMap: "Texture | null",
      iridescenceThicknessRange: "number[]",
      reflectivity: "number",
      sheen: "number",
      sheenColor: "Color",
      sheenColorMap: "Texture | null",
      sheenRoughness: "number",
      sheenRoughnessMap: "Texture | null",
      specularColor: "Color",
      specularColorMap: "Texture | null",
      specularIntensity: "number",
      specularIntensityMap: "Texture | null",
      thickness: "number",
      thicknessMap: "Texture | null",
      transmission: "number",
      transmissionMap: "Texture | null"
      // type: 'string'
    },
    proto: "MeshStandardMaterial"
  },
  MeshStandardMaterial: {
    cls: M.MeshStandardMaterial,
    isMeshStandardMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }', 
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      envMap: "Texture | null",
      envMapIntensity: "number",
      flatShading: "boolean",
      fog: "boolean",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      metalness: "number",
      metalnessMap: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      roughness: "number",
      roughnessMap: "Texture | null",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  MeshToonMaterial: {
    cls: M.MeshToonMaterial,
    members: {
      alphaMap: "Texture | null",
      aoMap: "Texture | null",
      aoMapIntensity: "number",
      bumpMap: "Texture | null",
      bumpScale: "number",
      color: "Color",
      // defines: '{ [key: string]: any }',
      displacementBias: "number",
      displacementMap: "Texture | null",
      displacementScale: "number",
      emissive: "Color",
      emissiveIntensity: "number",
      emissiveMap: "Texture | null",
      fog: "boolean",
      gradientMap: "Texture | null",
      lightMap: "Texture | null",
      lightMapIntensity: "number",
      map: "Texture | null",
      normalMap: "Texture | null",
      normalMapType: "types.NormalMapTypes",
      normalScale: "Vector2",
      // type: 'string',
      wireframe: "boolean",
      wireframeLinecap: "string",
      wireframeLinejoin: "string",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  Object3D: {
    cls: M.Object3D,
    isObject3D: !0,
    members: {
      up: "Vector3",
      position: "Vector3",
      rotation: "Euler",
      scale: "Vector3",
      visible: "Boolean"
    }
  },
  OrthographicCamera: {
    cls: M.OrthographicCamera,
    isOrthographicCamera: !0,
    members: {
      bottom: "number",
      far: "number",
      left: "number",
      near: "number",
      right: "number",
      top: "number",
      // type: "string | 'OrthographicCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PerspectiveCamera: {
    cls: M.PerspectiveCamera,
    isPerspectiveCamera: !0,
    members: {
      aspect: "number",
      far: "number",
      filmGauge: "number",
      filmOffset: "number",
      focus: "number",
      fov: "number",
      near: "number",
      //   type: "string | 'PerspectiveCamera'",
      //   view: `null | {
      //     enabled: boolean;
      //     fullWidth: number;
      //     fullHeight: number;
      //     offsetX: number;
      //     offsetY: number;
      //     width: number;
      //     height: number;
      // }`,
      zoom: "number"
    },
    proto: "Camera"
  },
  PointLight: {
    cls: M.PointLight,
    members: {
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      power: "number",
      // shadow: 'PointLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number"
      // type: 'string'
    },
    proto: "Light"
  },
  PointLightShadow: {
    cls: M.PointLightShadow,
    isPointLightShadow: !0,
    members: {},
    proto: "LightShadow"
  },
  Points: {
    cls: M.Points,
    members: {
      material: "Material"
    },
    proto: "Object3D"
  },
  PointsMaterial: {
    cls: M.PointsMaterial,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      size: "number",
      sizeAttenuation: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  PositionalAudio: {
    cls: M.PositionalAudio,
    members: {},
    proto: "Audio"
  },
  RawShaderMaterial: {
    cls: M.RawShaderMaterial,
    members: {},
    proto: "ShaderMaterial"
  },
  RectAreaLight: {
    cls: M.RectAreaLight,
    isRectAreaLight: !0,
    members: {
      height: "number",
      intensity: "number",
      power: "number",
      // type: "string | 'RectAreaLight'",
      width: "number"
    },
    proto: "Light"
  },
  Scene: {
    cls: M.Scene,
    isScene: !0,
    members: {
      background: "Color | Texture | CubeTexture | null",
      backgroundBlurriness: "number",
      backgroundIntensity: "number",
      environment: "Texture | null",
      fog: "FogBase | null",
      overrideMaterial: "Material | null"
      // type: "'Scene'"
    },
    proto: "Object3D"
  },
  ShaderMaterial: {
    cls: M.ShaderMaterial,
    isShaderMaterial: !0,
    members: {
      // clipping: 'boolean',
      //   defaultAttributeValues: 'any',
      //   defines: '{ [key: string]: any }', derivatives: 'any',
      //   extensions: `{
      //     derivatives: boolean;
      //     fragDepth: boolean;
      //     drawBuffers: boolean;
      //     shaderTextureLOD: boolean;
      // }`,
      fog: "boolean",
      // fragmentShader: 'string',
      // glslVersion: 'types.GLSLVersion | null',
      // index0AttributeName: 'string | undefined', lights: 'boolean', linewidth: 'number',
      // type: 'string',
      // uniforms: '{ [uniform: string]: IUniform }',
      // uniformsGroups: 'UniformsGroup[]',
      // uniformsNeedUpdate: 'boolean',
      // vertexShader: 'string',
      wireframe: "boolean",
      wireframeLinewidth: "number"
    },
    proto: "Material"
  },
  ShadowMaterial: {
    cls: M.ShadowMaterial,
    members: {
      color: "Color",
      fog: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  Source: {
    cls: M.Source,
    isSource: !0,
    members: {
      // data: 'any', id: 'number', uuid: 'string', version: 'number'
    }
  },
  SphericalHarmonics3: {
    cls: M.SphericalHarmonics3,
    isSphericalHarmonics3: !0,
    members: { coefficients: "Vector3[]" }
  },
  SpotLight: {
    cls: M.SpotLight,
    isSpotLight: !0,
    members: {
      angle: "number",
      castShadow: "boolean",
      decay: "number",
      distance: "number",
      intensity: "number",
      map: "Texture | null",
      penumbra: "number",
      position: "Vector3",
      power: "number",
      // shadow: 'SpotLightShadow',
      "shadow.mapSize.x": "Number",
      "shadow.mapSize.y": "Number",
      "shadow.bias": "Number",
      target: "Object3D"
      // type: "string | 'SpotLight'"
    },
    proto: "Light"
  },
  SpotLightShadow: {
    cls: M.SpotLightShadow,
    isSpotLightShadow: !0,
    members: { camera: "PerspectiveCamera", focus: "number" },
    proto: "LightShadow"
  },
  SpriteMaterial: {
    cls: M.SpriteMaterial,
    isSpriteMaterial: !0,
    members: {
      alphaMap: "Texture | null",
      color: "Color",
      fog: "boolean",
      map: "Texture | null",
      rotation: "number",
      sizeAttenuation: "boolean",
      transparent: "boolean"
      // type: 'string'
    },
    proto: "Material"
  },
  StereoCamera: {
    cls: M.StereoCamera,
    members: {
      aspect: "number",
      cameraL: "PerspectiveCamera",
      cameraR: "PerspectiveCamera",
      eyeSep: "number"
      // type: "'StereoCamera'"
    },
    proto: "Camera"
  },
  Texture: {
    cls: M.Texture,
    isTexture: !0,
    members: {
      anisotropy: "number",
      center: "Vector2",
      channel: "number",
      colorSpace: "types.ColorSpace",
      encoding: "types.TextureEncoding",
      flipY: "boolean",
      format: "types.WebGL1PixelFormat | types.WebGL2PixelFormat | types.DeepTexturePixelFormat | types.CompressedPixelFormat",
      generateMipmaps: "boolean",
      // id: 'number',
      image: "Image",
      internalFormat: "types.PixelFormatGPU | null",
      // isRenderTargetTexture: 'boolean',
      magFilter: "types.MagnificationTextureFilter",
      mapping: "types.Mapping | types.CubeTextureMapping",
      matrix: "Matrix3",
      // matrixAutoUpdate: 'boolean', minFilter: 'types.MinificationTextureFilter', mipmaps: 'any[]',
      // name: 'string',
      // needsPMREMUpdate: 'boolean',
      offset: "Vector2",
      // onUpdate: '() => void',
      premultiplyAlpha: "boolean",
      repeat: "Vector2",
      rotation: "number",
      // source: 'Source',
      type: "types.TextureDataType",
      unpackAlignment: "number",
      // userData: 'any',
      // uuid: 'string', version: 'number',
      wrapS: "types.Wrapping",
      wrapT: "types.Wrapping"
    },
    proto: "EventDispatcher"
  },
  VideoTexture: {
    cls: M.VideoTexture,
    isVideoTexture: !0,
    members: { generateMipmaps: "boolean", magFilter: "types.MagnificationTextureFilter", minFilter: "types.MinificationTextureFilter" },
    proto: "Texture"
  }
}, ci = {
  AONode: {
    cls: Ih,
    group: "lighting",
    members: { aoNode: "Node | null" },
    proto: "LightingNode"
  },
  AnalyticLightNode: {
    cls: nr,
    group: "lighting",
    members: { colorNode: "Node", light: "Light | null" },
    proto: "LightingNode"
  },
  ArrayElementNode: {
    cls: Za,
    group: "utils",
    members: { indexNode: "Node", node: "Node" },
    proto: "TempNode"
  },
  ArrayUniformNode: {
    cls: Rg,
    group: "core",
    isArrayUniformNode: !0,
    members: { nodes: "Node[]" },
    proto: "UniformNode"
  },
  AttributeNode: {
    cls: Gu,
    group: "core",
    members: {},
    proto: "Node"
  },
  BitangentNode: {
    cls: eo,
    group: "accessors",
    members: { scope: "types.BitangentNodeScope" },
    proto: "Node"
  },
  BlendModeNode: {
    cls: to,
    group: "display",
    members: { baseNode: "Node", blendMode: "types.BlendMode", blendNode: "Node" },
    proto: "TempNode"
  },
  BufferNode: {
    cls: Mh,
    group: "accessors",
    isBufferNode: !0,
    members: { bufferCount: "number", bufferType: "string" },
    proto: "UniformNode"
  },
  BypassNode: {
    cls: Og,
    group: "core",
    isBypassNode: !0,
    members: { callNode: "Node", outputNode: "Node" },
    proto: "Node"
  },
  CacheNode: {
    cls: Ig,
    group: "core",
    isCacheNode: !0,
    members: { cache: "NodeCache", node: "Node" },
    proto: "Node"
  },
  CameraNode: {
    cls: mh,
    group: "accessors",
    members: { scope: "types.CameraNodeScope" },
    proto: "Object3DNode"
  },
  CheckerNode: {
    cls: $v,
    group: "procedural",
    members: { uvNode: "Node" },
    proto: "TempNode"
  },
  CodeNode: {
    cls: bd,
    group: "code",
    isCodeNode: !0,
    members: { code: "string" },
    proto: "Node"
  },
  ColorAdjustmentNode: {
    cls: Ho,
    group: "display",
    members: { adjustmentNode: "Node", colorNode: "Node", method: "types.ColorAdjustmentMethod" },
    proto: "TempNode"
  },
  ColorSpaceNode: {
    cls: jo,
    group: "display",
    members: { method: "types.ColorSpaceNodeMethod", node: "Node" },
    proto: "TempNode"
  },
  ComputeNode: {
    cls: Vv,
    group: "gpgpu",
    isComputeNode: !0,
    members: { count: "number", dispatchCount: "number", workgroupSize: "number[]" },
    proto: "Node"
  },
  CondNode: {
    cls: Wh,
    group: "math",
    members: { condNode: "Node", elseNode: "Node", ifNode: "Node" },
    proto: "Node"
  },
  ConstNode: {
    cls: Ln,
    group: "core",
    isConstNode: !0,
    members: {},
    proto: "InputNode"
  },
  ContextNode: {
    cls: Xu,
    group: "core",
    isContextNode: !0,
    members: { context: "Object", node: "Node" },
    proto: "Node"
  },
  ConvertNode: {
    cls: Qa,
    group: "utils",
    members: { convertTo: "types.NodeTypeOption", node: "Node" },
    proto: "Node"
  },
  CubeTextureNode: {
    cls: M0,
    group: "accessors",
    isCubeTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "CubeTexture" },
    proto: "TextureNode"
  },
  EnvironmentNode: {
    cls: Vh,
    group: "lighting",
    members: { envNode: "Node | null" },
    proto: "LightingNode"
  },
  EquirectUVNode: {
    cls: F0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  ExpressionNode: {
    cls: Xy,
    group: "code",
    members: { snipped: "string" },
    proto: "TempNode"
  },
  FogExp2Node: {
    cls: Bv,
    group: "fog",
    isFogExp2Node: !0,
    members: { densityNode: "Node" },
    proto: "FogNode"
  },
  FogNode: {
    cls: xc,
    group: "fog",
    isFogNode: !0,
    members: { colorNode: "Node", factorNode: "Node" },
    proto: "Node"
  },
  FogRangeNode: {
    cls: Uv,
    group: "fog",
    isFogRangeNode: !0,
    members: { farNode: "Node", nearNode: "Node" },
    proto: "FogNode"
  },
  FrontFacingNode: {
    cls: dv,
    group: "display",
    isFrontFacingNode: !0,
    members: {},
    proto: "Node"
  },
  // FunctionCallNode: {
  //   cls: Nodes.FunctionCallNode,
  //   group: 'code',
  //   members: {
  //     functionNode: 'FunctionNode<P>',
  //     parameters: '{ [name: string]: Node }'
  //   },
  //   proto: 'TempNode'
  // },
  FunctionNode: {
    cls: Fv,
    group: "code",
    members: { keywords: "{ [key: string]: Node }" },
    proto: "CodeNode"
  },
  HemisphereLightNode: {
    cls: Xv,
    group: "lighting",
    members: { groundColorNode: "Node", lightDirectionNode: "Node", lightPositionNode: "Object3DNode" },
    proto: "AnalyticLightNode"
  },
  InputNode: {
    // cls: Nodes.InputNode,
    group: "core",
    isInputNode: !0,
    members: { precision: "types.Precision | null", value: "Color | Vector2 | Vector3 | Vector4 | Matrix3 | Matrix4 | boolean | number" },
    proto: "Node"
  },
  // InstanceNode: {
  //   cls: Nodes.InstanceNode,
  //   group: 'accessors',
  //   members: { instanceMatrixNode: 'Node', instanceMesh: 'InstancedMesh' },
  //   proto: 'Node'
  // },
  // LightingContextNode: {
  //   cls: Nodes.LightingContextNode,
  //   group: 'lighting',
  //   members: { lightingModelNode: 'LightingModelNode | null' },
  //   proto: 'ContextNode'
  // },
  LightingNode: {
    cls: _i,
    group: "lighting",
    members: {},
    proto: "Node"
  },
  LightsNode: {
    cls: E0,
    group: "lighting",
    members: { lightNodes: "LightingNode[]" },
    proto: "Node"
  },
  LineBasicNodeMaterial: {
    cls: Zv,
    group: "materials",
    isLineBasicNodeMaterial: !0,
    members: {},
    proto: ["LineBasicMaterial", "NodeMaterial"]
  },
  MatcapUVNode: {
    cls: V0,
    group: "utils",
    members: {},
    proto: "TempNode"
  },
  MaterialNode: {
    cls: bs,
    group: "accessors",
    members: { scope: "types.MaterialNodeScope" },
    proto: "Node"
  },
  MaterialReferenceNode: {
    cls: $y,
    group: "accessors",
    members: {},
    proto: "ReferenceNode"
  },
  MathNode: {
    cls: ke,
    group: "math",
    members: { aNode: "Node", bNode: "Node | null", cNode: "Node | null", method: "types.MathNodeMethod1 | types.MathNodeMethod2 | types.MathNodeMethod3" },
    proto: "TempNode"
  },
  MaxMipLevelNode: {
    cls: O0,
    group: "utils",
    members: { textureNode: "TextureNode" },
    proto: "UniformNode"
  },
  MeshBasicNodeMaterial: {
    cls: s1,
    group: "materials",
    isMeshBasicNodeMaterial: !0,
    members: { lights: "true" },
    proto: ["MeshBasicMaterial", "NodeMaterial"]
  },
  MeshPhysicalNodeMaterial: {
    cls: f1,
    group: "materials",
    members: { attenuationColorNode: "Node | null", attenuationDistanceNode: "Node | null", iridescenceIORNode: "null | Node", iridescenceNode: "null | CheckerNode", iridescenceThicknessNode: "null | Node", specularColorNode: "Node | null", specularIntensityNode: "Node | null", thicknessNode: "Node | null", transmissionNode: "Node | null" },
    proto: ["MeshPhysicalMaterial", "MeshStandardNodeMaterial"]
  },
  MeshStandardNodeMaterial: {
    cls: jd,
    group: "materials",
    isMeshStandardNodeMaterial: !0,
    members: { clearcoatNode: "Node | null", clearcoatRoughnessNode: "Node | null", emissiveNode: "Node | null", metalnessNode: "Node | null", roughnessNode: "Node | null" },
    proto: ["MeshStandardMaterial", "NodeMaterial"]
  },
  ModelViewProjectionNode: {
    cls: p0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  Node: {
    cls: Fe,
    group: "core",
    isNode: !0,
    members: {
      // id: 'number',
      // nodeType: 'NodeTypeOption | null',
      // type: 'string',
      // updateType: 'NodeUpdateTypeOption',
      // uuid: 'string'
    }
  },
  NodeAttribute: {
    cls: Ra,
    group: "core",
    isNodeAttribute: !0,
    members: { name: "string", type: "string" }
  },
  // NodeBuilder: {
  //   cls: Nodes.NodeBuilder,
  //   group: 'core',
  //   members: { buildStage: 'BuildStageOption | null', cache: 'NodeCache', computeShader: 'string', flowsData: 'any', fogNode: 'FogNode', fragmentShader: 'string', geometry: 'BufferGeometry', globalCache: 'NodeCache', hashNodes: '{ [hash: string]: Node }', lightsNode: 'LightsNode', material: 'Material', nodes: 'Node[]', object: 'Object3D', parser: 'NodeParser', renderer: 'Renderer', shaderStage: 'NodeShaderStageOption | null', stack: 'Node[]', updateNodes: 'Node[]', vertexShader: 'string' }
  // },
  NodeCache: {
    cls: nc,
    group: "core",
    members: {
      // id: 'number', nodesData: 'WeakMap<Node, NodeData>' 
    }
  },
  NodeCode: {
    cls: Ku,
    group: "core",
    isNodeCode: !0,
    members: {}
  },
  // NodeFrame: {
  //   cls: Nodes.NodeFrame,
  //   group: 'core',
  //   members: { camera: 'null | Camera', deltaTime: 'number', frameId: 'number', material: 'null | Material', object: 'null | Object3D', renderer: 'null | Renderer', startTime: 'null | number', time: 'number' }
  // },
  NodeFunction: {
    // cls: Nodes.NodeFunction,
    group: "core",
    isNodeFunction: !0,
    members: { inputs: "NodeFunctionInput[]", name: "string", presicion: "string", type: "string" }
  },
  NodeFunctionInput: {
    cls: $h,
    group: "core",
    isNodeFunctionInput: !0,
    members: { count: "null | number", isConst: "boolean", qualifier: "string" }
  },
  NodeKeywords: {
    cls: Zu,
    group: "core",
    members: {
      keywords: "string[]",
      // keywordsCallback: '{ [name: string]: (name: string) => Node }',
      nodes: "Node[]"
    }
  },
  // NodeLoader: {
  //   cls: Nodes.NodeLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'Loader<NodeLoaderResult>'
  // },
  NodeMaterial: {
    cls: Jt,
    group: "materials",
    isNodeMaterial: !0,
    members: {
      alphaTestNode: "Node | null",
      backdropAlphaNode: "Node | null",
      backdropNode: "Node | null",
      colorNode: "Node | null",
      envNode: "Node | null",
      lights: "true",
      lightsNode: "Node | null",
      normalNode: "Node | null",
      normals: "true",
      opacityNode: "Node | null",
      positionNode: "Node | null"
      // type: 'string'
    },
    proto: "ShaderMaterial"
  },
  // NodeMaterialLoader: {
  //   cls: Nodes.NodeMaterialLoader,
  //   group: 'loaders',
  //   members: { nodes: 'NodeLoaderResult' },
  //   proto: 'MaterialLoader'
  // },
  // NodeObjectLoader: {
  //   cls: Nodes.NodeObjectLoader,
  //   group: 'loaders',
  //   members: {},
  //   proto: 'ObjectLoader'
  // },
  // NodeParser: {
  //   // cls: Nodes.NodeParser,
  //   group: 'core',
  //   members: {}
  // },
  NodeUniform: {
    cls: Ju,
    group: "core",
    isNodeUniform: !0,
    members: { name: "string", needsUpdate: "boolean", node: "InputNode", type: "string", value: "NodeValueOption" }
  },
  NodeVar: {
    cls: sc,
    group: "core",
    isNodeVar: !0,
    members: { name: "string", type: "string" }
  },
  NodeVarying: {
    cls: Yu,
    group: "core",
    isNodeVarying: !0,
    members: { needsInterpolation: "false" },
    proto: "NodeVar"
  },
  NormalMapNode: {
    cls: bv,
    group: "display",
    members: { node: "Node", normalMapType: "types.NormalMapTypes", scaleNode: "Node | null" },
    proto: "TempNode"
  },
  NormalNode: {
    cls: Wo,
    group: "accessors",
    members: { scope: "types.NormalNodeScope" },
    proto: "Node"
  },
  Object3DNode: {
    cls: mn,
    group: "accessors",
    members: { object3d: "Object3D | null", scope: "types.Object3DNodeScope" },
    proto: "Node"
  },
  OperatorNode: {
    cls: Gg,
    group: "math",
    members: { aNode: "Node", bNode: "Node", op: "types.OperatorNodeOp" },
    proto: "TempNode"
  },
  OscNode: {
    cls: Qr,
    group: "utils",
    members: { method: "types.OscNodeMethod", timeNode: "Node" },
    proto: "Node"
  },
  PointLightNode: {
    cls: Wv,
    group: "lighting",
    members: { coneCosNode: "Node", cutoffDistanceNode: "Node", decayExponentNode: "Node", directionNode: "Node", penumbraCosNode: "Node" },
    proto: "AnalyticLightNode"
  },
  PointUVNode: {
    cls: iv,
    group: "accessors",
    isPointUVNode: !0,
    members: {},
    proto: "Node"
  },
  PointsNodeMaterial: {
    cls: Wd,
    group: "materials",
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", isPointsNodeMateria: "true", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", sizeNode: "Node | null" },
    proto: ["PointsMaterial", "NodeMaterial"]
  },
  PositionNode: {
    cls: Us,
    group: "accessors",
    members: { scope: "types.PositionNodeScope" },
    proto: "Node"
  },
  PosterizeNode: {
    cls: Tv,
    group: "display",
    members: { sourceNode: "Node", stepsNode: "Node" },
    proto: "Node"
  },
  PropertyNode: {
    cls: Qu,
    group: "core",
    members: {},
    proto: "Node"
  },
  RangeNode: {
    cls: Gv,
    group: "geometry",
    members: { max: "number | Color | Vector2 | Vector3 | Vector4", min: "number | Color | Vector2 | Vector3 | Vector4" },
    proto: "Node"
  },
  ReferenceNode: {
    cls: lc,
    group: "accessors",
    members: { node: "Node | null", object: "Object", property: "string", uniformType: "string" },
    proto: "Node"
  },
  ReflectVectorNode: {
    cls: S0,
    group: "accessors",
    members: {},
    proto: "Node"
  },
  RemapNode: {
    cls: H0,
    group: "utils",
    members: { doClamp: "boolean", inHighNode: "Node", inLowNode: "Node", node: "Node", outHighNode: "Node", outLowNode: "Node" },
    proto: "Node"
  },
  RotateUVNode: {
    cls: q0,
    group: "utils",
    members: { centerNode: "Node", rotationNode: "Node", uvNode: "Node" },
    proto: "TempNode"
  },
  SkinningNode: {
    cls: N0,
    group: "accessors",
    members: { bindMatrixInverseNode: "Node", bindMatrixNode: "Node", boneMatricesNode: "Node", skinIndexNode: "Node", skinWeightNode: "Node" },
    proto: "Node"
  },
  SpecularMIPLevelNode: {
    cls: I0,
    group: "utils",
    members: { roughnessNode: "Node | null", textureNode: "TextureNode" },
    proto: "Node"
  },
  SpriteNodeMaterial: {
    cls: g1,
    group: "materials",
    isSpriteNodeMaterial: !0,
    members: { alphaTestNode: "Node | null", colorNode: "Node | null", lightNode: "Node | null", opacityNode: "Node | null", positionNode: "Node | null", rotationNode: "Node | null", scaleNode: "Node | null" },
    proto: ["SpriteMaterial", "NodeMaterial"]
  },
  SpriteSheetUVNode: {
    cls: Y0,
    group: "utils",
    members: { countNode: "Node", frameNode: "Node", uvNode: "Node" },
    proto: "Node"
  },
  // StackNode: {
  //   cls: Nodes.StackNode,
  //   group: 'core',
  //   isStackNode: true,
  //   members: { nodes: 'Node[]', outputNode: 'Node | null' },
  //   proto: 'Node'
  // },
  // StorageBufferNode: {
  //   // cls: Nodes.StorageBufferNode,
  //   group: 'accessors',
  //   members: {},
  //   proto: 'BufferNode'
  // },
  TangentNode: {
    cls: Zr,
    group: "accessors",
    members: { scope: "types.TangentNodeScope" },
    proto: "Node"
  },
  TempNode: {
    cls: Tt,
    group: "core",
    isTempNode: !0,
    members: {},
    proto: "Node"
  },
  TextureNode: {
    cls: wi,
    group: "accessors",
    isTextureNode: !0,
    members: { levelNode: "Node | null", uvNode: "Node | null", value: "Texture" },
    proto: "UniformNode"
  },
  TimerNode: {
    cls: j0,
    group: "utils",
    members: {
      scale: "number"
      // scope: 'TimerNodeScope'
    },
    proto: "UniformNode"
  },
  ToneMappingNode: {
    cls: _v,
    group: "display",
    members: { colorNode: "Node | null", exposureNode: "Node", toneMapping: "types.ToneMapping" },
    proto: "TempNode"
  },
  TriplanarTexturesNode: {
    cls: Z0,
    group: "utils",
    members: {
      normalNode: "PositionNode",
      positionNode: "PositionNode",
      scaleNode: "Node",
      textureXNode: "TextureNode",
      textureYNode: "TextureNode | null",
      textureZNode: "TextureNode | null"
    },
    proto: "Node"
  },
  UVNode: {
    cls: zg,
    group: "accessors",
    isUVNode: !0,
    members: { index: "number" },
    proto: "AttributeNode"
  },
  UniformNode: {
    cls: nt,
    group: "core",
    isUniformNode: !0,
    members: {},
    proto: "InputNode"
  },
  // UserDataNode: {
  //   cls: Nodes.UserDataNode,
  //   group: 'accessors',
  //   members: { userData: 'NodeUserData | null' },
  //   proto: 'ReferenceNode<NodeUserData>'
  // },
  VarNode: {
    cls: Cg,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  VaryingNode: {
    cls: Fg,
    group: "core",
    members: { name: "string | null", node: "Node" },
    proto: "Node"
  },
  ViewportNode: {
    cls: zs,
    group: "display",
    isViewportNode: !0,
    members: { scope: "types.ViewportNodeScope" },
    proto: "Node"
  }
};
let Io = console;
const ze = {
  debug(...c) {
    Io.debug(...c);
  },
  notice(...c) {
    Io.info(...c);
  },
  warn(...c) {
    Io.warn(...c);
  },
  error(...c) {
    Io.error(...c);
  },
  panic(...c) {
    return Io.error(...c), `${c}`;
  }
}, lp = {};
function up(c) {
  const e = Object.entries(c);
  return e.forEach((t) => delete c[t[0]]), e.sort((t, r) => t[0].localeCompare(r[0])), e.forEach((t) => c[t[0]] = t[1]), c;
}
function bc(c) {
  return /Material$/.test(c) || !!ci[c];
}
const jS = new Set("bool,int,float,vec2,vec3,vec4,mat3,mat4,code,color,uint,int,property,sampler,texture,cubeTexture,ivec2,uvec2,bvec2,ivec3,uvec3,bvec3,ivec4,uvec4,bvec4,imat3,umat3,bmat3,imat4,umat4,bmat4".split(","));
function WS(c) {
  return jS.has(c);
}
const HS = new Set("void,Boolean,Number,String,Script,Color,Vector2,Vector3,Vector4,Matrix3,Matrix4,Euler,Audio,Image,Texture,CubeTexture,Material,Object3D,Object".split(","));
function XS(c) {
  return HS.has(c.split("[")[0]);
}
function $S(c) {
  return WS(c) || XS(c);
}
function qS(c, e) {
  for (const t of c)
    if (!e.includes(t))
      return !1;
  return !0;
}
function JS(c, e) {
  return c[`is${e}`];
}
function eu(c, e) {
  if (c === e)
    return !0;
  const t = Hd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (eu(r, e))
        return !0;
    return !1;
  }
  return eu(t.proto, e);
}
function YS(c, e) {
  if (e.includes(c))
    return !0;
  for (const t of e)
    if (eu(c, t))
      return !0;
  return !1;
}
function li(c, e) {
  if (c === e)
    return !0;
  const t = Hd(c);
  if (!t || !t.proto)
    return !1;
  if (Array.isArray(t.proto)) {
    for (const r of t.proto)
      if (li(r, e))
        return !0;
    return !1;
  }
  return li(t.proto, e);
}
function KS(c) {
  let e = null, t = null;
  const r = [];
  for (const n of c) {
    if (/^".+"$/.test(n)) {
      const i = /^"(.+)"$/.exec(n)[1];
      t ? t.push(i) : (t = [i], r.push(t));
      continue;
    }
    const [, s, o] = /^([^[\]]+)(\[\])?$/.exec(n) || [];
    if (s.startsWith("types.")) {
      const i = C1[s.substring(6)];
      if (!i)
        throw ze.panic(`type[${s}] not found`);
      Array.isArray(i) ? t ? t.push(...i) : (t = [...i], r.push(t)) : e ? Object.assign(e, i) : (e = { ...i }, r.push(e));
    } else
      n === "null" ? r.push(null) : s === "boolean" || /true|false/i.test(n) ? r.push("Boolean" + (o || "")) : s === "string" ? r.push("String" + (o || "")) : s === "number" ? r.push("Number" + (o || "")) : (!$S(s) && !bc(s) && ze.warn(`type[${n}] unsupported!`), r.push(n));
  }
  return r;
}
function hp(c, e, t) {
  for (const [r, n] of Object.entries(e)) {
    const s = KS(n.replace(/\s/mg, "").split("|")), [, o, i] = /^(.+)(Node)$/.exec(r) || [, r], a = !!i || s.findIndex((u) => typeof u == "string" && bc(u)) !== -1, l = c[o] || (c[o] = { types: s, direct: t });
    a && (l.nname = r), ZS(l.types, s);
  }
  return c;
}
function ZS(c, e) {
  const t = c.filter((r) => r !== null && !bc(r) && !e.includes(r));
  for (const r of e)
    c.includes(r) || c.push(JSON.parse(JSON.stringify(r)));
  t.forEach((r) => c.splice(c.indexOf(r), 1));
}
function QS(c, e) {
  for (const t of e)
    c.includes(t) || c.push(JSON.parse(JSON.stringify(t)));
}
function dp(c, e) {
  for (const [t, r] of Object.entries(e)) {
    const n = c[t];
    if (!n) {
      c[t] = JSON.parse(JSON.stringify(r));
      continue;
    }
    if (n.nname && r.nname && n.nname !== r.nname)
      throw ze.panic("type mismatched!");
    n.nname || (n.nname = r.nname), QS(n.types, r.types);
  }
  return c;
}
function ka(c) {
  const e = (t) => {
    const r = lp[t];
    if (r)
      return r;
    const n = { in: {}, out: {} }, s = ci[t] || Ba[t];
    if (!s)
      return n;
    let o = s.proto;
    if (o) {
      o = Array.isArray(o) ? o : [o];
      for (const i of o) {
        const a = e(i);
        dp(n.in, a.in), dp(n.out, a.out);
      }
    }
    return hp(n.in, s.members, "in"), s.out && hp(n.out, s.out, "out"), up(n.in), up(n.out), lp[t] = n, n;
  };
  return e(c);
}
function fp(c) {
  const e = n_(c);
  if (!e)
    throw ze.panic(`Node constructor[${c}] not found!`);
  return e.clsName;
}
function e_(c) {
  const e = Hd(c);
  if (e)
    return e.proto;
}
function Hd(c) {
  return ci[c] || Ba[c];
}
function Es(c, e, t, r, n) {
  if (ci[c])
    throw ze.panic(`class[${c}] exists`);
  if (re(c, e), ci[c] = { cls: e, members: t || {}, proto: r }, n)
    for (const [o, i] of Object.entries(n))
      Nc(o, i);
}
const t_ = [], Ga = {};
function Nc(c, e) {
  if (Ga[c])
    throw ze.panic(`Node Constructor[${c}] aready exists`);
  const r = (e.group || `Others.${c}`).split(".");
  let n = t_;
  const s = r.pop();
  for (const l of r) {
    let u = n.find((h) => h.name === l);
    u || (u = {
      name: l,
      icon: "",
      children: []
    }, n.push(u)), n = u.children;
  }
  if (n.find((l) => l.name === c))
    throw ze.panic(`Node Constructor[${c}] aready exists`);
  const i = ka(e.clsName), a = {
    name: c,
    ...e,
    title: s || c,
    in: { ...i.in },
    out: { ...i.out }
  };
  Ga[c] = a, n.push(a);
}
function n_(c) {
  return Ga[c];
}
function tu(c, e) {
  const t = Ga[c];
  if (!t)
    throw ze.panic(`Node Constructor[${c}] not found`);
  const r = t.func();
  if (e)
    if (r.copy)
      r.copy(e);
    else
      for (const n of [...Object.keys(t.in), ...Object.keys(t.out)]) {
        const s = e[n], o = typeof s, i = r[n];
        o === "undefined" || s === null || o === "boolean" || o === "string" || o === "number" ? r[n] = s : s.clone ? r[n] = s.clone() : i && i.copy ? i.copy(s) : r[n] = s;
      }
  return r;
}
const { createNodeMaterialFromType: s_ } = mw, r_ = vi.createMaterialFromType, Va = {};
vi.createMaterialFromType = function(c) {
  const e = s_(c);
  return e || (Va[c] ? new Va[c]() : r_.call(this, c));
};
function o_(c, e) {
  if (Va[c])
    throw ze.panic(`Material[${c}] aready exists`);
  Va[c] = e;
}
const pp = {};
function Ye(c, e) {
  if (pp[c])
    throw ze.panic(`Class[${c}] aready exists`);
  if (pp[c] = e, Ba[c] || (Ba[c] = e), li(c, "Object3D")) {
    if (ui[c])
      return;
    ui[c] = (t) => e.create(t || {});
  }
}
const ui = {
  AmbientLight: (c) => new M.AmbientLight(c.color, c.intensity),
  Bone: (c) => new M.Bone(),
  DirectionalLight: (c) => new M.DirectionalLight(c.color, c.intensity),
  HemisphereLight: (c) => new M.HemisphereLight(c.color, c.groundColor, c.intensity),
  Group: (c) => new M.Group(),
  InstancedMesh: (c) => {
    const e = new M.InstancedMesh(c.geometry, c.material, c.count), t = c.instanceMatrix, r = c.instanceColor;
    return e.instanceMatrix = new M.InstancedBufferAttribute(new Float32Array(t.array), 16), r !== void 0 && (e.instanceColor = new M.InstancedBufferAttribute(new Float32Array(r.array), r.itemSize)), e;
  },
  LOD: (c) => new M.LOD(),
  Line: (c) => new M.Line(c.geometry, c.material),
  LineLoop: (c) => new M.LineLoop(c.geometry, c.material),
  LineSegments: (c) => new M.LineSegments(c.geometry, c.material),
  LightProbe: (c) => new M.LightProbe().fromJSON(c),
  Mesh: (c) => new M.Mesh(c.geometry, c.material),
  Object3D: (c) => new M.Object3D(),
  OrthographicCamera: (c) => new M.OrthographicCamera(c.left, c.right, c.top, c.bottom, c.near, c.far),
  PerspectiveCamera: (c) => new M.PerspectiveCamera(c.fov, c.aspect, c.near, c.far),
  PointCloud: (c) => new M.Points(c.geometry, c.material),
  PointLight: (c) => new M.PointLight(c.color, c.intensity, c.distance, c.decay),
  Points: (c) => new M.Points(c.geometry, c.material),
  RectAreaLight: (c) => new M.RectAreaLight(c.color, c.intensity, c.width, c.height),
  Scene: (c) => new M.Scene(),
  SpotLight: (c) => new M.SpotLight(c.color, c.intensity, c.distance, c.angle, c.penumbra, c.decay),
  SkinnedMesh: (c) => new M.SkinnedMesh(c.geometry, c.material),
  Sprite: (c) => new M.Sprite(c.material)
}, i_ = new Set(Object.keys(ui));
function a_(c, e) {
  const t = ui[c];
  if (t)
    return t(e);
  throw ze.panic(`object class[${c}] not found`);
}
function c_(c) {
  return !!ui[c];
}
function E1(c) {
  if (i_.has(c))
    return c;
  const e = e_(c);
  if (e)
    return E1(e);
}
function Ts(c) {
  Object.keys(c).forEach((e) => delete c[e]);
}
const Gt = Symbol("getProxyRawObject");
function Xd(c, e) {
  return new Proxy(c, {
    get(t, r, n) {
      if (r === Gt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      if (Reflect.get(t, r, s) === n)
        return !0;
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else
        i = Reflect.set(t, r, n, t);
      return i && e && e(r, n), i;
    }
  });
}
function Zs(c, e) {
  e || (e = {});
  for (const [t, r] of Object.entries(c))
    r && typeof r == "object" && r.toArray ? e[t] = r.toArray() : e[t] = c[t];
  return e;
}
function Qs(c, e) {
  const t = [];
  for (const [r, n] of Object.entries(c)) {
    const s = e[r];
    s == null || s === n || (t.push(r), typeof n == "object" && n.fromArray ? n.fromArray(s) : c[r] = s);
  }
  return t;
}
Ye("Object3D", {
  // cls: Object3D,
  create: () => new vn(),
  members: {},
  group: "Objects.Empty Object3D",
  icon: "box"
});
const Hi = new M.Matrix4();
let rl, mp, gp;
function R1(c, e, t) {
  var l, u;
  if (!t || !t.geometry)
    return 0;
  rl || (rl = new Ammo.btVector3(), mp = new Ammo.btVector3(), gp = new Ammo.btVector3());
  const r = t.geometry, n = ((l = r.attributes.position) == null ? void 0 : l.array) || [], s = ((u = r.index) == null ? void 0 : u.array) || [];
  let o = 0, i;
  if (e && e !== t) {
    let h;
    e.quaternion ? h = e.quaternion : e.rotation ? h = new M.Quaternion().setFromEuler(e.rotation) : h = new M.Quaternion().identity();
    const d = new M.Matrix4().compose(new M.Vector3(1, 1, 1), h, e.position);
    Hi.copy(d.invert()), t.updateWorldMatrix(!1, !1), i = t.matrixWorld.clone().multiply(Hi);
  } else
    Hi.makeScale(t.scale.x, t.scale.y, t.scale.z), i = Hi;
  const a = s.length / 3;
  for (let h = 0; h < a; h++) {
    const d = [];
    for (let f = 0; f < 3; f++) {
      let p = new M.Vector3(n[s[h * 3 + f] * 3 + 0], n[s[h * 3 + f] * 3 + 1], n[s[h * 3 + f] * 3 + 2]);
      p = p.applyMatrix4(i);
      let m;
      f == 0 ? m = rl : f == 1 ? m = mp : m = gp, m.setValue(p.x, p.y, p.z), d.push(m);
    }
    c.addTriangle(d[0], d[1], d[2]), o++;
  }
  return t.children.forEach((h) => {
    o += R1(c, e, h);
  }), o;
}
var Hs;
((c) => {
  function e(o) {
    return new ammo.btVector3(o.x, o.y, o.z);
  }
  c.t2aVector3 = e;
  function t(o) {
    return new M.Vector3(o.x(), o.y(), o.z());
  }
  c.a2tVector3 = t;
  function r(o) {
    var a, l;
    const i = o.geometry;
    if (i)
      if (i.type === "PlaneGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = new ammo.btBoxShape(new ammo.btVector3(d, f, 0));
        return p.setMargin(0.01), p;
      } else if (i.type === "BoxGeometry") {
        const h = i.parameters, d = h.width !== void 0 ? h.width / 2 : 0.5, f = h.height !== void 0 ? h.height / 2 : 0.5, p = h.depth !== void 0 ? h.depth / 2 : 0.5, m = new ammo.btBoxShape(new ammo.btVector3(d, f, p));
        return m.setMargin(1e-3), m;
      } else if (i.type === "CylinderGeometry") {
        const h = i.parameters, d = new ammo.btCylinderShape(new ammo.btVector3(h.radiusBottom, h.height, h.radiusTop));
        return d.setMargin(0.01), d;
      } else if (i.type === "ConeGeometry") {
        const h = i.parameters, d = new ammo.btConeShape(h.radius, h.height);
        return d.setMargin(0.01), d;
      } else if (i.type === "CapsuleGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = h.length !== void 0 ? h.length : 1, p = new ammo.btCapsuleShape(d, f);
        return p.setMargin(0.01), p;
      } else if (i.type === "SphereGeometry" || i.type === "IcosahedronGeometry") {
        const h = i.parameters, d = h.radius !== void 0 ? h.radius : 1, f = new ammo.btSphereShape(d);
        return f.setMargin(1e-3), f;
      } else {
        const u = new ammo.btTriangleMesh(!0, !0), h = ((a = i.attributes.position) == null ? void 0 : a.array) || [], d = ((l = i.index) == null ? void 0 : l.array) || [];
        for (let p = 0; p * 3 < d.length; p += 1)
          u.addTriangle(
            new ammo.btVector3(
              h[d[p * 3] * 3],
              h[d[p * 3] * 3 + 1],
              h[d[p * 3] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 1] * 3],
              h[d[p * 3 + 1] * 3 + 1],
              h[d[p * 3 + 1] * 3 + 2]
            ),
            new ammo.btVector3(
              h[d[p * 3 + 2] * 3],
              h[d[p * 3 + 2] * 3 + 1],
              h[d[p * 3 + 2] * 3 + 2]
            ),
            !1
          );
        const f = new ammo.btConvexTriangleMeshShape(u, !0);
        return f.setMargin(1e-3), f;
      }
    else {
      const u = new ammo.btTriangleMesh(!0, !0), d = R1(u, o, o) ? new Ammo.btBvhTriangleMeshShape(u, !0) : new Ammo.btCompoundShape();
      return d.setMargin(0.01), d;
    }
  }
  c.createShape = r;
  function n(o, i = 0, a) {
    const l = a || r(o);
    function u(d, f, p) {
      const m = d.position, g = d.quaternion, b = new ammo.btTransform();
      b.setIdentity(), b.setOrigin(new ammo.btVector3(m.x, m.y, m.z)), b.setRotation(new ammo.btQuaternion(g.x, g.y, g.z, g.w));
      const v = new ammo.btDefaultMotionState(b), y = new ammo.btVector3(0, 0, 0);
      p.calculateLocalInertia(f, y);
      const x = new ammo.btRigidBodyConstructionInfo(f, v, p, y);
      return new ammo.btRigidBody(x);
    }
    function h(d, f, p) {
      const m = d.instanceMatrix.array, g = [];
      for (let b = 0; b < d.count; b++) {
        const v = b * 16, y = new ammo.btTransform();
        y.setFromOpenGLMatrix(u_(m, v, v + 16));
        const x = new ammo.btDefaultMotionState(y), N = new ammo.btVector3(0, 0, 0);
        p.calculateLocalInertia(f, N);
        const w = new ammo.btRigidBodyConstructionInfo(f, x, p, N), T = new ammo.btRigidBody(w);
        g.push(T);
      }
      return g;
    }
    return o.isInstancedMesh ? h(o, i, l) : (o.isMesh, u(o, i, l));
  }
  c.createBody = n;
  function s(o) {
    ammo.destroy(o);
  }
  c.destroyBody = s;
})(Hs || (Hs = {}));
class l_ {
  constructor(e = -9.82) {
    G(this, "world");
    G(this, "collisionConfiguration");
    G(this, "dispatcher");
    G(this, "broadphase");
    G(this, "solver");
    G(this, "softBodySolver");
    G(this, "softBodyHelpers");
    G(this, "worldTransform");
    G(this, "destroyed", !1);
    G(this, "meshes", []);
    G(this, "meshMap", /* @__PURE__ */ new WeakMap());
    G(this, "meshIdx", {});
    G(this, "conllisionMap", /* @__PURE__ */ new Set());
    this.collisionConfiguration = new ammo.btDefaultCollisionConfiguration(), this.dispatcher = new ammo.btCollisionDispatcher(this.collisionConfiguration), this.broadphase = new ammo.btDbvtBroadphase(), this.solver = new ammo.btSequentialImpulseConstraintSolver(), this.softBodySolver = new ammo.btDefaultSoftBodySolver(), this.softBodyHelpers = new Ammo.btSoftBodyHelpers(), this.world = new ammo.btSoftRigidDynamicsWorld(this.dispatcher, this.broadphase, this.solver, this.collisionConfiguration, this.softBodySolver), this.world.setGravity(new ammo.btVector3(0, e, 0)), this.worldTransform = new ammo.btTransform();
  }
  dispose() {
    if (!this.destroyed) {
      for (const e of this.meshes) {
        const t = this.meshMap.get(e);
        this.meshMap.delete(e), ammo.destroy(t);
      }
      this.meshes.length = 0, ammo.destroy(this.collisionConfiguration), ammo.destroy(this.dispatcher), ammo.destroy(this.broadphase), ammo.destroy(this.solver), ammo.destroy(this.softBodySolver), ammo.destroy(this.softBodyHelpers), ammo.destroy(this.world), ammo.destroy(this.worldTransform), this.destroyed = !0;
    }
  }
  addMesh(e, t) {
    if (t) {
      if (Array.isArray(t))
        for (const r of t)
          this.world.addRigidBody(r);
      else
        this.world.addRigidBody(t);
      this.meshes.push(e), this.meshMap.set(e, t), e.id && (this.meshIdx[e.id] = e);
    }
    e.world = this;
  }
  removeMesh(e) {
    const t = this.meshMap.get(e), r = this.meshes.indexOf(e);
    if (!t) {
      e.world = void 0;
      return;
    }
    if (r !== -1 && this.meshes.splice(r, 1), this.meshMap.delete(e), delete this.meshIdx[e.id], Array.isArray(t))
      for (const n of t)
        this.world.removeRigidBody(n);
    else
      this.world.removeRigidBody(t);
    e.world = void 0;
  }
  findBody(e) {
    return this.meshMap.get(e);
  }
  setMeshPosition(e, t, r = 0) {
    if (e.isInstancedMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      const s = n[r];
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), s.setWorldTransform(this.worldTransform);
    } else if (e.isMesh) {
      const n = this.meshMap.get(e);
      if (!n)
        return;
      this.worldTransform.setIdentity(), this.worldTransform.setOrigin(new ammo.btVector3(t.x, t.y, t.z)), n.setWorldTransform(this.worldTransform);
    }
  }
  detectCollision() {
    const e = this.dispatcher.getNumManifolds(), t = /* @__PURE__ */ new Set();
    for (let n = 0; n < e; n++) {
      const s = this.dispatcher.getManifoldByIndexInternal(n), o = s.getBody0().getUserIndex(), i = s.getBody1().getUserIndex();
      t.add(`${o}:${i}`);
    }
    for (const n of t) {
      if (this.conllisionMap.has(n))
        continue;
      this.conllisionMap.add(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionEnter", target: a }), a.dispatchEvent({ type: "onCollisionEnter", target: i }));
    }
    const r = [];
    for (const n of this.conllisionMap)
      t.has(n) || r.push(n);
    for (const n of r) {
      this.conllisionMap.delete(n);
      const [s, o] = n.split(":").map((l) => Number.parseInt(l)), i = this.meshIdx[s], a = this.meshIdx[o];
      i && a && (i.dispatchEvent({ type: "onCollisionLeave", target: a }), a.dispatchEvent({ type: "onCollisionLeave", target: i }));
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  step(e, t) {
    if (e) {
      this.world.stepSimulation(e, 10), this.detectCollision();
      for (let r = 0, n = this.meshes.length; r < n; r++) {
        const s = this.meshes[r];
        if (s.mass) {
          if (s.isInstancedMesh) {
            const o = s.instanceMatrix.array, i = this.meshMap.get(s);
            for (let a = 0; a < i.length; a++) {
              i[a].getMotionState().getWorldTransform(this.worldTransform);
              const h = this.worldTransform.getOrigin(), d = this.worldTransform.getRotation();
              h_(h, d, o, a * 16);
            }
            s.instanceMatrix.needsUpdate = !0, s.computeBoundingSphere();
          } else if (s.isMesh) {
            this.meshMap.get(s).getMotionState().getWorldTransform(this.worldTransform);
            const a = this.worldTransform.getOrigin(), l = this.worldTransform.getRotation();
            s.position.set(a.x(), a.y(), a.z()), s.quaternion.set(l.x(), l.y(), l.z(), l.w());
          }
        }
      }
    }
  }
}
function u_(c, e, t) {
  const r = [], n = e + t;
  for (let s = e; s < n; s++)
    r.push(c[s]);
  return r;
}
function h_(c, e, t, r) {
  const n = e.x(), s = e.y(), o = e.z(), i = e.w(), a = n + n, l = s + s, u = o + o, h = n * a, d = n * l, f = n * u, p = s * l, m = s * u, g = o * u, b = i * a, v = i * l, y = i * u;
  t[r + 0] = 1 - (p + g), t[r + 1] = d + y, t[r + 2] = f - v, t[r + 3] = 0, t[r + 4] = d - y, t[r + 5] = 1 - (h + g), t[r + 6] = m + b, t[r + 7] = 0, t[r + 8] = f + v, t[r + 9] = m - b, t[r + 10] = 1 - (h + p), t[r + 11] = 0, t[r + 12] = c.x(), t[r + 13] = c.y(), t[r + 14] = c.z(), t[r + 15] = 1;
}
var wc = /* @__PURE__ */ ((c) => (c[c.Ghost = 0] = "Ghost", c[c.RigidBody = 1] = "RigidBody", c))(wc || {});
C1.BodyType = {
  Ghost: 0,
  RigidBody: 1
  // SoftBody: 2,
};
const or = 1e-3;
class bn extends qt {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Xa(), r || new An({ wireframe: !0 }));
    G(this, "isEntity", !0);
    G(this, "geo");
    G(this, "geoMatrix", new Ge().identity());
    G(this, "physicalBody", null);
    G(this, "world");
    G(this, "_tmpAmmoVectorA", new Ammo.btVector3(0, 0, 0));
    G(this, "_tmpAmmoQuaternion", new Ammo.btQuaternion(0, 0, 0, 1));
    this._bodyType = n, this._mass = s, this.type = "Entity", t || this.rebuildBody(), this.geo = Xd(Object.assign({}, this.parameters), () => {
      this.rebuildGeometry();
    });
  }
  get mass() {
    return this._mass;
  }
  set mass(t) {
    this._mass !== t && (this._mass === 0 || t === 0 ? (this._mass = t, this.rebuildBody()) : this.physicalBody.setMassProps(t));
  }
  get bodyType() {
    return this._bodyType;
  }
  set bodyType(t) {
    this._bodyType !== t && (this._bodyType = t, this.rebuildBody());
  }
  get parameters() {
    return this.geometry.parameters || {};
  }
  moveTo(t) {
    this.physicalBody && this.setPhysicsBodyTransformation(t), this.position.copy(t);
  }
  applyTranslation(t) {
    return this.applyGeoMatrix4(new Ge().makeTranslation(t));
  }
  applyRotationFromEuler(t) {
    return this.applyGeoMatrix4(new Ge().makeRotationFromEuler(t));
  }
  applyScale(t) {
    return this.applyGeoMatrix4(new Ge().makeScale(t.x, t.y, t.z));
  }
  applyGeoMatrix4(t) {
    this.geoMatrix.premultiply(t), this.geometry.applyMatrix4(t);
  }
  clone(t) {
    const r = super.clone(t), n = this._mass || 0, s = this._bodyType || 0;
    (n !== this._mass || s !== this._bodyType) && (r._mass = n, r._bodyType = s, r.rebuildBody());
    const o = r.geo[Gt];
    return Object.assign(o, this.parameters), r.geoMatrix.copy(this.geoMatrix), r;
  }
  serialize(t) {
    t.mass = this._mass, t.bodyType = this._bodyType, t.geoMatrix = this.geoMatrix.toArray();
  }
  deserialize(t) {
    const r = t.mass || 0, n = t.bodyType || 0;
    (r !== this._mass || n !== this._bodyType) && (this._mass = r, this._bodyType = n, this.rebuildBody());
    const s = this.geo[Gt];
    Object.assign(s, this.parameters), t.geoMatrix && (this.geoMatrix.fromArray(t.geoMatrix), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox()), this.setPhysicsBodyTransformation(this.position);
  }
  dispose() {
    if (this.material instanceof zn)
      this.material.dispose();
    else if (Array.isArray(this.material))
      for (const t of this.material)
        t.material.dispose();
    this.physicalBody && (this.world && this.world.removeMesh(this), Hs.destroyBody(this.physicalBody), this.physicalBody = null);
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose(), this.geometry = t.fromJSON(this.geo[Gt]), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
  rebuildBody() {
    const t = this.world;
    this.physicalBody && (this.world && this.world.removeMesh(this), Hs.destroyBody(this.physicalBody)), this._bodyType !== 0 ? (this.physicalBody = Hs.createBody(this, this._mass), this.physicalBody.setUserIndex(this.id), t && t.addMesh(this, this.physicalBody)) : this.physicalBody = null;
  }
  /**
   * Sets the babylon object's position/rotation from the physics body's position/rotation
   * @param impostor imposter containing the physics body and babylon object
   * @param newPosition new position
   * @param newRotation new rotation
   */
  setPhysicsBodyTransformation(t, r) {
    if (!this.physicalBody)
      return;
    const n = this.physicalBody.getWorldTransform();
    if (Math.abs(n.getOrigin().x() - t.x) > or || Math.abs(n.getOrigin().y() - t.y) > or || Math.abs(n.getOrigin().z() - t.z) > or || r && (Math.abs(n.getRotation().x() - r.x) > or || Math.abs(n.getRotation().y() - r.y) > or || Math.abs(n.getRotation().z() - r.z) > or || Math.abs(n.getRotation().w() - r.w) > or))
      if (this._tmpAmmoVectorA.setValue(t.x, t.y, t.z), n.setOrigin(this._tmpAmmoVectorA), r && (this._tmpAmmoQuaternion.setValue(r.x, r.y, r.z, r.w), n.setRotation(this._tmpAmmoQuaternion)), this.physicalBody.setWorldTransform(n), this.mass == 0) {
        const s = this.physicalBody.getMotionState();
        s && s.setWorldTransform(n);
      } else
        this.physicalBody.activate();
  }
}
Ye("Entity", {
  create: ({ material: c, geometry: e } = {}) => new bn(e, c),
  members: {
    mass: "Number",
    bodyType: "types.BodyType"
  },
  proto: "Mesh",
  group: "",
  icon: ""
});
const d_ = 1024, f_ = 1024, ol = new ve(), p_ = new ve(), nn = {
  /** world time delta */
  delta: 0,
  /** world current time */
  now: 0,
  /** to y axis */
  gravity: new ve(0, -9.8, 0),
  windForce: new ve(),
  scene: null,
  gpuComputeRender: null,
  /** wait for x miliseconds */
  wait(c) {
    return new Promise((e) => {
      setTimeout(e, c, !0);
    });
  },
  random(c, e) {
    return c + Math.floor(Math.random() * (e - c + 1));
  },
  randomChoice(c) {
    if (Array.isArray(c)) {
      const e = Math.floor(Math.random() * c.length);
      return c[e];
    } else {
      const e = Object.keys(c), t = Math.floor(Math.random() * e.length);
      return c[t];
    }
  },
  calcObjectPosition(c, e, t, r) {
    if (t <= 0)
      return [c, e];
    const n = r ? ol.copy(e).normalize().multiply(e).multiply(e).multiplyScalar(-r) : ol.set(0, 0, 0);
    n.add(this.windForce);
    const s = n.divideScalar(t);
    s.add(this.gravity);
    const o = s.multiplyScalar(this.delta).add(e);
    return [p_.copy(o).add(e).multiplyScalar(0.5 * this.delta).add(c), ol];
  },
  combineBuffer(c, e, t) {
    let r = 0, n = 3;
    c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        n = f.itemSize, r += f.array.length;
      }
    });
    const s = r / n, o = t && s > t ? Math.ceil(s / t) : 1, i = Math.ceil(r / (n * o)), a = new Float32Array(i * n);
    let l = 0, u = 0, h = 0;
    return c.traverse(function(d) {
      if (d.isMesh) {
        const f = d.geometry.attributes[e];
        if (o === 1)
          a.set(f.array, h * n), l += f.array.length, h += f.array.length / n, u = l / n;
        else {
          const p = f.count;
          for (let m = 0; m < p; m++)
            u % o === 0 && (a[h * n] = f.array[m * n], a[h * n + 1] = f.array[m * n + 1], a[h * n + 2] = f.array[m * n + 2], h++), u++;
          l += f.array.length;
        }
      }
    }), new ro(a, n);
  }
};
class $d extends $a {
  constructor() {
    super();
    G(this, "isPhysicalScene", !0);
    G(this, "physics");
    G(this, "windForce", new ve());
    /** to y axis */
    G(this, "_gravity", -9.8);
    G(this, "objectsTrash", {});
    this.type = "PhysicalScene", this.physics = new l_(this._gravity);
  }
  get gravity() {
    return this._gravity;
  }
  set gravity(t) {
    this._gravity !== t && (this._gravity = t, this.physics.world.setGravity(new Ammo.btVector3(0, this._gravity, 0)));
  }
  update(t, r, n, s, o = !1) {
    nn.scene = this, nn.gravity.y = this._gravity;
    const i = this.windForce.clone().multiplyScalar(0.5 + 0.5 * Math.sin(s / 2e3));
    if (nn.windForce.copy(i), !o) {
      for (const a of this.children)
        a.visible && a.graph && a.graph.update(t, r, n, s);
      this.physics.step(n, s);
    }
  }
  add(...t) {
    super.add(...t);
    for (const r of t)
      delete this.objectsTrash[r.id], r instanceof bn && this.physics.addMesh(r, r.physicalBody), r.dispatchEvent({ type: "onBorn", source: this, object: r });
    return this;
  }
  remove(...t) {
    super.remove(...t);
    for (const r of t)
      r instanceof bn && this.physics.removeMesh(r), r.dispatchEvent({ type: "onDead", source: this, object: r }), this.objectsTrash[r.id] = r;
    return this;
  }
  serialize(t) {
    t.gravity = this.gravity, t.windForce = this.windForce.toArray();
  }
  deserialize(t) {
    t.gravity && (this.gravity = t.gravity), t.windForce && this.windForce.fromArray(t.windForce);
  }
  active() {
    this.dispatchEvent({ type: "onBorn", source: this, object: this });
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onBorn", source: this, object: t });
  }
  deactive() {
    for (const t of this.children)
      t.dispatchEvent && t.dispatchEvent({ type: "onDead", source: this, object: t });
    this.dispatchEvent({ type: "onDead", source: this, object: this });
  }
  dispose() {
    for (const t of Object.values(this.objectsTrash))
      t.traverse((r) => {
        if (r.dispose)
          r.dispose();
        else if (r.geometry instanceof Jn && r.geometry.dispose(), r.material instanceof zn)
          r.material.dispose();
        else if (Array.isArray(r.material))
          for (const n of r.material)
            n.dispose();
      });
    this.physics.dispose();
  }
}
Ye("PhysicalScene", {
  // cls: PhysicalScene,
  members: {
    gravity: "Number",
    windForce: "Vector3"
  },
  proto: "Scene",
  group: "Scenes.Physical Scene",
  icon: "scene",
  create: () => new $d()
});
const yp = new er(), Xi = new ve();
class L1 extends Cm {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new gn(e, 3)), this.setAttribute("uv", new gn(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Ma(t, 6, 1);
    return this.setAttribute("instanceStart", new Gs(r, 3, 0)), this.setAttribute("instanceEnd", new Gs(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new Ma(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Gs(r, 3, 0)), this.setAttribute("instanceColorEnd", new Gs(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new vb(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new er());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), yp.setFromBufferAttribute(t), this.boundingBox.union(yp));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new xi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Xi.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(Xi)), Xi.fromBufferAttribute(t, s), n = Math.max(n, r.distanceToSquared(Xi));
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
oo.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new wt(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
as.line = {
  uniforms: tr.merge([
    oo.common,
    oo.fog,
    oo.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class qd extends hs {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: tr.clone(as.line.uniforms),
      vertexShader: as.line.vertexShader,
      fragmentShader: as.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1));
  }
}
const vp = new ve(), xp = new ve(), jt = new pt(), Wt = new pt(), os = new pt(), il = new ve(), al = new Ge(), Xt = new xb(), bp = new ve(), $i = new er(), qi = new xi(), is = new pt();
let us, br;
function Np(c, e, t) {
  return is.set(0, 0, -e, 1).applyMatrix4(c.projectionMatrix), is.multiplyScalar(1 / is.w), is.x = br / t.width, is.y = br / t.height, is.applyMatrix4(c.projectionMatrixInverse), is.multiplyScalar(1 / is.w), Math.abs(Math.max(is.x, is.y));
}
function m_(c, e) {
  const t = c.matrixWorld, r = c.geometry, n = r.attributes.instanceStart, s = r.attributes.instanceEnd, o = Math.min(r.instanceCount, n.count);
  for (let i = 0, a = o; i < a; i++) {
    Xt.start.fromBufferAttribute(n, i), Xt.end.fromBufferAttribute(s, i), Xt.applyMatrix4(t);
    const l = new ve(), u = new ve();
    us.distanceSqToSegment(Xt.start, Xt.end, u, l), u.distanceTo(l) < br * 0.5 && e.push({
      point: u,
      pointOnLine: l,
      distance: us.origin.distanceTo(u),
      object: c,
      face: null,
      faceIndex: i,
      uv: null,
      uv1: null
    });
  }
}
function g_(c, e, t) {
  const r = e.projectionMatrix, s = c.material.resolution, o = c.matrixWorld, i = c.geometry, a = i.attributes.instanceStart, l = i.attributes.instanceEnd, u = Math.min(i.instanceCount, a.count), h = -e.near;
  us.at(1, os), os.w = 1, os.applyMatrix4(e.matrixWorldInverse), os.applyMatrix4(r), os.multiplyScalar(1 / os.w), os.x *= s.x / 2, os.y *= s.y / 2, os.z = 0, il.copy(os), al.multiplyMatrices(e.matrixWorldInverse, o);
  for (let d = 0, f = u; d < f; d++) {
    if (jt.fromBufferAttribute(a, d), Wt.fromBufferAttribute(l, d), jt.w = 1, Wt.w = 1, jt.applyMatrix4(al), Wt.applyMatrix4(al), jt.z > h && Wt.z > h)
      continue;
    if (jt.z > h) {
      const y = jt.z - Wt.z, x = (jt.z - h) / y;
      jt.lerp(Wt, x);
    } else if (Wt.z > h) {
      const y = Wt.z - jt.z, x = (Wt.z - h) / y;
      Wt.lerp(jt, x);
    }
    jt.applyMatrix4(r), Wt.applyMatrix4(r), jt.multiplyScalar(1 / jt.w), Wt.multiplyScalar(1 / Wt.w), jt.x *= s.x / 2, jt.y *= s.y / 2, Wt.x *= s.x / 2, Wt.y *= s.y / 2, Xt.start.copy(jt), Xt.start.z = 0, Xt.end.copy(Wt), Xt.end.z = 0;
    const m = Xt.closestPointToPointParameter(il, !0);
    Xt.at(m, bp);
    const g = Zt.lerp(jt.z, Wt.z, m), b = g >= -1 && g <= 1, v = il.distanceTo(bp) < br * 0.5;
    if (b && v) {
      Xt.start.fromBufferAttribute(a, d), Xt.end.fromBufferAttribute(l, d), Xt.start.applyMatrix4(o), Xt.end.applyMatrix4(o);
      const y = new ve(), x = new ve();
      us.distanceSqToSegment(Xt.start, Xt.end, x, y), t.push({
        point: x,
        pointOnLine: y,
        distance: us.origin.distanceTo(x),
        object: c,
        face: null,
        faceIndex: d,
        uv: null,
        uv1: null
      });
    }
  }
}
class y_ extends qt {
  constructor(e = new L1(), t = new qd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, n = new Float32Array(2 * t.count);
    for (let o = 0, i = 0, a = t.count; o < a; o++, i += 2)
      vp.fromBufferAttribute(t, o), xp.fromBufferAttribute(r, o), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + vp.distanceTo(xp);
    const s = new Ma(n, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Gs(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Gs(s, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, n = e.camera;
    n === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    us = e.ray;
    const o = this.matrixWorld, i = this.geometry, a = this.material;
    br = a.linewidth + s, i.boundingSphere === null && i.computeBoundingSphere(), qi.copy(i.boundingSphere).applyMatrix4(o);
    let l;
    if (r)
      l = br * 0.5;
    else {
      const h = Math.max(n.near, qi.distanceToPoint(us.origin));
      l = Np(n, h, a.resolution);
    }
    if (qi.radius += l, us.intersectsSphere(qi) === !1)
      return;
    i.boundingBox === null && i.computeBoundingBox(), $i.copy(i.boundingBox).applyMatrix4(o);
    let u;
    if (r)
      u = br * 0.5;
    else {
      const h = Math.max(n.near, $i.distanceToPoint(us.origin));
      u = Np(n, h, a.resolution);
    }
    $i.expandByScalar(u), us.intersectsBox($i) !== !1 && (r ? m_(this, t) : g_(this, n, t));
  }
}
class F1 extends L1 {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let n = 0; n < t; n += 3)
      r[2 * n] = e[n], r[2 * n + 1] = e[n + 1], r[2 * n + 2] = e[n + 2], r[2 * n + 3] = e[n + 3], r[2 * n + 4] = e[n + 4], r[2 * n + 5] = e[n + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class v_ extends y_ {
  constructor(e = new F1(), t = new qd({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class cl extends F1 {
  constructor() {
    super(...arguments);
    G(this, "isBezieoLineGeometry", !0);
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    return t.uuid = this.uuid, t.type = "BufferGeometry", t.data = {}, t;
  }
}
class hi extends qd {
  constructor() {
    super();
    G(this, "isBezierLineMaterial", !0);
    this.type = "BezierLineMaterial";
  }
}
class O1 extends v_ {
  constructor() {
    super(new cl(), new hi());
    G(this, "isBezierLine", !0);
    G(this, "fromPosition", new ve());
    G(this, "toPosition", new ve(1, 1, 0));
    G(this, "ctrl1", new ve(0.2, 0.1, 0));
    G(this, "ctrl2", new ve(0.8, 0.9, 0));
    G(this, "density", 10);
    G(this, "_tmpSize", new wt());
    this.type = "BezierLine", this.material.worldUnits = !0, this.material.linewidth = 0.1, this.onBeforeRender = (t, r, n, s, o, i) => {
      const { x: a, y: l } = t.getSize(this._tmpSize);
      (this.material.resolution.x !== a || this.material.resolution.y !== l) && (this.material.resolution.set(a, l), this.material.uniformsNeedUpdate = !0);
    }, this.updatePositions();
  }
  updatePositions() {
    const t = new bb(this.fromPosition, this.ctrl1, this.ctrl2, this.toPosition), r = Math.abs(this.fromPosition.clone().distanceTo(this.toPosition)), n = t.getPoints(this.density * r);
    this.geometry.setPositions(n.map((s) => [s.x, s.y, s.z]).flat()), this.computeLineDistances();
  }
  serialize(t) {
    t.type = "BezierLine", t.fromPosition = this.fromPosition.toArray(), t.toPosition = this.toPosition.toArray(), t.ctrl1 = this.ctrl1.toArray(), t.ctrl2 = this.ctrl2.toArray(), t.density = this.density;
  }
  deserialize(t) {
    this.fromPosition.fromArray(t.fromPosition), this.toPosition.fromArray(t.toPosition), this.ctrl1.fromArray(t.ctrl1), this.ctrl2.fromArray(t.ctrl2), this.density = t.density, this.geometry instanceof cl || (this.geometry = new cl()), this.updatePositions();
  }
}
o_("BezierLineMaterial", hi);
Ye("BezierLine", {
  // cls: BezierLine,
  create: () => new O1(),
  members: {
    fromPosition: "Vector3",
    toPosition: "Vector3",
    ctrl1: "Vector3",
    ctrl2: "Vector3",
    density: "Number"
  },
  proto: "Mesh",
  group: "Objects.Bezier Line",
  icon: "line"
});
Es("BezierLineMaterial", hi, {
  color: "Color",
  dashed: "Boolean",
  dashScale: "Number",
  dashSize: "Number",
  dashOffset: "Number",
  gapSize: "Number",
  opacity: "Number",
  linewidth: "Number",
  alphaToCoverage: "Boolean",
  worldUnits: "Boolean"
}, "ShaderMaterial", {
  bezierLineMaterial: { clsName: "bezierLineMaterial", func: () => new hi(), group: "Material.Bezier Line Material", icon: "brand-medium" }
});
Ye("PerspectiveCamera", {
  // cls: PerspectiveCamera,
  create: () => new Tr(),
  members: {},
  group: "Cameras.Perspective Camera",
  icon: "camera"
});
Ye("OrthographicCamera", {
  // cls: OrthographicCamera,
  create: () => new qa(),
  members: {},
  group: "Cameras.Orthographic Camera",
  icon: "camera"
});
class I1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isBox", !0);
    this.type = "Box";
  }
}
Ye("Box", {
  create: ({ material: c, geometry: e } = {}) => new I1(e, c || new Gn()),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.depthSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Box",
  icon: "box"
});
class P1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCapsule", !0);
    this.type = "Capsule";
  }
}
Ye("Capsule", {
  create: ({ material: c, geometry: e } = {}) => new P1(e || new Em(), c || new Gn()),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Entity",
  group: "Entities.Capsule",
  icon: "capsule"
});
class D1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCone", !0);
    this.type = "Cone";
  }
}
Ye("Cone", {
  create: ({ material: c, geometry: e } = {}) => new D1(e || new Nb(), c || new Gn()),
  members: {
    "geo.radius": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cone",
  icon: "cone"
});
class U1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isCylinder", !0);
    this.type = "Cylinder";
  }
}
Ye("Cylinder", {
  create: ({ material: c, geometry: e } = {}) => new U1(e || new wb(), c || new Gn()),
  members: {
    "geo.radiusTop": "Number",
    "geo.radiusBottom": "Number",
    "geo.height": "Number",
    "geo.radialSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.openEnded": "Boolean",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Cylinder",
  icon: "cylinder"
});
let z1 = class extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isSphere", !0);
    this.type = "Sphere";
  }
};
Ye("Sphere", {
  create: ({ material: c, geometry: e } = {}) => new z1(e || new Ja(), c || new Gn()),
  members: {
    "geo.radius": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number",
    "geo.phiStart": "Number",
    "geo.phiLength": "Number",
    "geo.phiSegments": "Number",
    "geo.thetaStart": "Number",
    "geo.thetaLength": "Number"
  },
  proto: "Entity",
  group: "Entities.Sphere",
  icon: "sphere"
});
class B1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorus", !0);
    this.type = "Torus";
  }
}
Ye("Torus", {
  create: ({ material: c, geometry: e } = {}) => new B1(e || new Tb(), c || new Gn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.arc": "Number"
  },
  proto: "Entity",
  group: "Entities.Torus",
  icon: "ring"
});
class k1 extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, n, s);
    G(this, "isTorusKnot", !0);
    this.type = "TorusKnot";
  }
}
Ye("TorusKnot", {
  create: ({ material: c, geometry: e } = {}) => new k1(e || new Sb(), c || new Gn()),
  members: {
    "geo.radius": "Number",
    "geo.tube": "Number",
    "geo.radialSegments": "Number",
    "geo.tubularSegments": "Number",
    "geo.p": "Number",
    "geo.q": "Number"
  },
  proto: "Entity",
  group: "Entities.TorusKnot",
  icon: "pipe"
});
const x_ = {
  curveSegments: 12,
  steps: 1,
  depth: 1,
  bevelEnabled: !0,
  bevelThickness: 0.2,
  bevelSize: 0.1,
  bevelOffset: 0,
  bevelSegments: 3
};
let Rr = class extends bn {
  constructor(t, r, n, s = 0, o = 0) {
    super(t || new Rm(), r || new Gn(), s, o);
    G(this, "isShape", !0);
    G(this, "shapes", []);
    G(this, "props");
    this.type = "Shape", this.props = Xd({ ...n }, () => {
      this.rebuildShapes();
    }), t || this.rebuildShapes();
  }
  get parameters() {
    var r;
    const t = ((r = this.geometry.parameters) == null ? void 0 : r.options) || {};
    return Object.keys(t).length ? t : { ...x_ };
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Gt], s = Zs(n), o = r.props[Gt];
    return Qs(o, s), r;
  }
  serialize(t) {
    super.serialize(t);
    const r = this.props[Gt];
    t.props = Zs(r);
  }
  deserialize(t) {
    if (super.deserialize(t), t.props) {
      const r = this.props[Gt];
      Qs(r, t.props);
    }
    this.shapes = Array.isArray(this.geometry.parameters.shapes) ? this.geometry.parameters.shapes : [this.geometry.parameters.shapes];
  }
  rebuildShapes() {
    this.rebuildGeometry();
  }
  rebuildGeometry() {
    const t = this.geometry.constructor;
    this.geometry.dispose();
    const r = this.geo[Gt];
    this.geometry = t.fromJSON({ shapes: this.shapes.map((n, s) => s), options: r }, this.shapes), this.geometry.applyMatrix4(this.geoMatrix), this.geometry.computeBoundingBox();
  }
};
Ye("Shape", {
  create: ({ material: c, geometry: e } = {}) => new Rr(e, c),
  members: {
    "geo.curveSegments": "Number",
    "geo.steps": "Number",
    "geo.depth": "Number",
    "geo.bevelEnabled": "Boolean",
    "geo.bevelThickness": "Number",
    "geo.bevelSize": "Number",
    "geo.bevelOffset": "Number",
    "geo.bevelSegments": "Number"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class G1 extends bn {
  constructor(t, r) {
    super(t || new Ar(), r || new Gn(), wc.Ghost, 0);
    G(this, "isPlane", !0);
    this.type = "Plane";
  }
}
Ye("Plane", {
  create: ({ material: c, geometry: e } = {}) => new G1(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.widthSegments": "Number",
    "geo.heightSegments": "Number"
  },
  /** yes, we hide mass and body-type properties */
  proto: "Mesh",
  group: "Shapes.Plane",
  icon: "plane"
});
class V1 extends Rr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { vec1: new wt(0, 0), vec2: new wt(1, 0), vec3: new wt(0, 1) }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeTriangle";
  }
  rebuildShapes() {
    const t = new Nu(), r = new No();
    t.subPaths.push(r);
    const { vec1: n, vec2: s, vec3: o } = this.props;
    r.moveTo(n.x, n.y), r.lineTo(s.x, s.y), r.lineTo(o.x, o.y), r.lineTo(n.x, n.y), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeTriangle", {
  create: ({ material: c, geometry: e } = {}) => new V1(e, c),
  members: {
    "props.vec1": "Vector2",
    "props.vec2": "Vector2",
    "props.vec3": "Vector2"
  },
  proto: "Shape",
  group: "Shapes.Triangle",
  icon: "triangle"
});
class j1 extends Rr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { size: 1 }, n, s);
    G(this, "isShapeSquare", !0);
    this.type = "ShapeSquare";
  }
  rebuildShapes() {
    const t = new No(), { size: r } = this.props;
    t.moveTo(0, 0), t.lineTo(r, 0), t.lineTo(r, r), t.lineTo(0, r), t.lineTo(0, 0), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeSquare", {
  create: ({ material: c, geometry: e } = {}) => new j1(e, c),
  members: {
    "props.size": "Number"
  },
  proto: "Shape",
  group: "Shapes.Square",
  icon: "square"
});
class W1 extends Rr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { width: 1, height: 1, radius: 0.2 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeRounded";
  }
  rebuildShapes() {
    const t = new Nu(), r = new No();
    t.subPaths.push(r);
    const { width: n, height: s, radius: o } = this.props;
    r.moveTo(0, o), r.lineTo(0, s - o), r.quadraticCurveTo(0, s, o, s), r.lineTo(0 + n - o, s), r.quadraticCurveTo(n, s, n, s - o), r.lineTo(0 + n, o), r.quadraticCurveTo(n, 0, n - o, 0), r.lineTo(o, 0), r.quadraticCurveTo(0, 0, 0, o), this.shapes = t.toShapes(!1), this.rebuildGeometry();
  }
}
Ye("ShapeRounded", {
  create: ({ material: c, geometry: e } = {}) => new W1(e, c),
  members: {
    "props.width": "Number",
    "props.height": "Number",
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Rounded rectangle",
  icon: "square"
});
class H1 extends Rr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeCircle";
  }
  rebuildShapes() {
    const t = new No(), { radius: r } = this.props;
    t.moveTo(0, r).quadraticCurveTo(r, r, r, 0).quadraticCurveTo(r, -r, 0, -r).quadraticCurveTo(-r, -r, -r, 0).quadraticCurveTo(-r, r, 0, r), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeCircle", {
  create: ({ material: c, geometry: e } = {}) => new H1(e, c),
  members: {
    "props.radius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Circle",
  icon: "ring"
});
class X1 extends Rr {
  constructor(t, r, n = 0, s = 0) {
    super(t, r, { radius: 1, innerRadius: 0.5 }, n, s);
    G(this, "isShapeTriangle", !0);
    this.type = "ShapeArc";
  }
  rebuildShapes() {
    const t = new No(), { radius: r, innerRadius: n } = this.props;
    t.moveTo(r, 0).absarc(0, 0, r, 0, Math.PI * 2, !1);
    const s = new _b().moveTo(n, 0).absarc(0, 0, n, 0, Math.PI * 2, !0);
    t.holes.push(s), this.shapes = [t], this.rebuildGeometry();
  }
}
Ye("ShapeArc", {
  create: ({ material: c, geometry: e } = {}) => new X1(e, c),
  members: {
    "props.radius": "Number",
    "props.innerRadius": "Number"
  },
  proto: "Shape",
  group: "Shapes.Arc Circle",
  icon: "ring"
});
Ye("PointLight", {
  // cls: PointLight,
  create: () => {
    const c = new Zo();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Point Light",
  icon: "bulb"
});
Ye("SpotLight", {
  // cls: SpotLight,
  create: () => {
    const c = new yi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c;
  },
  members: {},
  group: "Lights.Spot Light",
  icon: "bulb"
});
Ye("DirectionalLight", {
  // cls: DirectionalLight,
  create: () => {
    const c = new gi();
    return c.shadow.mapSize.x = 2048, c.shadow.mapSize.y = 2048, c.shadow.bias = -0.1, c;
  },
  members: {},
  group: "Lights.Directional Light",
  icon: "bulb"
});
Ye("AmbientLight", {
  // cls: AmbientLight,
  create: () => new vu(),
  members: {},
  group: "Lights.Ambient Light",
  icon: "bulb"
});
Ye("HemisphereLight", {
  // cls: HemisphereLight,
  create: () => new _m(),
  members: {},
  group: "Lights.Hemisphere Light",
  icon: "bulb"
});
function b_() {
  var c = /* @__PURE__ */ Object.create(null);
  function e(n, s) {
    var o = n.id, i = n.name, a = n.dependencies;
    a === void 0 && (a = []);
    var l = n.init;
    l === void 0 && (l = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !c[o])
      try {
        a = a.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = c[d.id].value), d;
        }), l = r("<" + i + ">.init", l), u && (u = r("<" + i + ">.getTransferables", u));
        var h = null;
        typeof l == "function" ? h = l.apply(void 0, a) : console.error("worker module init function failed to rehydrate"), c[o] = {
          id: o,
          value: h,
          getTransferables: u
        }, s(h);
      } catch (d) {
        d && d.noLog || console.error(d), s(d);
      }
  }
  function t(n, s) {
    var o, i = n.id, a = n.args;
    (!c[i] || typeof c[i].value != "function") && s(new Error("Worker module " + i + ": not found or its 'init' did not return a function"));
    try {
      var l = (o = c[i]).value.apply(o, a);
      l && typeof l.then == "function" ? l.then(u, function(h) {
        return s(h instanceof Error ? h : new Error("" + h));
      }) : u(l);
    } catch (h) {
      s(h);
    }
    function u(h) {
      try {
        var d = c[i].getTransferables && c[i].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), s(h, d);
      } catch (f) {
        console.error(f), s(f);
      }
    }
  }
  function r(n, s) {
    var o = void 0;
    self.troikaDefine = function(a) {
      return o = a;
    };
    var i = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(i);
    } catch (a) {
      console.error(a);
    }
    return URL.revokeObjectURL(i), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function(n) {
    var s = n.data, o = s.messageId, i = s.action, a = s.data;
    try {
      i === "registerModule" && e(a, function(l) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: { isCallable: typeof l == "function" }
        });
      }), i === "callModule" && t(a, function(l, u) {
        l instanceof Error ? postMessage({
          messageId: o,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: o,
          success: !0,
          result: l
        }, u || void 0);
      });
    } catch (l) {
      postMessage({
        messageId: o,
        success: !1,
        error: l.stack
      });
    }
  });
}
function N_(c) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = c.dependencies, r = c.init;
    t = Array.isArray(t) ? t.map(
      function(s) {
        return s && s._getInitResult ? s._getInitResult() : s;
      }
    ) : [];
    var n = Promise.all(t).then(function(s) {
      return r.apply(null, s);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var $1 = function() {
  var c = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), c = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return $1 = function() {
    return c;
  }, c;
}, w_ = 0, T_ = 0, ll = !1, $o = /* @__PURE__ */ Object.create(null), qo = /* @__PURE__ */ Object.create(null), nu = /* @__PURE__ */ Object.create(null);
function fs(c) {
  if ((!c || typeof c.init != "function") && !ll)
    throw new Error("requires `options.init` function");
  var e = c.dependencies, t = c.init, r = c.getTransferables, n = c.workerId;
  if (!$1())
    return N_(c);
  n == null && (n = "#default");
  var s = "workerModule" + ++w_, o = c.name || s, i = null;
  e = e && e.map(function(l) {
    return typeof l == "function" && !l.workerModuleData && (ll = !0, l = fs({
      workerId: n,
      name: "<" + o + "> function dependency: " + l.name,
      init: `function(){return (
` + Na(l) + `
)}`
    }), ll = !1), l && l.workerModuleData && (l = l.workerModuleData), l;
  });
  function a() {
    for (var l = [], u = arguments.length; u--; )
      l[u] = arguments[u];
    if (!i) {
      i = wp(n, "registerModule", a.workerModuleData);
      var h = function() {
        i = null, qo[n].delete(h);
      };
      (qo[n] || (qo[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return i.then(function(d) {
      var f = d.isCallable;
      if (f)
        return wp(n, "callModule", { id: s, args: l });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return a.workerModuleData = {
    isWorkerModule: !0,
    id: s,
    name: o,
    dependencies: e,
    init: Na(t),
    getTransferables: r && Na(r)
  }, a;
}
function S_(c) {
  qo[c] && qo[c].forEach(function(e) {
    e();
  }), $o[c] && ($o[c].terminate(), delete $o[c]);
}
function Na(c) {
  var e = c.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function __(c) {
  var e = $o[c];
  if (!e) {
    var t = Na(b_);
    e = $o[c] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + c.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var n = r.data, s = n.messageId, o = nu[s];
      if (!o)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete nu[s], o(n);
    };
  }
  return e;
}
function wp(c, e, t) {
  return new Promise(function(r, n) {
    var s = ++T_;
    nu[s] = function(o) {
      o.success ? r(o.result) : n(new Error("Error in worker " + e + " call: " + o.error));
    }, __(c).postMessage({
      messageId: s,
      action: e,
      data: t
    });
  });
}
function q1() {
  var c = function(e) {
    function t(H, X, C, O, I, k, z, Q) {
      var W = 1 - z;
      Q.x = W * W * H + 2 * W * z * C + z * z * I, Q.y = W * W * X + 2 * W * z * O + z * z * k;
    }
    function r(H, X, C, O, I, k, z, Q, W, q) {
      var ie = 1 - W;
      q.x = ie * ie * ie * H + 3 * ie * ie * W * C + 3 * ie * W * W * I + W * W * W * z, q.y = ie * ie * ie * X + 3 * ie * ie * W * O + 3 * ie * W * W * k + W * W * W * Q;
    }
    function n(H, X) {
      for (var C = /([MLQCZ])([^MLQCZ]*)/g, O, I, k, z, Q; O = C.exec(H); ) {
        var W = O[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(q) {
          return parseFloat(q);
        });
        switch (O[1]) {
          case "M":
            z = I = W[0], Q = k = W[1];
            break;
          case "L":
            (W[0] !== z || W[1] !== Q) && X("L", z, Q, z = W[0], Q = W[1]);
            break;
          case "Q": {
            X("Q", z, Q, z = W[2], Q = W[3], W[0], W[1]);
            break;
          }
          case "C": {
            X("C", z, Q, z = W[4], Q = W[5], W[0], W[1], W[2], W[3]);
            break;
          }
          case "Z":
            (z !== I || Q !== k) && X("L", z, Q, I, k);
            break;
        }
      }
    }
    function s(H, X, C) {
      C === void 0 && (C = 16);
      var O = { x: 0, y: 0 };
      n(H, function(I, k, z, Q, W, q, ie, ae, $) {
        switch (I) {
          case "L":
            X(k, z, Q, W);
            break;
          case "Q": {
            for (var F = k, te = z, Z = 1; Z < C; Z++)
              t(
                k,
                z,
                q,
                ie,
                Q,
                W,
                Z / (C - 1),
                O
              ), X(F, te, O.x, O.y), F = O.x, te = O.y;
            break;
          }
          case "C": {
            for (var Y = k, ee = z, pe = 1; pe < C; pe++)
              r(
                k,
                z,
                q,
                ie,
                ae,
                $,
                Q,
                W,
                pe / (C - 1),
                O
              ), X(Y, ee, O.x, O.y), Y = O.x, ee = O.y;
            break;
          }
        }
      });
    }
    var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", i = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", a = /* @__PURE__ */ new WeakMap(), l = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(H, X) {
      var C = H.getContext ? H.getContext("webgl", l) : H, O = a.get(C);
      if (!O) {
        let ie = function(Y) {
          var ee = k[Y];
          if (!ee && (ee = k[Y] = C.getExtension(Y), !ee))
            throw new Error(Y + " not supported");
          return ee;
        }, ae = function(Y, ee) {
          var pe = C.createShader(ee);
          return C.shaderSource(pe, Y), C.compileShader(pe), pe;
        }, $ = function(Y, ee, pe, ne) {
          if (!z[Y]) {
            var he = {}, fe = {}, K = C.createProgram();
            C.attachShader(K, ae(ee, C.VERTEX_SHADER)), C.attachShader(K, ae(pe, C.FRAGMENT_SHADER)), C.linkProgram(K), z[Y] = {
              program: K,
              transaction: function(me) {
                C.useProgram(K), me({
                  setUniform: function(de, qe) {
                    for (var le = [], Ne = arguments.length - 2; Ne-- > 0; )
                      le[Ne] = arguments[Ne + 2];
                    var ye = fe[qe] || (fe[qe] = C.getUniformLocation(K, qe));
                    C["uniform" + de].apply(C, [ye].concat(le));
                  },
                  setAttribute: function(de, qe, le, Ne, ye) {
                    var Te = he[de];
                    Te || (Te = he[de] = {
                      buf: C.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: C.getAttribLocation(K, de),
                      data: null
                    }), C.bindBuffer(C.ARRAY_BUFFER, Te.buf), C.vertexAttribPointer(Te.loc, qe, C.FLOAT, !1, 0, 0), C.enableVertexAttribArray(Te.loc), I ? C.vertexAttribDivisor(Te.loc, Ne) : ie("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Te.loc, Ne), ye !== Te.data && (C.bufferData(C.ARRAY_BUFFER, ye, le), Te.data = ye);
                  }
                });
              }
            };
          }
          z[Y].transaction(ne);
        }, F = function(Y, ee) {
          W++;
          try {
            C.activeTexture(C.TEXTURE0 + W);
            var pe = Q[Y];
            pe || (pe = Q[Y] = C.createTexture(), C.bindTexture(C.TEXTURE_2D, pe), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MIN_FILTER, C.NEAREST), C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MAG_FILTER, C.NEAREST)), C.bindTexture(C.TEXTURE_2D, pe), ee(pe, W);
          } finally {
            W--;
          }
        }, te = function(Y, ee, pe) {
          var ne = C.createFramebuffer();
          q.push(ne), C.bindFramebuffer(C.FRAMEBUFFER, ne), C.activeTexture(C.TEXTURE0 + ee), C.bindTexture(C.TEXTURE_2D, Y), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_2D, Y, 0);
          try {
            pe(ne);
          } finally {
            C.deleteFramebuffer(ne), C.bindFramebuffer(C.FRAMEBUFFER, q[--q.length - 1] || null);
          }
        }, Z = function() {
          k = {}, z = {}, Q = {}, W = -1, q.length = 0;
        };
        var I = typeof WebGL2RenderingContext < "u" && C instanceof WebGL2RenderingContext, k = {}, z = {}, Q = {}, W = -1, q = [];
        C.canvas.addEventListener("webglcontextlost", function(Y) {
          Z(), Y.preventDefault();
        }, !1), a.set(C, O = {
          gl: C,
          isWebGL2: I,
          getExtension: ie,
          withProgram: $,
          withTexture: F,
          withTextureFramebuffer: te,
          handleContextLoss: Z
        });
      }
      X(O);
    }
    function h(H, X, C, O, I, k, z, Q) {
      z === void 0 && (z = 15), Q === void 0 && (Q = null), u(H, function(W) {
        var q = W.gl, ie = W.withProgram, ae = W.withTexture;
        ae("copy", function($, F) {
          q.texImage2D(q.TEXTURE_2D, 0, q.RGBA, I, k, 0, q.RGBA, q.UNSIGNED_BYTE, X), ie("copy", o, i, function(te) {
            var Z = te.setUniform, Y = te.setAttribute;
            Y("aUV", 2, q.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", F), q.bindFramebuffer(q.FRAMEBUFFER, Q || null), q.disable(q.BLEND), q.colorMask(z & 8, z & 4, z & 2, z & 1), q.viewport(C, O, I, k), q.scissor(C, O, I, k), q.drawArrays(q.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(H, X, C) {
      var O = H.width, I = H.height;
      u(H, function(k) {
        var z = k.gl, Q = new Uint8Array(O * I * 4);
        z.readPixels(0, 0, O, I, z.RGBA, z.UNSIGNED_BYTE, Q), H.width = X, H.height = C, h(z, Q, 0, 0, O, I);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function p(H, X, C, O, I, k) {
      k === void 0 && (k = 1);
      var z = new Uint8Array(H * X), Q = O[2] - O[0], W = O[3] - O[1], q = [];
      s(C, function(Y, ee, pe, ne) {
        q.push({
          x1: Y,
          y1: ee,
          x2: pe,
          y2: ne,
          minX: Math.min(Y, pe),
          minY: Math.min(ee, ne),
          maxX: Math.max(Y, pe),
          maxY: Math.max(ee, ne)
        });
      }), q.sort(function(Y, ee) {
        return Y.maxX - ee.maxX;
      });
      for (var ie = 0; ie < H; ie++)
        for (var ae = 0; ae < X; ae++) {
          var $ = te(
            O[0] + Q * (ie + 0.5) / H,
            O[1] + W * (ae + 0.5) / X
          ), F = Math.pow(1 - Math.abs($) / I, k) / 2;
          $ < 0 && (F = 1 - F), F = Math.max(0, Math.min(255, Math.round(F * 255))), z[ae * H + ie] = F;
        }
      return z;
      function te(Y, ee) {
        for (var pe = 1 / 0, ne = 1 / 0, he = q.length; he--; ) {
          var fe = q[he];
          if (fe.maxX + ne <= Y)
            break;
          if (Y + ne > fe.minX && ee - ne < fe.maxY && ee + ne > fe.minY) {
            var K = b(Y, ee, fe.x1, fe.y1, fe.x2, fe.y2);
            K < pe && (pe = K, ne = Math.sqrt(pe));
          }
        }
        return Z(Y, ee) && (ne = -ne), ne;
      }
      function Z(Y, ee) {
        for (var pe = 0, ne = q.length; ne--; ) {
          var he = q[ne];
          if (he.maxX <= Y)
            break;
          var fe = he.y1 > ee != he.y2 > ee && Y < (he.x2 - he.x1) * (ee - he.y1) / (he.y2 - he.y1) + he.x1;
          fe && (pe += he.y1 < he.y2 ? 1 : -1);
        }
        return pe !== 0;
      }
    }
    function m(H, X, C, O, I, k, z, Q, W, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0), g(H, X, C, O, I, k, z, null, Q, W, q);
    }
    function g(H, X, C, O, I, k, z, Q, W, q, ie) {
      k === void 0 && (k = 1), W === void 0 && (W = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0);
      for (var ae = p(H, X, C, O, I, k), $ = new Uint8Array(ae.length * 4), F = 0; F < ae.length; F++)
        $[F * 4 + ie] = ae[F];
      h(z, $, W, q, H, X, 1 << 3 - ie, Q);
    }
    function b(H, X, C, O, I, k) {
      var z = I - C, Q = k - O, W = z * z + Q * Q, q = W ? Math.max(0, Math.min(1, ((H - C) * z + (X - O) * Q) / W)) : 0, ie = H - (C + q * z), ae = X - (O + q * Q);
      return ie * ie + ae * ae;
    }
    var v = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: p,
      generateIntoCanvas: m,
      generateIntoFramebuffer: g
    }), y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", N = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", w = new Float32Array([0, 0, 2, 0, 0, 2]), T = null, _ = !1, L = {}, A = /* @__PURE__ */ new WeakMap();
    function U(H) {
      if (!_ && !D(H))
        throw new Error("WebGL generation not supported");
    }
    function S(H, X, C, O, I, k, z) {
      if (k === void 0 && (k = 1), z === void 0 && (z = null), !z && (z = T, !z)) {
        var Q = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Q)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        z = T = Q.getContext("webgl", { depth: !1 });
      }
      U(z);
      var W = new Uint8Array(H * X * 4);
      u(z, function($) {
        var F = $.gl, te = $.withTexture, Z = $.withTextureFramebuffer;
        te("readable", function(Y, ee) {
          F.texImage2D(F.TEXTURE_2D, 0, F.RGBA, H, X, 0, F.RGBA, F.UNSIGNED_BYTE, null), Z(Y, ee, function(pe) {
            E(
              H,
              X,
              C,
              O,
              I,
              k,
              F,
              pe,
              0,
              0,
              0
              // red channel
            ), F.readPixels(0, 0, H, X, F.RGBA, F.UNSIGNED_BYTE, W);
          });
        });
      });
      for (var q = new Uint8Array(H * X), ie = 0, ae = 0; ie < W.length; ie += 4)
        q[ae++] = W[ie];
      return q;
    }
    function R(H, X, C, O, I, k, z, Q, W, q) {
      k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0), E(H, X, C, O, I, k, z, null, Q, W, q);
    }
    function E(H, X, C, O, I, k, z, Q, W, q, ie) {
      k === void 0 && (k = 1), W === void 0 && (W = 0), q === void 0 && (q = 0), ie === void 0 && (ie = 0), U(z);
      var ae = [];
      s(C, function($, F, te, Z) {
        ae.push($, F, te, Z);
      }), ae = new Float32Array(ae), u(z, function($) {
        var F = $.gl, te = $.isWebGL2, Z = $.getExtension, Y = $.withProgram, ee = $.withTexture, pe = $.withTextureFramebuffer, ne = $.handleContextLoss;
        if (ee("rawDistances", function(he, fe) {
          (H !== he._lastWidth || X !== he._lastHeight) && F.texImage2D(
            F.TEXTURE_2D,
            0,
            F.RGBA,
            he._lastWidth = H,
            he._lastHeight = X,
            0,
            F.RGBA,
            F.UNSIGNED_BYTE,
            null
          ), Y("main", y, x, function(K) {
            var Ae = K.setAttribute, me = K.setUniform, be = !te && Z("ANGLE_instanced_arrays"), de = !te && Z("EXT_blend_minmax");
            Ae("aUV", 2, F.STATIC_DRAW, 0, w), Ae("aLineSegment", 4, F.DYNAMIC_DRAW, 1, ae), me.apply(void 0, ["4f", "uGlyphBounds"].concat(O)), me("1f", "uMaxDistance", I), me("1f", "uExponent", k), pe(he, fe, function(qe) {
              F.enable(F.BLEND), F.colorMask(!0, !0, !0, !0), F.viewport(0, 0, H, X), F.scissor(0, 0, H, X), F.blendFunc(F.ONE, F.ONE), F.blendEquationSeparate(F.FUNC_ADD, te ? F.MAX : de.MAX_EXT), F.clear(F.COLOR_BUFFER_BIT), te ? F.drawArraysInstanced(F.TRIANGLES, 0, 3, ae.length / 4) : be.drawArraysInstancedANGLE(F.TRIANGLES, 0, 3, ae.length / 4);
            });
          }), Y("post", o, N, function(K) {
            K.setAttribute("aUV", 2, F.STATIC_DRAW, 0, w), K.setUniform("1i", "tex", fe), F.bindFramebuffer(F.FRAMEBUFFER, Q), F.disable(F.BLEND), F.colorMask(ie === 0, ie === 1, ie === 2, ie === 3), F.viewport(W, q, H, X), F.scissor(W, q, H, X), F.drawArrays(F.TRIANGLES, 0, 3);
          });
        }), F.isContextLost())
          throw ne(), new Error("webgl context lost");
      });
    }
    function D(H) {
      var X = !H || H === T ? L : H.canvas || H, C = A.get(X);
      if (C === void 0) {
        _ = !0;
        var O = null;
        try {
          var I = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], k = S(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            H
          );
          C = k && I.length === k.length && k.every(function(z, Q) {
            return z === I[Q];
          }), C || (O = "bad trial run results", console.info(I, k));
        } catch (z) {
          C = !1, O = z.message;
        }
        O && console.warn("WebGL SDF generation not supported:", O), _ = !1, A.set(X, C);
      }
      return C;
    }
    var P = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: S,
      generateIntoCanvas: R,
      generateIntoFramebuffer: E,
      isSupported: D
    });
    function se(H, X, C, O, I, k) {
      I === void 0 && (I = Math.max(O[2] - O[0], O[3] - O[1]) / 2), k === void 0 && (k = 1);
      try {
        return S.apply(P, arguments);
      } catch (z) {
        return console.info("WebGL SDF generation failed, falling back to JS", z), p.apply(v, arguments);
      }
    }
    function oe(H, X, C, O, I, k, z, Q, W, q) {
      I === void 0 && (I = Math.max(O[2] - O[0], O[3] - O[1]) / 2), k === void 0 && (k = 1), Q === void 0 && (Q = 0), W === void 0 && (W = 0), q === void 0 && (q = 0);
      try {
        return R.apply(P, arguments);
      } catch (ie) {
        return console.info("WebGL SDF generation failed, falling back to JS", ie), m.apply(v, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = se, e.generateIntoCanvas = oe, e.javascript = v, e.pathToLineSegments = s, e.webgl = P, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
function J1() {
  var c = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, n = {};
    r.L = 1, n[1] = "L", Object.keys(t).forEach(function(ne, he) {
      r[ne] = 1 << he + 1, n[r[ne]] = ne;
    }), Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI, o = r.L | r.R | r.AL, i = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, a = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, l = r.S | r.WS | r.B | s | r.PDI | a, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var ne = function(fe) {
          if (t.hasOwnProperty(fe)) {
            var K = 0;
            t[fe].split(",").forEach(function(Ae) {
              var me = Ae.split("+"), be = me[0], de = me[1];
              be = parseInt(be, 36), de = de ? parseInt(de, 36) : 0, u.set(K += be, r[fe]);
              for (var qe = 0; qe < de; qe++)
                u.set(++K, r[fe]);
            });
          }
        };
        for (var he in t)
          ne(he);
      }
    }
    function d(ne) {
      return h(), u.get(ne.codePointAt(0)) || r.L;
    }
    function f(ne) {
      return n[d(ne)];
    }
    var p = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(ne, he) {
      var fe = 36, K = 0, Ae = /* @__PURE__ */ new Map(), me = he && /* @__PURE__ */ new Map(), be;
      return ne.split(",").forEach(function de(qe) {
        if (qe.indexOf("+") !== -1)
          for (var le = +qe; le--; )
            de(be);
        else {
          be = qe;
          var Ne = qe.split(">"), ye = Ne[0], Te = Ne[1];
          ye = String.fromCodePoint(K += parseInt(ye, fe)), Te = String.fromCodePoint(K += parseInt(Te, fe)), Ae.set(ye, Te), he && me.set(Te, ye);
        }
      }), { map: Ae, reverseMap: me };
    }
    var g, b, v;
    function y() {
      if (!g) {
        var ne = m(p.pairs, !0), he = ne.map, fe = ne.reverseMap;
        g = he, b = fe, v = m(p.canonical, !1).map;
      }
    }
    function x(ne) {
      return y(), g.get(ne) || null;
    }
    function N(ne) {
      return y(), b.get(ne) || null;
    }
    function w(ne) {
      return y(), v.get(ne) || null;
    }
    var T = r.L, _ = r.R, L = r.EN, A = r.ES, U = r.ET, S = r.AN, R = r.CS, E = r.B, D = r.S, P = r.ON, se = r.BN, oe = r.NSM, H = r.AL, X = r.LRO, C = r.RLO, O = r.LRE, I = r.RLE, k = r.PDF, z = r.LRI, Q = r.RLI, W = r.FSI, q = r.PDI;
    function ie(ne, he) {
      for (var fe = 125, K = new Uint32Array(ne.length), Ae = 0; Ae < ne.length; Ae++)
        K[Ae] = d(ne[Ae]);
      var me = /* @__PURE__ */ new Map();
      function be(hn, Wn) {
        var dn = K[hn];
        K[hn] = Wn, me.set(dn, me.get(dn) - 1), dn & i && me.set(i, me.get(i) - 1), me.set(Wn, (me.get(Wn) || 0) + 1), Wn & i && me.set(i, (me.get(i) || 0) + 1);
      }
      for (var de = new Uint8Array(ne.length), qe = /* @__PURE__ */ new Map(), le = [], Ne = null, ye = 0; ye < ne.length; ye++)
        Ne || le.push(Ne = {
          start: ye,
          end: ne.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: he === "rtl" ? 1 : he === "ltr" ? 0 : Gf(ye, !1)
        }), K[ye] & E && (Ne.end = ye, Ne = null);
      for (var Te = I | O | C | X | s | q | k | E, Pe = function(hn) {
        return hn + (hn & 1 ? 1 : 2);
      }, Je = function(hn) {
        return hn + (hn & 1 ? 2 : 1);
      }, _e = 0; _e < le.length; _e++) {
        Ne = le[_e];
        var Ue = [{
          _level: Ne.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], ge = void 0, We = 0, $e = 0, ht = 0;
        me.clear();
        for (var Qe = Ne.start; Qe <= Ne.end; Qe++) {
          var xe = K[Qe];
          if (ge = Ue[Ue.length - 1], me.set(xe, (me.get(xe) || 0) + 1), xe & i && me.set(i, (me.get(i) || 0) + 1), xe & Te)
            if (xe & (I | O)) {
              de[Qe] = ge._level;
              var Oe = (xe === I ? Je : Pe)(ge._level);
              Oe <= fe && !We && !$e ? Ue.push({
                _level: Oe,
                _override: 0,
                _isolate: 0
              }) : We || $e++;
            } else if (xe & (C | X)) {
              de[Qe] = ge._level;
              var zt = (xe === C ? Je : Pe)(ge._level);
              zt <= fe && !We && !$e ? Ue.push({
                _level: zt,
                _override: xe & C ? _ : T,
                _isolate: 0
              }) : We || $e++;
            } else if (xe & s) {
              xe & W && (xe = Gf(Qe + 1, !0) === 1 ? Q : z), de[Qe] = ge._level, ge._override && be(Qe, ge._override);
              var Ee = (xe === Q ? Je : Pe)(ge._level);
              Ee <= fe && We === 0 && $e === 0 ? (ht++, Ue.push({
                _level: Ee,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Qe
              })) : We++;
            } else if (xe & q) {
              if (We > 0)
                We--;
              else if (ht > 0) {
                for ($e = 0; !Ue[Ue.length - 1]._isolate; )
                  Ue.pop();
                var Le = Ue[Ue.length - 1]._isolInitIndex;
                Le != null && (qe.set(Le, Qe), qe.set(Qe, Le)), Ue.pop(), ht--;
              }
              ge = Ue[Ue.length - 1], de[Qe] = ge._level, ge._override && be(Qe, ge._override);
            } else
              xe & k ? (We === 0 && ($e > 0 ? $e-- : !ge._isolate && Ue.length > 1 && (Ue.pop(), ge = Ue[Ue.length - 1])), de[Qe] = ge._level) : xe & E && (de[Qe] = Ne.level);
          else
            de[Qe] = ge._level, ge._override && xe !== se && be(Qe, ge._override);
        }
        for (var tt = [], De = null, we = Ne.start; we <= Ne.end; we++) {
          var He = K[we];
          if (!(He & a)) {
            var yt = de[we], at = He & s, ot = He === q;
            De && yt === De._level ? (De._end = we, De._endsWithIsolInit = at) : tt.push(De = {
              _start: we,
              _end: we,
              _level: yt,
              _startsWithPDI: ot,
              _endsWithIsolInit: at
            });
          }
        }
        for (var Ot = [], Fn = 0; Fn < tt.length; Fn++) {
          var ln = tt[Fn];
          if (!ln._startsWithPDI || ln._startsWithPDI && !qe.has(ln._start)) {
            for (var Nn = [De = ln], On = void 0; De && De._endsWithIsolInit && (On = qe.get(De._end)) != null; )
              for (var un = Fn + 1; un < tt.length; un++)
                if (tt[un]._start === On) {
                  Nn.push(De = tt[un]);
                  break;
                }
            for (var vt = [], Vn = 0; Vn < Nn.length; Vn++)
              for (var Nf = Nn[Vn], Rc = Nf._start; Rc <= Nf._end; Rc++)
                vt.push(Rc);
            for (var Wx = de[vt[0]], wf = Ne.level, Ri = vt[0] - 1; Ri >= 0; Ri--)
              if (!(K[Ri] & a)) {
                wf = de[Ri];
                break;
              }
            var Lc = vt[vt.length - 1], Hx = de[Lc], Tf = Ne.level;
            if (!(K[Lc] & s)) {
              for (var Li = Lc + 1; Li <= Ne.end; Li++)
                if (!(K[Li] & a)) {
                  Tf = de[Li];
                  break;
                }
            }
            Ot.push({
              _seqIndices: vt,
              _sosType: Math.max(wf, Wx) % 2 ? _ : T,
              _eosType: Math.max(Tf, Hx) % 2 ? _ : T
            });
          }
        }
        for (var Fc = 0; Fc < Ot.length; Fc++) {
          var Oc = Ot[Fc], Ie = Oc._seqIndices, To = Oc._sosType, Xx = Oc._eosType, Fr = de[Ie[0]] & 1 ? _ : T;
          if (me.get(oe))
            for (var Fi = 0; Fi < Ie.length; Fi++) {
              var Sf = Ie[Fi];
              if (K[Sf] & oe) {
                for (var Ic = To, Oi = Fi - 1; Oi >= 0; Oi--)
                  if (!(K[Ie[Oi]] & a)) {
                    Ic = K[Ie[Oi]];
                    break;
                  }
                be(Sf, Ic & (s | q) ? P : Ic);
              }
            }
          if (me.get(L))
            for (var Ii = 0; Ii < Ie.length; Ii++) {
              var _f = Ie[Ii];
              if (K[_f] & L)
                for (var Pi = Ii - 1; Pi >= -1; Pi--) {
                  var Mf = Pi === -1 ? To : K[Ie[Pi]];
                  if (Mf & o) {
                    Mf === H && be(_f, S);
                    break;
                  }
                }
            }
          if (me.get(H))
            for (var Pc = 0; Pc < Ie.length; Pc++) {
              var Af = Ie[Pc];
              K[Af] & H && be(Af, _);
            }
          if (me.get(A) || me.get(R))
            for (var So = 1; So < Ie.length - 1; So++) {
              var Dc = Ie[So];
              if (K[Dc] & (A | R)) {
                for (var Or = 0, Uc = 0, zc = So - 1; zc >= 0 && (Or = K[Ie[zc]], !!(Or & a)); zc--)
                  ;
                for (var Bc = So + 1; Bc < Ie.length && (Uc = K[Ie[Bc]], !!(Uc & a)); Bc++)
                  ;
                Or === Uc && (K[Dc] === A ? Or === L : Or & (L | S)) && be(Dc, Or);
              }
            }
          if (me.get(L))
            for (var rs = 0; rs < Ie.length; rs++) {
              var $x = Ie[rs];
              if (K[$x] & L) {
                for (var Di = rs - 1; Di >= 0 && K[Ie[Di]] & (U | a); Di--)
                  be(Ie[Di], L);
                for (rs++; rs < Ie.length && K[Ie[rs]] & (U | a | L); rs++)
                  K[Ie[rs]] !== L && be(Ie[rs], L);
              }
            }
          if (me.get(U) || me.get(A) || me.get(R))
            for (var _o = 0; _o < Ie.length; _o++) {
              var Cf = Ie[_o];
              if (K[Cf] & (U | A | R)) {
                be(Cf, P);
                for (var Ui = _o - 1; Ui >= 0 && K[Ie[Ui]] & a; Ui--)
                  be(Ie[Ui], P);
                for (var zi = _o + 1; zi < Ie.length && K[Ie[zi]] & a; zi++)
                  be(Ie[zi], P);
              }
            }
          if (me.get(L))
            for (var kc = 0, Ef = To; kc < Ie.length; kc++) {
              var Rf = Ie[kc], Gc = K[Rf];
              Gc & L ? Ef === T && be(Rf, T) : Gc & o && (Ef = Gc);
            }
          if (me.get(i)) {
            var Mo = _ | L | S, Lf = Mo | T, Bi = [];
            {
              for (var Ir = [], Pr = 0; Pr < Ie.length; Pr++)
                if (K[Ie[Pr]] & i) {
                  var Ao = ne[Ie[Pr]], Ff = void 0;
                  if (x(Ao) !== null)
                    if (Ir.length < 63)
                      Ir.push({ char: Ao, seqIndex: Pr });
                    else
                      break;
                  else if ((Ff = N(Ao)) !== null)
                    for (var Co = Ir.length - 1; Co >= 0; Co--) {
                      var Vc = Ir[Co].char;
                      if (Vc === Ff || Vc === N(w(Ao)) || x(w(Vc)) === Ao) {
                        Bi.push([Ir[Co].seqIndex, Pr]), Ir.length = Co;
                        break;
                      }
                    }
                }
              Bi.sort(function(hn, Wn) {
                return hn[0] - Wn[0];
              });
            }
            for (var jc = 0; jc < Bi.length; jc++) {
              for (var Of = Bi[jc], ki = Of[0], Wc = Of[1], If = !1, jn = 0, Hc = ki + 1; Hc < Wc; Hc++) {
                var Pf = Ie[Hc];
                if (K[Pf] & Lf) {
                  If = !0;
                  var Df = K[Pf] & Mo ? _ : T;
                  if (Df === Fr) {
                    jn = Df;
                    break;
                  }
                }
              }
              if (If && !jn) {
                jn = To;
                for (var Xc = ki - 1; Xc >= 0; Xc--) {
                  var Uf = Ie[Xc];
                  if (K[Uf] & Lf) {
                    var zf = K[Uf] & Mo ? _ : T;
                    zf !== Fr ? jn = zf : jn = Fr;
                    break;
                  }
                }
              }
              if (jn) {
                if (K[Ie[ki]] = K[Ie[Wc]] = jn, jn !== Fr) {
                  for (var Eo = ki + 1; Eo < Ie.length; Eo++)
                    if (!(K[Ie[Eo]] & a)) {
                      d(ne[Ie[Eo]]) & oe && (K[Ie[Eo]] = jn);
                      break;
                    }
                }
                if (jn !== Fr) {
                  for (var Ro = Wc + 1; Ro < Ie.length; Ro++)
                    if (!(K[Ie[Ro]] & a)) {
                      d(ne[Ie[Ro]]) & oe && (K[Ie[Ro]] = jn);
                      break;
                    }
                }
              }
            }
            for (var Rs = 0; Rs < Ie.length; Rs++)
              if (K[Ie[Rs]] & i) {
                for (var Bf = Rs, $c = Rs, qc = To, Lo = Rs - 1; Lo >= 0; Lo--)
                  if (K[Ie[Lo]] & a)
                    Bf = Lo;
                  else {
                    qc = K[Ie[Lo]] & Mo ? _ : T;
                    break;
                  }
                for (var kf = Xx, Fo = Rs + 1; Fo < Ie.length; Fo++)
                  if (K[Ie[Fo]] & (i | a))
                    $c = Fo;
                  else {
                    kf = K[Ie[Fo]] & Mo ? _ : T;
                    break;
                  }
                for (var Jc = Bf; Jc <= $c; Jc++)
                  K[Ie[Jc]] = qc === kf ? qc : Fr;
                Rs = $c;
              }
          }
        }
        for (var wn = Ne.start; wn <= Ne.end; wn++) {
          var qx = de[wn], Gi = K[wn];
          if (qx & 1 ? Gi & (T | L | S) && de[wn]++ : Gi & _ ? de[wn]++ : Gi & (S | L) && (de[wn] += 2), Gi & a && (de[wn] = wn === 0 ? Ne.level : de[wn - 1]), wn === Ne.end || d(ne[wn]) & (D | E))
            for (var Vi = wn; Vi >= 0 && d(ne[Vi]) & l; Vi--)
              de[Vi] = Ne.level;
        }
      }
      return {
        levels: de,
        paragraphs: le
      };
      function Gf(hn, Wn) {
        for (var dn = hn; dn < ne.length; dn++) {
          var Ls = K[dn];
          if (Ls & (_ | H))
            return 1;
          if (Ls & (E | T) || Wn && Ls === q)
            return 0;
          if (Ls & s) {
            var Vf = Jx(dn);
            dn = Vf === -1 ? ne.length : Vf;
          }
        }
        return 0;
      }
      function Jx(hn) {
        for (var Wn = 1, dn = hn + 1; dn < ne.length; dn++) {
          var Ls = K[dn];
          if (Ls & E)
            break;
          if (Ls & q) {
            if (--Wn === 0)
              return dn;
          } else
            Ls & s && Wn++;
        }
        return -1;
      }
    }
    var ae = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", $;
    function F() {
      if (!$) {
        var ne = m(ae, !0), he = ne.map, fe = ne.reverseMap;
        fe.forEach(function(K, Ae) {
          he.set(Ae, K);
        }), $ = he;
      }
    }
    function te(ne) {
      return F(), $.get(ne) || null;
    }
    function Z(ne, he, fe, K) {
      var Ae = ne.length;
      fe = Math.max(0, fe == null ? 0 : +fe), K = Math.min(Ae - 1, K == null ? Ae - 1 : +K);
      for (var me = /* @__PURE__ */ new Map(), be = fe; be <= K; be++)
        if (he[be] & 1) {
          var de = te(ne[be]);
          de !== null && me.set(be, de);
        }
      return me;
    }
    function Y(ne, he, fe, K) {
      var Ae = ne.length;
      fe = Math.max(0, fe == null ? 0 : +fe), K = Math.min(Ae - 1, K == null ? Ae - 1 : +K);
      var me = [];
      return he.paragraphs.forEach(function(be) {
        var de = Math.max(fe, be.start), qe = Math.min(K, be.end);
        if (de < qe) {
          for (var le = he.levels.slice(de, qe + 1), Ne = qe; Ne >= de && d(ne[Ne]) & l; Ne--)
            le[Ne] = be.level;
          for (var ye = be.level, Te = 1 / 0, Pe = 0; Pe < le.length; Pe++) {
            var Je = le[Pe];
            Je > ye && (ye = Je), Je < Te && (Te = Je | 1);
          }
          for (var _e = ye; _e >= Te; _e--)
            for (var Ue = 0; Ue < le.length; Ue++)
              if (le[Ue] >= _e) {
                for (var ge = Ue; Ue + 1 < le.length && le[Ue + 1] >= _e; )
                  Ue++;
                Ue > ge && me.push([ge + de, Ue + de]);
              }
        }
      }), me;
    }
    function ee(ne, he, fe, K) {
      var Ae = pe(ne, he, fe, K), me = [].concat(ne);
      return Ae.forEach(function(be, de) {
        me[de] = (he.levels[be] & 1 ? te(ne[be]) : null) || ne[be];
      }), me.join("");
    }
    function pe(ne, he, fe, K) {
      for (var Ae = Y(ne, he, fe, K), me = [], be = 0; be < ne.length; be++)
        me[be] = be;
      return Ae.forEach(function(de) {
        for (var qe = de[0], le = de[1], Ne = me.slice(qe, le + 1), ye = Ne.length; ye--; )
          me[le - ye] = Ne[ye];
      }), me;
    }
    return e.closingToOpeningBracket = N, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = w, e.getEmbeddingLevels = ie, e.getMirroredCharacter = te, e.getMirroredCharactersMap = Z, e.getReorderSegments = Y, e.getReorderedIndices = pe, e.getReorderedString = ee, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return c;
}
const Y1 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function su(c) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, n) {
    let s = Lm[n];
    return s ? su(s) : r;
  }
  return c.replace(e, t);
}
const Ht = [];
for (let c = 0; c < 256; c++)
  Ht[c] = (c < 16 ? "0" : "") + c.toString(16);
function M_() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Ht[c & 255] + Ht[c >> 8 & 255] + Ht[c >> 16 & 255] + Ht[c >> 24 & 255] + "-" + Ht[e & 255] + Ht[e >> 8 & 255] + "-" + Ht[e >> 16 & 15 | 64] + Ht[e >> 24 & 255] + "-" + Ht[t & 63 | 128] + Ht[t >> 8 & 255] + "-" + Ht[t >> 16 & 255] + Ht[t >> 24 & 255] + Ht[r & 255] + Ht[r >> 8 & 255] + Ht[r >> 16 & 255] + Ht[r >> 24 & 255]).toUpperCase();
}
const ir = Object.assign || function() {
  let c = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (c[n] = r[n]);
  }
  return c;
}, A_ = Date.now(), Tp = /* @__PURE__ */ new WeakMap(), Sp = /* @__PURE__ */ new Map();
let C_ = 1e10;
function ru(c, e) {
  const t = F_(e);
  let r = Tp.get(c);
  if (r || Tp.set(c, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const n = `_onBeforeCompile${t}`, s = function(l, u) {
    c.onBeforeCompile.call(this, l, u);
    const h = this.customProgramCacheKey() + "|" + l.vertexShader + "|" + l.fragmentShader;
    let d = Sp[h];
    if (!d) {
      const f = E_(this, l, e, t);
      d = Sp[h] = f;
    }
    l.vertexShader = d.vertexShader, l.fragmentShader = d.fragmentShader, ir(l.uniforms, this.uniforms), e.timeUniform && (l.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - A_;
      }
    }), this[n] && this[n](l);
  }, o = function() {
    return i(e.chained ? c : c.clone());
  }, i = function(l) {
    const u = Object.create(l, a);
    return Object.defineProperty(u, "baseMaterial", { value: c }), Object.defineProperty(u, "id", { value: C_++ }), u.uuid = M_(), u.uniforms = ir({}, l.uniforms, e.uniforms), u.defines = ir({}, l.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = ir({}, l.extensions, e.extensions), u._listeners = void 0, u;
  }, a = {
    constructor: { value: o },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return c.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(l) {
        this[n] = l;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(l) {
        return c.copy.call(this, l), !c.isShaderMaterial && !c.isDerivedMaterial && (ir(this.extensions, l.extensions), ir(this.defines, l.defines), ir(this.uniforms, tr.clone(l.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const l = new c.constructor();
        return i(l).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._depthMaterial;
        return l || (l = this._depthMaterial = ru(
          c.isDerivedMaterial ? c.getDepthMaterial() : new Mb({ depthPacking: Ab }),
          e
        ), l.defines.IS_DEPTH_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._distanceMaterial;
        return l || (l = this._distanceMaterial = ru(
          c.isDerivedMaterial ? c.getDistanceMaterial() : new Cb(),
          e
        ), l.defines.IS_DISTANCE_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: l, _distanceMaterial: u } = this;
        l && l.dispose(), u && u.dispose(), c.dispose.call(this);
      }
    }
  };
  return r[t] = o, new o();
}
function E_(c, { vertexShader: e, fragmentShader: t }, r, n) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: i,
    vertexTransform: a,
    fragmentDefs: l,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: p
  } = r;
  if (s = s || "", o = o || "", i = i || "", l = l || "", u = u || "", h = h || "", (a || f) && (e = su(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = su(t)), f) {
    let m = f({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (d) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (m.push(g), "")
    ), h = `${d}
${m.join(`
`)}
${h}`;
  }
  if (p) {
    const m = `
uniform float ${p};
`;
    s = m + s, l = m + l;
  }
  return a && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, s = `${s}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${a}
}
`, o = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, g, b, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, b)) ? g : `troika_${g}_${n}`), c.map && c.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = _p(e, n, s, o, i), t = _p(t, n, l, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function _p(c, e, t, r, n) {
  return (r || n || t) && (c = c.replace(
    Y1,
    `
${t}
void troikaOrigMain${e}() {`
  ), c += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${n}
}`), c;
}
function R_(c, e) {
  return c === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let L_ = 0;
const Mp = /* @__PURE__ */ new Map();
function F_(c) {
  const e = JSON.stringify(c, R_);
  let t = Mp.get(e);
  return t == null && Mp.set(e, t = ++L_), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function O_() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var L = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < L; b++) {
            var U = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), U.push({ val1: S, val2: R });
            }
            u.matrix.push(U);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var L = n.kern.rval[_].glyph2.indexOf(o);
          if (L != -1)
            return n.kern.rval[_].vals[L];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var L = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[L + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var U = h.lookupRec;
              for (w = 0; w < U.length; w += 2) {
                y = U[w];
                var S = i[U[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, L = 0, A = 0, U = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, U);
        var S = U.val;
        if (p += U.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", D = 0; D < R; D++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (L = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (L = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), O = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[O], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var W = l.length, q = (se = 0, S == "o31");
            for (se += W - (R = -3 & W); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function I_() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = R += 1 << S[D - 1];
      var P = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var se = E[D]; se < E[D + 1]; ++se)
          P[se] = se - E[D] << 5 | D;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var D = S.length, P = 0, se = new t(R); P < D; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < D; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], O = R - S[P], I = H[S[P] - 1]++ << O, k = I | (1 << O) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(D), P = 0; P < D; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var D = R / 8 | 0;
      return (S[D] | S[D + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var D = new Error(R || T[S]);
      if (D.code = S, Error.captureStackTrace && Error.captureStackTrace(D, _), !E)
        throw D;
      return D;
    }, L = function(S, R, E) {
      var D = S.length;
      if (!D || E && !E.l && D < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * D));
      var oe, H = function(ge) {
        var We = R.length;
        if (ge > We) {
          var $e = new e(Math.max(2 * We, ge));
          $e.set(R), R = $e;
        }
      }, X = E.f || 0, C = E.p || 0, O = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, W = 8 * D;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(fe = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[fe - 3] << 8, ae = fe + ie;
            if (ae > D) {
              se && _(0);
              break;
            }
            P && H(O + ie), R.set(S.subarray(fe, ae), O), E.b = O += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, F = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < F; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * F;
            var pe = x(Y), ne = (1 << pe) - 1, he = m(Y, pe, 1);
            for (ee = 0; ee < te; ) {
              var fe, K = he[N(S, C, ne)];
              if (C += 15 & K, (fe = K >>> 4) < 16)
                Z[ee++] = fe;
              else {
                var Ae = 0, me = 0;
                for (fe == 16 ? (me = 3 + N(S, C, 3), C += 2, Ae = Z[ee - 1]) : fe == 17 ? (me = 3 + N(S, C, 7), C += 3) : fe == 18 && (me = 11 + N(S, C, 127), C += 7); me--; )
                  Z[ee++] = Ae;
              }
            }
            var be = Z.subarray(0, $), de = Z.subarray($);
            z = x(be), Q = x(de), I = m(be, z, 1), k = m(de, Q, 1);
          } else
            _(1);
          if (C > W) {
            se && _(0);
            break;
          }
        }
        P && H(O + 131072);
        for (var qe = (1 << z) - 1, le = (1 << Q) - 1, Ne = C; ; Ne = C) {
          var ye = (Ae = I[w(S, C) & qe]) >>> 4;
          if ((C += 15 & Ae) > W) {
            se && _(0);
            break;
          }
          if (Ae || _(2), ye < 256)
            R[O++] = ye;
          else {
            if (ye == 256) {
              Ne = C, I = null;
              break;
            }
            var Te = ye - 254;
            if (ye > 264) {
              var Pe = n[ee = ye - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var Je = k[w(S, C) & le], _e = Je >>> 4;
            if (Je || _(3), C += 15 & Je, de = h[_e], _e > 3 && (Pe = s[_e], de += w(S, C) & (1 << Pe) - 1, C += Pe), C > W) {
              se && _(0);
              break;
            }
            P && H(O + 131072);
            for (var Ue = O + Te; O < Ue; O += 4)
              R[O] = R[O - de], R[O + 1] = R[O + 1 - de], R[O + 2] = R[O + 2 - de], R[O + 3] = R[O + 3 - de];
            O = Ue;
          }
        }
        E.l = I, E.p = Ne, E.b = O, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return O == R.length ? R : function(ge, We, $e) {
        (We == null || We < 0) && (We = 0), ($e == null || $e > ge.length) && ($e = ge.length);
        var ht = new (ge instanceof t ? t : ge instanceof r ? r : e)($e - We);
        return ht.set(ge.subarray(We, $e)), ht;
      }(R, 0, O);
    }, A = new e(0), U = typeof TextDecoder < "u" && new TextDecoder();
    try {
      U.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function D() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: D(), reserved: D(), totalSfntSize: P(), majorVersion: D(), minorVersion: D(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), O = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, W = new Uint8Array(12 + 16 * k.length + k.reduce(function($, F) {
        return $ + F.origLength + 4;
      }, 0)), q = W.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(O), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var F, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          F = new Uint8Array(te, 2), L(F, Z);
        } else
          Z = new Uint8Array(te);
        W.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), W.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function P_(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((L) => {
          let [A, U] = L.split("+");
          A = parseInt(A, 36), U = U ? parseInt(U, 36) : 0, u.set(_ += A, w[T]);
          for (let S = U; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, L = -1;
    for (let A = 0; A < N.length; A++) {
      const U = N.codePointAt(A);
      let S = h(U) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[L]++) : S & (n | l) && (_ === f || _ === m) && w[L]-- : T & (s | l) && (_ === f || _ === m) && w[L]--, _ = w[A] = R, T = S, L = A, U > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let L = 0; L < w.length; L++) {
      const A = w.codePointAt(L);
      A > 65535 && L++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: L, featureList: A } = _;
      let U;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (R[E.tab[D]])
              continue;
            R[E.tab[D]] = !0;
            const P = L[E.tab[D]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !U && (U = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!U || !se || g[U[oe]] === E.tag) && c.U._applySubs(T, oe, P, L);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, L = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, L), U = {
      unitsPerEm: L,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, D) {
        let P = 0;
        const se = 1 / U.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, O) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", W = 0;
              for (let F = 0, te = k.length; F < te; F++) {
                const Z = t[k[F]];
                Q += k[F];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[W++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let F = 0, te = z.length; F < te; F += 2) {
                  let Z = z[F], Y = z[F + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), D.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return U;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const D_ = /* @__PURE__ */ fs({
  name: "Typr Font Parser",
  dependencies: [O_, I_, P_],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function U_() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var L = x.weight;
      L === void 0 && (L = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), U = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, D = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var O = m.get(C);
        return O || (O = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, O)), O;
      }
      for (var H = function(C) {
        var O = y.codePointAt(C), I = s(O);
        D[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), O > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[D[I]], W = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in W = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== W) {
                  for (var F in Q[$])
                    if (o(k, Q[$][F])) {
                      z = F;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), D[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, O = I);
        }, O = 0; O < y.length; O++)
          C(O);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, O = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (O && (v(k) || f(O).has(k)))
            S[I] = S[I - 1];
          else {
            O = u[D[I]];
            var z = R[O.id];
            if (!z) {
              var Q = O.typeforms, W = g(Q, T, "sans-serif"), q = g(Q[W], _, "normal"), ie = b((C = Q[W]) === null || C === void 0 ? void 0 : C[q], L);
              z = R[O.id] = A + "/font-files/" + O.id + "/" + W + "." + q + "." + ie + ".woff";
            }
            var ae = U.get(z);
            ae == null && (ae = U.size, U.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(U.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function z_(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(L = 0) {
        for (let A = L, U = o.length; A < U; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const D = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                D[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: D, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[D];
                  if (!se) {
                    s(D, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < U && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let U = 0, S = A[1] - A[0]; U <= S; U++)
              f[A[0] + U] = w[_++] + T;
            _++;
          });
          let L = 0;
          N.forEach((A, U) => {
            s(A, (S) => {
              p[U + T] = S, ++L === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const B_ = /* @__PURE__ */ fs({
  name: "FontResolver",
  dependencies: [
    z_,
    D_,
    U_
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function k_(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let L, A;
      const U = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], U.push(L = { start: S, end: S, fontObj: _[T[S]] })) : L.end = S;
      N(U);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: L = "left",
    textIndent: A = 0,
    whiteSpace: U = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const O = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - O;
      const z = isFinite(T);
      let Q = null, W = null, q = null, ie = null, ae = null, $ = null, F = null, te = null, Z = 0, Y = 0, ee = U !== "nowrap";
      const pe = /* @__PURE__ */ new Map(), ne = h();
      let he = A, fe = 0, K = new d();
      const Ae = [K];
      k.forEach((le) => {
        const { fontObj: Ne } = le, { ascender: ye, descender: Te, unitsPerEm: Pe, lineGap: Je, capHeight: _e, xHeight: Ue } = Ne;
        let ge = pe.get(Ne);
        if (!ge) {
          const xe = v / Pe, Oe = w === "normal" ? (ye - Te + Je) * xe : w * v, zt = (Oe - (ye - Te) * xe) / 2, Ee = Math.min(Oe, (ye - Te) * xe), Le = (ye + Te) / 2 * xe + Ee / 2;
          ge = {
            index: pe.size,
            src: Ne.src,
            fontObj: Ne,
            fontSizeMult: xe,
            unitsPerEm: Pe,
            ascender: ye * xe,
            descender: Te * xe,
            capHeight: _e * xe,
            xHeight: Ue * xe,
            lineHeight: Oe,
            baseline: -zt - ye * xe,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ye + Te) / 2 * xe + Ee / 2,
            caretBottom: Le - Ee
          }, pe.set(Ne, ge);
        }
        const { fontSizeMult: We } = ge, $e = p.slice(le.start, le.end + 1);
        let ht, Qe;
        Ne.forEachGlyph($e, v, N, (xe, Oe, zt) => {
          Oe += fe, zt += le.start, ht = Oe, Qe = xe;
          const Ee = p.charAt(zt), Le = xe.advanceWidth * We, tt = K.count;
          let De;
          if ("isEmpty" in xe || (xe.isWhitespace = !!Ee && new RegExp(n).test(Ee), xe.canBreakAfter = !!Ee && s.test(Ee), xe.isEmpty = xe.xMin === xe.xMax || xe.yMin === xe.yMax || r.test(Ee)), !xe.isWhitespace && !xe.isEmpty && Y++, ee && z && !xe.isWhitespace && Oe + Le + he > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              De = new d(), he = -Oe;
            else
              for (let He = tt; He--; )
                if (He === 0 && S === "break-word") {
                  De = new d(), he = -Oe;
                  break;
                } else if (K.glyphAt(He).glyphObj.canBreakAfter) {
                  De = K.splitAt(He + 1);
                  const yt = De.glyphAt(0).x;
                  he -= yt;
                  for (let at = De.count; at--; )
                    De.glyphAt(at).x -= yt;
                  break;
                }
            De && (K.isSoftWrapped = !0, K = De, Ae.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = xe, we.x = Oe + he, we.width = Le, we.charIndex = zt, we.fontData = ge, Ee === `
` && (K = new d(), Ae.push(K), he = -(Oe + Le + N * v) + A);
        }), fe = ht + Qe.advanceWidth * We + N * v;
      });
      let me = 0;
      Ae.forEach((le) => {
        let Ne = !0;
        for (let ye = le.count; ye--; ) {
          const Te = le.glyphAt(ye);
          Ne && !Te.glyphObj.isWhitespace && (le.width = Te.x + Te.width, le.width > Z && (Z = le.width), Ne = !1);
          let { lineHeight: Pe, capHeight: Je, xHeight: _e, baseline: Ue } = Te.fontData;
          Pe > le.lineHeight && (le.lineHeight = Pe);
          const ge = Ue - le.baseline;
          ge < 0 && (le.baseline += ge, le.cap += ge, le.ex += ge), le.cap = Math.max(le.cap, le.baseline + Je), le.ex = Math.max(le.ex, le.baseline + _e);
        }
        le.baseline -= me, le.cap -= me, le.ex -= me, me += le.lineHeight;
      });
      let be = 0, de = 0;
      if (R && (typeof R == "number" ? be = -R : typeof R == "string" && (be = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? de = -E : typeof E == "string" && (de = E === "top" ? 0 : E === "top-baseline" ? -Ae[0].baseline : E === "top-cap" ? -Ae[0].cap : E === "top-ex" ? -Ae[0].ex : E === "middle" ? me / 2 : E === "bottom" ? me : E === "bottom-baseline" ? Ae[Ae.length - 1].baseline : l(E) * me)), !D) {
        const le = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), W = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, F = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let Ne = 0, ye = -1, Te = -1, Pe, Je;
        if (Ae.forEach((_e, Ue) => {
          let { count: ge, width: We } = _e;
          if (ge > 0) {
            let $e = 0;
            for (let Ee = ge; Ee-- && _e.glyphAt(Ee).glyphObj.isWhitespace; )
              $e++;
            let ht = 0, Qe = 0;
            if (L === "center")
              ht = (Z - We) / 2;
            else if (L === "right")
              ht = Z - We;
            else if (L === "justify" && _e.isSoftWrapped) {
              let Ee = 0;
              for (let Le = ge - $e; Le--; )
                _e.glyphAt(Le).glyphObj.isWhitespace && Ee++;
              Qe = (Z - We) / Ee;
            }
            if (Qe || ht) {
              let Ee = 0;
              for (let Le = 0; Le < ge; Le++) {
                let tt = _e.glyphAt(Le);
                const De = tt.glyphObj;
                tt.x += ht + Ee, Qe !== 0 && De.isWhitespace && Le < ge - $e && (Ee += Qe, tt.width += Qe);
              }
            }
            const xe = e.getReorderSegments(
              p,
              le,
              _e.glyphAt(0).charIndex,
              _e.glyphAt(_e.count - 1).charIndex
            );
            for (let Ee = 0; Ee < xe.length; Ee++) {
              const [Le, tt] = xe[Ee];
              let De = 1 / 0, we = -1 / 0;
              for (let He = 0; He < ge; He++)
                if (_e.glyphAt(He).charIndex >= Le) {
                  let yt = He, at = He;
                  for (; at < ge; at++) {
                    let ot = _e.glyphAt(at);
                    if (ot.charIndex > tt)
                      break;
                    at < ge - $e && (De = Math.min(De, ot.x), we = Math.max(we, ot.x + ot.width));
                  }
                  for (let ot = yt; ot < at; ot++) {
                    const Ot = _e.glyphAt(ot);
                    Ot.x = we - (Ot.x + Ot.width - De);
                  }
                  break;
                }
            }
            let Oe;
            const zt = (Ee) => Oe = Ee;
            for (let Ee = 0; Ee < ge; Ee++) {
              const Le = _e.glyphAt(Ee);
              Oe = Le.glyphObj;
              const tt = Oe.index, De = le.levels[Le.charIndex] & 1;
              if (De) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, zt);
              }
              if (oe) {
                const { charIndex: we, fontData: He } = Le, yt = Le.x + be, at = Le.x + Le.width + be;
                $[we * 4] = De ? at : yt, $[we * 4 + 1] = De ? yt : at, $[we * 4 + 2] = _e.baseline + He.caretBottom + de, $[we * 4 + 3] = _e.baseline + He.caretTop + de;
                const ot = we - ye;
                ot > 1 && u($, ye, ot), ye = we;
              }
              if (X) {
                const { charIndex: we } = Le;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (Je = X[Te]);
              }
              if (!Oe.isWhitespace && !Oe.isEmpty) {
                const we = Ne++, { fontSizeMult: He, src: yt, index: at } = Le.fontData, ot = ie[yt] || (ie[yt] = {});
                ot[tt] || (ot[tt] = {
                  path: Oe.path,
                  pathBounds: [Oe.xMin, Oe.yMin, Oe.xMax, Oe.yMax]
                });
                const Ot = Le.x + be, Fn = _e.baseline + de;
                q[we * 2] = Ot, q[we * 2 + 1] = Fn;
                const ln = Ot + Oe.xMin * He, Nn = Fn + Oe.yMin * He, On = Ot + Oe.xMax * He, un = Fn + Oe.yMax * He;
                ln < F[0] && (F[0] = ln), Nn < F[1] && (F[1] = Nn), On > F[2] && (F[2] = On), un > F[3] && (F[3] = un), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const vt = Pe.rect;
                if (ln < vt[0] && (vt[0] = ln), Nn < vt[1] && (vt[1] = Nn), On > vt[2] && (vt[2] = On), un > vt[3] && (vt[3] = un), Q[we] = tt, W[we] = at, X) {
                  const Vn = we * 3;
                  ae[Vn] = Je >> 16 & 255, ae[Vn + 1] = Je >> 8 & 255, ae[Vn + 2] = Je & 255;
                }
              }
            }
          }
        }), $) {
          const _e = p.length - ye;
          _e > 1 && u($, ye, _e);
        }
      }
      const qe = [];
      pe.forEach(({ index: le, src: Ne, unitsPerEm: ye, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue }) => {
        qe[le] = { src: Ne, unitsPerEm: ye, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: W,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: qe,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: de + Ae[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          be,
          de - me,
          be + Z,
          de
        ],
        visibleBounds: F,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const Nr = () => (self.performance || Date).now(), Tc = /* @__PURE__ */ q1();
let Ap;
function G_(c, e, t, r, n, s, o, i, a, l, u = !0) {
  return u ? j_(c, e, t, r, n, s, o, i, a, l).then(
    null,
    (h) => (Ap || (console.warn("WebGL SDF generation failed, falling back to JS", h), Ap = !0), Ep(c, e, t, r, n, s, o, i, a, l))
  ) : Ep(c, e, t, r, n, s, o, i, a, l);
}
const wa = [], V_ = 5;
let ou = 0;
function K1() {
  const c = Nr();
  for (; wa.length && Nr() - c < V_; )
    wa.shift()();
  ou = wa.length ? setTimeout(K1, 0) : 0;
}
const j_ = (...c) => new Promise((e, t) => {
  wa.push(() => {
    const r = Nr();
    try {
      Tc.webgl.generateIntoCanvas(...c), e({ timing: Nr() - r });
    } catch (n) {
      t(n);
    }
  }), ou || (ou = setTimeout(K1, 0));
}), W_ = 4, H_ = 2e3, Cp = {};
let X_ = 0;
function Ep(c, e, t, r, n, s, o, i, a, l) {
  const u = "TroikaTextSDFGenerator_JS_" + X_++ % W_;
  let h = Cp[u];
  return h || (h = Cp[u] = {
    workerModule: fs({
      name: u,
      workerId: u,
      dependencies: [
        q1,
        Nr
      ],
      init(d, f) {
        const p = d().javascript.generate;
        return function(...m) {
          const g = f();
          return {
            textureData: p(...m),
            timing: f() - g
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(c, e, t, r, n, s).then(({ textureData: d, timing: f }) => {
    const p = Nr(), m = new Uint8Array(d.length * 4);
    for (let g = 0; g < d.length; g++)
      m[g * 4 + l] = d[g];
    return Tc.webglUtils.renderImageData(o, m, i, a, c, e, 1 << 3 - l), f += Nr() - p, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      S_(u);
    }, H_)), { timing: f };
  });
}
function $_(c) {
  c._warm || (Tc.webgl.isSupported(c), c._warm = !0);
}
const q_ = Tc.webglUtils.resizeWebGLCanvasWithoutClearing, qr = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, J_ = /* @__PURE__ */ new je();
function Ur() {
  return (self.performance || Date).now();
}
const Rp = /* @__PURE__ */ Object.create(null);
function Y_(c, e) {
  c = Z_({}, c);
  const t = Ur(), { defaultFontURL: r } = qr, n = [];
  if (r && n.push({ label: "default", src: Lp(r) }), c.font && n.push({ label: "user", src: Lp(c.font) }), c.font = n, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || qr.sdfGlyphSize, c.unicodeFontsURL = c.unicodeFontsURL || qr.unicodeFontsURL, c.colorRanges != null) {
    let d = {};
    for (let f in c.colorRanges)
      if (c.colorRanges.hasOwnProperty(f)) {
        let p = c.colorRanges[f];
        typeof p != "number" && (p = J_.set(p).getHex()), d[f] = p;
      }
    c.colorRanges = d;
  }
  Object.freeze(c);
  const { textureWidth: s, sdfExponent: o } = qr, { sdfGlyphSize: i } = c, a = s / i * 4;
  let l = Rp[i];
  if (!l) {
    const d = document.createElement("canvas");
    d.width = s, d.height = i * 256 / a, l = Rp[i] = {
      glyphCount: 0,
      sdfGlyphSize: i,
      sdfCanvas: d,
      sdfTexture: new kn(
        d,
        void 0,
        void 0,
        void 0,
        uo,
        uo
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, l.sdfTexture.generateMipmaps = !1, K_(l);
  }
  const { sdfTexture: u, sdfCanvas: h } = l;
  eM(c).then((d) => {
    const { glyphIds: f, glyphFontIndices: p, fontData: m, glyphPositions: g, fontSize: b, timings: v } = d, y = [], x = new Float32Array(f.length * 4);
    let N = 0, w = 0;
    const T = Ur(), _ = m.map((R) => {
      let E = l.glyphsByFont.get(R.src);
      return E || l.glyphsByFont.set(R.src, E = /* @__PURE__ */ new Map()), E;
    });
    f.forEach((R, E) => {
      const D = p[E], { src: P, unitsPerEm: se } = m[D];
      let oe = _[D].get(R);
      if (!oe) {
        const { path: I, pathBounds: k } = d.glyphData[P][R], z = Math.max(k[2] - k[0], k[3] - k[1]) / i * (qr.sdfMargin * i + 0.5), Q = l.glyphCount++, W = [
          k[0] - z,
          k[1] - z,
          k[2] + z,
          k[3] + z
        ];
        _[D].set(R, oe = { path: I, atlasIndex: Q, sdfViewBox: W }), y.push(oe);
      }
      const { sdfViewBox: H } = oe, X = g[w++], C = g[w++], O = b / se;
      x[N++] = X + H[0] * O, x[N++] = C + H[1] * O, x[N++] = X + H[2] * O, x[N++] = C + H[3] * O, f[E] = oe.atlasIndex;
    }), v.quads = (v.quads || 0) + (Ur() - T);
    const L = Ur();
    v.sdf = {};
    const A = h.height, U = Math.ceil(l.glyphCount / a), S = Math.pow(2, Math.ceil(Math.log2(U * i)));
    S > A && (console.info(`Increasing SDF texture size ${A}->${S}`), q_(h, s, S), u.dispose()), Promise.all(y.map(
      (R) => Z1(R, l, c.gpuAccelerateSDF).then(({ timing: E }) => {
        v.sdf[R.atlasIndex] = E;
      })
    )).then(() => {
      y.length && !l.contextLost && (Q1(l), u.needsUpdate = !0), v.sdfTotal = Ur() - L, v.total = Ur() - t, e(Object.freeze({
        parameters: c,
        sdfTexture: u,
        sdfGlyphSize: i,
        sdfExponent: o,
        glyphBounds: x,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    l.contextLost || $_(h);
  });
}
function Z1({ path: c, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: n, contextLost: s }, o) {
  if (s)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: i, sdfExponent: a } = qr, l = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (i / r) * r, d = Math.floor(u / (i / r)) * r, f = e % 4;
  return G_(r, r, c, t, l, a, n, h, d, f, o);
}
function K_(c) {
  const e = c.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), c.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), c.contextLost = !1;
    const r = [];
    c.glyphsByFont.forEach((n) => {
      n.forEach((s) => {
        r.push(Z1(s, c, !0));
      });
    }), Promise.all(r).then(() => {
      Q1(c), c.sdfTexture.needsUpdate = !0;
    });
  });
}
function Z_(c, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (c[t] = e[t]);
  return c;
}
let Ji;
function Lp(c) {
  return Ji || (Ji = typeof document > "u" ? {} : document.createElement("a")), Ji.href = c, Ji.href;
}
function Q1(c) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = c, { width: r, height: n } = e, s = c.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== r * n * 4) && (o = new Uint8Array(r * n * 4), t.image = { width: r, height: n, data: o }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, r, n, s.RGBA, s.UNSIGNED_BYTE, o);
  }
}
const Q_ = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    k_,
    B_,
    J1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), eM = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    Q_
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (let t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), Fp = {};
function tM(c) {
  let e = Fp[c];
  if (!e) {
    const t = new Ar(1, 1, c, c), r = t.clone(), n = t.attributes, s = r.attributes, o = new Jn(), i = n.uv.count;
    for (let a = 0; a < i; a++)
      s.position.array[a * 3] *= -1, s.normal.array[a * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((a) => {
      o.setAttribute(
        a,
        new gn(
          [...n[a].array, ...s[a].array],
          n[a].itemSize
        )
      );
    }), o.setIndex([...t.index.array, ...r.index.array.map((a) => a + i)]), o.translate(0.5, 0.5, 0), e = Fp[c] = o;
  }
  return e;
}
const nM = "aTroikaGlyphBounds", Op = "aTroikaGlyphIndex", sM = "aTroikaGlyphColor";
class ex extends Cm {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new xi(), this.boundingBox = new er();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === yu ? t / 2 : 0, e === wu ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = tM(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, r, n, s) {
    ul(this, nM, e, 4), ul(this, Op, t, 1), ul(this, sM, s, 3), this._blockBounds = r, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: n, floor: s, min: o, max: i, sin: a, cos: l } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, p = e[2] / d, m = s((f + u) / h) !== s((p + u) / h) ? -d : o(a(f) * d, a(p) * d), g = s((f - u) / h) !== s((p - u) / h) ? d : i(a(f) * d, a(p) * d), b = s((f + n) / h) !== s((p + n) / h) ? d * 2 : i(d - l(f) * d, d - l(p) * d);
        r.min.set(m, e[1], t < 0 ? -b : 0), r.max.set(g, e[3], t < 0 ? 0 : b);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(Op).count, r = this._chunkedBounds;
    if (r)
      for (let n = r.length; n--; ) {
        t = r[n].end;
        let s = r[n].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function ul(c, e, t, r) {
  const n = c.getAttribute(e);
  t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (c.setAttribute(e, new Fm(t, r)), delete c._maxInstanceCount, c.dispose()) : n && c.deleteAttribute(e);
}
const rM = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, oM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, iM = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, aM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function cM(c) {
  const e = ru(c, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new wt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new pt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new pt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new wt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new je() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Ns() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: rM,
    vertexTransform: oM,
    fragmentDefs: iM,
    fragmentColorTransform: aM,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(r) && (r = r.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        Y1,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Jd = /* @__PURE__ */ new An({
  color: 16777215,
  side: wu,
  transparent: !0
}), Ip = 8421504, Pp = /* @__PURE__ */ new Ge(), Yi = /* @__PURE__ */ new ve(), hl = /* @__PURE__ */ new ve(), Po = [], lM = /* @__PURE__ */ new ve(), dl = "+x+y";
function Dp(c) {
  return Array.isArray(c) ? c[0] : c;
}
let tx = () => {
  const c = new qt(
    new Ar(1, 1),
    Jd
  );
  return tx = () => c, c;
}, nx = () => {
  const c = new qt(
    new Ar(1, 1, 32, 1),
    Jd
  );
  return nx = () => c, c;
};
const uM = { type: "syncstart" }, hM = { type: "synccomplete" }, sx = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], dM = sx.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class rx extends qt {
  constructor() {
    const e = new ex();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Ip, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = dl, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(uM), Y_({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((n) => n && n());
      })), this.dispatchEvent(hM), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, r, n, s, o) {
    this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s), s._hadOwnSide = s.hasOwnProperty("side"), this.geometry.setSide(s._actualSide = s.side), s.side = Om;
  }
  onAfterRender(e, t, r, n, s, o) {
    s._hadOwnSide ? s.side = s._actualSide : delete s.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Jd.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = cM(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Dp(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Dp(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: i, blockBounds: a } = n;
      r.uTroikaSDFTexture.value = i, r.uTroikaSDFTextureSize.value.set(i.image.width, i.image.height), r.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, r.uTroikaSDFExponent.value = n.sdfExponent, r.uTroikaTotalBounds.value.fromArray(a), r.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let l = 0, u = 0, h = 0, d, f, p, m = 0, g = 0;
      if (t) {
        let { outlineWidth: v, outlineOffsetX: y, outlineOffsetY: x, outlineBlur: N, outlineOpacity: w } = this;
        l = this._parsePercent(v) || 0, u = Math.max(0, this._parsePercent(N) || 0), d = w, m = this._parsePercent(y) || 0, g = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (p = this.strokeColor, r.uTroikaStrokeColor.value.set(p ?? Ip), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      r.uTroikaDistanceOffset.value = l, r.uTroikaPositionOffset.value.set(m, g), r.uTroikaBlurRadius.value = u, r.uTroikaStrokeWidth.value = h, r.uTroikaStrokeOpacity.value = f, r.uTroikaFillOpacity.value = d ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let b = this.clipRect;
      if (b && Array.isArray(b) && b.length === 4)
        r.uTroikaClipRect.value.fromArray(b);
      else {
        const v = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          a[0] - v,
          a[1] - v,
          a[2] + v,
          a[3] + v
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null)
      delete e.color;
    else {
      const i = e.hasOwnProperty("color") ? e.color : e.color = new je();
      (s !== i._input || typeof s == "object") && i.set(i._input = s);
    }
    let o = this.orientation || dl;
    if (o !== e._orientation) {
      let i = r.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let a = o !== dl && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (a) {
        let [, l, u, h, d] = a;
        Yi.set(0, 0, 0)[u] = l === "-" ? 1 : -1, hl.set(0, 0, 0)[d] = h === "-" ? -1 : 1, Pp.lookAt(lM, Yi.cross(hl), hl), i.setFromMatrix4(Pp);
      } else
        i.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new wt()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new wt()) {
    return Yi.copy(e), this.localPositionToTextCoords(this.worldToLocal(Yi), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: n } = this;
    if (r) {
      const s = r.blockBounds, o = n ? nx() : tx(), i = o.geometry, { position: a, uv: l } = i.attributes;
      for (let u = 0; u < l.count; u++) {
        let h = s[0] + l.getX(u) * (s[2] - s[0]);
        const d = s[1] + l.getY(u) * (s[3] - s[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), a.setXYZ(u, h, d, f);
      }
      i.boundingSphere = this.geometry.boundingSphere, i.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, Po.length = 0, o.raycast(e, Po);
      for (let u = 0; u < Po.length; u++)
        Po[u].object = this, t.push(Po[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, dM.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
sx.forEach((c) => {
  const e = "_private_" + c;
  Object.defineProperty(rx.prototype, c, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const di = {
  text: "String",
  anchorX: 'number|"left"|"center"|"right"',
  anchorY: 'number|"top"|"top-baseline"|"top-cap"|"top-ex"|"middle"|"bottom-baseline"|"bottom"',
  curveRadius: "number",
  direction: '"auto"|"ltr"|"rtl"',
  font: "string",
  fontSize: "number",
  fontWeight: 'number|"normal" | "bold"',
  fontStyle: '"normal"|"italic"',
  letterSpacing: "number",
  lineHeight: 'number|"normal"',
  maxWidth: "number",
  overflowWrap: '"normal" | "break-word"',
  textAlign: '"left" | "right" | "center" | "justify"',
  textIndent: "number",
  whiteSpace: '"normal"| "nowrap"',
  color: "Color",
  outlineWidth: "number",
  outlineColor: "Color",
  outlineOpacity: "number",
  outlineBlur: "number",
  outlineOffsetX: "number",
  outlineOffsetY: "number",
  strokeWidth: "number",
  strokeColor: "Color",
  strokeOpacity: "number",
  fillOpacity: "number",
  depthOffset: "number",
  clipRect: "number[]",
  orientation: "string",
  glyphGeometryDetail: "number",
  sdfGlyphSize: "number|null",
  gpuAccelerateSDF: "boolean"
};
class Yd extends rx {
  constructor() {
    super();
    G(this, "isTextMesh", !0);
    this.type = "TextMesh", this.text = "text", this.font = "/assets/fonts/STFangsong.ttf", this.color = new je(), this.outlineColor = new je(), this.strokeColor = new je();
  }
  serialize(t) {
    for (const [r, n] of Object.entries(di))
      if (n === "Color") {
        const s = this[r];
        t[r] = (s instanceof je ? s : new je(s)).toArray();
      } else
        t[r] = this[r];
    t.geo = {
      detail: this.geometry.detail,
      curveRadius: this.geometry.curveRadius,
      groups: this.geometry.groups,
      boundingSphere: { center: this.geometry.boundingSphere.center.toArray(), radius: this.geometry.boundingSphere.radius },
      boundingBox: { min: this.geometry.boundingBox.min.toArray(), max: this.geometry.boundingBox.max.toArray() }
    };
  }
  deserialize(t) {
    const r = new ex();
    r.copy(this.geometry), this.geometry = r, t.geo && (r.detail = t.geo.detail, r.curveRadius = t.geo.curveRadius, r.groups = t.geo.groups, r.boundingSphere.set(new ve().fromArray(t.geo.boundingSphere.center), t.geo.boundingSphere.radius), r.boundingBox = new er(new ve().fromArray(t.geo.boundingBox.min), new ve().fromArray(t.geo.boundingBox.max)));
    for (const [n, s] of Object.entries(di)) {
      const o = t[n];
      o !== void 0 && (s === "Color" ? this[n] = new je().fromArray(o) : this[n] = o);
    }
    this.sync();
  }
}
Ye("TextMesh", {
  // cls: TextMesh,
  create: () => new Yd(),
  members: di,
  proto: "Mesh",
  group: "Text.Text",
  icon: "text"
});
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function fM() {
  return typeof window > "u" && (self.window = self), function(c) {
    var e = { parse: function(n) {
      var s = e._bin, o = new Uint8Array(n);
      if (s.readASCII(o, 0, 4) == "ttcf") {
        var i = 4;
        s.readUshort(o, i), i += 2, s.readUshort(o, i), i += 2;
        var a = s.readUint(o, i);
        i += 4;
        for (var l = [], u = 0; u < a; u++) {
          var h = s.readUint(o, i);
          i += 4, l.push(e._readFont(o, h));
        }
        return l;
      }
      return [e._readFont(o, 0)];
    }, _readFont: function(n, s) {
      var o = e._bin, i = s;
      o.readFixed(n, s), s += 4;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: i }, h = {}, d = 0; d < a; d++) {
        var f = o.readASCII(n, s, 4);
        s += 4, o.readUint(n, s), s += 4;
        var p = o.readUint(n, s);
        s += 4;
        var m = o.readUint(n, s);
        s += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < l.length; d++) {
        var g = l[d];
        h[g] && (u[g.trim()] = e[g.trim()].parse(n, h[g].offset, h[g].length, u));
      }
      return u;
    }, _tabOffset: function(n, s, o) {
      for (var i = e._bin, a = i.readUshort(n, o + 4), l = o + 12, u = 0; u < a; u++) {
        var h = i.readASCII(n, l, 4);
        l += 4, i.readUint(n, l), l += 4;
        var d = i.readUint(n, l);
        if (l += 4, i.readUint(n, l), l += 4, h == s)
          return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, s) {
      return (n[s] << 8 | n[s + 1]) + (n[s + 2] << 8 | n[s + 3]) / 65540;
    }, readF2dot14: function(n, s) {
      return e._bin.readShort(n, s) / 16384;
    }, readInt: function(n, s) {
      return e._bin._view(n).getInt32(s);
    }, readInt8: function(n, s) {
      return e._bin._view(n).getInt8(s);
    }, readShort: function(n, s) {
      return e._bin._view(n).getInt16(s);
    }, readUshort: function(n, s) {
      return e._bin._view(n).getUint16(s);
    }, readUshorts: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(e._bin.readUshort(n, s + 2 * a));
      return i;
    }, readUint: function(n, s) {
      return e._bin._view(n).getUint32(s);
    }, readUint64: function(n, s) {
      return 4294967296 * e._bin.readUint(n, s) + e._bin.readUint(n, s + 4);
    }, readASCII: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++)
        i += String.fromCharCode(n[s + a]);
      return i;
    }, readUnicode: function(n, s, o) {
      for (var i = "", a = 0; a < o; a++) {
        var l = n[s++] << 8 | n[s++];
        i += String.fromCharCode(l);
      }
      return i;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, s, o) {
      var i = e._bin._tdec;
      return i && s == 0 && o == n.length ? i.decode(n) : e._bin.readASCII(n, s, o);
    }, readBytes: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(n[s + a]);
      return i;
    }, readASCIIArray: function(n, s, o) {
      for (var i = [], a = 0; a < o; a++)
        i.push(String.fromCharCode(n[s + a]));
      return i;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, s, o, i, a) {
      var l = e._bin, u = {}, h = s;
      l.readFixed(n, s), s += 4;
      var d = l.readUshort(n, s);
      s += 2;
      var f = l.readUshort(n, s);
      s += 2;
      var p = l.readUshort(n, s);
      return s += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, a), u;
    }, e._lctf.readLookupList = function(n, s, o) {
      var i = e._bin, a = s, l = [], u = i.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = e._lctf.readLookupTable(n, a + d, o);
        l.push(f);
      }
      return l;
    }, e._lctf.readLookupTable = function(n, s, o) {
      var i = e._bin, a = s, l = { tabs: [] };
      l.ltype = i.readUshort(n, s), s += 2, l.flag = i.readUshort(n, s), s += 2;
      var u = i.readUshort(n, s);
      s += 2;
      for (var h = l.ltype, d = 0; d < u; d++) {
        var f = i.readUshort(n, s);
        s += 2;
        var p = o(n, h, a + f, l);
        l.tabs.push(p);
      }
      return l;
    }, e._lctf.numOfOnes = function(n) {
      for (var s = 0, o = 0; o < 32; o++)
        n >>> o & 1 && s++;
      return s;
    }, e._lctf.readClassDef = function(n, s) {
      var o = e._bin, i = [], a = o.readUshort(n, s);
      if (s += 2, a == 1) {
        var l = o.readUshort(n, s);
        s += 2;
        var u = o.readUshort(n, s);
        s += 2;
        for (var h = 0; h < u; h++)
          i.push(l + h), i.push(l + h), i.push(o.readUshort(n, s)), s += 2;
      }
      if (a == 2) {
        var d = o.readUshort(n, s);
        for (s += 2, h = 0; h < d; h++)
          i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2, i.push(o.readUshort(n, s)), s += 2;
      }
      return i;
    }, e._lctf.getInterval = function(n, s) {
      for (var o = 0; o < n.length; o += 3) {
        var i = n[o], a = n[o + 1];
        if (n[o + 2], i <= s && s <= a)
          return o;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, s) {
      var o = e._bin, i = {};
      i.fmt = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.fmt == 1 && (i.tab = o.readUshorts(n, s, a)), i.fmt == 2 && (i.tab = o.readUshorts(n, s, 3 * a)), i;
    }, e._lctf.coverageIndex = function(n, s) {
      var o = n.tab;
      if (n.fmt == 1)
        return o.indexOf(s);
      if (n.fmt == 2) {
        var i = e._lctf.getInterval(o, s);
        if (i != -1)
          return o[i + 2] + (s - o[i]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2;
        var f = e._lctf.readFeatureTable(n, i + d);
        f.tag = h.trim(), a.push(f);
      }
      return a;
    }, e._lctf.readFeatureTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.featureParams = i + l);
      var u = o.readUshort(n, s);
      s += 2, a.tab = [];
      for (var h = 0; h < u; h++)
        a.tab.push(o.readUshort(n, s + 2 * h));
      return a;
    }, e._lctf.readScriptList = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readASCII(n, s, 4);
        s += 4;
        var d = o.readUshort(n, s);
        s += 2, a[h.trim()] = e._lctf.readScriptTable(n, i + d);
      }
      return a;
    }, e._lctf.readScriptTable = function(n, s) {
      var o = e._bin, i = s, a = {}, l = o.readUshort(n, s);
      s += 2, l > 0 && (a.default = e._lctf.readLangSysTable(n, i + l));
      var u = o.readUshort(n, s);
      s += 2;
      for (var h = 0; h < u; h++) {
        var d = o.readASCII(n, s, 4);
        s += 4;
        var f = o.readUshort(n, s);
        s += 2, a[d.trim()] = e._lctf.readLangSysTable(n, i + f);
      }
      return a;
    }, e._lctf.readLangSysTable = function(n, s) {
      var o = e._bin, i = {};
      o.readUshort(n, s), s += 2, i.reqFeature = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      return s += 2, i.features = o.readUshorts(n, s, a), i;
    }, e.CFF = {}, e.CFF.parse = function(n, s, o) {
      var i = e._bin;
      (n = new Uint8Array(n.buffer, s, o))[s = 0], n[++s], n[++s], n[++s], s++;
      var a = [];
      s = e.CFF.readIndex(n, s, a);
      for (var l = [], u = 0; u < a.length - 1; u++)
        l.push(i.readASCII(n, s + a[u], a[u + 1] - a[u]));
      s += a[a.length - 1];
      var h = [];
      s = e.CFF.readIndex(n, s, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++)
        d.push(e.CFF.readDict(n, s + h[u], s + h[u + 1]));
      s += h[h.length - 1];
      var f = d[0], p = [];
      s = e.CFF.readIndex(n, s, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++)
        m.push(i.readASCII(n, s + p[u], p[u + 1] - p[u]));
      if (s += p[p.length - 1], e.CFF.readSubrs(n, s, f), f.CharStrings) {
        s = f.CharStrings, p = [], s = e.CFF.readIndex(n, s, p);
        var g = [];
        for (u = 0; u < p.length - 1; u++)
          g.push(i.readBytes(n, s + p[u], p[u + 1] - p[u]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        s = f.FDArray;
        var b = [];
        for (s = e.CFF.readIndex(n, s, b), f.FDArray = [], u = 0; u < b.length - 1; u++) {
          var v = e.CFF.readDict(n, s + b[u], s + b[u + 1]);
          e.CFF._readFDict(n, v, m), f.FDArray.push(v);
        }
        s += b[b.length - 1], s = f.FDSelect, f.FDSelect = [];
        var y = n[s];
        if (s++, y != 3)
          throw y;
        var x = i.readUshort(n, s);
        for (s += 2, u = 0; u < x + 1; u++)
          f.FDSelect.push(i.readUshort(n, s), n[s + 2]), s += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, s, o) {
      var i;
      for (var a in s.Private && (i = s.Private[1], s.Private = e.CFF.readDict(n, i, i + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(n, i + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) != -1 && (s[a] = o[s[a] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, s, o) {
      var i = e._bin, a = [];
      s = e.CFF.readIndex(n, s, a);
      var l, u = a.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = l, o.Subrs = [];
      for (var h = 0; h < a.length - 1; h++)
        o.Subrs.push(i.readBytes(n, s + a[h], a[h + 1] - a[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, s) {
      for (var o = 0; o < n.charset.length; o++)
        if (n.charset[o] == s)
          return o;
      return -1;
    }, e.CFF.glyphBySE = function(n, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(n, s, o) {
      e._bin;
      var i = [".notdef"], a = n[s];
      if (s++, a != 0)
        throw "error: unknown encoding format: " + a;
      var l = n[s];
      s++;
      for (var u = 0; u < l; u++)
        i.push(n[s + u]);
      return i;
    }, e.CFF.readCharset = function(n, s, o) {
      var i = e._bin, a = [".notdef"], l = n[s];
      if (s++, l == 0)
        for (var u = 0; u < o; u++) {
          var h = i.readUshort(n, s);
          s += 2, a.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; a.length < o; ) {
          h = i.readUshort(n, s), s += 2;
          var d = 0;
          for (l == 1 ? (d = n[s], s++) : (d = i.readUshort(n, s), s += 2), u = 0; u <= d; u++)
            a.push(h), h++;
        }
      }
      return a;
    }, e.CFF.readIndex = function(n, s, o) {
      var i = e._bin, a = i.readUshort(n, s) + 1, l = n[s += 2];
      if (s++, l == 1)
        for (var u = 0; u < a; u++)
          o.push(n[s + u]);
      else if (l == 2)
        for (u = 0; u < a; u++)
          o.push(i.readUshort(n, s + 2 * u));
      else if (l == 3)
        for (u = 0; u < a; u++)
          o.push(16777215 & i.readUint(n, s + 3 * u - 1));
      else if (a != 1)
        throw "unsupported offset size: " + l + ", count: " + a;
      return (s += a * l) - 1;
    }, e.CFF.getCharString = function(n, s, o) {
      var i = e._bin, a = n[s], l = n[s + 1];
      n[s + 2], n[s + 3], n[s + 4];
      var u = 1, h = null, d = null;
      a <= 20 && (h = a, u = 1), a == 12 && (h = 100 * a + l, u = 2), 21 <= a && a <= 27 && (h = a, u = 1), a == 28 && (d = i.readShort(n, s + 1), u = 3), 29 <= a && a <= 31 && (h = a, u = 1), 32 <= a && a <= 246 && (d = a - 139, u = 1), 247 <= a && a <= 250 && (d = 256 * (a - 247) + l + 108, u = 2), 251 <= a && a <= 254 && (d = 256 * -(a - 251) - l - 108, u = 2), a == 255 && (d = i.readInt(n, s + 1) / 65535, u = 5), o.val = d ?? "o" + h, o.size = u;
    }, e.CFF.readCharString = function(n, s, o) {
      for (var i = s + o, a = e._bin, l = []; s < i; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = a.readShort(n, s + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = a.readInt(n, s + 1) / 65535, d = 5), l.push(p ?? "o" + f), s += d;
      }
      return l;
    }, e.CFF.readDict = function(n, s, o) {
      for (var i = e._bin, a = {}, l = []; s < o; ) {
        var u = n[s], h = n[s + 1];
        n[s + 2], n[s + 3], n[s + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = i.readShort(n, s + 1), d = 3), u == 29 && (p = i.readInt(n, s + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255)
          throw p = i.readInt(n, s + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var g = n[s + d];
            d++;
            var b = g >> 4, v = 15 & g;
            if (b != 15 && m.push(b), v != 15 && m.push(v), v == 15)
              break;
          }
          for (var y = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], N = 0; N < m.length; N++)
            y += x[m[N]];
          p = parseFloat(y);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (a[f] = l.length == 1 ? l[0] : l, l = []) : l.push(p), s += d;
      }
      return a;
    }, e.cmap = {}, e.cmap.parse = function(n, s, o) {
      n = new Uint8Array(n.buffer, s, o), s = 0;
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2;
      var u = [];
      a.tables = [];
      for (var h = 0; h < l; h++) {
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readUshort(n, s);
        s += 2;
        var p = i.readUint(n, s);
        s += 4;
        var m = "p" + d + "e" + f, g = u.indexOf(p);
        if (g == -1) {
          var b;
          g = a.tables.length, u.push(p);
          var v = i.readUshort(n, p);
          v == 0 ? b = e.cmap.parse0(n, p) : v == 4 ? b = e.cmap.parse4(n, p) : v == 6 ? b = e.cmap.parse6(n, p) : v == 12 ? b = e.cmap.parse12(n, p) : console.debug("unknown format: " + v, d, f, p), a.tables.push(b);
        }
        if (a[m] != null)
          throw "multiple tables for one platform+encoding";
        a[m] = g;
      }
      return a;
    }, e.cmap.parse0 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2, i.map = [];
      for (var l = 0; l < a - 6; l++)
        i.map.push(n[s + l]);
      return i;
    }, e.cmap.parse4 = function(n, s) {
      var o = e._bin, i = s, a = {};
      a.format = o.readUshort(n, s), s += 2;
      var l = o.readUshort(n, s);
      s += 2, o.readUshort(n, s), s += 2;
      var u = o.readUshort(n, s);
      s += 2;
      var h = u / 2;
      a.searchRange = o.readUshort(n, s), s += 2, a.entrySelector = o.readUshort(n, s), s += 2, a.rangeShift = o.readUshort(n, s), s += 2, a.endCount = o.readUshorts(n, s, h), s += 2 * h, s += 2, a.startCount = o.readUshorts(n, s, h), s += 2 * h, a.idDelta = [];
      for (var d = 0; d < h; d++)
        a.idDelta.push(o.readShort(n, s)), s += 2;
      for (a.idRangeOffset = o.readUshorts(n, s, h), s += 2 * h, a.glyphIdArray = []; s < i + l; )
        a.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return a;
    }, e.cmap.parse6 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, o.readUshort(n, s), s += 2, i.firstCode = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2, i.glyphIdArray = [];
      for (var l = 0; l < a; l++)
        i.glyphIdArray.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.cmap.parse12 = function(n, s) {
      var o = e._bin, i = {};
      i.format = o.readUshort(n, s), s += 2, s += 2, o.readUint(n, s), s += 4, o.readUint(n, s), s += 4;
      var a = o.readUint(n, s);
      s += 4, i.groups = [];
      for (var l = 0; l < a; l++) {
        var u = s + 12 * l, h = o.readUint(n, u + 0), d = o.readUint(n, u + 4), f = o.readUint(n, u + 8);
        i.groups.push([h, d, f]);
      }
      return i;
    }, e.glyf = {}, e.glyf.parse = function(n, s, o, i) {
      for (var a = [], l = 0; l < i.maxp.numGlyphs; l++)
        a.push(null);
      return a;
    }, e.glyf._parseGlyf = function(n, s) {
      var o = e._bin, i = n._data, a = e._tabOffset(i, "glyf", n._offset) + n.loca[s];
      if (n.loca[s] == n.loca[s + 1])
        return null;
      var l = {};
      if (l.noc = o.readShort(i, a), a += 2, l.xMin = o.readShort(i, a), a += 2, l.yMin = o.readShort(i, a), a += 2, l.xMax = o.readShort(i, a), a += 2, l.yMax = o.readShort(i, a), a += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(o.readUshort(i, a)), a += 2;
        var h = o.readUshort(i, a);
        if (a += 2, i.length - a < h)
          return null;
        l.instructions = o.readBytes(i, a, h), a += h;
        var d = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < d; u++) {
          var f = i[a];
          if (a++, l.flags.push(f), (8 & f) != 0) {
            var p = i[a];
            a++;
            for (var m = 0; m < p; m++)
              l.flags.push(f), u++;
          }
        }
        for (l.xs = [], u = 0; u < d; u++) {
          var g = (2 & l.flags[u]) != 0, b = (16 & l.flags[u]) != 0;
          g ? (l.xs.push(b ? i[a] : -i[a]), a++) : b ? l.xs.push(0) : (l.xs.push(o.readShort(i, a)), a += 2);
        }
        for (l.ys = [], u = 0; u < d; u++)
          g = (4 & l.flags[u]) != 0, b = (32 & l.flags[u]) != 0, g ? (l.ys.push(b ? i[a] : -i[a]), a++) : b ? l.ys.push(0) : (l.ys.push(o.readShort(i, a)), a += 2);
        var v = 0, y = 0;
        for (u = 0; u < d; u++)
          v += l.xs[u], y += l.ys[u], l.xs[u] = v, l.ys[u] = y;
      } else {
        var x;
        l.parts = [];
        do {
          x = o.readUshort(i, a), a += 2;
          var N = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(N), N.glyphIndex = o.readUshort(i, a), a += 2, 1 & x) {
            var w = o.readShort(i, a);
            a += 2;
            var T = o.readShort(i, a);
            a += 2;
          } else
            w = o.readInt8(i, a), a++, T = o.readInt8(i, a), a++;
          2 & x ? (N.m.tx = w, N.m.ty = T) : (N.p1 = w, N.p2 = T), 8 & x ? (N.m.a = N.m.d = o.readF2dot14(i, a), a += 2) : 64 & x ? (N.m.a = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2) : 128 & x && (N.m.a = o.readF2dot14(i, a), a += 2, N.m.b = o.readF2dot14(i, a), a += 2, N.m.c = o.readF2dot14(i, a), a += 2, N.m.d = o.readF2dot14(i, a), a += 2);
        } while (32 & x);
        if (256 & x) {
          var _ = o.readUshort(i, a);
          for (a += 2, l.instr = [], u = 0; u < _; u++)
            l.instr.push(i[a]), a++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GPOS.subt);
    }, e.GPOS.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, h + l);
      }
      if (s == 1 && u.fmt == 1) {
        var d = a.readUshort(n, o);
        o += 2;
        var f = e._lctf.numOfOnes(d);
        d != 0 && (u.pos = e.GPOS.readValueRecord(n, o, d));
      } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = a.readUshort(n, o), o += 2;
        var p = a.readUshort(n, o);
        o += 2, f = e._lctf.numOfOnes(d);
        var m = e._lctf.numOfOnes(p);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = a.readUshort(n, o);
          o += 2;
          for (var b = 0; b < g; b++) {
            var v = l + a.readUshort(n, o);
            o += 2;
            var y = a.readUshort(n, v);
            v += 2;
            for (var x = [], N = 0; N < y; N++) {
              var w = a.readUshort(n, v);
              v += 2, d != 0 && (S = e.GPOS.readValueRecord(n, v, d), v += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, v, p), v += 2 * m), x.push({ gid2: w, val1: S, val2: R });
            }
            u.pairsets.push(x);
          }
        }
        if (u.fmt == 2) {
          var T = a.readUshort(n, o);
          o += 2;
          var _ = a.readUshort(n, o);
          o += 2;
          var L = a.readUshort(n, o);
          o += 2;
          var A = a.readUshort(n, o);
          for (o += 2, u.classDef1 = e._lctf.readClassDef(n, l + T), u.classDef2 = e._lctf.readClassDef(n, l + _), u.matrix = [], b = 0; b < L; b++) {
            var U = [];
            for (N = 0; N < A; N++) {
              var S = null, R = null;
              d != 0 && (S = e.GPOS.readValueRecord(n, o, d), o += 2 * f), p != 0 && (R = e.GPOS.readValueRecord(n, o, p), o += 2 * m), U.push({ val1: S, val2: R });
            }
            u.matrix.push(U);
          }
        }
      } else {
        if (s == 9 && u.fmt == 1) {
          var E = a.readUshort(n, o);
          o += 2;
          var D = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = E;
          else if (i.ltype != E)
            throw "invalid extension substitution";
          return e.GPOS.subt(n, i.ltype, l + D);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, s, o) {
      var i = e._bin, a = [];
      return a.push(1 & o ? i.readShort(n, s) : 0), s += 1 & o ? 2 : 0, a.push(2 & o ? i.readShort(n, s) : 0), s += 2 & o ? 2 : 0, a.push(4 & o ? i.readShort(n, s) : 0), s += 4 & o ? 2 : 0, a.push(8 & o ? i.readShort(n, s) : 0), s += 8 & o ? 2 : 0, a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, s, o, i) {
      return e._lctf.parse(n, s, o, i, e.GSUB.subt);
    }, e.GSUB.subt = function(n, s, o, i) {
      var a = e._bin, l = o, u = {};
      if (u.fmt = a.readUshort(n, o), o += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
        var h = a.readUshort(n, o);
        o += 2, u.coverage = e._lctf.readCoverage(n, l + h);
      }
      if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = a.readShort(n, o), o += 2;
        else if (u.fmt == 2) {
          var d = a.readUshort(n, o);
          o += 2, u.newg = a.readUshorts(n, o, d), o += 2 * u.newg.length;
        }
      } else if (s == 4) {
        u.vals = [], d = a.readUshort(n, o), o += 2;
        for (var f = 0; f < d; f++) {
          var p = a.readUshort(n, o);
          o += 2, u.vals.push(e.GSUB.readLigatureSet(n, l + p));
        }
      } else if (s == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = a.readUshort(n, o);
          o += 2, u.cDef = e._lctf.readClassDef(n, l + m), u.scset = [];
          var g = a.readUshort(n, o);
          for (o += 2, f = 0; f < g; f++) {
            var b = a.readUshort(n, o);
            o += 2, u.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(n, l + b));
          }
        }
      } else if (s == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = a.readUshort(n, o), o += 2;
            for (var v = [], y = 0; y < d; y++)
              v.push(e._lctf.readCoverage(n, l + a.readUshort(n, o + 2 * y)));
            o += 2 * d, f == 0 && (u.backCvg = v), f == 1 && (u.inptCvg = v), f == 2 && (u.ahedCvg = v);
          }
          d = a.readUshort(n, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, o, d);
        }
      } else {
        if (s == 7 && u.fmt == 1) {
          var x = a.readUshort(n, o);
          o += 2;
          var N = a.readUint(n, o);
          if (o += 4, i.ltype == 9)
            i.ltype = x;
          else if (i.ltype != x)
            throw "invalid extension substitution";
          return e.GSUB.subt(n, i.ltype, l + N);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, s) {
      var o = e._bin.readUshort, i = s, a = [], l = o(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o(n, s);
        s += 2, a.push(e.GSUB.readSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readSubClassRule = function(n, s) {
      var o = e._bin.readUshort, i = {}, a = o(n, s), l = o(n, s += 2);
      s += 2, i.input = [];
      for (var u = 0; u < a - 1; u++)
        i.input.push(o(n, s)), s += 2;
      return i.substLookupRecords = e.GSUB.readSubstLookupRecords(n, s, l), i;
    }, e.GSUB.readSubstLookupRecords = function(n, s, o) {
      for (var i = e._bin.readUshort, a = [], l = 0; l < o; l++)
        a.push(i(n, s), i(n, s + 2)), s += 4;
      return a;
    }, e.GSUB.readChainSubClassSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readChainSubClassRule(n, i + h));
      }
      return a;
    }, e.GSUB.readChainSubClassRule = function(n, s) {
      for (var o = e._bin, i = {}, a = ["backtrack", "input", "lookahead"], l = 0; l < a.length; l++) {
        var u = o.readUshort(n, s);
        s += 2, l == 1 && u--, i[a[l]] = o.readUshorts(n, s, u), s += 2 * i[a[l]].length;
      }
      return u = o.readUshort(n, s), s += 2, i.subst = o.readUshorts(n, s, 2 * u), s += 2 * i.subst.length, i;
    }, e.GSUB.readLigatureSet = function(n, s) {
      var o = e._bin, i = s, a = [], l = o.readUshort(n, s);
      s += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(n, s);
        s += 2, a.push(e.GSUB.readLigature(n, i + h));
      }
      return a;
    }, e.GSUB.readLigature = function(n, s) {
      var o = e._bin, i = { chain: [] };
      i.nglyph = o.readUshort(n, s), s += 2;
      var a = o.readUshort(n, s);
      s += 2;
      for (var l = 0; l < a - 1; l++)
        i.chain.push(o.readUshort(n, s)), s += 2;
      return i;
    }, e.head = {}, e.head.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.fontRevision = i.readFixed(n, s), s += 4, i.readUint(n, s), s += 4, i.readUint(n, s), s += 4, a.flags = i.readUshort(n, s), s += 2, a.unitsPerEm = i.readUshort(n, s), s += 2, a.created = i.readUint64(n, s), s += 8, a.modified = i.readUint64(n, s), s += 8, a.xMin = i.readShort(n, s), s += 2, a.yMin = i.readShort(n, s), s += 2, a.xMax = i.readShort(n, s), s += 2, a.yMax = i.readShort(n, s), s += 2, a.macStyle = i.readUshort(n, s), s += 2, a.lowestRecPPEM = i.readUshort(n, s), s += 2, a.fontDirectionHint = i.readShort(n, s), s += 2, a.indexToLocFormat = i.readShort(n, s), s += 2, a.glyphDataFormat = i.readShort(n, s), s += 2, a;
    }, e.hhea = {}, e.hhea.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return i.readFixed(n, s), s += 4, a.ascender = i.readShort(n, s), s += 2, a.descender = i.readShort(n, s), s += 2, a.lineGap = i.readShort(n, s), s += 2, a.advanceWidthMax = i.readUshort(n, s), s += 2, a.minLeftSideBearing = i.readShort(n, s), s += 2, a.minRightSideBearing = i.readShort(n, s), s += 2, a.xMaxExtent = i.readShort(n, s), s += 2, a.caretSlopeRise = i.readShort(n, s), s += 2, a.caretSlopeRun = i.readShort(n, s), s += 2, a.caretOffset = i.readShort(n, s), s += 2, s += 8, a.metricDataFormat = i.readShort(n, s), s += 2, a.numberOfHMetrics = i.readUshort(n, s), s += 2, a;
    }, e.hmtx = {}, e.hmtx.parse = function(n, s, o, i) {
      for (var a = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < i.maxp.numGlyphs; d++)
        d < i.hhea.numberOfHMetrics && (u = a.readUshort(n, s), s += 2, h = a.readShort(n, s), s += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(n, s, o, i) {
      var a = e._bin, l = a.readUshort(n, s);
      if (s += 2, l == 1)
        return e.kern.parseV1(n, s - 2, o, i);
      var u = a.readUshort(n, s);
      s += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        s += 2, o = a.readUshort(n, s), s += 2;
        var f = a.readUshort(n, s);
        s += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0)
          throw "unknown kern table format: " + p;
        s = e.kern.readFormat0(n, s, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, s, o, i) {
      var a = e._bin;
      a.readFixed(n, s), s += 4;
      var l = a.readUint(n, s);
      s += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        a.readUint(n, s), s += 4;
        var d = a.readUshort(n, s);
        s += 2, a.readUshort(n, s), s += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0)
          throw "unknown kern table format: " + f;
        s = e.kern.readFormat0(n, s, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, s, o) {
      var i = e._bin, a = -1, l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2, i.readUshort(n, s), s += 2;
      for (var u = 0; u < l; u++) {
        var h = i.readUshort(n, s);
        s += 2;
        var d = i.readUshort(n, s);
        s += 2;
        var f = i.readShort(n, s);
        s += 2, h != a && (o.glyph1.push(h), o.rval.push({ glyph2: [], vals: [] }));
        var p = o.rval[o.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), a = h;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(n, s, o, i) {
      var a = e._bin, l = [], u = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
      if (u == 0)
        for (var d = 0; d < h; d++)
          l.push(a.readUshort(n, s + (d << 1)) << 1);
      if (u == 1)
        for (d = 0; d < h; d++)
          l.push(a.readUint(n, s + (d << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(n, s, o) {
      var i = e._bin, a = {}, l = i.readUint(n, s);
      return s += 4, a.numGlyphs = i.readUshort(n, s), s += 2, l == 65536 && (a.maxPoints = i.readUshort(n, s), s += 2, a.maxContours = i.readUshort(n, s), s += 2, a.maxCompositePoints = i.readUshort(n, s), s += 2, a.maxCompositeContours = i.readUshort(n, s), s += 2, a.maxZones = i.readUshort(n, s), s += 2, a.maxTwilightPoints = i.readUshort(n, s), s += 2, a.maxStorage = i.readUshort(n, s), s += 2, a.maxFunctionDefs = i.readUshort(n, s), s += 2, a.maxInstructionDefs = i.readUshort(n, s), s += 2, a.maxStackElements = i.readUshort(n, s), s += 2, a.maxSizeOfInstructions = i.readUshort(n, s), s += 2, a.maxComponentElements = i.readUshort(n, s), s += 2, a.maxComponentDepth = i.readUshort(n, s), s += 2), a;
    }, e.name = {}, e.name.parse = function(n, s, o) {
      var i = e._bin, a = {};
      i.readUshort(n, s), s += 2;
      var l = i.readUshort(n, s);
      s += 2, i.readUshort(n, s);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, f = 0; f < l; f++) {
        var p = i.readUshort(n, s);
        s += 2;
        var m = i.readUshort(n, s);
        s += 2;
        var g = i.readUshort(n, s);
        s += 2;
        var b = i.readUshort(n, s);
        s += 2;
        var v = i.readUshort(n, s);
        s += 2;
        var y = i.readUshort(n, s);
        s += 2;
        var x, N = h[b], w = d + 12 * l + y;
        if (p == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (p == 3 && m == 0)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 0)
          x = i.readASCII(n, w, v);
        else if (m == 1)
          x = i.readUnicode(n, w, v / 2);
        else if (m == 3)
          x = i.readUnicode(n, w, v / 2);
        else {
          if (p != 1)
            throw "unknown encoding " + m + ", platformID: " + p;
          x = i.readASCII(n, w, v), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var T = "p" + p + "," + g.toString(16);
        a[T] == null && (a[T] = {}), a[T][N !== void 0 ? N : b] = x, a[T]._lang = g;
      }
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 1033)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 0)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null && a[_]._lang == 3084)
          return a[_];
      for (var _ in a)
        if (a[_].postScriptName != null)
          return a[_];
      for (var _ in a) {
        u = _;
        break;
      }
      return console.debug("returning name table with languageID " + a[u]._lang), a[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, s, o) {
      var i = e._bin.readUshort(n, s);
      s += 2;
      var a = {};
      if (i == 0)
        e["OS/2"].version0(n, s, a);
      else if (i == 1)
        e["OS/2"].version1(n, s, a);
      else if (i == 2 || i == 3 || i == 4)
        e["OS/2"].version2(n, s, a);
      else {
        if (i != 5)
          throw "unknown OS/2 table version: " + i;
        e["OS/2"].version5(n, s, a);
      }
      return a;
    }, e["OS/2"].version0 = function(n, s, o) {
      var i = e._bin;
      return o.xAvgCharWidth = i.readShort(n, s), s += 2, o.usWeightClass = i.readUshort(n, s), s += 2, o.usWidthClass = i.readUshort(n, s), s += 2, o.fsType = i.readUshort(n, s), s += 2, o.ySubscriptXSize = i.readShort(n, s), s += 2, o.ySubscriptYSize = i.readShort(n, s), s += 2, o.ySubscriptXOffset = i.readShort(n, s), s += 2, o.ySubscriptYOffset = i.readShort(n, s), s += 2, o.ySuperscriptXSize = i.readShort(n, s), s += 2, o.ySuperscriptYSize = i.readShort(n, s), s += 2, o.ySuperscriptXOffset = i.readShort(n, s), s += 2, o.ySuperscriptYOffset = i.readShort(n, s), s += 2, o.yStrikeoutSize = i.readShort(n, s), s += 2, o.yStrikeoutPosition = i.readShort(n, s), s += 2, o.sFamilyClass = i.readShort(n, s), s += 2, o.panose = i.readBytes(n, s, 10), s += 10, o.ulUnicodeRange1 = i.readUint(n, s), s += 4, o.ulUnicodeRange2 = i.readUint(n, s), s += 4, o.ulUnicodeRange3 = i.readUint(n, s), s += 4, o.ulUnicodeRange4 = i.readUint(n, s), s += 4, o.achVendID = [i.readInt8(n, s), i.readInt8(n, s + 1), i.readInt8(n, s + 2), i.readInt8(n, s + 3)], s += 4, o.fsSelection = i.readUshort(n, s), s += 2, o.usFirstCharIndex = i.readUshort(n, s), s += 2, o.usLastCharIndex = i.readUshort(n, s), s += 2, o.sTypoAscender = i.readShort(n, s), s += 2, o.sTypoDescender = i.readShort(n, s), s += 2, o.sTypoLineGap = i.readShort(n, s), s += 2, o.usWinAscent = i.readUshort(n, s), s += 2, o.usWinDescent = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version1 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version0(n, s, o), o.ulCodePageRange1 = i.readUint(n, s), s += 4, o.ulCodePageRange2 = i.readUint(n, s), s += 4;
    }, e["OS/2"].version2 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version1(n, s, o), o.sxHeight = i.readShort(n, s), s += 2, o.sCapHeight = i.readShort(n, s), s += 2, o.usDefault = i.readUshort(n, s), s += 2, o.usBreak = i.readUshort(n, s), s += 2, o.usMaxContext = i.readUshort(n, s), s += 2;
    }, e["OS/2"].version5 = function(n, s, o) {
      var i = e._bin;
      return s = e["OS/2"].version2(n, s, o), o.usLowerOpticalPointSize = i.readUshort(n, s), s += 2, o.usUpperOpticalPointSize = i.readUshort(n, s), s += 2;
    }, e.post = {}, e.post.parse = function(n, s, o) {
      var i = e._bin, a = {};
      return a.version = i.readFixed(n, s), s += 4, a.italicAngle = i.readFixed(n, s), s += 4, a.underlinePosition = i.readShort(n, s), s += 2, a.underlineThickness = i.readShort(n, s), s += 2, a;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, s) {
      var o = n.cmap, i = -1;
      if (o.p0e4 != null ? i = o.p0e4 : o.p3e1 != null ? i = o.p3e1 : o.p1e0 != null ? i = o.p1e0 : o.p0e3 != null && (i = o.p0e3), i == -1)
        throw "no familiar platform and encoding!";
      var a = o.tables[i];
      if (a.format == 0)
        return s >= a.map.length ? 0 : a.map[s];
      if (a.format == 4) {
        for (var l = -1, u = 0; u < a.endCount.length; u++)
          if (s <= a.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || a.startCount[l] > s ? 0 : 65535 & (a.idRangeOffset[l] != 0 ? a.glyphIdArray[s - a.startCount[l] + (a.idRangeOffset[l] >> 1) - (a.idRangeOffset.length - l)] : s + a.idDelta[l]);
      }
      if (a.format == 12) {
        if (s > a.groups[a.groups.length - 1][1])
          return 0;
        for (u = 0; u < a.groups.length; u++) {
          var h = a.groups[u];
          if (h[0] <= s && s <= h[1])
            return h[2] + (s - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + a.format;
    }, e.U.glyphToPath = function(n, s) {
      var o = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[s]) {
        var i = n.SVG.entries[s];
        return i == null ? o : (typeof i == "string" && (i = e.SVG.toPath(i), n.SVG.entries[s] = i), i);
      }
      if (n.CFF) {
        var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, l = n.CFF, u = n.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= s; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[s], a, l, u, o);
      } else
        n.glyf && e.U._drawGlyf(s, n, o);
      return o;
    }, e.U._drawGlyf = function(n, s, o) {
      var i = s.glyf[n];
      i == null && (i = s.glyf[n] = e.glyf._parseGlyf(s, n)), i != null && (i.noc > -1 ? e.U._simpleGlyph(i, o) : e.U._compoGlyph(i, s, o));
    }, e.U._simpleGlyph = function(n, s) {
      for (var o = 0; o < n.noc; o++) {
        for (var i = o == 0 ? 0 : n.endPts[o - 1] + 1, a = n.endPts[o], l = i; l <= a; l++) {
          var u = l == i ? a : l - 1, h = l == a ? i : l + 1, d = 1 & n.flags[l], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[l], g = n.ys[l];
          if (l == i)
            if (d) {
              if (!f) {
                e.U.P.moveTo(s, m, g);
                continue;
              }
              e.U.P.moveTo(s, n.xs[u], n.ys[u]);
            } else
              f ? e.U.P.moveTo(s, n.xs[u], n.ys[u]) : e.U.P.moveTo(s, (n.xs[u] + m) / 2, (n.ys[u] + g) / 2);
          d ? f && e.U.P.lineTo(s, m, g) : p ? e.U.P.qcurveTo(s, m, g, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(s, m, g, (m + n.xs[h]) / 2, (g + n.ys[h]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(n, s, o) {
      for (var i = 0; i < n.parts.length; i++) {
        var a = { cmds: [], crds: [] }, l = n.parts[i];
        e.U._drawGlyf(l.glyphIndex, s, a);
        for (var u = l.m, h = 0; h < a.crds.length; h += 2) {
          var d = a.crds[h], f = a.crds[h + 1];
          o.crds.push(d * u.a + f * u.b + u.tx), o.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < a.cmds.length; h++)
          o.cmds.push(a.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, s) {
      var o = e._lctf.getInterval(s, n);
      return o == -1 ? 0 : s[o + 2];
    }, e.U.getPairAdjustment = function(n, s, o) {
      var i = !1;
      if (n.GPOS)
        for (var a = n.GPOS, l = a.lookupList, u = a.featureList, h = [], d = 0; d < u.length; d++) {
          var f = u[d];
          if (f.tag == "kern") {
            i = !0;
            for (var p = 0; p < f.tab.length; p++)
              if (!h[f.tab[p]]) {
                h[f.tab[p]] = !0;
                for (var m = l[f.tab[p]], g = 0; g < m.tabs.length; g++)
                  if (m.tabs[g] != null) {
                    var b, v = m.tabs[g];
                    if ((!v.coverage || (b = e._lctf.coverageIndex(v.coverage, s)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var x = v.pairsets[b];
                          for (d = 0; d < x.length; d++)
                            x[d].gid2 == o && (y = x[d]);
                        } else if (v.fmt == 2) {
                          var N = e.U._getGlyphClass(s, v.classDef1), w = e.U._getGlyphClass(o, v.classDef2);
                          y = v.matrix[N][w];
                        }
                        if (y) {
                          var T = 0;
                          return y.val1 && y.val1[2] && (T += y.val1[2]), y.val2 && y.val2[0] && (T += y.val2[0]), T;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (n.kern && !i) {
        var _ = n.kern.glyph1.indexOf(s);
        if (_ != -1) {
          var L = n.kern.rval[_].glyph2.indexOf(o);
          if (L != -1)
            return n.kern.rval[_].vals[L];
        }
      }
      return 0;
    }, e.U._applySubs = function(n, s, o, i) {
      for (var a = n.length - s - 1, l = 0; l < o.tabs.length; l++)
        if (o.tabs[l] != null) {
          var u, h = o.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[s])) != -1) {
            if (o.ltype == 1)
              n[s], h.fmt == 1 ? n[s] = n[s] + h.delta : n[s] = h.newg[u];
            else if (o.ltype == 4)
              for (var d = h.vals[u], f = 0; f < d.length; f++) {
                var p = d[f], m = p.chain.length;
                if (!(m > a)) {
                  for (var g = !0, b = 0, v = 0; v < m; v++) {
                    for (; n[s + b + (1 + v)] == -1; )
                      b++;
                    p.chain[v] != n[s + b + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (n[s] = p.nglyph, v = 0; v < m + b; v++)
                      n[s + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (o.ltype == 5 && h.fmt == 2)
              for (var y = e._lctf.getInterval(h.cDef, n[s]), x = h.cDef[y + 2], N = h.scset[x], w = 0; w < N.length; w++) {
                var T = N[w], _ = T.input;
                if (!(_.length > a)) {
                  for (g = !0, v = 0; v < _.length; v++) {
                    var L = e._lctf.getInterval(h.cDef, n[s + 1 + v]);
                    if (y == -1 && h.cDef[L + 2] != _[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var A = T.substLookupRecords;
                    for (f = 0; f < A.length; f += 2)
                      A[f], A[f + 1];
                  }
                }
              }
            else if (o.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(n, h.backCvg, s - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, s) || !e.U._glsCovered(n, h.ahedCvg, s + h.inptCvg.length))
                continue;
              var U = h.lookupRec;
              for (w = 0; w < U.length; w += 2) {
                y = U[w];
                var S = i[U[w + 1]];
                e.U._applySubs(n, s + y, S, i);
              }
            }
          }
        }
    }, e.U._glsCovered = function(n, s, o) {
      for (var i = 0; i < s.length; i++)
        if (e._lctf.coverageIndex(s[i], n[o + i]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, s, o) {
      for (var i = { cmds: [], crds: [] }, a = 0, l = 0; l < s.length; l++) {
        var u = s[l];
        if (u != -1) {
          for (var h = l < s.length - 1 && s[l + 1] != -1 ? s[l + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2)
            i.crds.push(d.crds[f] + a), i.crds.push(d.crds[f + 1]);
          for (o && i.cmds.push(o), f = 0; f < d.cmds.length; f++)
            i.cmds.push(d.cmds[f]);
          o && i.cmds.push("X"), a += n.hmtx.aWidth[u], l < s.length - 1 && (a += e.U.getPairAdjustment(n, u, h));
        }
      }
      return i;
    }, e.U.P = {}, e.U.P.moveTo = function(n, s, o) {
      n.cmds.push("M"), n.crds.push(s, o);
    }, e.U.P.lineTo = function(n, s, o) {
      n.cmds.push("L"), n.crds.push(s, o);
    }, e.U.P.curveTo = function(n, s, o, i, a, l, u) {
      n.cmds.push("C"), n.crds.push(s, o, i, a, l, u);
    }, e.U.P.qcurveTo = function(n, s, o, i, a) {
      n.cmds.push("Q"), n.crds.push(s, o, i, a);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, s, o, i, a) {
      for (var l = s.stack, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open, p = 0, m = s.x, g = s.y, b = 0, v = 0, y = 0, x = 0, N = 0, w = 0, T = 0, _ = 0, L = 0, A = 0, U = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, U);
        var S = U.val;
        if (p += U.size, S == "o1" || S == "o18")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o3" || S == "o23")
          l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (S == "o4")
          l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), f && e.U.P.closePath(a), g += l.pop(), e.U.P.moveTo(a, m, g), f = !0;
        else if (S == "o5")
          for (; l.length > 0; )
            m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
        else if (S == "o6" || S == "o7")
          for (var R = l.length, E = S == "o6", D = 0; D < R; D++) {
            var P = l.shift();
            E ? m += P : g += P, E = !E, e.U.P.lineTo(a, m, g);
          }
        else if (S == "o8" || S == "o24") {
          R = l.length;
          for (var se = 0; se + 6 <= R; )
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g), se += 6;
          S == "o24" && (m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g));
        } else {
          if (S == "o11")
            break;
          if (S == "o1234" || S == "o1235" || S == "o1236" || S == "o1237")
            S == "o1234" && (v = g, y = (b = m + l.shift()) + l.shift(), A = x = v + l.shift(), w = x, _ = g, m = (T = (N = (L = y + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1235" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), m = T + l.shift(), g = _ + l.shift(), l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1236" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), A = x = v + l.shift(), w = x, T = (N = (L = y + l.shift()) + l.shift()) + l.shift(), _ = w + l.shift(), m = T + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g)), S == "o1237" && (b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), L = y + l.shift(), A = x + l.shift(), N = L + l.shift(), w = A + l.shift(), T = N + l.shift(), _ = w + l.shift(), Math.abs(T - m) > Math.abs(_ - g) ? m = T + l.shift() : g = _ + l.shift(), e.U.P.curveTo(a, b, v, y, x, L, A), e.U.P.curveTo(a, N, w, T, _, m, g));
          else if (S == "o14") {
            if (l.length > 0 && !h && (d = l.shift() + o.nominalWidthX, h = !0), l.length == 4) {
              var oe = l.shift(), H = l.shift(), X = l.shift(), C = l.shift(), O = e.CFF.glyphBySE(o, X), I = e.CFF.glyphBySE(o, C);
              e.U._drawCFF(o.CharStrings[O], s, o, i, a), s.x = oe, s.y = H, e.U._drawCFF(o.CharStrings[I], s, o, i, a);
            }
            f && (e.U.P.closePath(a), f = !1);
          } else if (S == "o19" || S == "o20")
            l.length % 2 != 0 && !h && (d = l.shift() + i.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, p += u + 7 >> 3;
          else if (S == "o21")
            l.length > 2 && !h && (d = l.shift() + i.nominalWidthX, h = !0), g += l.pop(), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o22")
            l.length > 1 && !h && (d = l.shift() + i.nominalWidthX, h = !0), m += l.pop(), f && e.U.P.closePath(a), e.U.P.moveTo(a, m, g), f = !0;
          else if (S == "o25") {
            for (; l.length > 6; )
              m += l.shift(), g += l.shift(), e.U.P.lineTo(a, m, g);
            b = m + l.shift(), v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          } else if (S == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              b = m, v = g + l.shift(), m = y = b + l.shift(), g = (x = v + l.shift()) + l.shift(), e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o27")
            for (l.length % 2 && (g += l.shift()); l.length > 0; )
              v = g, y = (b = m + l.shift()) + l.shift(), x = v + l.shift(), m = y + l.shift(), g = x, e.U.P.curveTo(a, b, v, y, x, m, g);
          else if (S == "o10" || S == "o29") {
            var k = S == "o10" ? i : o;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var z = l.pop(), Q = k.Subrs[z + k.Bias];
              s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f, e.U._drawCFF(Q, s, o, i, a), m = s.x, g = s.y, u = s.nStems, h = s.haveWidth, d = s.width, f = s.open;
            }
          } else if (S == "o30" || S == "o31") {
            var W = l.length, q = (se = 0, S == "o31");
            for (se += W - (R = -3 & W); se < R; )
              q ? (v = g, y = (b = m + l.shift()) + l.shift(), g = (x = v + l.shift()) + l.shift(), R - se == 5 ? (m = y + l.shift(), se++) : m = y, q = !1) : (b = m, v = g + l.shift(), y = b + l.shift(), x = v + l.shift(), m = y + l.shift(), R - se == 5 ? (g = x + l.shift(), se++) : g = x, q = !0), e.U.P.curveTo(a, b, v, y, x, m, g), se += 4;
          } else {
            if ((S + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + S, n), S;
            l.push(S);
          }
        }
      }
      s.x = m, s.y = g, s.nStems = u, s.haveWidth = h, s.width = d, s.open = f;
    };
    var t = e, r = { Typr: t };
    return c.Typr = t, c.default = r, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function pM() {
  return function(c) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), i = function(S, R) {
      for (var E = new t(31), D = 0; D < 31; ++D)
        E[D] = R += 1 << S[D - 1];
      var P = new r(E[30]);
      for (D = 1; D < 30; ++D)
        for (var se = E[D]; se < E[D + 1]; ++se)
          P[se] = se - E[D] << 5 | D;
      return [E, P];
    }, a = i(n, 2), l = a[0], u = a[1];
    l[28] = 258, u[258] = 28;
    for (var h = i(s, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(S, R, E) {
      for (var D = S.length, P = 0, se = new t(R); P < D; ++P)
        ++se[S[P] - 1];
      var oe, H = new t(R);
      for (P = 0; P < R; ++P)
        H[P] = H[P - 1] + se[P - 1] << 1;
      if (E) {
        oe = new t(1 << R);
        var X = 15 - R;
        for (P = 0; P < D; ++P)
          if (S[P])
            for (var C = P << 4 | S[P], O = R - S[P], I = H[S[P] - 1]++ << O, k = I | (1 << O) - 1; I <= k; ++I)
              oe[d[I] >>> X] = C;
      } else
        for (oe = new t(D), P = 0; P < D; ++P)
          S[P] && (oe[P] = d[H[S[P] - 1]++] >>> 15 - S[P]);
      return oe;
    }, g = new e(288);
    for (f = 0; f < 144; ++f)
      g[f] = 8;
    for (f = 144; f < 256; ++f)
      g[f] = 9;
    for (f = 256; f < 280; ++f)
      g[f] = 7;
    for (f = 280; f < 288; ++f)
      g[f] = 8;
    var b = new e(32);
    for (f = 0; f < 32; ++f)
      b[f] = 5;
    var v = m(g, 9, 1), y = m(b, 5, 1), x = function(S) {
      for (var R = S[0], E = 1; E < S.length; ++E)
        S[E] > R && (R = S[E]);
      return R;
    }, N = function(S, R, E) {
      var D = R / 8 | 0;
      return (S[D] | S[D + 1] << 8) >> (7 & R) & E;
    }, w = function(S, R) {
      var E = R / 8 | 0;
      return (S[E] | S[E + 1] << 8 | S[E + 2] << 16) >> (7 & R);
    }, T = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], _ = function(S, R, E) {
      var D = new Error(R || T[S]);
      if (D.code = S, Error.captureStackTrace && Error.captureStackTrace(D, _), !E)
        throw D;
      return D;
    }, L = function(S, R, E) {
      var D = S.length;
      if (!D || E && !E.l && D < 5)
        return R || new e(0);
      var P = !R || E, se = !E || E.i;
      E || (E = {}), R || (R = new e(3 * D));
      var oe, H = function(ge) {
        var We = R.length;
        if (ge > We) {
          var $e = new e(Math.max(2 * We, ge));
          $e.set(R), R = $e;
        }
      }, X = E.f || 0, C = E.p || 0, O = E.b || 0, I = E.l, k = E.d, z = E.m, Q = E.n, W = 8 * D;
      do {
        if (!I) {
          E.f = X = N(S, C, 1);
          var q = N(S, C + 1, 3);
          if (C += 3, !q) {
            var ie = S[(fe = ((oe = C) / 8 | 0) + (7 & oe && 1) + 4) - 4] | S[fe - 3] << 8, ae = fe + ie;
            if (ae > D) {
              se && _(0);
              break;
            }
            P && H(O + ie), R.set(S.subarray(fe, ae), O), E.b = O += ie, E.p = C = 8 * ae;
            continue;
          }
          if (q == 1)
            I = v, k = y, z = 9, Q = 5;
          else if (q == 2) {
            var $ = N(S, C, 31) + 257, F = N(S, C + 10, 15) + 4, te = $ + N(S, C + 5, 31) + 1;
            C += 14;
            for (var Z = new e(te), Y = new e(19), ee = 0; ee < F; ++ee)
              Y[o[ee]] = N(S, C + 3 * ee, 7);
            C += 3 * F;
            var pe = x(Y), ne = (1 << pe) - 1, he = m(Y, pe, 1);
            for (ee = 0; ee < te; ) {
              var fe, K = he[N(S, C, ne)];
              if (C += 15 & K, (fe = K >>> 4) < 16)
                Z[ee++] = fe;
              else {
                var Ae = 0, me = 0;
                for (fe == 16 ? (me = 3 + N(S, C, 3), C += 2, Ae = Z[ee - 1]) : fe == 17 ? (me = 3 + N(S, C, 7), C += 3) : fe == 18 && (me = 11 + N(S, C, 127), C += 7); me--; )
                  Z[ee++] = Ae;
              }
            }
            var be = Z.subarray(0, $), de = Z.subarray($);
            z = x(be), Q = x(de), I = m(be, z, 1), k = m(de, Q, 1);
          } else
            _(1);
          if (C > W) {
            se && _(0);
            break;
          }
        }
        P && H(O + 131072);
        for (var qe = (1 << z) - 1, le = (1 << Q) - 1, Ne = C; ; Ne = C) {
          var ye = (Ae = I[w(S, C) & qe]) >>> 4;
          if ((C += 15 & Ae) > W) {
            se && _(0);
            break;
          }
          if (Ae || _(2), ye < 256)
            R[O++] = ye;
          else {
            if (ye == 256) {
              Ne = C, I = null;
              break;
            }
            var Te = ye - 254;
            if (ye > 264) {
              var Pe = n[ee = ye - 257];
              Te = N(S, C, (1 << Pe) - 1) + l[ee], C += Pe;
            }
            var Je = k[w(S, C) & le], _e = Je >>> 4;
            if (Je || _(3), C += 15 & Je, de = h[_e], _e > 3 && (Pe = s[_e], de += w(S, C) & (1 << Pe) - 1, C += Pe), C > W) {
              se && _(0);
              break;
            }
            P && H(O + 131072);
            for (var Ue = O + Te; O < Ue; O += 4)
              R[O] = R[O - de], R[O + 1] = R[O + 1 - de], R[O + 2] = R[O + 2 - de], R[O + 3] = R[O + 3 - de];
            O = Ue;
          }
        }
        E.l = I, E.p = Ne, E.b = O, I && (X = 1, E.m = z, E.d = k, E.n = Q);
      } while (!X);
      return O == R.length ? R : function(ge, We, $e) {
        (We == null || We < 0) && (We = 0), ($e == null || $e > ge.length) && ($e = ge.length);
        var ht = new (ge instanceof t ? t : ge instanceof r ? r : e)($e - We);
        return ht.set(ge.subarray(We, $e)), ht;
      }(R, 0, O);
    }, A = new e(0), U = typeof TextDecoder < "u" && new TextDecoder();
    try {
      U.decode(A, { stream: !0 });
    } catch {
    }
    return c.convert_streams = function(S) {
      var R = new DataView(S), E = 0;
      function D() {
        var $ = R.getUint16(E);
        return E += 2, $;
      }
      function P() {
        var $ = R.getUint32(E);
        return E += 4, $;
      }
      function se($) {
        ie.setUint16(ae, $), ae += 2;
      }
      function oe($) {
        ie.setUint32(ae, $), ae += 4;
      }
      for (var H = { signature: P(), flavor: P(), length: P(), numTables: D(), reserved: D(), totalSfntSize: P(), majorVersion: D(), minorVersion: D(), metaOffset: P(), metaLength: P(), metaOrigLength: P(), privOffset: P(), privLength: P() }, X = 0; Math.pow(2, X) <= H.numTables; )
        X++;
      X--;
      for (var C = 16 * Math.pow(2, X), O = 16 * H.numTables - C, I = 12, k = [], z = 0; z < H.numTables; z++)
        k.push({ tag: P(), offset: P(), compLength: P(), origLength: P(), origChecksum: P() }), I += 16;
      var Q, W = new Uint8Array(12 + 16 * k.length + k.reduce(function($, F) {
        return $ + F.origLength + 4;
      }, 0)), q = W.buffer, ie = new DataView(q), ae = 0;
      return oe(H.flavor), se(H.numTables), se(C), se(X), se(O), k.forEach(function($) {
        oe($.tag), oe($.origChecksum), oe(I), oe($.origLength), $.outOffset = I, (I += $.origLength) % 4 != 0 && (I += 4 - I % 4);
      }), k.forEach(function($) {
        var F, te = S.slice($.offset, $.offset + $.compLength);
        if ($.compLength != $.origLength) {
          var Z = new Uint8Array($.origLength);
          F = new Uint8Array(te, 2), L(F, Z);
        } else
          Z = new Uint8Array(te);
        W.set(Z, $.outOffset);
        var Y = 0;
        (I = $.outOffset + $.origLength) % 4 != 0 && (Y = 4 - I % 4), W.set(new Uint8Array(Y).buffer, $.outOffset + $.origLength), Q = I + Y;
      }), q.slice(0, Q);
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({}).convert_streams;
}
function mM(c, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, s = 2, o = 4, i = 8, a = 16, l = 32;
  let u;
  function h(N) {
    if (!u) {
      const w = {
        R: s,
        L: n,
        D: o,
        C: a,
        U: l,
        T: i
      };
      u = /* @__PURE__ */ new Map();
      for (let T in r) {
        let _ = 0;
        r[T].split(",").forEach((L) => {
          let [A, U] = L.split("+");
          A = parseInt(A, 36), U = U ? parseInt(U, 36) : 0, u.set(_ += A, w[T]);
          for (let S = U; S--; )
            u.set(++_, w[T]);
        });
      }
    }
    return u.get(N) || l;
  }
  const d = 1, f = 2, p = 3, m = 4, g = [null, "isol", "init", "fina", "medi"];
  function b(N) {
    const w = new Uint8Array(N.length);
    let T = l, _ = d, L = -1;
    for (let A = 0; A < N.length; A++) {
      const U = N.codePointAt(A);
      let S = h(U) | 0, R = d;
      S & i || (T & (n | o | a) ? S & (s | o | a) ? (R = p, (_ === d || _ === p) && w[L]++) : S & (n | l) && (_ === f || _ === m) && w[L]-- : T & (s | l) && (_ === f || _ === m) && w[L]--, _ = w[A] = R, T = S, L = A, U > 65535 && A++);
    }
    return w;
  }
  function v(N, w) {
    const T = [];
    for (let L = 0; L < w.length; L++) {
      const A = w.codePointAt(L);
      A > 65535 && L++, T.push(c.U.codeToGlyph(N, A));
    }
    const _ = N.GSUB;
    if (_) {
      const { lookupList: L, featureList: A } = _;
      let U;
      const S = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, R = [];
      A.forEach((E) => {
        if (S.test(E.tag))
          for (let D = 0; D < E.tab.length; D++) {
            if (R[E.tab[D]])
              continue;
            R[E.tab[D]] = !0;
            const P = L[E.tab[D]], se = /^(isol|init|fina|medi)$/.test(E.tag);
            se && !U && (U = b(w));
            for (let oe = 0; oe < T.length; oe++)
              (!U || !se || g[U[oe]] === E.tag) && c.U._applySubs(T, oe, P, L);
          }
      });
    }
    return T;
  }
  function y(...N) {
    for (let w = 0; w < N.length; w++)
      if (typeof N[w] == "number")
        return N[w];
  }
  function x(N) {
    const w = /* @__PURE__ */ Object.create(null), T = N["OS/2"], _ = N.hhea, L = N.head.unitsPerEm, A = y(T && T.sTypoAscender, _ && _.ascender, L), U = {
      unitsPerEm: L,
      ascender: A,
      descender: y(T && T.sTypoDescender, _ && _.descender, 0),
      capHeight: y(T && T.sCapHeight, A),
      xHeight: y(T && T.sxHeight, A),
      lineGap: y(T && T.sTypoLineGap, _ && _.lineGap),
      supportsCodePoint(S) {
        return c.U.codeToGlyph(N, S) > 0;
      },
      forEachGlyph(S, R, E, D) {
        let P = 0;
        const se = 1 / U.unitsPerEm * R, oe = v(N, S);
        let H = 0, X = -1;
        return oe.forEach((C, O) => {
          if (C !== -1) {
            let I = w[C];
            if (!I) {
              const { cmds: k, crds: z } = c.U.glyphToPath(N, C);
              let Q = "", W = 0;
              for (let F = 0, te = k.length; F < te; F++) {
                const Z = t[k[F]];
                Q += k[F];
                for (let Y = 1; Y <= Z; Y++)
                  Q += (Y > 1 ? "," : "") + z[W++];
              }
              let q, ie, ae, $;
              if (z.length) {
                q = ie = 1 / 0, ae = $ = -1 / 0;
                for (let F = 0, te = z.length; F < te; F += 2) {
                  let Z = z[F], Y = z[F + 1];
                  Z < q && (q = Z), Y < ie && (ie = Y), Z > ae && (ae = Z), Y > $ && ($ = Y);
                }
              } else
                q = ae = ie = $ = 0;
              I = w[C] = {
                index: C,
                advanceWidth: N.hmtx.aWidth[C],
                xMin: q,
                yMin: ie,
                xMax: ae,
                yMax: $,
                path: Q,
                pathCommandCount: k.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (P += c.U.getPairAdjustment(N, X, C) * se), D.call(null, I, P, H), I.advanceWidth && (P += I.advanceWidth * se), E && (P += E * R), X = C;
          }
          H += S.codePointAt(H) > 65535 ? 2 : 1;
        }), P;
      }
    };
    return U;
  }
  return function(w) {
    const T = new Uint8Array(w, 0, 4), _ = c._bin.readASCII(T, 0, 4);
    if (_ === "wOFF")
      w = e(w);
    else if (_ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(c.parse(w)[0]);
  };
}
const gM = /* @__PURE__ */ fs({
  name: "Typr Font Parser",
  dependencies: [fM, pM, mM],
  init(c, e, t) {
    const r = c(), n = e();
    return t(r, n);
  }
}), yM = gM;
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function vM() {
  return function(c) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var x = y >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var x = this.buckets.get(y >> 5);
      return x !== void 0 && (x & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(x, N) {
        y.push((+N).toString(36) + ":" + x.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var x = this;
      this.buckets.clear(), y.split(",").forEach(function(N) {
        var w = N.split(":");
        x.buckets.set(parseInt(w[0], 36), parseInt(w[1], 36));
      });
    };
    var t = Math.pow(2, 8), r = t - 1, n = ~r;
    function s(y) {
      var x = function(w) {
        return w & n;
      }(y).toString(16), N = function(w) {
        return (w & n) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + x + "-" + N + ".json";
    }
    function o(y, x) {
      var N = y & r, w = x.codePointAt(N / 6 | 0);
      return ((w = (w || 48) - 48) & 1 << N % 6) != 0;
    }
    function i(y, x) {
      var N;
      (N = y, N.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(w) {
        return w.split("-").map(function(T) {
          return parseInt(T.trim(), 16);
        });
      })).forEach(function(w) {
        var T = w[0], _ = w[1];
        _ === void 0 && (_ = T), x(T, _);
      });
    }
    function a(y, x) {
      i(y, function(N, w) {
        for (var T = N; T <= w; T++)
          x(T);
      });
    }
    var l = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(y) {
      var x = h.get(y);
      return x || (x = new e(), a(y.ranges, function(N) {
        return x.add(N);
      }), h.set(y, x)), x;
    }
    var p, m = /* @__PURE__ */ new Map();
    function g(y, x, N) {
      return y[x] ? x : y[N] ? N : function(w) {
        for (var T in w)
          return T;
      }(y);
    }
    function b(y, x) {
      var N = x;
      if (!y.includes(N)) {
        N = 1 / 0;
        for (var w = 0; w < y.length; w++)
          Math.abs(y[w] - x) < Math.abs(N - x) && (N = y[w]);
      }
      return N;
    }
    function v(y) {
      return p || (p = /* @__PURE__ */ new Set(), a("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        p.add(x);
      })), p.has(y);
    }
    return c.CodePointSet = e, c.clearCache = function() {
      l = {}, u = {};
    }, c.getFontsForString = function(y, x) {
      x === void 0 && (x = {});
      var N, w = x.lang;
      w === void 0 && (w = /\p{Script=Hangul}/u.test(N = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(N) ? "ja" : "en");
      var T = x.category;
      T === void 0 && (T = "sans-serif");
      var _ = x.style;
      _ === void 0 && (_ = "normal");
      var L = x.weight;
      L === void 0 && (L = 400);
      var A = (x.dataUrl || d).replace(/\/$/g, ""), U = /* @__PURE__ */ new Map(), S = new Uint8Array(y.length), R = {}, E = {}, D = new Array(y.length), P = /* @__PURE__ */ new Map(), se = !1;
      function oe(C) {
        var O = m.get(C);
        return O || (O = fetch(A + "/" + C).then(function(I) {
          if (!I.ok)
            throw new Error(I.statusText);
          return I.json().then(function(k) {
            if (!Array.isArray(k) || k[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + k[0]);
            return k[1];
          });
        }).catch(function(I) {
          if (A !== d)
            return se || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + I.message), se = !0), A = d, m.delete(C), oe(C);
          throw I;
        }), m.set(C, O)), O;
      }
      for (var H = function(C) {
        var O = y.codePointAt(C), I = s(O);
        D[C] = I, l[I] || P.has(I) || P.set(I, oe(I).then(function(k) {
          l[I] = k;
        })), O > 65535 && (C++, X = C);
      }, X = 0; X < y.length; X++)
        H(X);
      return Promise.all(P.values()).then(function() {
        P.clear();
        for (var C = function(I) {
          var k = y.codePointAt(I), z = null, Q = l[D[I]], W = void 0;
          for (var q in Q) {
            var ie = E[q];
            if (ie === void 0 && (ie = E[q] = new RegExp(q).test(w || "en")), ie) {
              for (var ae in W = q, Q[q])
                if (o(k, Q[q][ae])) {
                  z = ae;
                  break;
                }
              break;
            }
          }
          if (!z) {
            e:
              for (var $ in Q)
                if ($ !== W) {
                  for (var F in Q[$])
                    if (o(k, Q[$][F])) {
                      z = F;
                      break e;
                    }
                }
          }
          z || (console.debug("No font coverage for U+" + k.toString(16)), z = "latin"), D[I] = z, u[z] || P.has(z) || P.set(z, oe("font-meta/" + z + ".json").then(function(te) {
            u[z] = te;
          })), k > 65535 && (I++, O = I);
        }, O = 0; O < y.length; O++)
          C(O);
        return Promise.all(P.values());
      }).then(function() {
        for (var C, O = null, I = 0; I < y.length; I++) {
          var k = y.codePointAt(I);
          if (O && (v(k) || f(O).has(k)))
            S[I] = S[I - 1];
          else {
            O = u[D[I]];
            var z = R[O.id];
            if (!z) {
              var Q = O.typeforms, W = g(Q, T, "sans-serif"), q = g(Q[W], _, "normal"), ie = b((C = Q[W]) === null || C === void 0 ? void 0 : C[q], L);
              z = R[O.id] = A + "/font-files/" + O.id + "/" + W + "." + q + "." + ie + ".woff";
            }
            var ae = U.get(z);
            ae == null && (ae = U.size, U.set(z, ae)), S[I] = ae;
          }
          k > 65535 && (I++, S[I] = S[I - 1]);
        }
        return { fontUrls: Array.from(U.keys()), chars: S };
      });
    }, Object.defineProperty(c, "__esModule", { value: !0 }), c;
  }({});
}
function xM(c, e) {
  const t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function n(o, i) {
    const a = (l) => {
      console.error(`Failure loading font ${o}`, l);
    };
    try {
      const l = new XMLHttpRequest();
      l.open("get", o, !0), l.responseType = "arraybuffer", l.onload = function() {
        if (l.status >= 400)
          a(new Error(l.statusText));
        else if (l.status > 0)
          try {
            const u = c(l.response);
            u.src = o, i(u);
          } catch (u) {
            a(u);
          }
      }, l.onerror = a, l.send();
    } catch (l) {
      a(l);
    }
  }
  function s(o, i) {
    let a = t[o];
    a ? i(a) : r[o] ? r[o].push(i) : (r[o] = [i], n(o, (l) => {
      l.src = o, t[o] = l, r[o].forEach((u) => u(l)), delete r[o];
    }));
  }
  return function(o, i, {
    lang: a,
    fonts: l = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(o.length), p = [];
    o.length || v();
    const m = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), l && !Array.isArray(l) && (l = [l]), l = l.slice().filter((x) => !x.lang || x.lang.test(a)).reverse(), l.length) {
      let T = 0;
      (function _(L = 0) {
        for (let A = L, U = o.length; A < U; A++) {
          const S = o.codePointAt(A);
          if (T === 1 && p[f[A - 1]].supportsCodePoint(S) || /\s/.test(o[A]))
            f[A] = f[A - 1], T === 2 && (g[g.length - 1][1] = A);
          else
            for (let R = f[A], E = l.length; R <= E; R++)
              if (R === E) {
                const D = T === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                D[1] = A, T = 2;
              } else {
                f[A] = R;
                const { src: D, unicodeRange: P } = l[R];
                if (!P || y(S, P)) {
                  const se = t[D];
                  if (!se) {
                    s(D, () => {
                      _(A);
                    });
                    return;
                  }
                  if (se.supportsCodePoint(S)) {
                    let oe = m.get(se);
                    typeof oe != "number" && (oe = p.length, p.push(se), m.set(se, oe)), f[A] = oe, T = 1;
                    break;
                  }
                }
              }
          S > 65535 && A + 1 < U && (f[A + 1] = f[A], A++, T === 2 && (g[g.length - 1][1] = A));
        }
        b();
      })();
    } else
      g.push([0, o.length - 1]), b();
    function b() {
      if (g.length) {
        const x = g.map((N) => o.substring(N[0], N[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: a || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: N, chars: w }) => {
          const T = p.length;
          let _ = 0;
          g.forEach((A) => {
            for (let U = 0, S = A[1] - A[0]; U <= S; U++)
              f[A[0] + U] = w[_++] + T;
            _++;
          });
          let L = 0;
          N.forEach((A, U) => {
            s(A, (S) => {
              p[U + T] = S, ++L === N.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      i({
        chars: f,
        fonts: p
      });
    }
    function y(x, N) {
      for (let w = 0; w < N.length; w++) {
        const [T, _ = T] = N[w];
        if (T <= x && x <= _)
          return !0;
      }
      return !1;
    }
  };
}
const bM = /* @__PURE__ */ fs({
  name: "FontResolver",
  dependencies: [
    xM,
    yM,
    vM
  ],
  init(c, e, t) {
    return c(e, t());
  }
});
function NM(c, e) {
  const r = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", s = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function o({ text: p, lang: m, fonts: g, style: b, weight: v, preResolvedFonts: y, unicodeFontsURL: x }, N) {
    const w = ({ chars: T, fonts: _ }) => {
      let L, A;
      const U = [];
      for (let S = 0; S < T.length; S++)
        T[S] !== A ? (A = T[S], U.push(L = { start: S, end: S, fontObj: _[T[S]] })) : L.end = S;
      N(U);
    };
    y ? w(y) : c(
      p,
      w,
      { lang: m, fonts: g, style: b, weight: v, unicodeFontsURL: x }
    );
  }
  function i({
    text: p = "",
    font: m,
    lang: g,
    sdfGlyphSize: b = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: x = "normal",
    letterSpacing: N = 0,
    lineHeight: w = "normal",
    maxWidth: T = 1 / 0,
    direction: _,
    textAlign: L = "left",
    textIndent: A = 0,
    whiteSpace: U = "normal",
    overflowWrap: S = "normal",
    anchorX: R = 0,
    anchorY: E = 0,
    metricsOnly: D = !1,
    unicodeFontsURL: P,
    preResolvedFonts: se = null,
    includeCaretPositions: oe = !1,
    chunkedBoundsSize: H = 8192,
    colorRanges: X = null
  }, C) {
    const O = h(), I = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, N = +N, T = +T, w = w || "normal", A = +A, o({
      text: p,
      lang: g,
      style: x,
      weight: y,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: P,
      preResolvedFonts: se
    }, (k) => {
      I.fontLoad = h() - O;
      const z = isFinite(T);
      let Q = null, W = null, q = null, ie = null, ae = null, $ = null, F = null, te = null, Z = 0, Y = 0, ee = U !== "nowrap";
      const pe = /* @__PURE__ */ new Map(), ne = h();
      let he = A, fe = 0, K = new d();
      const Ae = [K];
      k.forEach((le) => {
        const { fontObj: Ne } = le, { ascender: ye, descender: Te, unitsPerEm: Pe, lineGap: Je, capHeight: _e, xHeight: Ue } = Ne;
        let ge = pe.get(Ne);
        if (!ge) {
          const xe = v / Pe, Oe = w === "normal" ? (ye - Te + Je) * xe : w * v, zt = (Oe - (ye - Te) * xe) / 2, Ee = Math.min(Oe, (ye - Te) * xe), Le = (ye + Te) / 2 * xe + Ee / 2;
          ge = {
            index: pe.size,
            src: Ne.src,
            fontObj: Ne,
            fontSizeMult: xe,
            unitsPerEm: Pe,
            ascender: ye * xe,
            descender: Te * xe,
            capHeight: _e * xe,
            xHeight: Ue * xe,
            lineHeight: Oe,
            baseline: -zt - ye * xe,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: (ye + Te) / 2 * xe + Ee / 2,
            caretBottom: Le - Ee
          }, pe.set(Ne, ge);
        }
        const { fontSizeMult: We } = ge, $e = p.slice(le.start, le.end + 1);
        let ht, Qe;
        Ne.forEachGlyph($e, v, N, (xe, Oe, zt) => {
          Oe += fe, zt += le.start, ht = Oe, Qe = xe;
          const Ee = p.charAt(zt), Le = xe.advanceWidth * We, tt = K.count;
          let De;
          if ("isEmpty" in xe || (xe.isWhitespace = !!Ee && new RegExp(n).test(Ee), xe.canBreakAfter = !!Ee && s.test(Ee), xe.isEmpty = xe.xMin === xe.xMax || xe.yMin === xe.yMax || r.test(Ee)), !xe.isWhitespace && !xe.isEmpty && Y++, ee && z && !xe.isWhitespace && Oe + Le + he > T && tt) {
            if (K.glyphAt(tt - 1).glyphObj.canBreakAfter)
              De = new d(), he = -Oe;
            else
              for (let He = tt; He--; )
                if (He === 0 && S === "break-word") {
                  De = new d(), he = -Oe;
                  break;
                } else if (K.glyphAt(He).glyphObj.canBreakAfter) {
                  De = K.splitAt(He + 1);
                  const yt = De.glyphAt(0).x;
                  he -= yt;
                  for (let at = De.count; at--; )
                    De.glyphAt(at).x -= yt;
                  break;
                }
            De && (K.isSoftWrapped = !0, K = De, Ae.push(K), Z = T);
          }
          let we = K.glyphAt(K.count);
          we.glyphObj = xe, we.x = Oe + he, we.width = Le, we.charIndex = zt, we.fontData = ge, Ee === `
` && (K = new d(), Ae.push(K), he = -(Oe + Le + N * v) + A);
        }), fe = ht + Qe.advanceWidth * We + N * v;
      });
      let me = 0;
      Ae.forEach((le) => {
        let Ne = !0;
        for (let ye = le.count; ye--; ) {
          const Te = le.glyphAt(ye);
          Ne && !Te.glyphObj.isWhitespace && (le.width = Te.x + Te.width, le.width > Z && (Z = le.width), Ne = !1);
          let { lineHeight: Pe, capHeight: Je, xHeight: _e, baseline: Ue } = Te.fontData;
          Pe > le.lineHeight && (le.lineHeight = Pe);
          const ge = Ue - le.baseline;
          ge < 0 && (le.baseline += ge, le.cap += ge, le.ex += ge), le.cap = Math.max(le.cap, le.baseline + Je), le.ex = Math.max(le.ex, le.baseline + _e);
        }
        le.baseline -= me, le.cap -= me, le.ex -= me, me += le.lineHeight;
      });
      let be = 0, de = 0;
      if (R && (typeof R == "number" ? be = -R : typeof R == "string" && (be = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : l(R)))), E && (typeof E == "number" ? de = -E : typeof E == "string" && (de = E === "top" ? 0 : E === "top-baseline" ? -Ae[0].baseline : E === "top-cap" ? -Ae[0].cap : E === "top-ex" ? -Ae[0].ex : E === "middle" ? me / 2 : E === "bottom" ? me : E === "bottom-baseline" ? Ae[Ae.length - 1].baseline : l(E) * me)), !D) {
        const le = e.getEmbeddingLevels(p, _);
        Q = new Uint16Array(Y), W = new Uint8Array(Y), q = new Float32Array(Y * 2), ie = {}, F = [1 / 0, 1 / 0, -1 / 0, -1 / 0], te = [], oe && ($ = new Float32Array(p.length * 4)), X && (ae = new Uint8Array(Y * 3));
        let Ne = 0, ye = -1, Te = -1, Pe, Je;
        if (Ae.forEach((_e, Ue) => {
          let { count: ge, width: We } = _e;
          if (ge > 0) {
            let $e = 0;
            for (let Ee = ge; Ee-- && _e.glyphAt(Ee).glyphObj.isWhitespace; )
              $e++;
            let ht = 0, Qe = 0;
            if (L === "center")
              ht = (Z - We) / 2;
            else if (L === "right")
              ht = Z - We;
            else if (L === "justify" && _e.isSoftWrapped) {
              let Ee = 0;
              for (let Le = ge - $e; Le--; )
                _e.glyphAt(Le).glyphObj.isWhitespace && Ee++;
              Qe = (Z - We) / Ee;
            }
            if (Qe || ht) {
              let Ee = 0;
              for (let Le = 0; Le < ge; Le++) {
                let tt = _e.glyphAt(Le);
                const De = tt.glyphObj;
                tt.x += ht + Ee, Qe !== 0 && De.isWhitespace && Le < ge - $e && (Ee += Qe, tt.width += Qe);
              }
            }
            const xe = e.getReorderSegments(
              p,
              le,
              _e.glyphAt(0).charIndex,
              _e.glyphAt(_e.count - 1).charIndex
            );
            for (let Ee = 0; Ee < xe.length; Ee++) {
              const [Le, tt] = xe[Ee];
              let De = 1 / 0, we = -1 / 0;
              for (let He = 0; He < ge; He++)
                if (_e.glyphAt(He).charIndex >= Le) {
                  let yt = He, at = He;
                  for (; at < ge; at++) {
                    let ot = _e.glyphAt(at);
                    if (ot.charIndex > tt)
                      break;
                    at < ge - $e && (De = Math.min(De, ot.x), we = Math.max(we, ot.x + ot.width));
                  }
                  for (let ot = yt; ot < at; ot++) {
                    const Ot = _e.glyphAt(ot);
                    Ot.x = we - (Ot.x + Ot.width - De);
                  }
                  break;
                }
            }
            let Oe;
            const zt = (Ee) => Oe = Ee;
            for (let Ee = 0; Ee < ge; Ee++) {
              const Le = _e.glyphAt(Ee);
              Oe = Le.glyphObj;
              const tt = Oe.index, De = le.levels[Le.charIndex] & 1;
              if (De) {
                const we = e.getMirroredCharacter(p[Le.charIndex]);
                we && Le.fontData.fontObj.forEachGlyph(we, 0, 0, zt);
              }
              if (oe) {
                const { charIndex: we, fontData: He } = Le, yt = Le.x + be, at = Le.x + Le.width + be;
                $[we * 4] = De ? at : yt, $[we * 4 + 1] = De ? yt : at, $[we * 4 + 2] = _e.baseline + He.caretBottom + de, $[we * 4 + 3] = _e.baseline + He.caretTop + de;
                const ot = we - ye;
                ot > 1 && u($, ye, ot), ye = we;
              }
              if (X) {
                const { charIndex: we } = Le;
                for (; we > Te; )
                  Te++, X.hasOwnProperty(Te) && (Je = X[Te]);
              }
              if (!Oe.isWhitespace && !Oe.isEmpty) {
                const we = Ne++, { fontSizeMult: He, src: yt, index: at } = Le.fontData, ot = ie[yt] || (ie[yt] = {});
                ot[tt] || (ot[tt] = {
                  path: Oe.path,
                  pathBounds: [Oe.xMin, Oe.yMin, Oe.xMax, Oe.yMax]
                });
                const Ot = Le.x + be, Fn = _e.baseline + de;
                q[we * 2] = Ot, q[we * 2 + 1] = Fn;
                const ln = Ot + Oe.xMin * He, Nn = Fn + Oe.yMin * He, On = Ot + Oe.xMax * He, un = Fn + Oe.yMax * He;
                ln < F[0] && (F[0] = ln), Nn < F[1] && (F[1] = Nn), On > F[2] && (F[2] = On), un > F[3] && (F[3] = un), we % H === 0 && (Pe = { start: we, end: we, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, te.push(Pe)), Pe.end++;
                const vt = Pe.rect;
                if (ln < vt[0] && (vt[0] = ln), Nn < vt[1] && (vt[1] = Nn), On > vt[2] && (vt[2] = On), un > vt[3] && (vt[3] = un), Q[we] = tt, W[we] = at, X) {
                  const Vn = we * 3;
                  ae[Vn] = Je >> 16 & 255, ae[Vn + 1] = Je >> 8 & 255, ae[Vn + 2] = Je & 255;
                }
              }
            }
          }
        }), $) {
          const _e = p.length - ye;
          _e > 1 && u($, ye, _e);
        }
      }
      const qe = [];
      pe.forEach(({ index: le, src: Ne, unitsPerEm: ye, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue }) => {
        qe[le] = { src: Ne, unitsPerEm: ye, ascender: Te, descender: Pe, lineHeight: Je, capHeight: _e, xHeight: Ue };
      }), I.typesetting = h() - ne, C({
        glyphIds: Q,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: W,
        //index into fontData for each glyph
        glyphPositions: q,
        //x,y of each glyph's origin in layout
        glyphData: ie,
        //dict holding data about each glyph appearing in the text
        fontData: qe,
        //data about each font used in the text
        caretPositions: $,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: ae,
        //color for each glyph, if color ranges supplied
        chunkedBounds: te,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: de + Ae[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          be,
          de - me,
          be + Z,
          de
        ],
        visibleBounds: F,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: I
      });
    });
  }
  function a(p, m) {
    i({ ...p, metricsOnly: !0 }, (g) => {
      const [b, v, y, x] = g.blockBounds;
      m({
        width: y - b,
        height: x - v
      });
    });
  }
  function l(p) {
    let m = p.match(/^([\d.]+)%$/), g = m ? parseFloat(m[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(p, m, g) {
    const b = p[m * 4], v = p[m * 4 + 1], y = p[m * 4 + 2], x = p[m * 4 + 3], N = (v - b) / g;
    for (let w = 0; w < g; w++) {
      const T = (m + w) * 4;
      p[T] = b + N * w, p[T + 1] = b + N * (w + 1), p[T + 2] = y, p[T + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, g, b) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(v) {
      this.data[this.index * f.length + g] = v;
    }
  }), p), { data: null, index: 0 }), {
    typeset: i,
    measure: a
  };
}
const wM = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    NM,
    bM,
    J1
  ],
  init(c, e, t) {
    return c(e, t());
  }
}), TM = wM, SM = /* @__PURE__ */ fs({
  name: "Typesetter",
  dependencies: [
    TM
  ],
  init(c) {
    return function(e) {
      return new Promise((t) => {
        c.typeset(e, t);
      });
    };
  },
  getTransferables(c) {
    const e = [];
    for (const t in c)
      c[t] && c[t].buffer && e.push(c[t].buffer);
    return e;
  }
}), _M = new je();
let Ki;
function MM(c) {
  return Ki || (Ki = typeof document > "u" ? {} : document.createElement("a")), Ki.href = c, Ki.href;
}
const ox = {
  font: "/assets/fonts/STFangsong.ttf",
  lang: "en",
  fontSize: 0.1,
  fontWeight: "normal",
  fontStyle: "normal",
  letterSpacing: 0,
  lineHeight: "normal",
  maxWidth: 1,
  direction: "auto",
  textAlign: "left",
  textIndent: 0,
  whiteSpace: "normal",
  overflowWrap: "normal",
  anchorX: 0,
  anchorY: 0,
  colorRanges: null,
  includeCaretPositions: !0,
  sdfGlyphSize: 64,
  gpuAccelerateSDF: !1
};
async function AM(c) {
  c = { ...ox, ...c };
  const e = [];
  if (c.font && e.push({ label: "user", src: MM(c.font) }), c.font = e, c.text = "" + c.text, c.sdfGlyphSize = c.sdfGlyphSize || 64, c.colorRanges != null) {
    const h = {};
    for (const d in c.colorRanges)
      if (Object.hasOwn(c.colorRanges, d)) {
        let f = c.colorRanges[d];
        typeof f != "number" && (f = _M.set(f).getHex()), h[d] = f;
      }
    c.colorRanges = h;
  }
  Object.freeze(c);
  const t = await SM(c), { glyphIds: r, glyphFontIndices: n, fontData: s, glyphData: o, glyphPositions: i, fontSize: a } = t, l = new Nu();
  let u = 0;
  return r.forEach((h, d) => {
    const f = n[d], { src: p, unitsPerEm: m } = s[f], { path: g } = o[p][h], b = i[u++], v = i[u++], y = a / m, x = g.replace(/([A-Z])/mg, (N, w) => `$${w}`).split("$").filter((N) => N);
    for (const N of x) {
      const w = N[0];
      if (w === "Z")
        continue;
      const T = N.substring(1).split(",").map((_, L) => (L % 2 ? v : b) + Number.parseFloat(_) * y);
      w === "M" ? l.moveTo(...T) : w === "L" ? l.lineTo(...T) : w === "Q" ? l.quadraticCurveTo(...T) : w === "C" && l.bezierCurveTo(...T);
    }
  }), l.toShapes(!1);
}
const CM = Object.fromEntries(Object.entries(di).map((c) => [`props.${c[0]}`, c[1]]));
class ix extends Rr {
  constructor(t, r) {
    super(t, r, {
      ...ox,
      color: new je(),
      strokeColor: new je(),
      outlineColor: new je()
    }, 0, 0);
    G(this, "isText3D", !0);
    this.type = "Text3D";
  }
  async rebuildShapes() {
    this.shapes = await AM(this.props), this.rebuildGeometry();
  }
}
Ye("Text3D", {
  members: CM,
  proto: "Shape",
  group: "Text.3D Text",
  icon: "text",
  create: ({ material: c, geometry: e } = {}) => new ix(e || new Rm(), c)
});
class ax extends Eb {
  constructor() {
    super();
    G(this, "isAudioListener2", !0);
    this.type = "AudioListener2";
  }
  toJSON(t) {
    const r = super.toJSON(t), n = { ...r.object };
    return delete n.children, t.listeners[n.uuid] = n, r;
  }
}
class cx extends Rb {
  constructor(t) {
    super(t);
    G(this, "isPositionalAudio2", !0);
    G(this, "_src", "");
    this.type = "PositionalAudio2";
  }
  get src() {
    return this._src;
  }
  set src(t) {
    this._src !== t && (this._src = t, this.isPlaying && this.stop(), new Lb().load(t, (r) => {
      this.setBuffer(r);
    }));
  }
  play(t) {
    return this.isPlaying && this.stop(), super.play(t);
  }
  clone(t) {
    const r = _r.get(this.listener);
    return new this.constructor(r).copy(this, t);
  }
  serialize(t) {
    t.autoplay = this.autoplay, t.loop = this.loop, t.src = this._src, t.listener = this.listener.uuid;
  }
  deserialize(t) {
    this.autoplay = t.autoplay || !1, this.loop = t.loop || !1, this.src = t.src;
  }
}
Ye("AudioListener2", {
  create: () => new ax(),
  proto: "AudioListener",
  members: {},
  group: "Audio.Audio Listener",
  icon: "ear"
});
Ye("PositionalAudio2", {
  create: ({ listener: c }) => new cx(c),
  proto: "PositionalAudio",
  members: {
    autoplay: "Boolean",
    loop: "Boolean",
    src: "Audio"
  },
  group: "Audio.Positional Audio",
  icon: "audio"
});
function Up(c, e) {
  if (e === Fb)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), c;
  if (e === Pl || e === Im) {
    let t = c.getIndex();
    if (t === null) {
      const o = [], i = c.getAttribute("position");
      if (i !== void 0) {
        for (let a = 0; a < i.count; a++)
          o.push(a);
        c.setIndex(o), t = c.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), c;
    }
    const r = t.count - 2, n = [];
    if (e === Pl)
      for (let o = 1; o <= r; o++)
        n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
    else
      for (let o = 0; o < r; o++)
        o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = c.clone();
    return s.setIndex(n), s.clearGroups(), s;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), c;
}
class Kd extends wr {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new OM(t);
    }), this.register(function(t) {
      return new GM(t);
    }), this.register(function(t) {
      return new VM(t);
    }), this.register(function(t) {
      return new jM(t);
    }), this.register(function(t) {
      return new PM(t);
    }), this.register(function(t) {
      return new DM(t);
    }), this.register(function(t) {
      return new UM(t);
    }), this.register(function(t) {
      return new zM(t);
    }), this.register(function(t) {
      return new FM(t);
    }), this.register(function(t) {
      return new BM(t);
    }), this.register(function(t) {
      return new IM(t);
    }), this.register(function(t) {
      return new kM(t);
    }), this.register(function(t) {
      return new RM(t);
    }), this.register(function(t) {
      return new WM(t);
    }), this.register(function(t) {
      return new HM(t);
    });
  }
  load(e, t, r, n) {
    const s = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ho.extractUrlBase(e), this.manager.itemStart(e);
    const i = function(l) {
      n ? n(l) : console.error(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }, a = new qs(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        s.parse(l, o, function(u) {
          t(u), s.manager.itemEnd(e);
        }, i);
      } catch (u) {
        i(u);
      }
    }, r, i);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, r, n) {
    let s;
    const o = {}, i = {}, a = new TextDecoder();
    if (typeof e == "string")
      s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (a.decode(new Uint8Array(e, 0, 4)) === lx) {
        try {
          o[et.KHR_BINARY_GLTF] = new XM(e);
        } catch (h) {
          n && n(h);
          return;
        }
        s = JSON.parse(o[et.KHR_BINARY_GLTF].content);
      } else
        s = JSON.parse(a.decode(e));
    else
      s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new oA(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), i[h.name] = h, o[h.name] = !0;
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
        switch (h) {
          case et.KHR_MATERIALS_UNLIT:
            o[h] = new LM();
            break;
          case et.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new $M(s, this.dracoLoader);
            break;
          case et.KHR_TEXTURE_TRANSFORM:
            o[h] = new qM();
            break;
          case et.KHR_MESH_QUANTIZATION:
            o[h] = new JM();
            break;
          default:
            d.indexOf(h) >= 0 && i[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(i), l.parse(r, n);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function(n, s) {
      r.parse(e, t, n, s);
    });
  }
}
function EM() {
  let c = {};
  return {
    get: function(e) {
      return c[e];
    },
    add: function(e, t) {
      c[e] = t;
    },
    remove: function(e) {
      delete c[e];
    },
    removeAll: function() {
      c = {};
    }
  };
}
const et = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class RM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, r = "light:" + e;
    let n = t.cache.get(r);
    if (n)
      return n;
    const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
    let l;
    const u = new je(16777215);
    a.color !== void 0 && u.setRGB(a.color[0], a.color[1], a.color[2], En);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        l = new gi(u), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        l = new Zo(u), l.distance = h;
        break;
      case "spot":
        l = new yi(u), l.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, l.angle = a.spot.outerConeAngle, l.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return l.position.set(0, 0, 0), l.decay = 2, Bs(l, a), a.intensity !== void 0 && (l.intensity = a.intensity), l.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(l), t.cache.add(r, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, r = this.parser, s = r.json.nodes[e], i = (s.extensions && s.extensions[this.name] || {}).light;
    return i === void 0 ? null : this._loadLight(i).then(function(a) {
      return r._getNodeRef(t.cache, i, a);
    });
  }
}
class LM {
  constructor() {
    this.name = et.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return An;
  }
  extendParams(e, t, r) {
    const n = [];
    e.color = new je(1, 1, 1), e.opacity = 1;
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], En), e.opacity = o[3];
      }
      s.baseColorTexture !== void 0 && n.push(r.assignTexture(e, "map", s.baseColorTexture, yn));
    }
    return Promise.all(n);
  }
}
class FM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class OM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const i = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new wt(i, i);
    }
    return Promise.all(s);
  }
}
class IM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s);
  }
}
class PM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [];
    t.sheenColor = new je(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const i = o.sheenColorFactor;
      t.sheenColor.setRGB(i[0], i[1], i[2], En);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, yn)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s);
  }
}
class DM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s);
  }
}
class UM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const i = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new je().setRGB(i[0], i[1], i[2], En), Promise.all(s);
  }
}
class zM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = n.extensions[this.name];
    return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
  }
}
class BM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const i = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new je().setRGB(i[0], i[1], i[2], En), o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, yn)), Promise.all(s);
  }
}
class kM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : As;
  }
  extendMaterialParams(e, t) {
    const r = this.parser, n = r.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const s = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s);
  }
}
class GM {
  constructor(e) {
    this.parser = e, this.name = et.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, r = t.json, n = r.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const s = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class VM {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class jM {
  constructor(e) {
    this.parser = e, this.name = et.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, r = this.parser, n = r.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[t])
      return null;
    const o = s.extensions[t], i = n.images[o.source];
    let a = r.textureLoader;
    if (i.uri) {
      const l = r.options.manager.getHandler(i.uri);
      l !== null && (a = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return r.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class WM {
  constructor(e) {
    this.name = et.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const n = r.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return s.then(function(i) {
        const a = n.byteOffset || 0, l = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(i, a, l);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, n.mode, n.filter), f;
        });
      });
    } else
      return null;
  }
}
class HM {
  constructor(e) {
    this.name = et.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const n = t.meshes[r.mesh];
    for (const l of n.primitives)
      if (l.mode !== Pn.TRIANGLES && l.mode !== Pn.TRIANGLE_STRIP && l.mode !== Pn.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const o = r.extensions[this.name].attributes, i = [], a = {};
    for (const l in o)
      i.push(this.parser.getDependency("accessor", o[l]).then((u) => (a[l] = u, a[l])));
    return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then((l) => {
      const u = l.pop(), h = u.isGroup ? u.children : [u], d = l[0].count, f = [];
      for (const p of h) {
        const m = new Ge(), g = new ve(), b = new dr(), v = new ve(1, 1, 1), y = new Ob(p.geometry, p.material, d);
        for (let x = 0; x < d; x++)
          a.TRANSLATION && g.fromBufferAttribute(a.TRANSLATION, x), a.ROTATION && b.fromBufferAttribute(a.ROTATION, x), a.SCALE && v.fromBufferAttribute(a.SCALE, x), y.setMatrixAt(x, m.compose(g, b, v));
        for (const x in a)
          if (x === "_COLOR_0") {
            const N = a[x];
            y.instanceColor = new Fm(N.array, N.itemSize, N.normalized);
          } else
            x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, a[x]);
        vn.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), f.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
}
const lx = "glTF", Do = 12, zp = { JSON: 1313821514, BIN: 5130562 };
class XM {
  constructor(e) {
    this.name = et.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Do), r = new TextDecoder();
    if (this.header = {
      magic: r.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== lx)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - Do, s = new DataView(e, Do);
    let o = 0;
    for (; o < n; ) {
      const i = s.getUint32(o, !0);
      o += 4;
      const a = s.getUint32(o, !0);
      if (o += 4, a === zp.JSON) {
        const l = new Uint8Array(e, Do + o, i);
        this.content = r.decode(l);
      } else if (a === zp.BIN) {
        const l = Do + o;
        this.body = e.slice(l, l + i);
      }
      o += i;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class $M {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = et.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, i = {}, a = {}, l = {};
    for (const u in o) {
      const h = iu[u] || u.toLowerCase();
      i[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = iu[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = r.accessors[e.attributes[u]], f = co[d.componentType];
        l[h] = f.name, a[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", s).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(u, function(d) {
          for (const f in d.attributes) {
            const p = d.attributes[f], m = a[f];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, i, l);
      });
    });
  }
}
class qM {
  constructor() {
    this.name = et.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class JM {
  constructor() {
    this.name = et.KHR_MESH_QUANTIZATION;
  }
}
class ux extends zb {
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = r[s + o];
    return t;
  }
  interpolate_(e, t, r, n) {
    const s = this.resultBuffer, o = this.sampleValues, i = this.valueSize, a = i * 2, l = i * 3, u = n - t, h = (r - t) / u, d = h * h, f = d * h, p = e * l, m = p - l, g = -2 * f + 3 * d, b = f - d, v = 1 - g, y = b - d + h;
    for (let x = 0; x !== i; x++) {
      const N = o[m + x + i], w = o[m + x + a] * u, T = o[p + x + i], _ = o[p + x] * u;
      s[x] = v * N + y * w + g * T + b * _;
    }
    return s;
  }
}
const YM = new dr();
class KM extends ux {
  interpolate_(e, t, r, n) {
    const s = super.interpolate_(e, t, r, n);
    return YM.fromArray(s).normalize().toArray(s), s;
  }
}
const Pn = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, co = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Bp = {
  9728: Vs,
  9729: uo,
  9984: Bm,
  9985: km,
  9986: Gm,
  9987: bo
}, kp = {
  33071: fo,
  33648: Vm,
  10497: Js
}, fl = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, iu = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Fs = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, ZM = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: zm,
  STEP: Ub
}, pl = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function QM(c) {
  return c.DefaultMaterial === void 0 && (c.DefaultMaterial = new Gn({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Om
  })), c.DefaultMaterial;
}
function ar(c, e, t) {
  for (const r in t.extensions)
    c[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]);
}
function Bs(c, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(c.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function eA(c, e, t) {
  let r = !1, n = !1, s = !1;
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (h.POSITION !== void 0 && (r = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (s = !0), r && n && s)
      break;
  }
  if (!r && !n && !s)
    return Promise.resolve(c);
  const o = [], i = [], a = [];
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (r) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : c.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : c.attributes.normal;
      i.push(d);
    }
    if (s) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : c.attributes.color;
      a.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(i),
    Promise.all(a)
  ]).then(function(l) {
    const u = l[0], h = l[1], d = l[2];
    return r && (c.morphAttributes.position = u), n && (c.morphAttributes.normal = h), s && (c.morphAttributes.color = d), c.morphTargetsRelative = !0, c;
  });
}
function tA(c, e) {
  if (c.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, r = e.weights.length; t < r; t++)
      c.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (c.morphTargetInfluences.length === t.length) {
      c.morphTargetDictionary = {};
      for (let r = 0, n = t.length; r < n; r++)
        c.morphTargetDictionary[t[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function nA(c) {
  let e;
  const t = c.extensions && c.extensions[et.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + ml(t.attributes) : e = c.indices + ":" + ml(c.attributes) + ":" + c.mode, c.targets !== void 0)
    for (let r = 0, n = c.targets.length; r < n; r++)
      e += ":" + ml(c.targets[r]);
  return e;
}
function ml(c) {
  let e = "";
  const t = Object.keys(c).sort();
  for (let r = 0, n = t.length; r < n; r++)
    e += t[r] + ":" + c[t[r]] + ";";
  return e;
}
function au(c) {
  switch (c) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function sA(c) {
  return c.search(/\.jpe?g($|\?)/i) > 0 || c.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : c.search(/\.webp($|\?)/i) > 0 || c.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const rA = new Ge();
class oA {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new EM(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, n = !1, s = -1;
    typeof navigator < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || n && s < 98 ? this.textureLoader = new Tu(this.options.manager) : this.textureLoader = new Ib(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new qs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this, n = this.json, s = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(this._invokeAll(function(o) {
      return o.beforeRoot && o.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(o) {
      const i = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: r,
        userData: {}
      };
      return ar(s, i, n), Bs(i, n), Promise.all(r._invokeAll(function(a) {
        return a.afterRoot && a.afterRoot(i);
      })).then(function() {
        e(i);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n].joints;
      for (let i = 0, a = o.length; i < a; i++)
        e[o[i]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1)
      return r;
    const n = r.clone(), s = (o, i) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(i, a);
      for (const [l, u] of o.children.entries())
        s(u, i.children[l]);
    };
    return s(r, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const n = e(t[r]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && r.push(s);
    }
    return r;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const r = e + ":" + t;
    let n = this.cache.get(r);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(s) {
            return s != this && s.getDependency && s.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(s, o) {
        return r.getDependency(e, o);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[et.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(s, o) {
      r.load(ho.resolveURL(t.uri, n.path), s, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(r) {
      const n = t.byteLength || 0, s = t.byteOffset || 0;
      return r.slice(s, s + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, r = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = fl[n.type], i = co[n.componentType], a = n.normalized === !0, l = new i(n.count * o);
      return Promise.resolve(new ro(l, o, a));
    }
    const s = [];
    return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(o) {
      const i = o[0], a = fl[n.type], l = co[n.componentType], u = l.BYTES_PER_ELEMENT, h = u * a, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? r.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, g;
      if (f && f !== h) {
        const b = Math.floor(d / f), v = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + b + ":" + n.count;
        let y = t.cache.get(v);
        y || (m = new l(i, b * f, n.count * f / u), y = new bm(m, f / u), t.cache.add(v, y)), g = new Gs(y, a, d % f / u, p);
      } else
        i === null ? m = new l(n.count * a) : m = new l(i, d, n.count * a), g = new ro(m, a, p);
      if (n.sparse !== void 0) {
        const b = fl.SCALAR, v = co[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, x = n.sparse.values.byteOffset || 0, N = new v(o[1], y, n.sparse.count * b), w = new l(o[2], x, n.sparse.count * a);
        i !== null && (g = new ro(g.array.slice(), g.itemSize, g.normalized));
        for (let T = 0, _ = N.length; T < _; T++) {
          const L = N[T];
          if (g.setX(L, w[T * a]), a >= 2 && g.setY(L, w[T * a + 1]), a >= 3 && g.setZ(L, w[T * a + 2]), a >= 4 && g.setW(L, w[T * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, r = this.options, s = t.textures[e].source, o = t.images[s];
    let i = this.textureLoader;
    if (o.uri) {
      const a = r.manager.getHandler(o.uri);
      a !== null && (i = a);
    }
    return this.loadTextureImage(e, s, i);
  }
  loadTextureImage(e, t, r) {
    const n = this, s = this.json, o = s.textures[e], i = s.images[t], a = (i.uri || i.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const l = this.loadImageSource(t, r).then(function(u) {
      u.flipY = !1, u.name = o.name || i.name || "", u.name === "" && typeof i.uri == "string" && i.uri.startsWith("data:image/") === !1 && (u.name = i.uri);
      const d = (s.samplers || {})[o.sampler] || {};
      return u.magFilter = Bp[d.magFilter] || uo, u.minFilter = Bp[d.minFilter] || bo, u.wrapS = kp[d.wrapS] || Js, u.wrapT = kp[d.wrapT] || Js, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = l, l;
  }
  loadImageSource(e, t) {
    const r = this, n = this.json, s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], i = self.URL || self.webkitURL;
    let a = o.uri || "", l = !1;
    if (o.bufferView !== void 0)
      a = r.getDependency("bufferView", o.bufferView).then(function(h) {
        l = !0;
        const d = new Blob([h], { type: o.mimeType });
        return a = i.createObjectURL(d), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(d, f) {
        let p = d;
        t.isImageBitmapLoader === !0 && (p = function(m) {
          const g = new kn(m);
          g.needsUpdate = !0, d(g);
        }), t.load(ho.resolveURL(h, s.path), p, void 0, f);
      });
    }).then(function(h) {
      return l === !0 && i.revokeObjectURL(a), h.userData.mimeType = o.mimeType || sA(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, r, n) {
    const s = this;
    return this.getDependency("texture", r.index).then(function(o) {
      if (!o)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[et.KHR_TEXTURE_TRANSFORM]) {
        const i = r.extensions !== void 0 ? r.extensions[et.KHR_TEXTURE_TRANSFORM] : void 0;
        if (i) {
          const a = s.associations.get(o);
          o = s.extensions[et.KHR_TEXTURE_TRANSFORM].extendTexture(o, i), s.associations.set(o, a);
        }
      }
      return n !== void 0 && (o.colorSpace = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const i = "PointsMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new xu(), zn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, a.sizeAttenuation = !1, this.cache.add(i, a)), r = a;
    } else if (e.isLine) {
      const i = "LineBasicMaterial:" + r.uuid;
      let a = this.cache.get(i);
      a || (a = new bu(), zn.prototype.copy.call(a, r), a.color.copy(r.color), a.map = r.map, this.cache.add(i, a)), r = a;
    }
    if (n || s || o) {
      let i = "ClonedMaterial:" + r.uuid + ":";
      n && (i += "derivative-tangents:"), s && (i += "vertex-colors:"), o && (i += "flat-shading:");
      let a = this.cache.get(i);
      a || (a = r.clone(), s && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(i, a), this.associations.set(a, this.associations.get(r))), r = a;
    }
    e.material = r;
  }
  getMaterialType() {
    return Gn;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, r = this.json, n = this.extensions, s = r.materials[e];
    let o;
    const i = {}, a = s.extensions || {}, l = [];
    if (a[et.KHR_MATERIALS_UNLIT]) {
      const h = n[et.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), l.push(h.extendParams(i, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (i.color = new je(1, 1, 1), i.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        i.color.setRGB(d[0], d[1], d[2], En), i.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(i, "map", h.baseColorTexture, yn)), i.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, i.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(i, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(i, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, i);
      })));
    }
    s.doubleSided === !0 && (i.side = wu);
    const u = s.alphaMode || pl.OPAQUE;
    if (u === pl.BLEND ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === pl.MASK && (i.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "normalMap", s.normalTexture)), i.normalScale = new wt(1, 1), s.normalTexture.scale !== void 0)) {
      const h = s.normalTexture.scale;
      i.normalScale.set(h, h);
    }
    if (s.occlusionTexture !== void 0 && o !== An && (l.push(t.assignTexture(i, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (i.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== An) {
      const h = s.emissiveFactor;
      i.emissive = new je().setRGB(h[0], h[1], h[2], En);
    }
    return s.emissiveTexture !== void 0 && o !== An && l.push(t.assignTexture(i, "emissiveMap", s.emissiveTexture, yn)), Promise.all(l).then(function() {
      const h = new o(i);
      return s.name && (h.name = s.name), Bs(h, s), t.associations.set(h, { materials: e }), s.extensions && ar(n, h, s), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Qo.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, r = this.extensions, n = this.primitiveCache;
    function s(i) {
      return r[et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(i, t).then(function(a) {
        return Gp(a, i, t);
      });
    }
    const o = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i], u = nA(l), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        l.extensions && l.extensions[et.KHR_DRACO_MESH_COMPRESSION] ? d = s(l) : d = Gp(new Jn(), l, t), n[u] = { primitive: l, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, r = this.json, n = this.extensions, s = r.meshes[e], o = s.primitives, i = [];
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a].material === void 0 ? QM(this.cache) : this.getDependency("material", o[a].material);
      i.push(u);
    }
    return i.push(t.loadGeometries(o)), Promise.all(i).then(function(a) {
      const l = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let f = 0, p = u.length; f < p; f++) {
        const m = u[f], g = o[f];
        let b;
        const v = l[f];
        if (g.mode === Pn.TRIANGLES || g.mode === Pn.TRIANGLE_STRIP || g.mode === Pn.TRIANGLE_FAN || g.mode === void 0)
          b = s.isSkinnedMesh === !0 ? new Pm(m, v) : new qt(m, v), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), g.mode === Pn.TRIANGLE_STRIP ? b.geometry = Up(b.geometry, Im) : g.mode === Pn.TRIANGLE_FAN && (b.geometry = Up(b.geometry, Pl));
        else if (g.mode === Pn.LINES)
          b = new Pb(m, v);
        else if (g.mode === Pn.LINE_STRIP)
          b = new Dm(m, v);
        else if (g.mode === Pn.LINE_LOOP)
          b = new Db(m, v);
        else if (g.mode === Pn.POINTS)
          b = new Um(m, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(b.geometry.morphAttributes).length > 0 && tA(b, s), b.name = t.createUniqueName(s.name || "mesh_" + e), Bs(b, s), g.extensions && ar(n, b, g), t.assignFinalMaterial(b), h.push(b);
      }
      for (let f = 0, p = h.length; f < p; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return s.extensions && ar(n, h[0], s), h[0];
      const d = new io();
      s.extensions && ar(n, d, s), t.associations.set(d, { meshes: e });
      for (let f = 0, p = h.length; f < p; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e], n = r[r.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? t = new Tr(Zt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : r.type === "orthographic" && (t = new qa(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), r.name && (t.name = this.createUniqueName(r.name)), Bs(t, r), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], r = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      r.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(n) {
      const s = n.pop(), o = n, i = [], a = [];
      for (let l = 0, u = o.length; l < u; l++) {
        const h = o[l];
        if (h) {
          i.push(h);
          const d = new Ge();
          s !== null && d.fromArray(s.array, l * 16), a.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
      }
      return new Su(i, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, r = this, n = t.animations[e], s = n.name ? n.name : "animation_" + e, o = [], i = [], a = [], l = [], u = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const f = n.channels[h], p = n.samplers[f.sampler], m = f.target, g = m.node, b = n.parameters !== void 0 ? n.parameters[p.input] : p.input, v = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (o.push(this.getDependency("node", g)), i.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", v)), l.push(p), u.push(m));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(i),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u)
    ]).then(function(h) {
      const d = h[0], f = h[1], p = h[2], m = h[3], g = h[4], b = [];
      for (let v = 0, y = d.length; v < y; v++) {
        const x = d[v], N = f[v], w = p[v], T = m[v], _ = g[v];
        if (x === void 0)
          continue;
        x.updateMatrix && x.updateMatrix();
        const L = r._createAnimationTracks(x, N, w, T, _);
        if (L)
          for (let A = 0; A < L.length; A++)
            b.push(L[A]);
      }
      return new _u(s, void 0, b);
    });
  }
  createNodeMesh(e) {
    const t = this.json, r = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : r.getDependency("mesh", n.mesh).then(function(s) {
      const o = r._getNodeRef(r.meshCache, n.mesh, s);
      return n.weights !== void 0 && o.traverse(function(i) {
        if (i.isMesh)
          for (let a = 0, l = n.weights.length; a < l; a++)
            i.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, r = this, n = t.nodes[e], s = r._loadNodeShallow(e), o = [], i = n.children || [];
    for (let l = 0, u = i.length; l < u; l++)
      o.push(r.getDependency("node", i[l]));
    const a = n.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", n.skin);
    return Promise.all([
      s,
      Promise.all(o),
      a
    ]).then(function(l) {
      const u = l[0], h = l[1], d = l[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, rA);
      });
      for (let f = 0, p = h.length; f < p; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, r = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const s = t.nodes[e], o = s.name ? n.createUniqueName(s.name) : "", i = [], a = n._invokeOne(function(l) {
      return l.createNodeMesh && l.createNodeMesh(e);
    });
    return a && i.push(a), s.camera !== void 0 && i.push(n.getDependency("camera", s.camera).then(function(l) {
      return n._getNodeRef(n.cameraCache, s.camera, l);
    })), n._invokeAll(function(l) {
      return l.createNodeAttachment && l.createNodeAttachment(e);
    }).forEach(function(l) {
      i.push(l);
    }), this.nodeCache[e] = Promise.all(i).then(function(l) {
      let u;
      if (s.isBone === !0 ? u = new Dl() : l.length > 1 ? u = new io() : l.length === 1 ? u = l[0] : u = new vn(), u !== l[0])
        for (let h = 0, d = l.length; h < d; h++)
          u.add(l[h]);
      if (s.name && (u.userData.name = s.name, u.name = o), Bs(u, s), s.extensions && ar(r, u, s), s.matrix !== void 0) {
        const h = new Ge();
        h.fromArray(s.matrix), u.applyMatrix4(h);
      } else
        s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, r = this.json.scenes[e], n = this, s = new io();
    r.name && (s.name = n.createUniqueName(r.name)), Bs(s, r), r.extensions && ar(t, s, r);
    const o = r.nodes || [], i = [];
    for (let a = 0, l = o.length; a < l; a++)
      i.push(n.getDependency("node", o[a]));
    return Promise.all(i).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        s.add(a[u]);
      const l = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof zn || d instanceof kn) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = l(s), s;
    });
  }
  _createAnimationTracks(e, t, r, n, s) {
    const o = [], i = e.name ? e.name : e.uuid, a = [];
    Fs[s.path] === Fs.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && a.push(d.name ? d.name : d.uuid);
    }) : a.push(i);
    let l;
    switch (Fs[s.path]) {
      case Fs.weights:
        l = zl;
        break;
      case Fs.rotation:
        l = Bl;
        break;
      case Fs.position:
      case Fs.scale:
        l = Ul;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            l = zl;
            break;
          case 2:
          case 3:
          default:
            l = Ul;
            break;
        }
        break;
    }
    const u = n.interpolation !== void 0 ? ZM[n.interpolation] : zm, h = this._getArrayFromAccessor(r);
    for (let d = 0, f = a.length; d < f; d++) {
      const p = new l(
        a[d] + "." + Fs[s.path],
        t.array,
        h,
        u
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const r = au(t.constructor), n = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++)
        n[s] = t[s] * r;
      t = n;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(r) {
      const n = this instanceof Bl ? KM : ux;
      return new n(this.times, this.values, this.getValueSize() / 3, r);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function iA(c, e, t) {
  const r = e.attributes, n = new er();
  if (r.POSITION !== void 0) {
    const i = t.json.accessors[r.POSITION], a = i.min, l = i.max;
    if (a !== void 0 && l !== void 0) {
      if (n.set(
        new ve(a[0], a[1], a[2]),
        new ve(l[0], l[1], l[2])
      ), i.normalized) {
        const u = au(co[i.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const s = e.targets;
  if (s !== void 0) {
    const i = new ve(), a = new ve();
    for (let l = 0, u = s.length; l < u; l++) {
      const h = s[l];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, p = d.max;
        if (f !== void 0 && p !== void 0) {
          if (a.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), a.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), a.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
            const m = au(co[d.componentType]);
            a.multiplyScalar(m);
          }
          i.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(i);
  }
  c.boundingBox = n;
  const o = new xi();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, c.boundingSphere = o;
}
function Gp(c, e, t) {
  const r = e.attributes, n = [];
  function s(o, i) {
    return t.getDependency("accessor", o).then(function(a) {
      c.setAttribute(i, a);
    });
  }
  for (const o in r) {
    const i = iu[o] || o.toLowerCase();
    i in c.attributes || n.push(s(r[o], i));
  }
  if (e.indices !== void 0 && !c.index) {
    const o = t.getDependency("accessor", e.indices).then(function(i) {
      c.setIndex(i);
    });
    n.push(o);
  }
  return Hf.workingColorSpace !== En && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Hf.workingColorSpace}" not supported.`), Bs(c, e), iA(c, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? eA(c, e.targets, t) : c;
  });
}
const gl = /* @__PURE__ */ new WeakMap();
class aA extends wr {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, r, n) {
    const s = new qs(this.manager);
    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o) => {
      this.parse(o, t, n);
    }, r, n);
  }
  parse(e, t, r) {
    this.decodeDracoFile(e, t, null, null, yn).catch(r);
  }
  decodeDracoFile(e, t, r, n, s = En) {
    const o = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: s
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const r = JSON.stringify(t);
    if (gl.has(e)) {
      const a = gl.get(e);
      if (a.key === r)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++, o = e.byteLength, i = this._getWorker(s, o).then((a) => (n = a, new Promise((l, u) => {
      n._callbacks[s] = { resolve: l, reject: u }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return i.catch(() => !0).then(() => {
      n && s && this._releaseTask(n, s);
    }), gl.set(e, {
      key: r,
      promise: i
    }), i;
  }
  _createGeometry(e) {
    const t = new Jn();
    e.index && t.setIndex(new ro(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const n = e.attributes[r], s = n.name, o = n.array, i = n.itemSize, a = new ro(o, i);
      s === "color" && (this._assignVertexColorSpace(a, n.vertexColorSpace), a.normalized = !(o instanceof Float32Array)), t.setAttribute(s, a);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== yn)
      return;
    const r = new je();
    for (let n = 0, s = e.count; n < s; n++)
      r.fromBufferAttribute(e, n).convertSRGBToLinear(), e.setXYZ(n, r.r, r.g, r.b);
  }
  _loadLibrary(e, t) {
    const r = new qs(this.manager);
    return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((n, s) => {
      r.load(e, n, void 0, s);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((r) => {
      const n = r[0];
      e || (this.decoderConfig.wasmBinary = r[1]);
      const s = cA.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(s) {
          const o = s.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, s) {
          return n._taskLoad > s._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return r._taskCosts[e] = t, r._taskLoad += t, r;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function cA() {
  let c, e;
  onmessage = function(o) {
    const i = o.data;
    switch (i.type) {
      case "init":
        c = i.decoderConfig, e = new Promise(function(u) {
          c.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(c);
        });
        break;
      case "decode":
        const a = i.buffer, l = i.taskConfig;
        e.then((u) => {
          const h = u.draco, d = new h.Decoder();
          try {
            const f = t(h, d, new Int8Array(a), l), p = f.attributes.map((m) => m.array.buffer);
            f.index && p.push(f.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: f }, p);
          } catch (f) {
            console.error(f), self.postMessage({ type: "error", id: i.id, error: f.message });
          } finally {
            h.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, i, a, l) {
    const u = l.attributeIDs, h = l.attributeTypes;
    let d, f;
    const p = i.GetEncodedGeometryType(a);
    if (p === o.TRIANGULAR_MESH)
      d = new o.Mesh(), f = i.DecodeArrayToMesh(a, a.byteLength, d);
    else if (p === o.POINT_CLOUD)
      d = new o.PointCloud(), f = i.DecodeArrayToPointCloud(a, a.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const m = { index: null, attributes: [] };
    for (const g in u) {
      const b = self[h[g]];
      let v, y;
      if (l.useUniqueIDs)
        y = u[g], v = i.GetAttributeByUniqueId(d, y);
      else {
        if (y = i.GetAttributeId(d, o[u[g]]), y === -1)
          continue;
        v = i.GetAttribute(d, y);
      }
      const x = n(o, i, d, g, b, v);
      g === "color" && (x.vertexColorSpace = l.vertexColorSpace), m.attributes.push(x);
    }
    return p === o.TRIANGULAR_MESH && (m.index = r(o, i, d)), o.destroy(d), m;
  }
  function r(o, i, a) {
    const u = a.num_faces() * 3, h = u * 4, d = o._malloc(h);
    i.GetTrianglesUInt32Array(a, h, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function n(o, i, a, l, u, h) {
    const d = h.num_components(), p = a.num_points() * d, m = p * u.BYTES_PER_ELEMENT, g = s(o, u), b = o._malloc(m);
    i.GetAttributeDataArrayForAllPoints(a, h, g, m, b);
    const v = new u(o.HEAPF32.buffer, b, p).slice();
    return o._free(b), {
      name: l,
      array: v,
      itemSize: d
    };
  }
  function s(o, i) {
    switch (i) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Vp = function(c) {
  return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Vp(""));
} catch {
  Vp = function(e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Un = Uint8Array, Ws = Uint16Array, cu = Uint32Array, hx = new Un([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), dx = new Un([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), lA = new Un([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), fx = function(c, e) {
  for (var t = new Ws(31), r = 0; r < 31; ++r)
    t[r] = e += 1 << c[r - 1];
  for (var n = new cu(t[30]), r = 1; r < 30; ++r)
    for (var s = t[r]; s < t[r + 1]; ++s)
      n[s] = s - t[r] << 5 | r;
  return [t, n];
}, px = fx(hx, 2), mx = px[0], uA = px[1];
mx[28] = 258, uA[258] = 28;
var hA = fx(dx, 0), dA = hA[0], lu = new Ws(32768);
for (var ft = 0; ft < 32768; ++ft) {
  var Os = (ft & 43690) >>> 1 | (ft & 21845) << 1;
  Os = (Os & 52428) >>> 2 | (Os & 13107) << 2, Os = (Os & 61680) >>> 4 | (Os & 3855) << 4, lu[ft] = ((Os & 65280) >>> 8 | (Os & 255) << 8) >>> 1;
}
var Jo = function(c, e, t) {
  for (var r = c.length, n = 0, s = new Ws(e); n < r; ++n)
    ++s[c[n] - 1];
  var o = new Ws(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + s[n - 1] << 1;
  var i;
  if (t) {
    i = new Ws(1 << e);
    var a = 15 - e;
    for (n = 0; n < r; ++n)
      if (c[n])
        for (var l = n << 4 | c[n], u = e - c[n], h = o[c[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          i[lu[h] >>> a] = l;
  } else
    for (i = new Ws(r), n = 0; n < r; ++n)
      c[n] && (i[n] = lu[o[c[n] - 1]++] >>> 15 - c[n]);
  return i;
}, Mi = new Un(288);
for (var ft = 0; ft < 144; ++ft)
  Mi[ft] = 8;
for (var ft = 144; ft < 256; ++ft)
  Mi[ft] = 9;
for (var ft = 256; ft < 280; ++ft)
  Mi[ft] = 7;
for (var ft = 280; ft < 288; ++ft)
  Mi[ft] = 8;
var gx = new Un(32);
for (var ft = 0; ft < 32; ++ft)
  gx[ft] = 5;
var fA = /* @__PURE__ */ Jo(Mi, 9, 1), pA = /* @__PURE__ */ Jo(gx, 5, 1), yl = function(c) {
  for (var e = c[0], t = 1; t < c.length; ++t)
    c[t] > e && (e = c[t]);
  return e;
}, Hn = function(c, e, t) {
  var r = e / 8 | 0;
  return (c[r] | c[r + 1] << 8) >> (e & 7) & t;
}, vl = function(c, e) {
  var t = e / 8 | 0;
  return (c[t] | c[t + 1] << 8 | c[t + 2] << 16) >> (e & 7);
}, mA = function(c) {
  return (c / 8 | 0) + (c & 7 && 1);
}, gA = function(c, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > c.length) && (t = c.length);
  var r = new (c instanceof Ws ? Ws : c instanceof cu ? cu : Un)(t - e);
  return r.set(c.subarray(e, t)), r;
}, yA = function(c, e, t) {
  var r = c.length;
  if (!r || t && !t.l && r < 5)
    return e || new Un(0);
  var n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new Un(r * 3));
  var o = function(Q) {
    var W = e.length;
    if (Q > W) {
      var q = new Un(Math.max(W * 2, Q));
      q.set(e), e = q;
    }
  }, i = t.f || 0, a = t.p || 0, l = t.b || 0, u = t.l, h = t.d, d = t.m, f = t.n, p = r * 8;
  do {
    if (!u) {
      t.f = i = Hn(c, a, 1);
      var m = Hn(c, a + 1, 3);
      if (a += 3, m)
        if (m == 1)
          u = fA, h = pA, d = 9, f = 5;
        else if (m == 2) {
          var y = Hn(c, a, 31) + 257, x = Hn(c, a + 10, 15) + 4, N = y + Hn(c, a + 5, 31) + 1;
          a += 14;
          for (var w = new Un(N), T = new Un(19), _ = 0; _ < x; ++_)
            T[lA[_]] = Hn(c, a + _ * 3, 7);
          a += x * 3;
          for (var L = yl(T), A = (1 << L) - 1, U = Jo(T, L, 1), _ = 0; _ < N; ) {
            var S = U[Hn(c, a, A)];
            a += S & 15;
            var g = S >>> 4;
            if (g < 16)
              w[_++] = g;
            else {
              var R = 0, E = 0;
              for (g == 16 ? (E = 3 + Hn(c, a, 3), a += 2, R = w[_ - 1]) : g == 17 ? (E = 3 + Hn(c, a, 7), a += 3) : g == 18 && (E = 11 + Hn(c, a, 127), a += 7); E--; )
                w[_++] = R;
            }
          }
          var D = w.subarray(0, y), P = w.subarray(y);
          d = yl(D), f = yl(P), u = Jo(D, d, 1), h = Jo(P, f, 1);
        } else
          throw "invalid block type";
      else {
        var g = mA(a) + 4, b = c[g - 4] | c[g - 3] << 8, v = g + b;
        if (v > r) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + b), e.set(c.subarray(g, v), l), t.b = l += b, t.p = a = v * 8;
        continue;
      }
      if (a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(l + 131072);
    for (var se = (1 << d) - 1, oe = (1 << f) - 1, H = a; ; H = a) {
      var R = u[vl(c, a) & se], X = R >>> 4;
      if (a += R & 15, a > p) {
        if (s)
          throw "unexpected EOF";
        break;
      }
      if (!R)
        throw "invalid length/literal";
      if (X < 256)
        e[l++] = X;
      else if (X == 256) {
        H = a, u = null;
        break;
      } else {
        var C = X - 254;
        if (X > 264) {
          var _ = X - 257, O = hx[_];
          C = Hn(c, a, (1 << O) - 1) + mx[_], a += O;
        }
        var I = h[vl(c, a) & oe], k = I >>> 4;
        if (!I)
          throw "invalid distance";
        a += I & 15;
        var P = dA[k];
        if (k > 3) {
          var O = dx[k];
          P += vl(c, a) & (1 << O) - 1, a += O;
        }
        if (a > p) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && o(l + 131072);
        for (var z = l + C; l < z; l += 4)
          e[l] = e[l - P], e[l + 1] = e[l + 1 - P], e[l + 2] = e[l + 2 - P], e[l + 3] = e[l + 3 - P];
        l = z;
      }
    }
    t.l = u, t.p = H, t.b = l, u && (i = 1, t.m = d, t.d = h, t.n = f);
  } while (!i);
  return l == e.length ? e : gA(e, 0, l);
}, vA = /* @__PURE__ */ new Un(0), xA = function(c) {
  if ((c[0] & 15) != 8 || c[0] >>> 4 > 7 || (c[0] << 8 | c[1]) % 31)
    throw "invalid zlib data";
  if (c[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function bA(c, e) {
  return yA((xA(c), c.subarray(2, -4)), e);
}
var NA = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), wA = 0;
try {
  NA.decode(vA, { stream: !0 }), wA = 1;
} catch {
}
function yx(c, e, t) {
  const r = t.length - c - 1;
  if (e >= t[r])
    return r - 1;
  if (e <= t[c])
    return c;
  let n = c, s = r, o = Math.floor((n + s) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? s = o : n = o, o = Math.floor((n + s) / 2);
  return o;
}
function TA(c, e, t, r) {
  const n = [], s = [], o = [];
  n[0] = 1;
  for (let i = 1; i <= t; ++i) {
    s[i] = e - r[c + 1 - i], o[i] = r[c + i] - e;
    let a = 0;
    for (let l = 0; l < i; ++l) {
      const u = o[l + 1], h = s[i - l], d = n[l] / (u + h);
      n[l] = a + u * d, a = h * d;
    }
    n[i] = a;
  }
  return n;
}
function SA(c, e, t, r) {
  const n = yx(c, r, e), s = TA(n, r, c, e), o = new pt(0, 0, 0, 0);
  for (let i = 0; i <= c; ++i) {
    const a = t[n - c + i], l = s[i], u = a.w * l;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * l;
  }
  return o;
}
function _A(c, e, t, r, n) {
  const s = [];
  for (let h = 0; h <= t; ++h)
    s[h] = 0;
  const o = [];
  for (let h = 0; h <= r; ++h)
    o[h] = s.slice(0);
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = s.slice(0);
  i[0][0] = 1;
  const a = s.slice(0), l = s.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[c + 1 - h], l[h] = n[c + h] - e;
    let d = 0;
    for (let f = 0; f < h; ++f) {
      const p = l[f + 1], m = a[h - f];
      i[h][f] = p + m;
      const g = i[f][h - 1] / i[h][f];
      i[f][h] = d + p * g, d = m * g;
    }
    i[h][h] = d;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = i[h][t];
  for (let h = 0; h <= t; ++h) {
    let d = 0, f = 1;
    const p = [];
    for (let m = 0; m <= t; ++m)
      p[m] = s.slice(0);
    p[0][0] = 1;
    for (let m = 1; m <= r; ++m) {
      let g = 0;
      const b = h - m, v = t - m;
      h >= m && (p[f][0] = p[d][0] / i[v + 1][b], g = p[f][0] * i[b][v]);
      const y = b >= -1 ? 1 : -b, x = h - 1 <= v ? m - 1 : t - h;
      for (let w = y; w <= x; ++w)
        p[f][w] = (p[d][w] - p[d][w - 1]) / i[v + 1][b + w], g += p[f][w] * i[b + w][v];
      h <= v && (p[f][m] = -p[d][m - 1] / i[v + 1][h], g += p[f][m] * i[h][v]), o[m][h] = g;
      const N = d;
      d = f, f = N;
    }
  }
  let u = t;
  for (let h = 1; h <= r; ++h) {
    for (let d = 0; d <= t; ++d)
      o[h][d] *= u;
    u *= t - h;
  }
  return o;
}
function MA(c, e, t, r, n) {
  const s = n < c ? n : c, o = [], i = yx(c, r, e), a = _A(i, r, c, s, e), l = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), d = h.w;
    h.x *= d, h.y *= d, h.z *= d, l[u] = h;
  }
  for (let u = 0; u <= s; ++u) {
    const h = l[i - c].clone().multiplyScalar(a[u][0]);
    for (let d = 1; d <= c; ++d)
      h.add(l[i - c + d].clone().multiplyScalar(a[u][d]));
    o[u] = h;
  }
  for (let u = s + 1; u <= n + 1; ++u)
    o[u] = new pt(0, 0, 0);
  return o;
}
function AA(c, e) {
  let t = 1;
  for (let n = 2; n <= c; ++n)
    t *= n;
  let r = 1;
  for (let n = 2; n <= e; ++n)
    r *= n;
  for (let n = 2; n <= c - e; ++n)
    r *= n;
  return t / r;
}
function CA(c) {
  const e = c.length, t = [], r = [];
  for (let s = 0; s < e; ++s) {
    const o = c[s];
    t[s] = new ve(o.x, o.y, o.z), r[s] = o.w;
  }
  const n = [];
  for (let s = 0; s < e; ++s) {
    const o = t[s].clone();
    for (let i = 1; i <= s; ++i)
      o.sub(n[s - i].clone().multiplyScalar(AA(s, i) * r[i]));
    n[s] = o.divideScalar(r[0]);
  }
  return n;
}
function EA(c, e, t, r, n) {
  const s = MA(c, e, t, r, n);
  return CA(s);
}
class RA extends Bb {
  constructor(e, t, r, n, s) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = s || this.knots.length - 1;
    for (let o = 0; o < r.length; ++o) {
      const i = r[o];
      this.controlPoints[o] = new pt(i.x, i.y, i.z, i.w);
    }
  }
  getPoint(e, t = new ve()) {
    const r = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), s = SA(this.degree, this.knots, this.controlPoints, n);
    return s.w !== 1 && s.divideScalar(s.w), r.set(s.x, s.y, s.z);
  }
  getTangent(e, t = new ve()) {
    const r = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), s = EA(this.degree, this.knots, this.controlPoints, n, 1);
    return r.copy(s[1]).normalize(), r;
  }
}
let Ke, St, pn;
class LA extends wr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, n) {
    const s = this, o = s.path === "" ? ho.extractUrlBase(e) : s.path, i = new qs(this.manager);
    i.setPath(s.path), i.setResponseType("arraybuffer"), i.setRequestHeader(s.requestHeader), i.setWithCredentials(s.withCredentials), i.load(e, function(a) {
      try {
        t(s.parse(a, o));
      } catch (l) {
        n ? n(l) : console.error(l), s.manager.itemError(e);
      }
    }, r, n);
  }
  parse(e, t) {
    if (UA(e))
      Ke = new DA().parse(e);
    else {
      const n = Nx(e);
      if (!zA(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Wp(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Wp(n));
      Ke = new PA().parse(n);
    }
    const r = new Tu(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new FA(r, this.manager).parse(Ke);
  }
}
class FA {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    St = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), r = this.parseMaterials(t), n = this.parseDeformers(), s = new OA().parse(n);
    return this.parseScene(n, s, r), pn;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ke && Ke.Connections.connections.forEach(function(r) {
      const n = r[0], s = r[1], o = r[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const i = { ID: s, relationship: o };
      e.get(n).parents.push(i), e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(s).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ke.Objects) {
      const r = Ke.Objects.Video;
      for (const n in r) {
        const s = r[n], o = parseInt(n);
        if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
          const i = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0, a = typeof s.Content == "string" && s.Content !== "";
          if (i || a) {
            const l = this.parseImage(r[n]);
            t[s.RelativeFilename || s.Filename] = l;
          }
        }
      }
    }
    for (const r in e) {
      const n = e[r];
      t[n] !== void 0 ? e[r] = t[n] : e[r] = e[r].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, r = e.RelativeFilename || e.Filename, n = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
    let s;
    switch (n) {
      case "bmp":
        s = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        s = "image/jpeg";
        break;
      case "png":
        s = "image/png";
        break;
      case "tif":
        s = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", r), s = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + s + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: s }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ke.Objects) {
      const r = Ke.Objects.Texture;
      for (const n in r) {
        const s = this.parseTexture(r[n], e);
        t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const r = this.loadTexture(e, t);
    r.ID = e.id, r.name = e.attrName;
    const n = e.WrapModeU, s = e.WrapModeV, o = n !== void 0 ? n.value : 0, i = s !== void 0 ? s.value : 0;
    if (r.wrapS = o === 0 ? Js : fo, r.wrapT = i === 0 ? Js : fo, "Scaling" in e) {
      const a = e.Scaling.value;
      r.repeat.x = a[0], r.repeat.y = a[1];
    }
    if ("Translation" in e) {
      const a = e.Translation.value;
      r.offset.x = a[0], r.offset.y = a[1];
    }
    return r;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let r;
    const n = this.textureLoader.path, s = St.get(e.id).children;
    s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (r = t[s[0].ID], (r.indexOf("blob:") === 0 || r.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const i = e.FileName.slice(-3).toLowerCase();
    if (i === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new kn()) : (a.setPath(this.textureLoader.path), o = a.load(r));
    } else
      i === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new kn()) : o = this.textureLoader.load(r);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ke.Objects) {
      const r = Ke.Objects.Material;
      for (const n in r) {
        const s = this.parseMaterial(r[n], e);
        s !== null && t.set(parseInt(n), s);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const r = e.id, n = e.attrName;
    let s = e.ShadingModel;
    if (typeof s == "object" && (s = s.value), !St.has(r))
      return null;
    const o = this.parseParameters(e, t, r);
    let i;
    switch (s.toLowerCase()) {
      case "phong":
        i = new ga();
        break;
      case "lambert":
        i = new Am();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), i = new ga();
        break;
    }
    return i.setValues(o), i.name = n, i;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, r) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new je().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new je().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new je().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new je().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new je().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new je().fromArray(e.SpecularColor.value).convertSRGBToLinear());
    const s = this;
    return St.get(r).children.forEach(function(o) {
      const i = o.relationship;
      switch (i) {
        case "Bump":
          n.bumpMap = s.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = s.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = s.getTexture(t, o.ID), n.map !== void 0 && (n.map.colorSpace = yn);
          break;
        case "DisplacementColor":
          n.displacementMap = s.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = s.getTexture(t, o.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = yn);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = s.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = s.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = jm, n.envMap.colorSpace = yn);
          break;
        case "SpecularColor":
          n.specularMap = s.getTexture(t, o.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = yn);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = s.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", i);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ke.Objects && t in Ke.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = St.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ke.Objects) {
      const r = Ke.Objects.Deformer;
      for (const n in r) {
        const s = r[n], o = St.get(parseInt(n));
        if (s.attrType === "Skin") {
          const i = this.parseSkeleton(o, r);
          i.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), i.geometryID = o.parents[0].ID, e[n] = i;
        } else if (s.attrType === "BlendShape") {
          const i = {
            id: n
          };
          i.rawTargets = this.parseMorphTargets(o, r), i.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = i;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const r = [];
    return e.children.forEach(function(n) {
      const s = t[n.ID];
      if (s.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new Ge().fromArray(s.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), r.push(o);
    }), {
      rawBones: r,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const r = [];
    for (let n = 0; n < e.children.length; n++) {
      const s = e.children[n], o = t[s.ID], i = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      i.geoID = St.get(parseInt(s.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, r.push(i);
    }
    return r;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, r) {
    pn = new io();
    const n = this.parseModels(e.skeletons, t, r), s = Ke.Objects.Model, o = this;
    n.forEach(function(a) {
      const l = s[a.ID];
      o.setLookAtProperties(a, l), St.get(a.ID).parents.forEach(function(h) {
        const d = n.get(h.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && pn.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), pn.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const l = xx(a.userData.transformData);
        a.applyMatrix4(l), a.updateWorldMatrix();
      }
    });
    const i = new IA().parse();
    pn.children.length === 1 && pn.children[0].isGroup && (pn.children[0].animations = i, pn = pn.children[0]), pn.animations = i;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, r) {
    const n = /* @__PURE__ */ new Map(), s = Ke.Objects.Model;
    for (const o in s) {
      const i = parseInt(o), a = s[o], l = St.get(i);
      let u = this.buildSkeleton(l, e, i, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(l);
            break;
          case "Light":
            u = this.createLight(l);
            break;
          case "Mesh":
            u = this.createMesh(l, t, r);
            break;
          case "NurbsCurve":
            u = this.createCurve(l, t);
            break;
          case "LimbNode":
          case "Root":
            u = new Dl();
            break;
          case "Null":
          default:
            u = new io();
            break;
        }
        u.name = a.attrName ? Qo.sanitizeNodeName(a.attrName) : "", u.userData.originalName = a.attrName, u.ID = i;
      }
      this.getTransformData(u, a), n.set(i, u);
    }
    return n;
  }
  buildSkeleton(e, t, r, n) {
    let s = null;
    return e.parents.forEach(function(o) {
      for (const i in t) {
        const a = t[i];
        a.rawBones.forEach(function(l, u) {
          if (l.ID === o.ID) {
            const h = s;
            s = new Dl(), s.matrixWorld.copy(l.transformLink), s.name = n ? Qo.sanitizeNodeName(n) : "", s.userData.originalName = n, s.ID = r, a.bones[u] = s, h !== null && s.add(h);
          }
        });
      }
    }), s;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ke.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new vn();
    else {
      let n = 0;
      r.CameraProjectionType !== void 0 && r.CameraProjectionType.value === 1 && (n = 1);
      let s = 1;
      r.NearPlane !== void 0 && (s = r.NearPlane.value / 1e3);
      let o = 1e3;
      r.FarPlane !== void 0 && (o = r.FarPlane.value / 1e3);
      let i = window.innerWidth, a = window.innerHeight;
      r.AspectWidth !== void 0 && r.AspectHeight !== void 0 && (i = r.AspectWidth.value, a = r.AspectHeight.value);
      const l = i / a;
      let u = 45;
      r.FieldOfView !== void 0 && (u = r.FieldOfView.value);
      const h = r.FocalLength ? r.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new Tr(u, l, s, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new qa(-i / 2, i / 2, a / 2, -a / 2, s, o);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new vn();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, r;
    if (e.children.forEach(function(n) {
      const s = Ke.Objects.NodeAttribute[n.ID];
      s !== void 0 && (r = s);
    }), r === void 0)
      t = new vn();
    else {
      let n;
      r.LightType === void 0 ? n = 0 : n = r.LightType.value;
      let s = 16777215;
      r.Color !== void 0 && (s = new je().fromArray(r.Color.value).convertSRGBToLinear());
      let o = r.Intensity === void 0 ? 1 : r.Intensity.value / 100;
      r.CastLightOnObject !== void 0 && r.CastLightOnObject.value === 0 && (o = 0);
      let i = 0;
      r.FarAttenuationEnd !== void 0 && (r.EnableFarAttenuation !== void 0 && r.EnableFarAttenuation.value === 0 ? i = 0 : i = r.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new Zo(s, o, i, a);
          break;
        case 1:
          t = new gi(s, o);
          break;
        case 2:
          let l = Math.PI / 3;
          r.InnerAngle !== void 0 && (l = Zt.degToRad(r.InnerAngle.value));
          let u = 0;
          r.OuterAngle !== void 0 && (u = Zt.degToRad(r.OuterAngle.value), u = Math.max(u, 1)), t = new yi(s, o, i, l, u, a);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), t = new Zo(s, o);
          break;
      }
      r.CastShadows !== void 0 && r.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, r) {
    let n, s = null, o = null;
    const i = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (s = t.get(a.ID)), r.has(a.ID) && i.push(r.get(a.ID));
    }), i.length > 1 ? o = i : i.length > 0 ? o = i[0] : (o = new ga({
      name: wr.DEFAULT_MATERIAL_NAME,
      color: 13421772
    }), i.push(o)), "color" in s.attributes && i.forEach(function(a) {
      a.vertexColors = !0;
    }), s.FBX_Deformer ? (n = new Pm(s, o), n.normalizeSkinWeights()) : n = new qt(s, o), n;
  }
  createCurve(e, t) {
    const r = e.children.reduce(function(s, o) {
      return t.has(o.ID) && (s = t.get(o.ID)), s;
    }, null), n = new bu({
      name: wr.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Dm(r, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const r = {};
    "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? r.eulerOrder = bx(t.RotationOrder.value) : r.eulerOrder = "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && St.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const s = Ke.Objects.Model[n.ID];
        if ("Lcl_Translation" in s) {
          const o = s.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), pn.add(e.target)) : e.lookAt(new ve().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, r) {
    const n = this.parsePoseNodes();
    for (const s in e) {
      const o = e[s];
      St.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const l = a.ID;
          St.get(l).parents.forEach(function(h) {
            r.has(h.ID) && r.get(h.ID).bind(new Su(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ke.Objects) {
      const t = Ke.Objects.Pose;
      for (const r in t)
        if (t[r].attrType === "BindPose" && t[r].NbPoseNodes > 0) {
          const n = t[r].PoseNode;
          Array.isArray(n) ? n.forEach(function(s) {
            e[s.Node] = new Ge().fromArray(s.Matrix.a);
          }) : e[n.Node] = new Ge().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ke && "AmbientColor" in Ke.GlobalSettings) {
      const e = Ke.GlobalSettings.AmbientColor.value, t = e[0], r = e[1], n = e[2];
      if (t !== 0 || r !== 0 || n !== 0) {
        const s = new je(t, r, n).convertSRGBToLinear();
        pn.add(new vu(s, 1));
      }
    }
  }
}
class OA {
  constructor() {
    this.negativeMaterialIndices = !1;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ke.Objects) {
      const r = Ke.Objects.Geometry;
      for (const n in r) {
        const s = St.get(parseInt(n)), o = this.parseGeometry(s, r[n], e);
        t.set(parseInt(n), o);
      }
    }
    return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, r) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, r);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, r) {
    const n = r.skeletons, s = [], o = e.parents.map(function(h) {
      return Ke.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const i = e.children.reduce(function(h, d) {
      return n[d.ID] !== void 0 && (h = n[d.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      r.morphTargets[h.ID] !== void 0 && s.push(r.morphTargets[h.ID]);
    });
    const a = o[0], l = {};
    "RotationOrder" in a && (l.eulerOrder = bx(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
    const u = xx(l);
    return this.genGeometry(t, i, s, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, r, n) {
    const s = new Jn();
    e.attrName && (s.name = e.attrName);
    const o = this.parseGeoNode(e, t), i = this.genBuffers(o), a = new gn(i.vertex, 3);
    if (a.applyMatrix4(n), s.setAttribute("position", a), i.colors.length > 0 && s.setAttribute("color", new gn(i.colors, 3)), t && (s.setAttribute("skinIndex", new kb(i.weightsIndices, 4)), s.setAttribute("skinWeight", new gn(i.vertexWeights, 4)), s.FBX_Deformer = t), i.normal.length > 0) {
      const l = new Ns().getNormalMatrix(n), u = new gn(i.normal, 3);
      u.applyNormalMatrix(l), s.setAttribute("normal", u);
    }
    if (i.uvs.forEach(function(l, u) {
      const h = u === 0 ? "uv" : `uv${u}`;
      s.setAttribute(h, new gn(i.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let l = i.materialIndex[0], u = 0;
      if (i.materialIndex.forEach(function(h, d) {
        h !== l && (s.addGroup(u, d - u, l), l = h, u = d);
      }), s.groups.length > 0) {
        const h = s.groups[s.groups.length - 1], d = h.start + h.count;
        d !== i.materialIndex.length && s.addGroup(d, i.materialIndex.length - d, l);
      }
      s.groups.length === 0 && s.addGroup(0, i.materialIndex.length, i.materialIndex[0]);
    }
    return this.addMorphTargets(s, e, r, n), s;
  }
  parseGeoNode(e, t) {
    const r = {};
    if (r.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], r.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      r.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && r.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return r.weightTable = {}, t !== null && (r.skeleton = t, t.rawBones.forEach(function(n, s) {
      n.indices.forEach(function(o, i) {
        r.weightTable[o] === void 0 && (r.weightTable[o] = []), r.weightTable[o].push({
          id: s,
          weight: n.weights[i]
        });
      });
    })), r;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let r = 0, n = 0, s = !1, o = [], i = [], a = [], l = [], u = [], h = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, p) {
      let m, g = !1;
      f < 0 && (f = f ^ -1, g = !0);
      let b = [], v = [];
      if (o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = Zi(p, r, f, e.color);
        a.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          v.push(y.weight), b.push(y.id);
        }), v.length > 4) {
          s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
          const y = [0, 0, 0, 0], x = [0, 0, 0, 0];
          v.forEach(function(N, w) {
            let T = N, _ = b[w];
            x.forEach(function(L, A, U) {
              if (T > L) {
                U[A] = T, T = L;
                const S = y[A];
                y[A] = _, _ = S;
              }
            });
          }), b = y, v = x;
        }
        for (; v.length < 4; )
          v.push(0), b.push(0);
        for (let y = 0; y < 4; ++y)
          u.push(v[y]), h.push(b[y]);
      }
      if (e.normal) {
        const y = Zi(p, r, f, e.normal);
        i.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = Zi(p, r, f, e.material)[0], m < 0 && (d.negativeMaterialIndices = !0, m = 0)), e.uv && e.uv.forEach(function(y, x) {
        const N = Zi(p, r, f, y);
        l[x] === void 0 && (l[x] = []), l[x].push(N[0]), l[x].push(N[1]);
      }), n++, g && (n > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), d.genFace(t, e, o, m, i, a, l, u, h, n), r++, n = 0, o = [], i = [], a = [], l = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, r, n, s, o, i, a, l, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[r[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[r[h * 3]]), e.vertex.push(t.vertexPositions[r[h * 3 + 1]]), e.vertex.push(t.vertexPositions[r[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[(h - 1) * 4]), e.weightsIndices.push(l[(h - 1) * 4 + 1]), e.weightsIndices.push(l[(h - 1) * 4 + 2]), e.weightsIndices.push(l[(h - 1) * 4 + 3]), e.weightsIndices.push(l[h * 4]), e.weightsIndices.push(l[h * 4 + 1]), e.weightsIndices.push(l[h * 4 + 2]), e.weightsIndices.push(l[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(i[f][0]), e.uvs[f].push(i[f][1]), e.uvs[f].push(i[f][(h - 1) * 2]), e.uvs[f].push(i[f][(h - 1) * 2 + 1]), e.uvs[f].push(i[f][h * 2]), e.uvs[f].push(i[f][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, r, n) {
    if (r.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const s = this;
    r.forEach(function(o) {
      o.rawTargets.forEach(function(i) {
        const a = Ke.Objects.Geometry[i.geoID];
        a !== void 0 && s.genMorphGeometry(e, t, a, n, i.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, r, n, s) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], i = r.Vertices !== void 0 ? r.Vertices.a : [], a = r.Indexes !== void 0 ? r.Indexes.a : [], l = e.attributes.position.count * 3, u = new Float32Array(l);
    for (let p = 0; p < a.length; p++) {
      const m = a[p] * 3;
      u[m] = i[p * 3], u[m + 1] = i[p * 3 + 1], u[m + 2] = i[p * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, d = this.genBuffers(h), f = new gn(d.vertex, 3);
    f.name = s || r.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Normals.a;
    let s = [];
    return r === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.UV.a;
    let s = [];
    return r === "IndexToDirect" && (s = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType, n = e.Colors.a;
    let s = [];
    r === "IndexToDirect" && (s = e.ColorIndex.a);
    for (let o = 0, i = new je(); o < n.length; o += 4)
      i.fromArray(n, o).convertSRGBToLinear().toArray(n, o);
    return {
      dataSize: 4,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, r = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: r
      };
    const n = e.Materials.a, s = [];
    for (let o = 0; o < n.length; ++o)
      s.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: s,
      mappingType: t,
      referenceType: r
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Jn();
    const r = t - 1, n = e.KnotVector.a, s = [], o = e.Points.a;
    for (let h = 0, d = o.length; h < d; h += 4)
      s.push(new pt().fromArray(o, h));
    let i, a;
    if (e.Form === "Closed")
      s.push(s[0]);
    else if (e.Form === "Periodic") {
      i = r, a = n.length - 1 - i;
      for (let h = 0; h < r; ++h)
        s.push(s[h]);
    }
    const u = new RA(r, n, s, i, a).getPoints(s.length * 12);
    return new Jn().setFromPoints(u);
  }
}
class IA {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const r in t) {
        const n = t[r], s = this.addClip(n);
        e.push(s);
      }
    return e;
  }
  parseClips() {
    if (Ke.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ke.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const r in e) {
      const n = e[r];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const s = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(s.id, s);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ke.Objects.AnimationCurve;
    for (const r in t) {
      const n = {
        id: t[r].id,
        times: t[r].KeyTime.a.map(BA),
        values: t[r].KeyValueFloat.a
      }, s = St.get(n.id);
      if (s !== void 0) {
        const o = s.parents[0].ID, i = s.parents[0].relationship;
        i.match(/X/) ? e.get(o).curves.x = n : i.match(/Y/) ? e.get(o).curves.y = n : i.match(/Z/) ? e.get(o).curves.z = n : i.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ke.Objects.AnimationLayer, r = /* @__PURE__ */ new Map();
    for (const n in t) {
      const s = [], o = St.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, l) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (s[l] === void 0) {
              const h = St.get(a.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const d = Ke.Objects.Model[h.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const f = {
                  modelName: d.attrName ? Qo.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                pn.traverse(function(p) {
                  p.ID === d.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new Ge()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), s[l] = f;
              }
            }
            s[l] && (s[l][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (s[l] === void 0) {
              const h = St.get(a.ID).parents.filter(function(b) {
                return b.relationship !== void 0;
              })[0].ID, d = St.get(h).parents[0].ID, f = St.get(d).parents[0].ID, p = St.get(f).parents[0].ID, m = Ke.Objects.Model[p], g = {
                modelName: m.attrName ? Qo.sanitizeNodeName(m.attrName) : "",
                morphName: Ke.Objects.Deformer[h].attrName
              };
              s[l] = g;
            }
            s[l][u.attr] = u;
          }
        }
      }), r.set(parseInt(n), s));
    }
    return r;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ke.Objects.AnimationStack, r = {};
    for (const n in t) {
      const s = St.get(parseInt(n)).children;
      s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const o = e.get(s[0].ID);
      r[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return r;
  }
  addClip(e) {
    let t = [];
    const r = this;
    return e.layer.forEach(function(n) {
      t = t.concat(r.generateTracks(n));
    }), new _u(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let r = new ve(), n = new dr(), s = new ve();
    if (e.transform && e.transform.decompose(r, n, s), r = r.toArray(), n = new ws().setFromQuaternion(n, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(e.modelName, e.R.curves, n, e.preRotation, e.postRotation, e.eulerOrder);
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, r, n) {
    const s = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(s, t, r);
    return new Ul(e + "." + n, s, o);
  }
  generateRotationTrack(e, t, r, n, s, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Zt.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Zt.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Zt.degToRad));
    const i = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(i, t, r);
    n !== void 0 && (n = n.map(Zt.degToRad), n.push(o), n = new ws().fromArray(n), n = new dr().setFromEuler(n)), s !== void 0 && (s = s.map(Zt.degToRad), s.push(o), s = new ws().fromArray(s), s = new dr().setFromEuler(s).invert());
    const l = new dr(), u = new ws(), h = [];
    for (let d = 0; d < a.length; d += 3)
      u.set(a[d], a[d + 1], a[d + 2], o), l.setFromEuler(u), n !== void 0 && l.premultiply(n), s !== void 0 && l.multiply(s), l.toArray(h, d / 3 * 4);
    return new Bl(e + ".quaternion", i, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, r = t.values.map(function(s) {
      return s / 100;
    }), n = pn.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new zl(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, r);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(r, n) {
      return r - n;
    }), t.length > 1) {
      let r = 1, n = t[0];
      for (let s = 1; s < t.length; s++) {
        const o = t[s];
        o !== n && (t[r] = o, n = o, r++);
      }
      t = t.slice(0, r);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, r) {
    const n = r, s = [];
    let o = -1, i = -1, a = -1;
    return e.forEach(function(l) {
      if (t.x && (o = t.x.times.indexOf(l)), t.y && (i = t.y.times.indexOf(l)), t.z && (a = t.z.times.indexOf(l)), o !== -1) {
        const u = t.x.values[o];
        s.push(u), n[0] = u;
      } else
        s.push(n[0]);
      if (i !== -1) {
        const u = t.y.values[i];
        s.push(u), n[1] = u;
      } else
        s.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        s.push(u), n[2] = u;
      } else
        s.push(n[2]);
    }), s;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const r = e.values[t - 1], n = e.values[t] - r, s = Math.abs(n);
      if (s >= 180) {
        const o = s / 180, i = n / o;
        let a = r + i;
        const l = e.times[t - 1], h = (e.times[t] - l) / o;
        let d = l + h;
        const f = [], p = [];
        for (; d < e.times[t]; )
          f.push(d), d += h, p.push(a), a += i;
        e.times = Hp(e.times, t, f), e.values = Hp(e.values, t, p);
      }
    }
  }
}
class PA {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new vx(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, r = e.split(/[\r\n]+/);
    return r.forEach(function(n, s) {
      const o = n.match(/^[\s\t]*;/), i = n.match(/^[\s\t]*$/);
      if (o || i)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : l ? t.parseNodeProperty(n, l, r[++s]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const r = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), s = { name: r }, o = this.parseNodeAttr(n), i = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(r, s) : r in i ? (r === "PoseNode" ? i.PoseNode.push(s) : i[r].id !== void 0 && (i[r] = {}, i[r][i[r].id] = i[r]), o.id !== "" && (i[r][o.id] = s)) : typeof o.id == "number" ? (i[r] = {}, i[r][o.id] = s) : r !== "Properties70" && (r === "PoseNode" ? i[r] = [s] : i[r] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let r = "", n = "";
    return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: r, type: n };
  }
  parseNodeProperty(e, t, r) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, s);
      return;
    }
    if (n === "C") {
      const a = s.split(",").slice(1), l = parseInt(a[0]), u = parseInt(a[1]);
      let h = s.split(",").slice(3);
      h = h.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", s = [l, u], GA(s, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = s), n in o && Array.isArray(o[n]) ? o[n].push(s) : n !== "a" ? o[n] = s : o.a = s, this.setCurrentProp(o, n), n === "a" && s.slice(-1) !== "," && (o.a = bl(s));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = bl(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, r) {
    const n = r.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), s = n[0], o = n[1], i = n[2], a = n[3];
    let l = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        l = parseFloat(l);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        l = bl(l);
        break;
    }
    this.getPrevNode()[s] = {
      type: o,
      type2: i,
      flag: a,
      value: l
    }, this.setCurrentProp(this.getPrevNode(), s);
  }
}
class DA {
  parse(e) {
    const t = new jp(e);
    t.skip(23);
    const r = t.getUint32();
    if (r < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
    const n = new vx();
    for (; !this.endOfContent(t); ) {
      const s = this.parseNode(t, r);
      s !== null && n.add(s.name, s);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const r = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), s = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), i = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let d = 0; d < s; d++)
      a.push(this.parseProperty(e));
    const l = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (r.singleProperty = s === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(i, r, d);
    }
    return r.propertyList = a, typeof l == "number" && (r.id = l), u !== "" && (r.attrName = u), h !== "" && (r.attrType = h), i !== "" && (r.name = i), r;
  }
  parseSubNode(e, t, r) {
    if (r.singleProperty === !0) {
      const n = r.propertyList[0];
      Array.isArray(n) ? (t[r.name] = r, r.a = n) : t[r.name] = n;
    } else if (e === "Connections" && r.name === "C") {
      const n = [];
      r.propertyList.forEach(function(s, o) {
        o !== 0 && n.push(s);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (r.name === "Properties70")
      Object.keys(r).forEach(function(s) {
        t[s] = r[s];
      });
    else if (e === "Properties70" && r.name === "P") {
      let n = r.propertyList[0], s = r.propertyList[1];
      const o = r.propertyList[2], i = r.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? a = [
        r.propertyList[4],
        r.propertyList[5],
        r.propertyList[6]
      ] : a = r.propertyList[4], t[n] = {
        type: s,
        type2: o,
        flag: i,
        value: a
      };
    } else
      t[r.name] === void 0 ? typeof r.id == "number" ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : r.name === "PoseNode" ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : t[r.name][r.id] === void 0 && (t[r.name][r.id] = r);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let r;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return r = e.getUint32(), e.getArrayBuffer(r);
      case "S":
        return r = e.getUint32(), e.getString(r);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), s = e.getUint32(), o = e.getUint32();
        if (s === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const i = bA(new Uint8Array(e.getArrayBuffer(o))), a = new jp(i.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class jp {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    const t = this.offset;
    let r = new Uint8Array(this.dv.buffer, t, e);
    this.skip(e);
    const n = r.indexOf(0);
    return n >= 0 && (r = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(r);
  }
}
class vx {
  add(e, t) {
    this[e] = t;
  }
}
function UA(c) {
  const e = "Kaydara FBX Binary  \0";
  return c.byteLength >= e.length && e === Nx(c, 0, e.length);
}
function zA(c) {
  const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let t = 0;
  function r(n) {
    const s = c[n - 1];
    return c = c.slice(t + n), t++, s;
  }
  for (let n = 0; n < e.length; ++n)
    if (r(1) === e[n])
      return !1;
  return !0;
}
function Wp(c) {
  const e = /FBXVersion: (\d+)/, t = c.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function BA(c) {
  return c / 46186158e3;
}
const kA = [];
function Zi(c, e, t, r) {
  let n;
  switch (r.mappingType) {
    case "ByPolygonVertex":
      n = c;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = r.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
  }
  r.referenceType === "IndexToDirect" && (n = r.indices[n]);
  const s = n * r.dataSize, o = s + r.dataSize;
  return VA(kA, r.buffer, s, o);
}
const xl = new ws(), zr = new ve();
function xx(c) {
  const e = new Ge(), t = new Ge(), r = new Ge(), n = new Ge(), s = new Ge(), o = new Ge(), i = new Ge(), a = new Ge(), l = new Ge(), u = new Ge(), h = new Ge(), d = new Ge(), f = c.inheritType ? c.inheritType : 0;
  if (c.translation && e.setPosition(zr.fromArray(c.translation)), c.preRotation) {
    const A = c.preRotation.map(Zt.degToRad);
    A.push(c.eulerOrder || ws.DEFAULT_ORDER), t.makeRotationFromEuler(xl.fromArray(A));
  }
  if (c.rotation) {
    const A = c.rotation.map(Zt.degToRad);
    A.push(c.eulerOrder || ws.DEFAULT_ORDER), r.makeRotationFromEuler(xl.fromArray(A));
  }
  if (c.postRotation) {
    const A = c.postRotation.map(Zt.degToRad);
    A.push(c.eulerOrder || ws.DEFAULT_ORDER), n.makeRotationFromEuler(xl.fromArray(A)), n.invert();
  }
  c.scale && s.scale(zr.fromArray(c.scale)), c.scalingOffset && i.setPosition(zr.fromArray(c.scalingOffset)), c.scalingPivot && o.setPosition(zr.fromArray(c.scalingPivot)), c.rotationOffset && a.setPosition(zr.fromArray(c.rotationOffset)), c.rotationPivot && l.setPosition(zr.fromArray(c.rotationPivot)), c.parentMatrixWorld && (h.copy(c.parentMatrix), u.copy(c.parentMatrixWorld));
  const p = t.clone().multiply(r).multiply(n), m = new Ge();
  m.extractRotation(u);
  const g = new Ge();
  g.copyPosition(u);
  const b = g.clone().invert().multiply(u), v = m.clone().invert().multiply(b), y = s, x = new Ge();
  if (f === 0)
    x.copy(m).multiply(p).multiply(v).multiply(y);
  else if (f === 1)
    x.copy(m).multiply(v).multiply(p).multiply(y);
  else {
    const U = new Ge().scale(new ve().setFromMatrixScale(h)).clone().invert(), S = v.clone().multiply(U);
    x.copy(m).multiply(p).multiply(S).multiply(y);
  }
  const N = l.clone().invert(), w = o.clone().invert();
  let T = e.clone().multiply(a).multiply(l).multiply(t).multiply(r).multiply(n).multiply(N).multiply(i).multiply(o).multiply(s).multiply(w);
  const _ = new Ge().copyPosition(T), L = u.clone().multiply(_);
  return d.copyPosition(L), T = d.clone().multiply(x), T.premultiply(u.invert()), T;
}
function bx(c) {
  c = c || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return c === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[c];
}
function bl(c) {
  return c.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Nx(c, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = c.byteLength), new TextDecoder().decode(new Uint8Array(c, e, t));
}
function GA(c, e) {
  for (let t = 0, r = c.length, n = e.length; t < n; t++, r++)
    c[r] = e[t];
}
function VA(c, e, t, r) {
  for (let n = t, s = 0; n < r; n++, s++)
    c[s] = e[n];
  return c;
}
function Hp(c, e, t) {
  return c.slice(0, e).concat(t).concat(c.slice(e));
}
const wx = new aA();
wx.setDecoderPath("/draco/");
class Sc extends bn {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Ja(0.1), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isModel3D", !0);
    G(this, "_model", "");
    G(this, "_modelRoot", null);
    G(this, "_modeMatrix");
    G(this, "_object");
    G(this, "_isLoading", !1);
    G(this, "_castShadowModel", !1);
    G(this, "_receiveShadowModel", !1);
    G(this, "_objectOrgSize", new ve());
    this.type = "Model3D", this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this.onBeforeRender = () => {
      (this._castShadowModel !== this.castShadow || this._receiveShadowModel !== this.receiveShadow) && this.updateModelShadow();
    }, this.geometry.boundingBox || this.geometry.computeBoundingBox();
  }
  get model() {
    return this._model;
  }
  set model(t) {
    this._model !== t && (this._object && this._object.removeFromParent(), this._model && (this._modeMatrix = void 0), this._model = t, this.loadModel());
  }
  async loadModel() {
    if (this._object && (this._object.removeFromParent(), this._object = void 0), !this._model)
      return;
    this._isLoading = !0;
    let t;
    if (/.glb$/i.test(this._model))
      t = new Kd(), t.setDRACOLoader(wx);
    else if (/.fbx$/i.test(this._model))
      t = new LA();
    else
      throw ze.panic(`Model[${this._model}] is not supported!`);
    const r = await t.loadAsync(this._model);
    r instanceof io ? this._object = r : this._object = r.scene, this._modelRoot = r, this._object.__isHidden = !0, this._isLoading = !1, this.material.visible = !1, this.add(this._object), this.objectAutoSize(), this.updateModelShadow();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.resizeObject();
  }
  resizeObject() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0);
    const r = this.geometry.boundingBox.getSize(new ve()).divide(this._objectOrgSize), n = Math.min(r.x, r.y, r.z);
    this._object.scale.set(n, n, n);
  }
  objectAutoSize() {
    if (!this._object || !this.geometry.boundingBox)
      return;
    if (this.updateMatrixWorld(!0), this._object.updateMatrixWorld(!0), this._modeMatrix)
      return this._object.applyMatrix4(this._modeMatrix);
    const t = this.geometry.boundingBox.getSize(new ve()).multiply(this.scale), r = this.getWorldPosition(new ve()), n = new er().setFromObject(this._object, !0), s = n.getCenter(new ve()), o = n.getSize(this._objectOrgSize), i = t.divide(o), a = Math.min(i.x, i.y, i.z);
    this._object.position.copy(r.sub(s).multiply(i)), this._object.scale.set(a, a, a);
  }
  updateModelShadow() {
    this._object && (this._castShadowModel = this.castShadow, this._receiveShadowModel = this.receiveShadow, this._object.traverse((t) => {
      t.castShadow = this._castShadowModel, t.receiveShadow = this._receiveShadowModel;
    }));
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), r.geometry = s(t.geometries, this.geometry), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        o !== this._object && r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    super.serialize(t), t.model = this._model, t.objectOrgSize = this._objectOrgSize.toArray(), this._object && (t.modeMatrix = this._object.matrix.toArray());
  }
  deserialize(t) {
    super.deserialize(t), t.objectOrgSize && this._objectOrgSize.fromArray(t.objectOrgSize), t.modeMatrix && (this._modeMatrix = new Ge().fromArray(t.modeMatrix), this._object && this._object.applyMatrix4(this._modeMatrix)), this.model = t.model;
  }
}
Ye("Model3D", {
  create: ({ material: c, geometry: e } = {}) => new Sc(e, c),
  members: {
    model: "String"
  },
  proto: "Entity",
  group: "",
  icon: ""
});
class Tx extends Sc {
  constructor(e, t, r = 0, n = 0) {
    super(e || new Xa(1, 1, 1), t, r, n), this.type = "StaticMesh";
  }
  rebuildBody() {
    if (!this._object)
      return;
    const e = this.world;
    if (this.physicalBody && (this.world && this.world.removeMesh(this), Hs.destroyBody(this.physicalBody)), this._bodyType !== wc.Ghost) {
      const t = Hs.createShape(this._object);
      this.physicalBody = Hs.createBody(this, this._mass, t), this.physicalBody.setUserIndex(this.id), e && e.addMesh(this, this.physicalBody);
    } else
      this.physicalBody = null;
  }
}
Ye("StaticMesh", {
  create: ({ material: c, geometry: e } = {}) => new Tx(e, c),
  members: {
    "geo.width": "Number",
    "geo.height": "Number",
    "geo.depth": "Number",
    model: "String"
  },
  proto: "Entity",
  group: "Objects.Static Mesh",
  icon: "mesh"
});
class Sx extends Sc {
  constructor(t, r, n = 0, s = 0) {
    super(t || new Em(), r || new An({ wireframe: !0, transparent: !0 }), n, s);
    G(this, "isCharacter", !0);
    G(this, "actions", {});
    G(this, "_mixer");
    G(this, "_clips", []);
    G(this, "_objectOrgSize", new ve());
    this.type = "Character";
  }
  async loadModel() {
    if (await super.loadModel(), !this._object || !this._modelRoot)
      return;
    const t = this._object.getObjectByProperty("isMesh", !0);
    t && (t.onBeforeRender = () => {
      this._mixer && this._mixer.update(nn.delta);
    }), this._mixer = new Gb(this._object), this._mixer.addEventListener("finished", ({ action: r }) => {
      const n = Object.entries(this.actions).find((s) => s[1].action === r);
      n && (ze.notice(`action ${n[0]} finished!`), n[1].isPending = !1, n[1].resolve && (n[1].resolve(!0), n[1].resolve = void 0));
    }), this._clips = this._modelRoot.animations || [];
    for (const r of this._clips)
      this.actions[r.name] = { isPending: !1, action: this._mixer.clipAction(r), resolve: void 0 };
  }
  async act(t, r) {
    const n = this.actions[t];
    if (n) {
      if (n.isPending)
        return !0;
    } else
      return !1;
    n.isPending = !0;
    const s = n.action;
    return s.clampWhenFinished = !0, s.reset().setLoop(r ? Vb : jb, r ? 1 / 0 : 1).setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(1).play(), new Promise((o) => {
      n.resolve = o;
    });
  }
  stop(t) {
    const r = t ? [t] : Object.keys(this.actions);
    for (const n of r) {
      const s = this.actions[n];
      if (s) {
        if (!s.isPending)
          continue;
      } else
        continue;
      s.isPending = !1, s.resolve && (s.resolve(!1), s.resolve = void 0), s.action.stop();
    }
  }
}
Ye("Character", {
  create: ({ material: c, geometry: e } = {}) => new Sx(e, c),
  members: {
    "geo.radius": "Number",
    "geo.length": "Number",
    "geo.capSegments": "Number",
    "geo.radialSegments": "Number"
  },
  proto: "Model3D",
  group: "Objects.Character",
  icon: "human"
});
const Bt = new ve(), jA = new ve();
class _x extends Um {
  constructor(t, r) {
    super(t || new Jn(), r);
    G(this, "isParticles", !0);
    G(this, "mass", 0);
    /** Resistance Coefficient */
    G(this, "airResCoe", 25e-4);
    G(this, "growSpeed", 1);
    G(this, "spaceSize", new ve(1, 1, 1));
    G(this, "bornSpaceSize", new ve(1, 1, 1));
    G(this, "bornPoint", new ve(0, 0, 0));
    G(this, "_count", 100);
    G(this, "_countFired", 0);
    G(this, "_positions", null);
    G(this, "_velocities", null);
    G(this, "_bornTime", 0);
    this.type = "Particles", this.rebuildBuffer(), this.onBeforeRender = () => {
      this.update();
    };
  }
  get count() {
    return this._count;
  }
  set count(t) {
    t <= 0 && (t = 100), this._count !== t && (this._count = t, this.rebuildBuffer());
  }
  rebuildBuffer() {
    this._countFired = 0, this.geometry.setDrawRange(0, 0);
    const t = new Float32Array(this._count * 3), r = new Float32Array(this._count * 3), n = new gn(t, 3), s = new gn(r, 3);
    n.setUsage(gu), this.geometry.setAttribute("position", n), this._positions = n, this._velocities = s;
  }
  update() {
    for (let t = 0; t < this._countFired; t++) {
      const r = this._positions.getX(t), n = this._positions.getY(t), s = this._positions.getZ(t);
      if (this.isOutofSpace(r, n, s))
        this._positions.setXYZ(t, ...this.randBornPoint()), this._velocities.setXYZ(t, 0, 0, 0);
      else {
        const [o, i] = nn.calcObjectPosition(
          Bt.set(r, n, s),
          jA.set(this._velocities.getX(t), this._velocities.getY(t), this._velocities.getZ(t)),
          this.mass,
          this.airResCoe
        );
        this._positions.setXYZ(t, ...o.toArray()), this._velocities.setXYZ(t, ...i.toArray());
      }
    }
    this.grow(), this._positions.needsUpdate = !0;
  }
  grow() {
    if (this._countFired >= this._count)
      return;
    const t = this._bornTime === 0 ? 1 : (nn.now - this._bornTime) / 1e3;
    this._bornTime || (this._bornTime = nn.now);
    const r = Math.floor(t * this.growSpeed), n = Math.min(r, this._count) - this._countFired;
    if (n <= 0)
      return;
    const s = this._countFired;
    this._countFired += n;
    for (let o = s; o < this._countFired; o++)
      this._positions.setXYZ(o, ...this.randBornPoint()), this._velocities.setXYZ(o, 0, 0, 0);
    this.geometry.setDrawRange(0, this._countFired);
  }
  isOutofSpace(t, r, n) {
    return t > this.spaceSize.x || t < -this.spaceSize.x || r > this.spaceSize.y || r < -this.spaceSize.y || n > this.spaceSize.z || n < -this.spaceSize.z;
  }
  randBornPoint() {
    return Bt.copy(this.bornPoint), Bt.x += this.bornSpaceSize.x * (Math.random() - 0.5) * 2, Bt.y += this.bornSpaceSize.y * (Math.random() - 0.5) * 2, Bt.z += this.bornSpaceSize.z * (Math.random() - 0.5) * 2, Bt.x > this.spaceSize.x ? Bt.x = this.spaceSize.x - 1e-5 : Bt.x < -this.spaceSize.x && (Bt.x = -this.spaceSize.x + 1e-5), Bt.y > this.spaceSize.y ? Bt.y = this.spaceSize.y - 1e-5 : Bt.y < -this.spaceSize.y && (Bt.y = -this.spaceSize.y + 1e-5), Bt.z > this.spaceSize.z ? Bt.z = this.spaceSize.z - 1e-5 : Bt.z < -this.spaceSize.z && (Bt.z = -this.spaceSize.z + 1e-5), Bt.toArray();
  }
  toJSON(t) {
    const r = {}, n = {
      metadata: {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      },
      object: r
    };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let i = 0, a = this.material.length; i < a; i++)
          o.push(s(t.materials, this.material[i]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (const o of this.children)
        r.children.push(o.toJSON(t).object);
    }
    return n;
    function s(o, i) {
      return o[i.uuid] === void 0 && (o[i.uuid] = i.toJSON(t)), i.uuid;
    }
  }
  serialize(t) {
    t.mass = this.mass, t.spaceSize = this.spaceSize.toArray(), t.bornSpaceSize = this.bornSpaceSize.toArray(), t.bornPoint = this.bornPoint.toArray(), t.count = this.count, t.growSpeed = this.growSpeed, t.airResCoe = this.airResCoe;
  }
  deserialize(t) {
    t.mass !== void 0 && (this.mass = t.mass), t.spaceSize && this.spaceSize.fromArray(t.spaceSize), t.bornSpaceSize && this.bornSpaceSize.fromArray(t.bornSpaceSize), t.bornPoint && this.bornPoint.fromArray(t.bornPoint), t.count > 0 && (this.count = t.count), t.growSpeed > 0 && (this.growSpeed = t.growSpeed), t.airResCoe !== void 0 && (this.airResCoe = t.airResCoe);
  }
}
Ye("Particles", {
  members: {
    mass: "Number",
    airResCoe: "Number",
    count: "Number",
    spaceSize: "Vector3",
    bornPoint: "Vector3",
    bornSpaceSize: "Vector3",
    growSpeed: "Number"
  },
  proto: "Points",
  group: "Particles.Particles",
  icon: "box",
  create: () => new _x()
});
class _c extends qt {
  constructor(e, t = {}) {
    super(e), this.isRefractor = !0, this.type = "Refractor", this.camera = new Tr();
    const r = this, n = t.color !== void 0 ? new je(t.color) : new je(8355711), s = t.textureWidth || 512, o = t.textureHeight || 512, i = t.clipBias || 0, a = t.shader || _c.RefractorShader, l = t.multisample !== void 0 ? t.multisample : 4, u = this.camera;
    u.matrixAutoUpdate = !1, u.userData.refractor = !0;
    const h = new kl(), d = new Ge(), f = new Mu(s, o, { samples: l, type: Wm });
    this.material = new hs({
      name: a.name !== void 0 ? a.name : "unspecified",
      uniforms: tr.clone(a.uniforms),
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      transparent: !0
      // ensures, refractors are drawn from farthest to closest
    }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = d;
    const p = function() {
      const y = new ve(), x = new ve(), N = new Ge(), w = new ve(), T = new ve();
      return function(L) {
        return y.setFromMatrixPosition(r.matrixWorld), x.setFromMatrixPosition(L.matrixWorld), w.subVectors(y, x), N.extractRotation(r.matrixWorld), T.set(0, 0, 1), T.applyMatrix4(N), w.dot(T) < 0;
      };
    }(), m = function() {
      const y = new ve(), x = new ve(), N = new dr(), w = new ve();
      return function() {
        r.matrixWorld.decompose(x, N, w), y.set(0, 0, 1).applyQuaternion(N).normalize(), y.negate(), h.setFromNormalAndCoplanarPoint(y, x);
      };
    }(), g = function() {
      const y = new kl(), x = new pt(), N = new pt();
      return function(T) {
        u.matrixWorld.copy(T.matrixWorld), u.matrixWorldInverse.copy(u.matrixWorld).invert(), u.projectionMatrix.copy(T.projectionMatrix), u.far = T.far, y.copy(h), y.applyMatrix4(u.matrixWorldInverse), x.set(y.normal.x, y.normal.y, y.normal.z, y.constant);
        const _ = u.projectionMatrix;
        N.x = (Math.sign(x.x) + _.elements[8]) / _.elements[0], N.y = (Math.sign(x.y) + _.elements[9]) / _.elements[5], N.z = -1, N.w = (1 + _.elements[10]) / _.elements[14], x.multiplyScalar(2 / x.dot(N)), _.elements[2] = x.x, _.elements[6] = x.y, _.elements[10] = x.z + 1 - i, _.elements[14] = x.w;
      };
    }();
    function b(y) {
      d.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), d.multiply(y.projectionMatrix), d.multiply(y.matrixWorldInverse), d.multiply(r.matrixWorld);
    }
    function v(y, x, N) {
      r.visible = !1;
      const w = y.getRenderTarget(), T = y.xr.enabled, _ = y.shadowMap.autoUpdate;
      y.xr.enabled = !1, y.shadowMap.autoUpdate = !1, y.setRenderTarget(f), y.autoClear === !1 && y.clear(), y.render(x, u), y.xr.enabled = T, y.shadowMap.autoUpdate = _, y.setRenderTarget(w);
      const L = N.viewport;
      L !== void 0 && y.state.viewport(L), r.visible = !0;
    }
    this.onBeforeRender = function(y, x, N) {
      N.userData.refractor !== !0 && p(N) && (m(), b(N), g(N), v(y, x, N));
    }, this.getRenderTarget = function() {
      return f;
    }, this.dispose = function() {
      f.dispose(), r.material.dispose();
    };
  }
}
_c.RefractorShader = {
  name: "RefractorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Qi = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
class Zd extends qt {
  constructor(t, r) {
    super(t || new Ar(1, 1), r || new hs({
      name: Qi.name,
      uniforms: tr.clone(Qi.uniforms),
      fragmentShader: Qi.fragmentShader,
      vertexShader: Qi.vertexShader
    }));
    G(this, "isReflector", !0);
    G(this, "props", {
      color: new je(8355711),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      multisample: 4
    });
    G(this, "renderTarget");
    G(this, "camera", new Tr());
    this.type = "Reflector";
    const n = new kl(), s = new ve(), o = new ve(), i = new ve(), a = new Ge(), l = new ve(0, 0, -1), u = new pt(), h = new ve(), d = new ve(), f = new pt(), p = new Ge(), m = this.camera;
    this.renderTarget = new Mu(this.props.textureWidth, this.props.textureHeight, { samples: this.props.multisample, type: Wm }), r ? this.props.color = this.material.uniforms.color.value : this.material.uniforms.color.value = this.props.color, this.material.uniforms.tDiffuse.value = this.renderTarget.texture, this.material.uniforms.textureMatrix.value = p, this.onBeforeRender = (g, b, v) => {
      if (o.setFromMatrixPosition(this.matrixWorld), i.setFromMatrixPosition(v.matrixWorld), a.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(a), h.subVectors(o, i), h.dot(s) > 0)
        return;
      h.reflect(s).negate(), h.add(o), a.extractRotation(v.matrixWorld), l.set(0, 0, -1), l.applyMatrix4(a), l.add(i), d.subVectors(o, l), d.reflect(s).negate(), d.add(o), m.position.copy(h), m.up.set(0, 1, 0), m.up.applyMatrix4(a), m.up.reflect(s), m.lookAt(d), m.far = v instanceof Tr ? v.far : 1e3, m.updateMatrixWorld(), m.projectionMatrix.copy(v.projectionMatrix), p.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), p.multiply(m.projectionMatrix), p.multiply(m.matrixWorldInverse), p.multiply(this.matrixWorld), n.setFromNormalAndCoplanarPoint(s, o), n.applyMatrix4(m.matrixWorldInverse), u.set(n.normal.x, n.normal.y, n.normal.z, n.constant);
      const y = m.projectionMatrix;
      f.x = (Math.sign(u.x) + y.elements[8]) / y.elements[0], f.y = (Math.sign(u.y) + y.elements[9]) / y.elements[5], f.z = -1, f.w = (1 + y.elements[10]) / y.elements[14], u.multiplyScalar(2 / u.dot(f)), y.elements[2] = u.x, y.elements[6] = u.y, y.elements[10] = u.z + 1 - this.props.clipBias, y.elements[14] = u.w, this.visible = !1;
      const x = g.getRenderTarget(), N = g.xr.enabled, w = g.shadowMap.autoUpdate;
      g.xr.enabled = !1, g.shadowMap.autoUpdate = !1, g.setRenderTarget(this.renderTarget), g.state.buffers.depth.setMask(!0), g.autoClear === !1 && g.clear(), g.render(b, m), g.xr.enabled = N, g.shadowMap.autoUpdate = w, g.setRenderTarget(x);
      const T = v.viewport;
      T !== void 0 && g.state.viewport(T), this.visible = !0;
    };
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.renderTarget.setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t);
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  dispose() {
    this.renderTarget.dispose(), this.material.dispose();
  }
  clone(t) {
    const r = super.clone(t), n = Zs(this.props);
    return Qs(r.props, n), r;
  }
  serialize(t) {
    t.props = Zs(this.props);
  }
  deserialize(t) {
    t.props && Qs(this.props, t.props);
  }
}
Ye("Reflector", {
  members: {
    castShadow: "Boolean",
    receiveShadow: "Boolean",
    color: "Color",
    textureWidth: "Number",
    textureHeight: "Number",
    clipBias: "Number"
  },
  proto: "Object3D",
  group: "Objects.Reflector",
  icon: "plane",
  create: ({ geometry: c, material: e } = {}) => new Zd(c, e)
});
const Ta = 0.15, ea = Ta * 0.5, so = class so extends bn {
  constructor(t, r) {
    super(t || new Ar(10, 10), r || new hs({
      uniforms: tr.merge([
        oo.fog,
        so.WaterShader.uniforms
      ]),
      vertexShader: so.WaterShader.vertexShader,
      fragmentShader: so.WaterShader.fragmentShader,
      transparent: !0,
      fog: !0
    }), 0, 0);
    G(this, "isWaterPlane", !0);
    G(this, "props", {
      color: new je(),
      textureWidth: 512,
      textureHeight: 512,
      clipBias: 0,
      flowDirection: new wt(1, 0),
      flowSpeed: 0.03,
      reflectivity: 0.02,
      scale: 1
    });
    G(this, "textureMatrix", new Ge());
    G(this, "reflector");
    G(this, "refractor");
    G(this, "refractorClipBias");
    this.type = "WaterPlane", t || (this.rotation.x = -Math.PI / 2);
    const n = new Zd(t);
    n.textureWidth = this.props.textureWidth, n.textureHeight = this.props.textureHeight, n.clipBias = this.props.clipBias;
    const s = new _c(t, {
      textureWidth: this.props.textureWidth,
      textureHeight: this.props.textureHeight,
      clipBias: 0
    });
    if (this.refractorClipBias = s.camera.projectionMatrix.elements[10], n.matrixAutoUpdate = !1, s.matrixAutoUpdate = !1, this.reflector = n, this.refractor = s, r)
      this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.props.flowDirection = this.material.uniforms.flowDirection.value, this.props.color = this.material.uniforms.color.value, this.props.reflectivity = this.material.uniforms.reflectivity.value, this.textureMatrix = this.material.uniforms.textureMatrix.value, this.props.scale = this.material.uniforms.config.value.w;
    else {
      this.material.uniforms.flowDirection = {
        type: "v2",
        value: this.props.flowDirection
      };
      const o = new kn(), i = new kn();
      o.wrapS = o.wrapT = Js, i.wrapS = i.wrapT = Js, this.material.uniforms.tReflectionMap.value = n.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = s.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = o, this.material.uniforms.tNormalMap1.value = i, this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = ea, this.material.uniforms.config.value.z = ea, this.material.uniforms.config.value.w = this.props.scale;
    }
    this.onBeforeRender = function(o, i, a) {
      this.updateTextureMatrix(a), this.updateFlow(), this.visible = !1, n.matrixWorld.copy(this.matrixWorld), s.matrixWorld.copy(this.matrixWorld), n.onBeforeRender(o, i, a, null, null, null), s.onBeforeRender(o, i, a, null, null, null), this.visible = !0;
    };
  }
  get normalMap0() {
    return this.material.uniforms.tNormalMap0.value;
  }
  set normalMap0(t) {
    const r = this.material.uniforms.tNormalMap0.value;
    r !== t && (this.material.uniforms.tNormalMap0.value = t, r.dispose());
  }
  get normalMap1() {
    return this.material.uniforms.tNormalMap1.value;
  }
  set normalMap1(t) {
    const r = this.material.uniforms.tNormalMap1.value;
    r !== t && (this.material.uniforms.tNormalMap1.value = t, r.dispose());
  }
  get color() {
    return this.props.color;
  }
  set color(t) {
    this.props.color = t, this.material.uniforms.color.value = t;
  }
  get textureWidth() {
    return this.props.textureWidth;
  }
  set textureWidth(t) {
    this.props.textureWidth !== t && (this.props.textureWidth = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get textureHeight() {
    return this.props.textureHeight;
  }
  set textureHeight(t) {
    this.props.textureHeight !== t && (this.props.textureHeight = t, this.reflector.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight), this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight));
  }
  get clipBias() {
    return this.props.clipBias;
  }
  set clipBias(t) {
    this.props.clipBias !== t && (this.props.clipBias = t, this.reflector.clipBias = t);
  }
  get flowDirection() {
    return this.props.flowDirection;
  }
  set flowDirection(t) {
    this.props.flowDirection !== t && (this.props.flowDirection = t, this.material.uniforms.flowDirection.value = t);
  }
  get flowSpeed() {
    return this.props.flowSpeed;
  }
  set flowSpeed(t) {
    this.props.flowSpeed !== t && (this.props.flowSpeed = t);
  }
  get reflectivity() {
    return this.props.reflectivity;
  }
  set reflectivity(t) {
    this.props.reflectivity !== t && (this.props.reflectivity = t, this.material.uniforms.reflectivity.value = this.props.reflectivity);
  }
  get waterScale() {
    return this.props.scale;
  }
  set waterScale(t) {
    this.props.scale !== t && (this.props.scale = t, this.material.uniforms.config.value.w = this.props.scale);
  }
  appleProps() {
    this.material.uniforms.color.value = this.props.color, this.material.uniforms.reflectivity.value = this.props.reflectivity, this.material.uniforms.flowDirection.value = this.props.flowDirection, this.material.uniforms.config.value.w = this.props.scale, this.reflector.textureWidth = this.props.textureWidth, this.reflector.textureHeight = this.props.textureHeight, this.reflector.clipBias = this.props.clipBias, this.refractor.getRenderTarget().setSize(this.props.textureWidth, this.props.textureHeight);
  }
  clone(t) {
    const r = super.clone(t), n = this.props[Gt], s = Zs(n), o = r.props[Gt];
    return Qs(o, s), o.appleProps(), r;
  }
  serialize(t) {
    super.serialize(t), t.props = Zs(this.props);
  }
  deserialize(t) {
    super.deserialize(t), t.props && (Qs(this.props, t.props), this.appleProps());
  }
  dispose() {
    this.reflector.dispose(), this.refractor.dispose();
  }
  rebuildGeometry() {
    super.rebuildGeometry(), this.reflector.geometry = this.geometry, this.refractor.geometry = this.geometry;
  }
  updateTextureMatrix(t) {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), this.textureMatrix.multiply(t.projectionMatrix), this.textureMatrix.multiply(t.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld);
  }
  updateFlow() {
    const t = this.material.uniforms.config;
    t.value.x += this.props.flowSpeed * nn.delta, t.value.y = t.value.x + ea, t.value.x >= Ta ? (t.value.x = 0, t.value.y = ea) : t.value.y >= Ta && (t.value.y = t.value.y - Ta);
  }
};
G(so, "WaterShader", {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new pt()
    }
  },
  vertexShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_vertex>
      #include <logdepthbuf_pars_vertex>
  
      uniform mat4 textureMatrix;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        vUv = uv;
        vCoord = textureMatrix * vec4( position, 1.0 );
  
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vToEye = cameraPosition - worldPosition.xyz;
  
        vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
        gl_Position = projectionMatrix * mvPosition;
  
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
  
      }`
  ),
  fragmentShader: (
    /* glsl */
    `
  
      #include <common>
      #include <fog_pars_fragment>
      #include <logdepthbuf_pars_fragment>
  
      uniform sampler2D tReflectionMap;
      uniform sampler2D tRefractionMap;
      uniform sampler2D tNormalMap0;
      uniform sampler2D tNormalMap1;
  
      #ifdef USE_FLOWMAP
        uniform sampler2D tFlowMap;
      #else
        uniform vec2 flowDirection;
      #endif
  
      uniform vec3 color;
      uniform float reflectivity;
      uniform vec4 config;
  
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
  
      void main() {
  
        #include <logdepthbuf_fragment>
  
        float flowMapOffset0 = config.x;
        float flowMapOffset1 = config.y;
        float halfCycle = config.z;
        float scale = config.w;
  
        vec3 toEye = normalize( vToEye );
  
        // determine flow direction
        vec2 flow;
        #ifdef USE_FLOWMAP
          flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
        #else
          flow = flowDirection;
        #endif
        flow.x *= - 1.0;
  
        // sample normal maps (distort uvs with flowdata)
        vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
        vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );
  
        // linear interpolate to get the final normal color
        float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
        vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );
  
        // calculate normal vector
        vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
  
        // calculate the fresnel term to blend reflection and refraction maps
        float theta = max( dot( toEye, normal ), 0.0 );
        float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );
  
        // calculate final uv coords
        vec3 coord = vCoord.xyz / vCoord.w;
        vec2 uv = coord.xy + coord.z * normal.xz * 0.05;
  
        vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
        vec4 refractColor = texture2D( tRefractionMap, uv );
  
        // multiply water color with the mix of both textures
        gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );
  
        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
  
      }`
  )
});
let uu = so;
const Nl = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new ve() },
    up: { value: new ve(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
}, WA = new vn();
class Mx extends qt {
  constructor(t, r) {
    super(t || new Xa(1, 1, 1), r || new hs({
      name: "SkyShader",
      fragmentShader: Nl.fragmentShader,
      vertexShader: Nl.vertexShader,
      uniforms: tr.clone(Nl.uniforms),
      side: yu,
      depthWrite: !1
    }));
    G(this, "isSkyBox", !0);
    G(this, "_renderTarget");
    G(this, "_pmremGenerator");
    G(this, "_sceneTmp", new $a());
    G(this, "_sceneRoot");
    G(this, "_sun");
    G(this, "_sunPosition");
    this.type = "SkyBox", t || this.scale.multiplyScalar(1e3), r || (this.material.uniforms.turbidity.value = 10, this.material.uniforms.rayleigh.value = 2, this.material.uniforms.mieCoefficient.value = 5e-3, this.material.uniforms.mieDirectionalG.value = 0.8, this.material.uniforms.sunPosition.value.copy(this.calSunPosition(2, 180))), this._sunPosition = this.material.uniforms.sunPosition.value, this.onBeforeRender = async (n, s, o) => {
      this._sceneRoot = s, this._sun && typeof this._sun == "string" && (this._sun = s.getObjectByProperty("uuid", this._sun)), this._renderTarget || (this._renderTarget = 1, this._pmremGenerator = new Wb(n), this.updateRenderTarget()), this._sun && !this._sun.position.equals(this._sunPosition) && this.updateSunPotision();
    };
  }
  get turbidity() {
    return this.material.uniforms.turbidity.value;
  }
  set turbidity(t) {
    this.material.uniforms.turbidity.value = t;
  }
  get rayleigh() {
    return this.material.uniforms.rayleigh.value;
  }
  set rayleigh(t) {
    this.material.uniforms.rayleigh.value = t;
  }
  get mieCoefficient() {
    return this.material.uniforms.mieCoefficient.value;
  }
  set mieCoefficient(t) {
    this.material.uniforms.mieCoefficient.value = t;
  }
  get mieDirectionalG() {
    return this.material.uniforms.mieDirectionalG.value;
  }
  set mieDirectionalG(t) {
    this.material.uniforms.mieDirectionalG.value = t;
  }
  get sunPosition() {
    return this.material.uniforms.sunPosition.value;
  }
  set sunPosition(t) {
    this.material.uniforms.sunPosition.value.copy(t);
  }
  get sun() {
    return WA;
  }
  set sun(t) {
    t instanceof gi && (this._sun = t, this.updateSunPotision());
  }
  calSunPosition(t, r) {
    const n = Zt.degToRad(90 - t), s = Zt.degToRad(r), o = new ve();
    return o.setFromSphericalCoords(1, n, s), o;
  }
  updateSunPotision() {
    typeof this._sun == "object" && (this.material.uniforms.sunPosition.value.copy(this._sun.position), this.updateRenderTarget());
  }
  updateRenderTarget() {
    if (this._renderTarget !== void 0 && typeof this._renderTarget == "object" && this._renderTarget.dispose(), !this._pmremGenerator)
      return;
    const t = this.parent, r = t ? t.children.indexOf(this) : -1;
    t && t.children.splice(r, 1), this._sceneTmp.children.push(this), this._renderTarget = this._pmremGenerator.fromScene(this._sceneTmp), t && (r !== -1 ? t.children.splice(r, 0, this) : t.children.push(this)), this._sceneRoot && (this._sceneRoot.background = this._renderTarget.texture, this._sceneRoot.environment = this._renderTarget.texture);
  }
  serialize(t) {
    t.scale = this.scale.toArray(), t.turbidity = this.turbidity, t.rayleigh = this.rayleigh, t.mieCoefficient = this.mieCoefficient, t.mieDirectionalG = this.mieDirectionalG, t.sunPosition = this.sunPosition.toArray(), this._sun && (t.sun = this._sun.uuid || this._sun);
  }
  deserialize(t) {
    this.scale.fromArray(t.scale), this.turbidity = t.turbidity, this.rayleigh = t.rayleigh, this.mieCoefficient = t.mieCoefficient, this.mieDirectionalG = t.mieDirectionalG, this.sunPosition.fromArray(t.sunPosition), t.sun && (this._sun = t.sun), this.updateRenderTarget();
  }
}
Ye(
  "SkyBox",
  {
    members: {
      scale: "Vector3",
      turbidity: "Number",
      rayleigh: "Number",
      mieCoefficient: "Number",
      mieDirectionalG: "Number",
      sun: "Object3D"
    },
    proto: "Object3D",
    group: "Objects.Sky Box",
    icon: "box",
    create: ({ geometry: c, material: e } = {}) => new Mx(c, e)
  }
);
Jn.prototype.computeBoundsTree = rN;
Jn.prototype.disposeBoundsTree = oN;
qt.prototype.raycast = iN;
class tn extends Fe {
  constructor(t, r, n) {
    super("void");
    G(this, "isObjectNode", !0);
    G(this, "typesExtended", { in: {}, out: {} });
    G(this, "isObject3DNode");
    G(this, "eventDispatcher", null);
    G(this, "_object", null);
    G(this, "_objectRaw", null);
    this._inst = t, this.objectType = r, n && (this.object = n), this.updateType = "none", this.isObject3DNode = li(r, "Object3D"), this.initTypes();
  }
  get object() {
    return this._object;
  }
  set object(t) {
    if (typeof t != "object" || !JS(t, this.objectType))
      throw ze.panic(`type is not compitable, expected type is ${this.objectType}!`);
    this._objectRaw = t, this._object = new Proxy(t, {
      get(r, n, s) {
        if (n === Gt)
          return r;
        if (typeof n != "string")
          return Reflect.get(r, n, s);
        const o = n.split(".");
        if (o.length > 1) {
          let i = Reflect.get(r, o[0], s);
          for (let a = 1; a < o.length; a++)
            i = i[o[a]];
          return i;
        }
        return Reflect.get(r, n, s);
      },
      set: (r, n, s, o) => {
        if (typeof n != "string")
          return Reflect.set(r, n, s, o);
        if (Reflect.get(r, n, o) === s)
          return !0;
        let a = !0;
        const l = n.split(".");
        if (l.length > 1) {
          let u = Reflect.get(r, l[0], o);
          const h = l.pop();
          for (let d = 1; d < l.length; d++)
            u = u[l[d]];
          if (u[h] === s)
            return !0;
          u[h] = s;
        } else
          a = Reflect.set(r, n, s, r);
        if (this.eventDispatcher) {
          const u = !!this.typesExtended.in[n];
          this.eventDispatcher.dispatchEvent({ type: u ? "nodeEventInputChanged" : "nodeEventOutputChanged", source: null, node: this, fields: [n] });
        }
        return a;
      }
    }), (t instanceof vn || t instanceof M.Material) && (this.objectType = t.type, this.initTypes()), Object.defineProperty(this, "_object", {
      writable: !1
    });
  }
  getObjectsExtended() {
    return { in: this.object, out: this.object };
  }
  fill(t, r) {
    this._object && typeof this._object == "string" && (this.object = r[this._object] || t.getObjectByProperty("uuid", this._object));
  }
  dispose() {
    this._object && this._object instanceof kn && this._object.dispose();
  }
  toJSON(t) {
    const r = super.toJSON(t);
    if (this._object instanceof kn) {
      const n = this._object.toJSON(t);
      t.textures[this._object.uuid] = n;
    }
    return r;
  }
  serialize(t) {
    if (!this._object)
      throw ze.panic("object has not been set before serialize!");
    super.serialize(t), t._inst = this._inst, t.object = this._object.uuid, t.objectType = this.objectType;
  }
  deserialize(t) {
    if (!li(t.objectType, this.objectType))
      throw ze.panic(`type is not compitable, expected type is ${this.objectType}!`);
    super.deserialize(t), this._object = t.object, this.initTypes();
  }
  createDefault(t) {
    if (this.isObject3DNode)
      this.object = t, this.objectType = t.type, this.initTypes();
    else {
      const r = M[this.objectType];
      if (!r)
        throw ze.panic(`class[${this.objectType}] not found in THREE!`);
      this.object = new r();
    }
  }
  initTypes() {
    const t = ka(this.objectType);
    if (!t)
      throw ze.panic(`class[${this.objectType}] not found!`);
    Ts(this.typesExtended.in), Object.assign(this.typesExtended.in, t.in), Ts(this.typesExtended.out), Object.assign(this.typesExtended.out, t.out);
  }
}
Es(
  "ObjectNode",
  tn,
  {
    // @ts-expect-error
    object: "Object3D | Texture"
  },
  "",
  {
    object3DRef: { clsName: "ObjectNode", func: () => new tn("object3DRef", "Object3D"), group: "Objects.Object", icon: "box" },
    texture: { clsName: "ObjectNode", func: () => new tn("texture", "Texture"), group: "Inputs.Primitives.Texture", icon: "photo" }
    // cubeTexture: { clsName: 'CubeTexture', func: () => new ObjectNode('cubeTexture', 'CubeTexture'), group: 'Inputs.Primitives.Cube Texture', icon: 'photo' },
  }
);
const Ax = {
  Boolean: {
    fromJson: (c) => new Boolean(c),
    toJson: (c) => c
  },
  Number: {
    fromJson: (c) => c ?? 0,
    toJson: (c) => c
  },
  String: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Url: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Script: {
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Color: {
    fromJson: (c) => new je().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector2: {
    fromJson: (c) => new wt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector3: {
    fromJson: (c) => new ve().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Vector4: {
    fromJson: (c) => new pt().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  Euler: {
    fromJson: (c) => new ws().fromArray(c || []),
    toJson: (c) => c.toArray()
  },
  // uniformNode for gpu
  bool: {
    label: "bool UniformNode",
    fromJson: function(c) {
      const e = new nt(!1, "bool");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  float: {
    label: "float UniformNode",
    fromJson: function(c) {
      const e = new nt(0, "float");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  color: {
    label: "color UniformNode",
    fromJson: function(c) {
      const e = new nt(new je(), "color");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec2: {
    label: "vec2 UniformNode",
    fromJson: function(c) {
      const e = new nt(new wt());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec3: {
    label: "vec3 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ve());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  vec4: {
    label: "vec4 UniformNode",
    fromJson: function(c) {
      const e = new nt(new ve());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  int: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "int");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ns());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  mat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge());
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  code: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  uint: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(0, "uint");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  void: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  property: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  sampler: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  cubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  ivec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "ivec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "uvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec2: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new wt(), "bvec2");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ve(), "ivec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ve(), "uvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new ve(), "bvec3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  ivec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "ivec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  uvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "uvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bvec4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new pt(), "bvec4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ns(), "imat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ns(), "umat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat3: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ns(), "bmat3");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  imat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "imat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  umat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "umat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  bmat4: {
    label: void 0,
    fromJson: function(c) {
      const e = new nt(new Ge(), "bmat4");
      return c && e.deserialize(c), e;
    },
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix3: {
    label: void 0,
    fromJson: (c) => new Ns(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Matrix4: {
    label: void 0,
    fromJson: (c) => new Ge(),
    toJson: function(c) {
      const e = {};
      return c.serialize(e), c;
    }
  },
  Audio: {
    label: void 0,
    fromJson: (c) => c || "",
    toJson: (c) => c
  },
  Image: {
    label: void 0,
    fromJson: function(c) {
      const e = document.createElement("img");
      return c != null && c.src && (e.src = c.src), e;
    },
    toJson: function(c) {
      return { src: c.src };
    }
  },
  Texture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  CubeTexture: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Material: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  },
  Object3D: {
    label: void 0,
    fromJson: function() {
      throw new Error("Function not implemented.");
    },
    toJson: function() {
      throw new Error("Function not implemented.");
    }
  }
};
function ta(c, e) {
  return Ax[c].fromJson(e);
}
function Xp(c, e) {
  return Ax[c].toJson(e);
}
const Cx = globalThis.AsyncFunction || (async (c) => c).constructor;
class xo extends tn {
  constructor(t, r, n = !0) {
    super(t, "Object3D", r);
    G(this, "isScriptNode", !0);
    G(this, "inputs");
    G(this, "outputs");
    G(this, "enabled", !1);
    G(this, "_parametersProps", ["params", "out", "THREE", "TSL", "world", "window", "document"]);
    G(this, "_parameters", [null, null, M, S1, nn, null, null]);
    G(this, "_code", "");
    // eslint-disable-next-line @typescript-eslint/ban-types
    G(this, "_main");
    this.editable = n, this.inputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this.outputs = new Proxy({}, {
      set: (s, o, i, a) => typeof o != "string" ? Reflect.set(s, o, i, a) : Reflect.get(s, o, a) === i ? !0 : (this.eventDispatcher && this.eventDispatcher.dispatchEvent({ type: "nodeEventOutputChanged", source: null, node: this, fields: [o] }), Reflect.set(s, o, i, a))
    }), this._parameters[0] = this.inputs, this._parameters[1] = this.outputs, this._main = this.compile();
  }
  get code() {
    return this._code;
  }
  set code(t) {
    this._code = t;
    try {
      this._main = this.compile();
    } catch (r) {
      console.warn(r);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this._code && this.object && await this._main.call(this._objectRaw, ...this._parameters);
  }
  getObjectsExtended() {
    return { in: this.inputs, out: this.outputs };
  }
  initTypes() {
  }
  addInput(t, r) {
    if (this.typesExtended.in[t])
      return;
    this.typesExtended.in[t] = { types: [r], direct: "in", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = ta(r);
    return this.inputs[t] = n, n;
  }
  removeInput(t) {
    return this.typesExtended.in[t] ? (delete this.typesExtended.in[t], delete this.inputs[t], !0) : !1;
  }
  addOutput(t, r) {
    if (this.typesExtended.out[t])
      return;
    this.typesExtended.out[t] = { types: [r], direct: "out", nname: /^[a-z]/.test(r) ? t : void 0 };
    const n = ta(r);
    return this.outputs[t] = n, n;
  }
  removeOutput(t) {
    return this.typesExtended.out[t] ? (delete this.typesExtended.out[t], delete this.outputs[t], !0) : !1;
  }
  serialize(t) {
    var r;
    super.serialize(t), t.object = (r = this.object) == null ? void 0 : r.uuid, t.types = { ...this.typesExtended }, t.enabled = this.enabled, t.inputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.in))
      t.inputs[n] = Xp(s.types[0], this.inputs[n]);
    t.outputs = {};
    for (const [n, s] of Object.entries(this.typesExtended.out))
      t.outputs[n] = Xp(s.types[0], this.outputs[n]);
    t.code = this._code;
  }
  deserialize(t) {
    var r, n;
    super.deserialize(t), (r = t.types) != null && r.in && (Ts(this.typesExtended.in), Object.assign(this.typesExtended.in, t.types.in));
    for (const [s, o] of Object.entries(this.typesExtended.in)) {
      const i = t.inputs ? t.inputs[s] : void 0;
      this.inputs[s] = ta(o.types[0], i);
    }
    (n = t.types) != null && n.out && (Ts(this.typesExtended.out), Object.assign(this.typesExtended.out, t.types.out));
    for (const [s, o] of Object.entries(this.typesExtended.out)) {
      const i = t.outputs ? t.outputs[s] : void 0;
      this.outputs[s] = ta(o.types[0], i);
    }
    t.code !== void 0 && (this.code = t.code), this.enabled = t.enabled;
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new Cx(this._parametersProps, this._code);
  }
}
Es(
  "ScriptNode",
  xo,
  {
    enabled: "Boolean",
    code: "Script"
  },
  "ObjectNode"
);
class _n extends xo {
  constructor() {
    super(...arguments);
    G(this, "isScriptBlockNode", !0);
    G(this, "_prev");
    G(this, "_next");
  }
  get prev() {
    return this._prev;
  }
  set prev(t) {
    this._prev = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async exec(t) {
    this.enabled && this.object && (this._code ? await this._main.call(this._objectRaw, ...this._parameters) : !0) !== !1 && this._next && await this._next.exec(t);
  }
  fill(t, r) {
    super.fill(t, r), this.prev && typeof this.prev == "string" && (this.prev = r[this.prev]), this.next && typeof this.next == "string" && (this.next = r[this.next]);
  }
  serialize(t) {
    var r, n;
    super.serialize(t), t.prev = (r = this.prev) == null ? void 0 : r.uuid, t.next = (n = this.next) == null ? void 0 : n.uuid;
  }
  deserialize(t) {
    super.deserialize(t), this.prev = t.prev, this.next = t.next;
  }
}
Es("ScriptBlockNode", _n, {}, "ScriptNode", {
  scriptBlock: { clsName: "UpdateNode", func: () => new _n("scriptBlock"), group: "Scripts.Script Block", icon: "brand-javascript" }
});
class hr extends _n {
  constructor(t, r, n, s) {
    super(t, n);
    G(this, "isEventListenerNode", !0);
    G(this, "_event", "onBorn");
    G(this, "_eventSource");
    G(this, "_listener");
    r && (this._event = r), this._eventSource = s || this.object;
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t, this._eventSource || (this._eventSource = t), this.resetEventlisten(this._event);
  }
  get event() {
    return this._event;
  }
  set event(t) {
    this.resetEventlisten(t), this._event = t;
  }
  serialize(t) {
    super.serialize(t), t.event = this.event;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event;
  }
  resetEventlisten(t) {
    this.object === null || typeof this.object != "object" || (this._listener && this._eventSource.removeEventListener(this.event, this._listener), this._listener = (r) => {
      this.exec(r);
    }, this._eventSource.addEventListener(t, this._listener));
  }
  dispose() {
    super.dispose(), this._listener && typeof this.object == "object" && this._eventSource.removeEventListener(this.event, this._listener);
  }
}
Es("EventListenerNode", hr, {
  event: "String"
}, "ScriptBlockNode", {
  eventOnBorn: { clsName: "EventListenerNode", func: () => new hr("eventOnBorn", "onBorn"), group: "Scripts.On Born", icon: "loader" },
  eventOnDead: { clsName: "EventListenerNode", func: () => new hr("eventOnDead", "onDead"), group: "Scripts.On Dead", icon: "bell-off" },
  eventOnCollisionEnter: { clsName: "EventListenerNode", func: () => new hr("eventOnCollisionEnter", "onCollisionEnter"), group: "Scripts.On Collision Enter", icon: "arrows-shuffle" },
  eventOnCollisionLeave: { clsName: "EventListenerNode", func: () => new hr("eventOnCollisionLeave", "onCollisionLeave"), group: "Scripts.On Collision Leave", icon: "arrow-bounce" },
  eventCustom: { clsName: "EventListenerNode", func: () => new hr("eventCustom", "onCustomEvent"), group: "Scripts.On Custom Event", icon: "calendar-event" }
});
class $p extends xo {
  constructor(t, r) {
    super(t, r);
    G(this, "isUpdateNode", !0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdate(t, r, n, s) {
    if (this.enabled && this._code && this.object)
      try {
        this._main.call(this._objectRaw, ...this._parameters, n, s);
      } catch (o) {
        console.error(o);
      }
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  compile() {
    return new Function(...this._parametersProps, "delta", "now", this._code);
  }
}
Es("UpdateNode", $p, {}, "ScriptNode", {
  update: { clsName: "UpdateNode", func: () => new $p("update"), group: "Scripts.On Update", icon: "refresh" }
});
class qp extends _n {
  constructor(t, r) {
    super(t, r);
    G(this, "isKeyboardNode", !0);
    G(this, "event", "keydown");
    G(this, "key", "");
    G(this, "_listenerKeyDown");
    G(this, "_listenerKeyUp");
    G(this, "_listenerBorn");
    G(this, "_listenerDead");
    G(this, "_isActived", !1);
    this._listenerKeyDown = (s) => {
      this.exec(s);
    }, this._listenerKeyUp = (s) => {
      this.exec(s);
    }, this._listenerBorn = () => {
      this._isActived = !0;
    }, this._listenerDead = () => {
      this._isActived = !1;
    };
    const n = ["_listenerKeyDown", "_listenerKeyUp"];
    window.addEventListener("keydown", this._listenerKeyDown), window.addEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), n.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const s of n)
      Object.defineProperty(this, s, {
        writable: !1
      });
  }
  get object() {
    return super.object;
  }
  set object(t) {
    super.object = t;
    const r = [];
    this.object && typeof this.object == "object" && (this.object.addEventListener("onBorn", this._listenerBorn), this.object.addEventListener("onDead", this._listenerDead), r.push("_listener", "_listenerBorn", "_listenerDead"));
    for (const n of r)
      Object.defineProperty(this, n, {
        writable: !1
      });
  }
  async exec(t) {
    if (this._isActived && !(t.type !== this.event || t.key !== this.key))
      return super.exec(t);
  }
  serialize(t) {
    super.serialize(t), t.event = this.event, t.key = this.key;
  }
  deserialize(t) {
    super.deserialize(t), this.event = t.event, this.key = t.key;
  }
  dispose() {
    super.dispose(), window.removeEventListener("keydown", this._listenerKeyDown), window.removeEventListener("keyup", this._listenerKeyUp), this.object && typeof this.object == "object" && (this.object.removeEventListener("onBorn", this._listenerBorn), this.object.removeEventListener("onDead", this._listenerDead));
  }
}
Es("KeyboardNode", qp, {
  event: '"keydown"|"keyup"',
  key: '"a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"'
}, "ScriptBlockNode", {
  keyboardEvent: { clsName: "KeyboardNode", func: () => new qp("keyboardEvent"), group: "Scripts.On Keyboard", icon: "keyboard" }
});
const HA = {
  lineBasicMaterial: { clsName: "LineBasicMaterial", func: () => new M.LineBasicMaterial(), group: "Material.Line Basic Material", icon: "brand-medium" },
  // lineBasicNodeMaterial: { clsName: 'LineBasicNodeMaterial', func: () => new Nodes.LineBasicNodeMaterial(), group: 'Material.Line Basic Material Node', icon: 'brand-medium' },
  meshBasicMaterial: { clsName: "MeshBasicMaterial", func: () => new M.MeshBasicMaterial(), group: "Material.Mesh Basic Material", icon: "brand-medium" },
  // meshBasicNodeMaterial: { clsName: 'MeshBasicNodeMaterial', func: () => new Nodes.MeshBasicNodeMaterial(), group: 'Material.Mesh Basic Material Node', icon: 'brand-medium' },
  meshPhysicalMaterial: { clsName: "MeshPhysicalMaterial", func: () => new M.MeshPhysicalMaterial({}), group: "Material.Mesh Physical Material", icon: "brand-medium" },
  // meshPhysicalNodeMaterial: { clsName: 'MeshPhysicalNodeMaterial', func: () => new Nodes.MeshPhysicalNodeMaterial({}), group: 'Material.Mesh Physical Material Node', icon: 'brand-medium' },
  meshStandardMaterial: { clsName: "MeshStandardMaterial", func: () => new M.MeshStandardMaterial(), group: "Material.Mesh Standard Material", icon: "brand-medium" },
  // meshStandardNodeMaterial: { clsName: 'MeshStandardNodeMaterial', func: () => new Nodes.MeshStandardNodeMaterial(), group: 'Material.Mesh Standard Material Node', icon: 'brand-medium' },
  pointsMaterial: { clsName: "PointsMaterial", func: () => new M.PointsMaterial(), group: "Material.Points Material", icon: "brand-medium" },
  // pointsNodeMaterial: { clsName: 'PointsNodeMaterial', func: () => new Nodes.PointsNodeMaterial(), group: 'Material.Points Material Node', icon: 'brand-medium' },
  spriteMaterial: { clsName: "SpriteMaterial", func: () => new M.SpriteMaterial(), group: "Material.Sprite Material", icon: "brand-medium" },
  // spriteNodeMaterial: { clsName: 'SpriteNodeMaterial', func: () => new Nodes.SpriteNodeMaterial(), group: 'Material.Sprite Material Node', icon: 'brand-medium' },
  pongMaterial: { clsName: "MeshPhongMaterial", func: () => new M.MeshPhongMaterial(), group: "Material.Phong Material", icon: "brand-medium" },
  toonMaterial: { clsName: "MeshToonMaterial", func: () => new M.MeshToonMaterial({ color: 16777215, refractionRatio: 0.98 }), group: "Material.Toon Material", icon: "brand-medium" },
  normalMaterial: { clsName: "MeshNormalMaterial", func: () => new M.MeshNormalMaterial(), group: "Material.Normal Material", icon: "brand-medium" },
  matcapMaterial: { clsName: "MeshMatcapMaterial", func: () => new M.MeshMatcapMaterial(), group: "Material.Matcap Material", icon: "brand-medium" },
  lambertMaterial: { clsName: "MeshLambertMaterial", func: () => new M.MeshLambertMaterial(), group: "Material.Lambert Material", icon: "brand-medium" },
  depthMaterial: { clsName: "MeshDepthMaterial", func: () => new M.MeshDepthMaterial(), group: "Material.Depth Material", icon: "brand-medium" }
};
for (const [c, e] of Object.entries(HA))
  Nc(c, e);
function Sa(c, e) {
  return c instanceof tn ? c : new Proxy(c, {
    get(t, r, n) {
      if (r === Gt)
        return t;
      if (typeof r != "string")
        return Reflect.get(t, r, n);
      if (Reflect.has(t, `${r}Node`)) {
        const o = Reflect.get(t, `${r}Node`, n);
        if (o !== null)
          return o;
      }
      const s = r.split(".");
      if (s.length > 1) {
        let o = Reflect.get(t, s[0], n);
        for (let i = 1; i < s.length; i++)
          o = o[s[i]];
        return o;
      }
      return Reflect.get(t, r, n);
    },
    set: (t, r, n, s) => {
      if (typeof r != "string")
        return Reflect.set(t, r, n, s);
      let o = r;
      Reflect.has(t, `${r}Node`) && n && n.isNode && (o = `${r}Node`);
      let i = !0;
      const a = r.split(".");
      if (a.length > 1) {
        let l = Reflect.get(t, a[0], s);
        const u = a.pop();
        for (let h = 1; h < a.length; h++)
          l = l[a[h]];
        if (l[u] === n)
          return !0;
        l[u] = n;
      } else {
        if (Reflect.get(t, o, s) === n)
          return !0;
        i = Reflect.set(t, o, n, s);
      }
      return i && e.dispatchEvent({ type: "nodeEventInputChanged", source: null, node: c, fields: [r] }), i;
    }
  });
}
class Qd extends _n {
  constructor(t, r, n, s) {
    super(t, s, !1);
    G(this, "isEffectNode", !0);
    Ts(this.typesExtended.in), Ts(this.inputs);
    for (const [o, i] of Object.entries(r.in || {}))
      this.addInput(o, i);
    Ts(this.typesExtended.out), Ts(this.outputs);
    for (const [o, i] of Object.entries(r.out || {}))
      this.addOutput(o, i);
    n && (this.code = n);
  }
  serialize(t) {
    super.serialize(t), delete t.code, delete t.types;
  }
}
Es("EffectNode", Qd, {}, "ScriptBlockNode");
function ef(c, e, t, r) {
  return Nc(c, {
    clsName: "EffectNode",
    func: () => new Qd(c, t, r),
    group: `Effects.${e}`,
    icon: "polygon"
  });
}
ef(
  "FallingPoints",
  "Falling Points",
  {
    in: {
      speed: "Number",
      size: "Number",
      maxCount: "Number"
    }
  },
  `const worldPosition = this.getWorldPosition(new THREE.Vector3());
const initialPosition = world.combineBuffer(this, 'position', params.maxCount || 1000);
const geometry = new THREE.BufferGeometry();

this.traverse(function (child) {
  if (child.isMesh) {
    child.material.visible = false;
  }
} );

geometry.setAttribute( 'position', initialPosition.clone() );
geometry.attributes.position.setUsage( THREE.DynamicDrawUsage );

const size = params.size || 0.02;
const mesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size, color: 0xffffff } ) );
const positions = geometry.attributes.position;
const count = positions.count;
const speed = params.speed || 5;
const minY = -worldPosition.y;
let resolve;
const promise = new Promise((rslv) => resolve = rslv);

mesh.onBeforeRender = () => {
  const delta = world.delta;
  let verticesDown = 0;

  for ( let i = 0; i < count; i ++ ) {
    const px = positions.getX( i );
    const py = positions.getY( i );
    const pz = positions.getZ( i );

    if ( py > minY ) {
      positions.setXYZ(
        i,
        px + 1.5 * ( 0.50 - Math.random() ) * speed * delta,
        py + 3.0 * ( 0.25 - Math.random() ) * speed * delta,
        pz + 1.5 * ( 0.50 - Math.random() ) * speed * delta
      );
    } else {
      verticesDown += 1;
    }
  }

  // all vertices down
  if ( verticesDown >= count ) {
    resolve();
  }
  positions.needsUpdate = true;
};
this.add(mesh);
await promise;
this.removeFromParent();
`
);
class Ex extends vn {
  constructor(t, r, n) {
    super();
    G(this, "isEffect", !0);
    G(this, "props");
    this.geometry = t, this.material = r, this.type = "Effect", this.props = Xd({ ...n }, (s, o) => {
      this.onPropsChanged([s], [o]);
    }), this.addEventListener("added", async () => {
      await this.onAttached();
    }), this.addEventListener("removed", async () => {
      await this.onDetached();
    });
  }
  async onAttached() {
    await this.build();
  }
  onPropsChanged(t, r) {
  }
  onDetached() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  async build() {
  }
  dispose() {
    this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.material && (this.material.dispose(), this.geometry = void 0);
  }
  clone(t) {
    const r = super.clone(t), n = Zs(this.props), s = r.props[Gt];
    return Qs(s, n), r;
  }
  serialize(t) {
    t.props = Zs(this.props);
  }
  deserialize(t) {
    if (t.props) {
      const r = this.props[Gt];
      Qs(r, t.props), this.build();
    }
  }
}
Ye(
  "Effect",
  {
    members: {},
    proto: "Object3D",
    group: "",
    icon: "",
    create: () => new Ex()
  }
);
const hu = {};
function Rx(c, e) {
  if (hu[c])
    throw ze.panic(`Class[${c}] aready exists`);
  return hu[c] = e, Ye(c, e);
}
function XA(c, e) {
  const t = hu[c];
  if (!t)
    throw ze.panic(`Class[${c}] not found!`);
  return t.create(e);
}
nn.createEffect = XA;
class $A extends Ex {
  constructor() {
    super(void 0, void 0, { maxCount: 1e3, texture: "", lerpPosition: 0, intensity: 0.04, size: 4 });
    G(this, "isEffectBurning", !0);
    this.type = "EffectBurning";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onPropsChanged(t, r) {
    const n = this.parent;
    if (!n || !(n instanceof qt))
      return;
    t.includes("maxCount") && (this.geometry && (this.geometry.dispose(), this.geometry = void 0), this.build());
    let s = !1;
    if (t.includes("lerpPosition"))
      if (this.material) {
        const o = _t("targetPosition", "vec3"), i = Ft(this.props.lerpPosition), a = xn(sn, o, i);
        this.material.positionNode = a, this.material.uniformsNeedUpdate = !0;
      } else
        s = !0;
    t.includes("texture") && (s = !0), s && (this.material && (this.material.dispose(), this.material = void 0), this.build());
  }
  async buildMaterial() {
    if (!this.props.texture)
      return;
    const t = _t("targetPosition", "vec3"), r = _t("particleSize", "float"), n = Ft(this.props.lerpPosition), s = xn(sn, t, n), o = await new Tu().loadAsync(this.props.texture);
    o.colorSpace = yn;
    const i = _t("particleSpeed", "float"), a = _t("particleIntensity", "float"), l = Qh(1), u = K0(
      rt(6, 6),
      // count
      av,
      // uv
      l.mul(i)
      // current frame
    ), d = Cn(o, u).mul(a), f = new Wd({
      depthWrite: !1,
      transparent: !0,
      sizeAttenuation: !0,
      blending: Hb
    });
    f.colorNode = d, f.sizeNode = r, f.positionNode = s, this.material && this.material.dispose(), this.material = f;
  }
  buildGeometry() {
    const t = this.parent;
    if (!t || !(t instanceof qt))
      return;
    const r = new Jn(), n = [], s = [], o = [], i = nn.combineBuffer(t, "position", this.props.maxCount || 1e3), a = i.count;
    for (let l = 0; l < a; l++)
      n.push(20 + Math.random() * 50), s.push(Math.random() * this.props.intensity), o.push(this.props.size + Math.random() * this.props.size);
    r.setAttribute("position", i), r.setAttribute("targetPosition", i), r.setAttribute("particleSpeed", new gn(n, 1)), r.setAttribute("particleIntensity", new gn(s, 1)), r.setAttribute("particleSize", new gn(o, 1)), this.geometry && this.geometry.dispose(), this.geometry = r;
  }
  async build() {
    this.geometry || this.buildGeometry(), this.material || await this.buildMaterial(), this.geometry && this.material && (this.isPoints = !0, this.visible = !0);
  }
  toJSON(t) {
    const r = this.isPoints;
    delete this.isPoints;
    const n = super.toJSON(t);
    return this.isPoints = r, n;
  }
}
Rx(
  "EffectBurning",
  {
    members: {
      "props.maxCount": "Number",
      "props.texture": "Url",
      "props.lerpPosition": "Number",
      "props.intensity": "Number",
      "props.size": "Number"
    },
    proto: "Effect",
    group: "Effects.Burning Effect",
    icon: "fireworks",
    create: () => new $A()
  }
);
ef(
  "Burning",
  "Burning Body",
  {
    in: {
      texture: "Url",
      lerpPosition: "Number",
      time: "Number",
      maxCount: "Number"
    }
  },
  `const effect = world.createEffect('EffectBurning');
effect.props.maxCount = params.maxCount || 1000;
effect.props.lerpPosition = params.lerpPosition;
effect.props.texture = params.texture;
this.add(effect);

// waits
if (params.time) {
  await world.wait(params.time);
  effect.removeFromParent();
}
`
);
class qA extends Fe {
  constructor(e) {
    super(e.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, e);
  }
  generate(e) {
    return this.node.build(e, this.getNodeType(e));
  }
}
const dt = qA, _a = new Xh();
_a.camera = new Tr();
const Jp = {
  LineBasicNodeMaterial: as.basic,
  MeshBasicNodeMaterial: as.basic,
  PointsNodeMaterial: as.points,
  MeshStandardNodeMaterial: as.standard,
  MeshPhysicalNodeMaterial: as.physical,
  MeshPhongNodeMaterial: as.phong
}, JA = {
  [ke.ATAN2]: "atan"
}, YA = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function ms(c) {
  return `#include <${c}>`;
}
function Uo(c) {
  return `${c}Shader`;
}
class Yp extends D0 {
  constructor(e, t, r, n = null) {
    super(e, t, new v1(), null, n), this.shader = r, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow();
  }
  getMethod(e) {
    return JA[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (e.isMeshPhysicalNodeMaterial ? t = "MeshPhysicalNodeMaterial" : e.isMeshStandardNodeMaterial ? t = "MeshStandardNodeMaterial" : e.isMeshPhongNodeMaterial ? t = "MeshPhongNodeMaterial" : e.isMeshBasicNodeMaterial ? t = "MeshBasicNodeMaterial" : e.isPointsNodeMaterial ? t = "PointsNodeMaterial" : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"), Jp[t] !== void 0) {
      const r = Jp[t], n = this.shader;
      n.vertexShader = r.vertexShader, n.fragmentShader = r.fragmentShader, n.uniforms = tr.merge([r.uniforms, oo.lights]);
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot("fragment", new dt({
      node: ds,
      nodeType: "vec3",
      source: ms("clipping_planes_fragment"),
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), t.toneMappingNode && t.toneMappingNode.isNode === !0 && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: ms("tonemapping_fragment"),
      target: ""
    })), e.colorNode && e.colorNode.isNode && this.addSlot("fragment", new dt({
      node: e.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), e.opacityNode && e.opacityNode.isNode && this.addSlot("fragment", new dt({
      node: e.opacityNode,
      nodeType: "float",
      source: ms("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), e.normalNode && e.normalNode.isNode && this.addSlot("fragment", new dt({
      node: e.normalNode,
      nodeType: "vec3",
      source: ms("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), e.emissiveNode && e.emissiveNode.isNode && this.addSlot("fragment", new dt({
      node: e.emissiveNode,
      nodeType: "vec3",
      source: ms("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshStandardNodeMaterial && (e.metalnessNode && e.metalnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.metalnessNode,
      nodeType: "float",
      source: ms("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.roughnessNode && e.roughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.roughnessNode,
      nodeType: "float",
      source: ms("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), e.isMeshPhysicalNodeMaterial && (e.clearcoatNode && e.clearcoatNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), e.clearcoatRoughnessNode && e.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), e.clearcoatNormalNode && e.clearcoatNormalNode.isNode && this.addSlot("fragment", new dt({
      node: e.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), e.defines.USE_CLEARCOAT = "") : delete e.defines.USE_CLEARCOAT, e.sheenNode && e.sheenNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), e.sheenRoughnessNode && e.sheenRoughnessNode.isNode && this.addSlot("fragment", new dt({
      node: e.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), e.defines.USE_SHEEN = "") : delete e.defines.USE_SHEEN, e.iridescenceNode && e.iridescenceNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), e.iridescenceIORNode && e.iridescenceIORNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), e.iridescenceThicknessNode && e.iridescenceThicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), e.defines.USE_IRIDESCENCE = "") : delete e.defines.USE_IRIDESCENCE, e.iorNode && e.iorNode.isNode && this.addSlot("fragment", new dt({
      node: e.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), e.specularColorNode && e.specularColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), e.specularIntensityNode && e.specularIntensityNode.isNode && this.addSlot("fragment", new dt({
      node: e.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), e.transmissionNode && e.transmissionNode.isNode ? (this.addSlot("fragment", new dt({
      node: e.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), e.thicknessNode && e.thicknessNode.isNode && this.addSlot("fragment", new dt({
      node: e.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), e.attenuationDistanceNode && e.attenuationDistanceNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), e.attenuationColorNode && e.attenuationColorNode.isNode && this.addSlot("fragment", new dt({
      node: e.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), e.transmission = 1, e.defines.USE_TRANSMISSION = "") : (e.transmission = 0, delete e.defines.USE_TRANSMISSION))), e.positionNode && e.positionNode.isNode && this.addSlot("vertex", new dt({
      node: e.positionNode,
      nodeType: "vec3",
      source: ms("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), e.sizeNode && e.sizeNode.isNode && this.addSlot("vertex", new dt({
      node: e.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  getTexture(e, t, r) {
    return e.isTextureCube ? `textureCube( ${t}, ${r} )` : `texture2D( ${t}, ${r} )`;
  }
  getTextureBias(e, t, r, n) {
    return this.material.extensions !== void 0 && (this.material.extensions.shaderTextureLOD = !0), `textureLod( ${t}, ${r}, ${n} )`;
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let r = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let s = null;
      n.type === "texture" ? s = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? s = `samplerCube ${n.name}; ` : s = `${this.getVectorType(n.type)} ${n.name}; `;
      const o = n.node.precision;
      o !== null ? s = "uniform " + YA[o] + " " + s : s = "uniform " + s, r += s;
    }
    return r;
  }
  getAttributes(e) {
    let t = "";
    if (e === "vertex") {
      const r = this.attributes;
      for (const n of r)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (t += `attribute ${n.type} ${n.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const r = this.varyings;
    if (e === "vertex")
      for (const n of r)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (e === "fragment")
      for (const n of r)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, r, n = this) {
    const s = Uo(e);
    let o = n[s];
    const i = o.indexOf(t);
    if (i !== -1) {
      const a = o.substring(0, i + t.length), l = o.substring(i + t.length);
      o = `${a}
${r}
${l}`;
    }
    n[s] = o;
  }
  replaceCode(e, t, r, n = this) {
    const s = Uo(e);
    n[s] = n[s].replaceAll(t, r);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of Yr) {
      const r = this.getUniforms(t), n = this.getAttributes(t), s = this.getVaryings(t), o = this.getVars(t), i = this.getCodes(t);
      e[t] = `${this.getSignature()}
// <node_builder>

// uniforms
${r}

// attributes
${n}

// varyings
${s}

// vars
${o}

// codes
${i}

// </node_builder>

${this.shader[Uo(t)]}
`;
    }
    this.vertexShader = e.vertex, this.fragmentShader = e.fragment;
  }
  build() {
    return super.build(), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(e, ...t) {
    for (const r of t) {
      const n = ms(r), s = Lm[r], o = Uo(e);
      this.shader[o] = this.shader[o].replaceAll(n, s);
    }
  }
  _sortSlotsToFlow() {
    for (const e of Yr) {
      const t = this.shader[Uo(e)], r = this.slots[e].sort((n, s) => t.indexOf(n.source) > t.indexOf(s.source) ? 1 : -1);
      for (const n of r)
        this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of Yr) {
      for (const t of this.slots[e]) {
        const r = this.getFlowData(
          t
          /*, shaderStage*/
        ), n = t.inclusionType, s = t.source, o = r.code + `
	` + t.target.replace("%RESULT%", r.result);
        n === "append" ? this.addCode(e, s, o) : n === "replace" ? this.replaceCode(e, s, o) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        e,
        "main() {",
        `
	` + this.flowCode[e]
      );
    }
  }
  _addUniforms() {
    for (const e of Yr)
      for (const t of this.uniforms[e])
        this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    _a.object = this.object, _a.renderer = this.renderer;
    for (const e of this.updateNodes)
      _a.updateNode(e);
  }
}
const du = /* @__PURE__ */ new WeakMap(), Jr = new Xh();
zn.prototype.onBuild = function(c, e, t) {
  if (Array.isArray(c.material))
    for (const r of c.material)
      r.isNodeMaterial === !0 && du.set(r, new Yp(c, t, e, r).build());
  else
    c.material.isNodeMaterial === !0 && du.set(c.material, new Yp(c, t, e).build());
};
zn.prototype.onBeforeRender = function(c, e, t, r, n) {
  const s = du.get(this);
  if (s !== void 0) {
    Jr.material = this, Jr.camera = t, Jr.object = n, Jr.renderer = c;
    const o = s.updateNodes;
    if (o.length > 0) {
      c.state.useProgram(null);
      for (const i of o)
        Jr.updateNode(i);
    }
  }
};
class KA {
  constructor(e, t, r) {
    this.variables = [], this.currentTextureIndex = 0;
    let n = $f;
    const s = new $a(), o = new Xb();
    o.position.z = 1;
    const i = {
      passThruTexture: { value: null }
    }, a = h(f(), i), l = new qt(new Ar(2, 2), a);
    s.add(l), this.setDataType = function(p) {
      return n = p, this;
    }, this.addVariable = function(p, m, g) {
      const b = this.createShaderMaterial(m), v = {
        name: p,
        initialValueTexture: g,
        material: b,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: Vs,
        magFilter: Vs
      };
      return this.variables.push(v), v;
    }, this.setVariableDependencies = function(p, m) {
      p.dependencies = m;
    }, this.init = function() {
      if (r.capabilities.isWebGL2 === !1 && r.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (r.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let p = 0; p < this.variables.length; p++) {
        const m = this.variables[p];
        m.renderTargets[0] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), m.renderTargets[1] = this.createRenderTarget(e, t, m.wrapS, m.wrapT, m.minFilter, m.magFilter), this.renderTexture(m.initialValueTexture, m.renderTargets[0]), this.renderTexture(m.initialValueTexture, m.renderTargets[1]);
        const g = m.material, b = g.uniforms;
        if (m.dependencies !== null)
          for (let v = 0; v < m.dependencies.length; v++) {
            const y = m.dependencies[v];
            if (y.name !== m.name) {
              let x = !1;
              for (let N = 0; N < this.variables.length; N++)
                if (y.name === this.variables[N].name) {
                  x = !0;
                  break;
                }
              if (!x)
                return "Variable dependency not found. Variable=" + m.name + ", dependency=" + y.name;
            }
            b[y.name] = { value: null }, g.fragmentShader = `
uniform sampler2D ` + y.name + `;
` + g.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const p = this.currentTextureIndex, m = this.currentTextureIndex === 0 ? 1 : 0;
      for (let g = 0, b = this.variables.length; g < b; g++) {
        const v = this.variables[g];
        if (v.dependencies !== null) {
          const y = v.material.uniforms;
          for (let x = 0, N = v.dependencies.length; x < N; x++) {
            const w = v.dependencies[x];
            y[w.name].value = w.renderTargets[p].texture;
          }
        }
        this.doRenderTarget(v.material, v.renderTargets[m]);
      }
      this.currentTextureIndex = m;
    }, this.getCurrentRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(p) {
      return p.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      l.geometry.dispose(), l.material.dispose();
      const p = this.variables;
      for (let m = 0; m < p.length; m++) {
        const g = p[m];
        g.initialValueTexture && g.initialValueTexture.dispose();
        const b = g.renderTargets;
        for (let v = 0; v < b.length; v++)
          b[v].dispose();
      }
    };
    function u(p) {
      p.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function h(p, m) {
      m = m || {};
      const g = new hs({
        name: "GPUComputationShader",
        uniforms: m,
        vertexShader: d(),
        fragmentShader: p
      });
      return u(g), g;
    }
    this.createShaderMaterial = h, this.createRenderTarget = function(p, m, g, b, v, y) {
      return p = p || e, m = m || t, g = g || fo, b = b || fo, v = v || Vs, y = y || Vs, new Mu(p, m, {
        wrapS: g,
        wrapT: b,
        minFilter: v,
        magFilter: y,
        format: Xf,
        type: n,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const p = new Float32Array(e * t * 4), m = new ya(p, e, t, Xf, $f);
      return m.needsUpdate = !0, m;
    }, this.renderTexture = function(p, m) {
      i.passThruTexture.value = p, this.doRenderTarget(a, m), i.passThruTexture.value = null;
    }, this.doRenderTarget = function(p, m) {
      const g = r.getRenderTarget(), b = r.xr.enabled, v = r.shadowMap.autoUpdate;
      r.xr.enabled = !1, r.shadowMap.autoUpdate = !1, l.material = p, r.setRenderTarget(m), r.render(s, o), l.material = a, r.xr.enabled = b, r.shadowMap.autoUpdate = v, r.setRenderTarget(g);
    };
    function d() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function f() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const Nt = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function Lx(c) {
  const e = await fetch(c);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function ZA(c) {
  if (!c)
    throw new Error("No basePath supplied");
  return await Lx(`${c}/profilesList.json`);
}
async function QA(c, e, t = null, r = !0) {
  if (!c)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await ZA(e);
  let s;
  if (c.profiles.some((a) => {
    const l = n[a];
    return l && (s = {
      profileId: a,
      profilePath: `${e}/${l.path}`,
      deprecated: !!l.deprecated
    }), !!s;
  }), !s) {
    if (!t)
      throw new Error("No matching profile name found");
    const a = n[t];
    if (!a)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    s = {
      profileId: t,
      profilePath: `${e}/${a.path}`,
      deprecated: !!a.deprecated
    };
  }
  const o = await Lx(s.profilePath);
  let i;
  if (r) {
    let a;
    if (c.handedness === "any" ? a = o.layouts[Object.keys(o.layouts)[0]] : a = o.layouts[c.handedness], !a)
      throw new Error(
        `No matching handedness, ${c.handedness}, in profile ${s.profileId}`
      );
    a.assetPath && (i = s.profilePath.replace("profile.json", a.assetPath));
  }
  return { profile: o, assetPath: i };
}
const eC = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Nt.ComponentState.DEFAULT
};
function tC(c = 0, e = 0) {
  let t = c, r = e;
  if (Math.sqrt(c * c + e * e) > 1) {
    const o = Math.atan2(e, c);
    t = Math.cos(o), r = Math.sin(o);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: r * 0.5 + 0.5
  };
}
class nC {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === Nt.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(eC);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: r,
    state: n
  }) {
    const { normalizedXAxis: s, normalizedYAxis: o } = tC(e, t);
    switch (this.componentProperty) {
      case Nt.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? s : 0.5;
        break;
      case Nt.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? o : 0.5;
        break;
      case Nt.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? r : 0;
        break;
      case Nt.ComponentProperty.STATE:
        this.valueNodeProperty === Nt.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class sC {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((r) => {
      const n = new nC(t.visualResponses[r]);
      this.visualResponses[r] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: Nt.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = Nt.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = Nt.ComponentState.PRESSED : (t.touched || this.values.button > Nt.ButtonTouchThreshold) && (this.values.state = Nt.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Nt.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Nt.AxisTouchThreshold && (this.values.state = Nt.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Nt.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Nt.AxisTouchThreshold && (this.values.state = Nt.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class rC {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, r) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = r, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const s = this.layoutDescription.components[n];
      this.components[n] = new sC(n, s);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const oC = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", iC = "generic-trigger";
class aC extends vn {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((r) => {
        const { valueNode: n, minNode: s, maxNode: o, value: i, valueNodeProperty: a } = r;
        n && (a === Nt.VisualResponseProperty.VISIBILITY ? n.visible = i : a === Nt.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          s.quaternion,
          o.quaternion,
          i
        ), n.position.lerpVectors(
          s.position,
          o.position,
          i
        )));
      });
    }));
  }
}
function cC(c, e) {
  Object.values(c.components).forEach((t) => {
    const { type: r, touchPointNodeName: n, visualResponses: s } = t;
    if (r === Nt.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const o = new Ja(1e-3), i = new An({ color: 255 }), a = new qt(o, i);
        t.touchPointNode.add(a);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(s).forEach((o) => {
      const { valueNodeName: i, minNodeName: a, maxNodeName: l, valueNodeProperty: u } = o;
      if (u === Nt.VisualResponseProperty.TRANSFORM) {
        if (o.minNode = e.getObjectByName(a), o.maxNode = e.getObjectByName(l), !o.minNode) {
          console.warn(`Could not find ${a} in the model`);
          return;
        }
        if (!o.maxNode) {
          console.warn(`Could not find ${l} in the model`);
          return;
        }
      }
      o.valueNode = e.getObjectByName(i), o.valueNode || console.warn(`Could not find ${i} in the model`);
    });
  });
}
function Kp(c, e) {
  cC(c.motionController, e), c.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = c.envMap, t.material.needsUpdate = !0);
  }), c.add(e);
}
class lC {
  constructor(e = null) {
    this.gltfLoader = e, this.path = oC, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new Kd());
  }
  createControllerModel(e) {
    const t = new aC();
    let r = null;
    return e.addEventListener("connected", (n) => {
      const s = n.data;
      s.targetRayMode !== "tracked-pointer" || !s.gamepad || QA(s, this.path, iC).then(({ profile: o, assetPath: i }) => {
        t.motionController = new rC(
          s,
          o,
          i
        );
        const a = this._assetCache[t.motionController.assetUrl];
        if (a)
          r = a.scene.clone(), Kp(t, r);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (l) => {
              this._assetCache[t.motionController.assetUrl] = l, r = l.scene.clone(), Kp(t, r);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((o) => {
        console.warn(o);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(r), r = null;
    }), t;
  }
}
const uC = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
class hC {
  constructor(e, t, r, n, s = null) {
    this.controller = t, this.handModel = e, this.bones = [], s === null && (s = new Kd(), s.setPath(r || uC)), s.load(`${n}.glb`, (o) => {
      const i = o.scene.children[0];
      this.handModel.add(i);
      const a = i.getObjectByProperty("type", "SkinnedMesh");
      a.frustumCulled = !1, a.castShadow = !0, a.receiveShadow = !0, [
        "wrist",
        "thumb-metacarpal",
        "thumb-phalanx-proximal",
        "thumb-phalanx-distal",
        "thumb-tip",
        "index-finger-metacarpal",
        "index-finger-phalanx-proximal",
        "index-finger-phalanx-intermediate",
        "index-finger-phalanx-distal",
        "index-finger-tip",
        "middle-finger-metacarpal",
        "middle-finger-phalanx-proximal",
        "middle-finger-phalanx-intermediate",
        "middle-finger-phalanx-distal",
        "middle-finger-tip",
        "ring-finger-metacarpal",
        "ring-finger-phalanx-proximal",
        "ring-finger-phalanx-intermediate",
        "ring-finger-phalanx-distal",
        "ring-finger-tip",
        "pinky-finger-metacarpal",
        "pinky-finger-phalanx-proximal",
        "pinky-finger-phalanx-intermediate",
        "pinky-finger-phalanx-distal",
        "pinky-finger-tip"
      ].forEach((u) => {
        const h = i.getObjectByName(u);
        h !== void 0 ? h.jointName = u : console.warn(`Couldn't find ${u} in ${n} hand mesh`), this.bones.push(h);
      });
    });
  }
  updateMesh() {
    const e = this.controller.joints;
    for (let t = 0; t < this.bones.length; t++) {
      const r = this.bones[t];
      if (r) {
        const n = e[r.jointName];
        if (n.visible) {
          const s = n.position;
          r.position.copy(s), r.quaternion.copy(n.quaternion);
        }
      }
    }
  }
}
const dC = 0.01, fC = "index-finger-tip";
class Zp extends vn {
  constructor(e, t = null) {
    super(), this.controller = e, this.motionController = null, this.envMap = null, this.loader = t, this.mesh = null, e.addEventListener("connected", (r) => {
      const n = r.data;
      n.hand && !this.motionController && (this.xrInputSource = n, this.motionController = new hC(this, e, this.path, n.handedness, this.loader));
    }), e.addEventListener("disconnected", () => {
      this.clear(), this.motionController = null;
    });
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && this.motionController.updateMesh();
  }
  getPointerPosition() {
    const e = this.controller.joints[fC];
    return e ? e.position : null;
  }
  intersectBoxObject(e) {
    const t = this.getPointerPosition();
    if (t) {
      const r = new xi(t, dC), n = new er().setFromObject(e);
      return r.intersectsBox(n);
    } else
      return !1;
  }
  checkButton(e) {
    this.intersectBoxObject(e) ? e.onPress() : e.onClear(), e.isPressed() && e.whilePressed();
  }
}
class pC extends $d {
  constructor() {
    super(), this.name;
    const e = new qa(-5, 5, 5, -5);
    e.near = 1e-4, e.far = 1e3, e.position.set(0, 0, 4), this.add(e);
    const t = new qt(new Ja(0.5), new An({ color: 8947967, wireframe: !0 }));
    t.onBeforeRender = () => {
      t.rotation.y -= 4e-3;
    }, this.add(t);
    const r = new Yd();
    r.text = "Loading...", r.color = 8947865, r.anchorX = "center", r.fontSize = 0.16, r.position.set(0, -0.6, 0), this.add(r);
  }
}
const Kt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], mC = Math.PI / 180;
function tf() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Kt[c & 255] + Kt[c >> 8 & 255] + Kt[c >> 16 & 255] + Kt[c >> 24 & 255] + "-" + Kt[e & 255] + Kt[e >> 8 & 255] + "-" + Kt[e >> 16 & 15 | 64] + Kt[e >> 24 & 255] + "-" + Kt[t & 63 | 128] + Kt[t >> 8 & 255] + "-" + Kt[t >> 16 & 255] + Kt[t >> 24 & 255] + Kt[r & 255] + Kt[r >> 8 & 255] + Kt[r >> 16 & 255] + Kt[r >> 24 & 255]).toLowerCase();
}
function Dn(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function zo(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return c / 4294967295;
    case Uint16Array:
      return c / 65535;
    case Uint8Array:
      return c / 255;
    case Int32Array:
      return Math.max(c / 2147483647, -1);
    case Int16Array:
      return Math.max(c / 32767, -1);
    case Int8Array:
      return Math.max(c / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function fn(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return Math.round(c * 4294967295);
    case Uint16Array:
      return Math.round(c * 65535);
    case Uint8Array:
      return Math.round(c * 255);
    case Int32Array:
      return Math.round(c * 2147483647);
    case Int16Array:
      return Math.round(c * 32767);
    case Int8Array:
      return Math.round(c * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class Ai {
  constructor(e = 0, t = 0, r = 0, n = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = n;
  }
  static slerpFlat(e, t, r, n, s, o, i) {
    let a = r[n + 0], l = r[n + 1], u = r[n + 2], h = r[n + 3];
    const d = s[o + 0], f = s[o + 1], p = s[o + 2], m = s[o + 3];
    if (i === 0) {
      e[t + 0] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (i === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
      return;
    }
    if (h !== m || a !== d || l !== f || u !== p) {
      let g = 1 - i;
      const b = a * d + l * f + u * p + h * m, v = b >= 0 ? 1 : -1, y = 1 - b * b;
      if (y > Number.EPSILON) {
        const N = Math.sqrt(y), w = Math.atan2(N, b * v);
        g = Math.sin(g * w) / N, i = Math.sin(i * w) / N;
      }
      const x = i * v;
      if (a = a * g + d * x, l = l * g + f * x, u = u * g + p * x, h = h * g + m * x, g === 1 - i) {
        const N = 1 / Math.sqrt(a * a + l * l + u * u + h * h);
        a *= N, l *= N, u *= N, h *= N;
      }
    }
    e[t] = a, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, r, n, s, o) {
    const i = r[n], a = r[n + 1], l = r[n + 2], u = r[n + 3], h = s[o], d = s[o + 1], f = s[o + 2], p = s[o + 3];
    return e[t] = i * p + u * h + a * f - l * d, e[t + 1] = a * p + u * d + l * h - i * f, e[t + 2] = l * p + u * f + i * d - a * h, e[t + 3] = u * p - i * h - a * d - l * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._order, i = Math.cos, a = Math.sin, l = i(r / 2), u = i(n / 2), h = i(s / 2), d = a(r / 2), f = a(n / 2), p = a(s / 2);
    switch (o) {
      case "XYZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * h + l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * h - l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h + d * f * p;
        break;
      case "YZX":
        this._x = d * u * h + l * f * p, this._y = l * f * h + d * u * p, this._z = l * u * p - d * f * h, this._w = l * u * h - d * f * p;
        break;
      case "XZY":
        this._x = d * u * h - l * f * p, this._y = l * f * h - d * u * p, this._z = l * u * p + d * f * h, this._w = l * u * h + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], n = t[4], s = t[8], o = t[1], i = t[5], a = t[9], l = t[2], u = t[6], h = t[10], d = r + i + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - a) * f, this._y = (s - l) * f, this._z = (o - n) * f;
    } else if (r > i && r > h) {
      const f = 2 * Math.sqrt(1 + r - i - h);
      this._w = (u - a) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (s + l) / f;
    } else if (i > h) {
      const f = 2 * Math.sqrt(1 + i - r - h);
      this._w = (s - l) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (a + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - r - i);
      this._w = (o - n) / f, this._x = (s + l) / f, this._y = (a + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Dn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const n = Math.min(1, t / r);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, n = e._y, s = e._z, o = e._w, i = t._x, a = t._y, l = t._z, u = t._w;
    return this._x = r * u + o * i + n * l - s * a, this._y = n * u + o * a + s * i - r * l, this._z = s * u + o * l + r * a - n * i, this._w = o * u - r * i - n * a - s * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, n = this._y, s = this._z, o = this._w;
    let i = o * e._w + r * e._x + n * e._y + s * e._z;
    if (i < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, i = -i) : this.copy(e), i >= 1)
      return this._w = o, this._x = r, this._y = n, this._z = s, this;
    const a = 1 - i * i;
    if (a <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * r + t * this._x, this._y = f * n + t * this._y, this._z = f * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(a), u = Math.atan2(l, i), h = Math.sin((1 - t) * u) / l, d = Math.sin(t * u) / l;
    return this._w = o * h + this._w * d, this._x = r * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class j {
  constructor(e = 0, t = 0, r = 0) {
    j.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Qp.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Qp.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * n, this.y = s[1] * t + s[4] * r + s[7] * n, this.z = s[2] * t + s[5] * r + s[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * r + s[11] * n + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * n + s[12]) * o, this.y = (s[1] * t + s[5] * r + s[9] * n + s[13]) * o, this.z = (s[2] * t + s[6] * r + s[10] * n + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, n = this.z, s = e.x, o = e.y, i = e.z, a = e.w, l = 2 * (o * n - i * r), u = 2 * (i * t - s * n), h = 2 * (s * r - o * t);
    return this.x = t + a * l + o * h - i * u, this.y = r + a * u + i * l - s * h, this.z = n + a * h + s * u - o * l, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, n = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * n, this.y = s[1] * t + s[5] * r + s[9] * n, this.z = s[2] * t + s[6] * r + s[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, n = e.y, s = e.z, o = t.x, i = t.y, a = t.z;
    return this.x = n * a - s * i, this.y = s * o - r * a, this.z = r * i - n * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return wl.copy(this).projectOnVector(e), this.sub(wl);
  }
  reflect(e) {
    return this.sub(wl.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Dn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const wl = /* @__PURE__ */ new j(), Qp = /* @__PURE__ */ new Ai();
class Re {
  constructor(e = 0, t = 0) {
    Re.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Dn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * r - o * n + e.x, this.y = s * n + o * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ci {
  constructor(e = new j(1 / 0, 1 / 0, 1 / 0), t = new j(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Xn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Xn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Xn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const s = r.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, i = s.count; o < i; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, Xn) : Xn.fromBufferAttribute(s, o), Xn.applyMatrix4(e.matrixWorld), this.expandByPoint(Xn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), na.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(), na.copy(r.boundingBox)), na.applyMatrix4(e.matrixWorld), this.union(na);
    }
    const n = e.children;
    for (let s = 0, o = n.length; s < o; s++)
      this.expandByObject(n[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Xn), Xn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Bo), sa.subVectors(this.max, Bo), Br.subVectors(e.a, Bo), kr.subVectors(e.b, Bo), Gr.subVectors(e.c, Bo), Is.subVectors(kr, Br), Ps.subVectors(Gr, kr), cr.subVectors(Br, Gr);
    let t = [
      0,
      -Is.z,
      Is.y,
      0,
      -Ps.z,
      Ps.y,
      0,
      -cr.z,
      cr.y,
      Is.z,
      0,
      -Is.x,
      Ps.z,
      0,
      -Ps.x,
      cr.z,
      0,
      -cr.x,
      -Is.y,
      Is.x,
      0,
      -Ps.y,
      Ps.x,
      0,
      -cr.y,
      cr.x,
      0
    ];
    return !Tl(t, Br, kr, Gr, sa) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Tl(t, Br, kr, Gr, sa)) ? !1 : (ra.crossVectors(Is, Ps), t = [ra.x, ra.y, ra.z], Tl(t, Br, kr, Gr, sa));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Xn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Xn).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (gs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), gs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), gs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), gs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), gs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), gs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), gs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), gs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(gs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const gs = [
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j()
], Xn = /* @__PURE__ */ new j(), na = /* @__PURE__ */ new Ci(), Br = /* @__PURE__ */ new j(), kr = /* @__PURE__ */ new j(), Gr = /* @__PURE__ */ new j(), Is = /* @__PURE__ */ new j(), Ps = /* @__PURE__ */ new j(), cr = /* @__PURE__ */ new j(), Bo = /* @__PURE__ */ new j(), sa = /* @__PURE__ */ new j(), ra = /* @__PURE__ */ new j(), lr = /* @__PURE__ */ new j();
function Tl(c, e, t, r, n) {
  for (let s = 0, o = c.length - 3; s <= o; s += 3) {
    lr.fromArray(c, s);
    const i = n.x * Math.abs(lr.x) + n.y * Math.abs(lr.y) + n.z * Math.abs(lr.z), a = e.dot(lr), l = t.dot(lr), u = r.dot(lr);
    if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > i)
      return !1;
  }
  return !0;
}
class Fx {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(t);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const n = r.slice(0);
      for (let s = 0, o = n.length; s < o; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const gC = 1015, em = 35044, oa = 2e3, tm = 2001, Ct = /* @__PURE__ */ new j(), ia = /* @__PURE__ */ new Re();
class lo {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = em, this.updateRange = { offset: 0, count: -1 }, this.gpuType = gC, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        ia.fromBufferAttribute(this, t), ia.applyMatrix3(e), this.setXY(t, ia.x, ia.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Ct.fromBufferAttribute(this, t), Ct.applyMatrix3(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Ct.fromBufferAttribute(this, t), Ct.applyMatrix4(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Ct.fromBufferAttribute(this, t), Ct.applyNormalMatrix(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Ct.fromBufferAttribute(this, t), Ct.transformDirection(e), this.setXYZ(t, Ct.x, Ct.y, Ct.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = zo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = fn(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = zo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = fn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, n) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, r, n, s) {
    return e *= this.itemSize, this.normalized && (t = fn(t, this.array), r = fn(r, this.array), n = fn(n, this.array), s = fn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== em && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class yC extends lo {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class vC extends lo {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class Xe extends lo {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
const xC = /* @__PURE__ */ new Ci(), ko = /* @__PURE__ */ new j(), Sl = /* @__PURE__ */ new j();
class bC {
  constructor(e = new j(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : xC.setFromPoints(e).getCenter(r);
    let n = 0;
    for (let s = 0, o = e.length; s < o; s++)
      n = Math.max(n, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    ko.subVectors(e, this.center);
    const t = ko.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), n = (r - this.radius) * 0.5;
      this.center.addScaledVector(ko, n / r), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Sl.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(ko.copy(e.center).add(Sl)), this.expandByPoint(ko.copy(e.center).sub(Sl))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Kn {
  constructor(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    Kn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g);
  }
  set(e, t, r, n, s, o, i, a, l, u, h, d, f, p, m, g) {
    const b = this.elements;
    return b[0] = e, b[4] = t, b[8] = r, b[12] = n, b[1] = s, b[5] = o, b[9] = i, b[13] = a, b[2] = l, b[6] = u, b[10] = h, b[14] = d, b[3] = f, b[7] = p, b[11] = m, b[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Kn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, n = 1 / Vr.setFromMatrixColumn(e, 0).length(), s = 1 / Vr.setFromMatrixColumn(e, 1).length(), o = 1 / Vr.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z, o = Math.cos(r), i = Math.sin(r), a = Math.cos(n), l = Math.sin(n), u = Math.cos(s), h = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = -a * h, t[8] = l, t[1] = f + p * l, t[5] = d - m * l, t[9] = -i * a, t[2] = m - d * l, t[6] = p + f * l, t[10] = o * a;
    } else if (e.order === "YXZ") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d + m * i, t[4] = p * i - f, t[8] = o * l, t[1] = o * h, t[5] = o * u, t[9] = -i, t[2] = f * i - p, t[6] = m + d * i, t[10] = o * a;
    } else if (e.order === "ZXY") {
      const d = a * u, f = a * h, p = l * u, m = l * h;
      t[0] = d - m * i, t[4] = -o * h, t[8] = p + f * i, t[1] = f + p * i, t[5] = o * u, t[9] = m - d * i, t[2] = -o * l, t[6] = i, t[10] = o * a;
    } else if (e.order === "ZYX") {
      const d = o * u, f = o * h, p = i * u, m = i * h;
      t[0] = a * u, t[4] = p * l - f, t[8] = d * l + m, t[1] = a * h, t[5] = m * l + d, t[9] = f * l - p, t[2] = -l, t[6] = i * a, t[10] = o * a;
    } else if (e.order === "YZX") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = m - d * h, t[8] = p * h + f, t[1] = h, t[5] = o * u, t[9] = -i * u, t[2] = -l * u, t[6] = f * h + p, t[10] = d - m * h;
    } else if (e.order === "XZY") {
      const d = o * a, f = o * l, p = i * a, m = i * l;
      t[0] = a * u, t[4] = -h, t[8] = l * u, t[1] = d * h + m, t[5] = o * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = i * u, t[10] = m * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(NC, e, wC);
  }
  lookAt(e, t, r) {
    const n = this.elements;
    return Tn.subVectors(e, t), Tn.lengthSq() === 0 && (Tn.z = 1), Tn.normalize(), Ds.crossVectors(r, Tn), Ds.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Tn.x += 1e-4 : Tn.z += 1e-4, Tn.normalize(), Ds.crossVectors(r, Tn)), Ds.normalize(), aa.crossVectors(Tn, Ds), n[0] = Ds.x, n[4] = aa.x, n[8] = Tn.x, n[1] = Ds.y, n[5] = aa.y, n[9] = Tn.y, n[2] = Ds.z, n[6] = aa.z, n[10] = Tn.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[4], a = r[8], l = r[12], u = r[1], h = r[5], d = r[9], f = r[13], p = r[2], m = r[6], g = r[10], b = r[14], v = r[3], y = r[7], x = r[11], N = r[15], w = n[0], T = n[4], _ = n[8], L = n[12], A = n[1], U = n[5], S = n[9], R = n[13], E = n[2], D = n[6], P = n[10], se = n[14], oe = n[3], H = n[7], X = n[11], C = n[15];
    return s[0] = o * w + i * A + a * E + l * oe, s[4] = o * T + i * U + a * D + l * H, s[8] = o * _ + i * S + a * P + l * X, s[12] = o * L + i * R + a * se + l * C, s[1] = u * w + h * A + d * E + f * oe, s[5] = u * T + h * U + d * D + f * H, s[9] = u * _ + h * S + d * P + f * X, s[13] = u * L + h * R + d * se + f * C, s[2] = p * w + m * A + g * E + b * oe, s[6] = p * T + m * U + g * D + b * H, s[10] = p * _ + m * S + g * P + b * X, s[14] = p * L + m * R + g * se + b * C, s[3] = v * w + y * A + x * E + N * oe, s[7] = v * T + y * U + x * D + N * H, s[11] = v * _ + y * S + x * P + N * X, s[15] = v * L + y * R + x * se + N * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], n = e[8], s = e[12], o = e[1], i = e[5], a = e[9], l = e[13], u = e[2], h = e[6], d = e[10], f = e[14], p = e[3], m = e[7], g = e[11], b = e[15];
    return p * (+s * a * h - n * l * h - s * i * d + r * l * d + n * i * f - r * a * f) + m * (+t * a * f - t * l * d + s * o * d - n * o * f + n * l * u - s * a * u) + g * (+t * l * h - t * i * f - s * o * h + r * o * f + s * i * u - r * l * u) + b * (-n * i * u - t * a * h + t * i * d + n * o * h - r * o * d + r * a * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = e[9], d = e[10], f = e[11], p = e[12], m = e[13], g = e[14], b = e[15], v = h * g * l - m * d * l + m * a * f - i * g * f - h * a * b + i * d * b, y = p * d * l - u * g * l - p * a * f + o * g * f + u * a * b - o * d * b, x = u * m * l - p * h * l + p * i * f - o * m * f - u * i * b + o * h * b, N = p * h * a - u * m * a - p * i * d + o * m * d + u * i * g - o * h * g, w = t * v + r * y + n * x + s * N;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / w;
    return e[0] = v * T, e[1] = (m * d * s - h * g * s - m * n * f + r * g * f + h * n * b - r * d * b) * T, e[2] = (i * g * s - m * a * s + m * n * l - r * g * l - i * n * b + r * a * b) * T, e[3] = (h * a * s - i * d * s - h * n * l + r * d * l + i * n * f - r * a * f) * T, e[4] = y * T, e[5] = (u * g * s - p * d * s + p * n * f - t * g * f - u * n * b + t * d * b) * T, e[6] = (p * a * s - o * g * s - p * n * l + t * g * l + o * n * b - t * a * b) * T, e[7] = (o * d * s - u * a * s + u * n * l - t * d * l - o * n * f + t * a * f) * T, e[8] = x * T, e[9] = (p * h * s - u * m * s - p * r * f + t * m * f + u * r * b - t * h * b) * T, e[10] = (o * m * s - p * i * s + p * r * l - t * m * l - o * r * b + t * i * b) * T, e[11] = (u * i * s - o * h * s - u * r * l + t * h * l + o * r * f - t * i * f) * T, e[12] = N * T, e[13] = (u * m * n - p * h * n + p * r * d - t * m * d - u * r * g + t * h * g) * T, e[14] = (p * i * n - o * m * n - p * r * a + t * m * a + o * r * g - t * i * g) * T, e[15] = (o * h * n - u * i * n + u * r * a - t * h * a - o * r * d + t * i * d) * T, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, n = e.y, s = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= s, t[1] *= r, t[5] *= n, t[9] *= s, t[2] *= r, t[6] *= n, t[10] *= s, t[3] *= r, t[7] *= n, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), n = Math.sin(t), s = 1 - r, o = e.x, i = e.y, a = e.z, l = s * o, u = s * i;
    return this.set(
      l * o + r,
      l * i - n * a,
      l * a + n * i,
      0,
      l * i + n * a,
      u * i + r,
      u * a - n * o,
      0,
      l * a - n * i,
      u * a + n * o,
      s * a * a + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, n, s, o) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const n = this.elements, s = t._x, o = t._y, i = t._z, a = t._w, l = s + s, u = o + o, h = i + i, d = s * l, f = s * u, p = s * h, m = o * u, g = o * h, b = i * h, v = a * l, y = a * u, x = a * h, N = r.x, w = r.y, T = r.z;
    return n[0] = (1 - (m + b)) * N, n[1] = (f + x) * N, n[2] = (p - y) * N, n[3] = 0, n[4] = (f - x) * w, n[5] = (1 - (d + b)) * w, n[6] = (g + v) * w, n[7] = 0, n[8] = (p + y) * T, n[9] = (g - v) * T, n[10] = (1 - (d + m)) * T, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, r) {
    const n = this.elements;
    let s = Vr.set(n[0], n[1], n[2]).length();
    const o = Vr.set(n[4], n[5], n[6]).length(), i = Vr.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], $n.copy(this);
    const l = 1 / s, u = 1 / o, h = 1 / i;
    return $n.elements[0] *= l, $n.elements[1] *= l, $n.elements[2] *= l, $n.elements[4] *= u, $n.elements[5] *= u, $n.elements[6] *= u, $n.elements[8] *= h, $n.elements[9] *= h, $n.elements[10] *= h, t.setFromRotationMatrix($n), r.x = s, r.y = o, r.z = i, this;
  }
  makePerspective(e, t, r, n, s, o, i = oa) {
    const a = this.elements, l = 2 * s / (t - e), u = 2 * s / (r - n), h = (t + e) / (t - e), d = (r + n) / (r - n);
    let f, p;
    if (i === oa)
      f = -(o + s) / (o - s), p = -2 * o * s / (o - s);
    else if (i === tm)
      f = -o / (o - s), p = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + i);
    return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = u, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, r, n, s, o, i = oa) {
    const a = this.elements, l = 1 / (t - e), u = 1 / (r - n), h = 1 / (o - s), d = (t + e) * l, f = (r + n) * u;
    let p, m;
    if (i === oa)
      p = (o + s) * h, m = -2 * h;
    else if (i === tm)
      p = s * h, m = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + i);
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = m, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const Vr = /* @__PURE__ */ new j(), $n = /* @__PURE__ */ new Kn(), NC = /* @__PURE__ */ new j(0, 0, 0), wC = /* @__PURE__ */ new j(1, 1, 1), Ds = /* @__PURE__ */ new j(), aa = /* @__PURE__ */ new j(), Tn = /* @__PURE__ */ new j(), nm = /* @__PURE__ */ new Kn(), sm = /* @__PURE__ */ new Ai();
class Mc {
  constructor(e = 0, t = 0, r = 0, n = Mc.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, n = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const n = e.elements, s = n[0], o = n[4], i = n[8], a = n[1], l = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Dn(i, -1, 1)), Math.abs(i) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Dn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(i, f), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Dn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Dn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(a, s)) : (this._x = 0, this._z = Math.atan2(-o, l));
        break;
      case "YZX":
        this._z = Math.asin(Dn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(i, f));
        break;
      case "XZY":
        this._z = Math.asin(-Dn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(i, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return nm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(nm, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return sm.setFromEuler(this), this.setFromQuaternion(sm, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Mc.DEFAULT_ORDER = "XYZ";
class TC {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
class Ei {
  constructor(e, t, r, n, s, o, i, a, l) {
    Ei.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, n, s, o, i, a, l);
  }
  set(e, t, r, n, s, o, i, a, l) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = i, u[3] = t, u[4] = s, u[5] = a, u[6] = r, u[7] = o, u[8] = l, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, n = t.elements, s = this.elements, o = r[0], i = r[3], a = r[6], l = r[1], u = r[4], h = r[7], d = r[2], f = r[5], p = r[8], m = n[0], g = n[3], b = n[6], v = n[1], y = n[4], x = n[7], N = n[2], w = n[5], T = n[8];
    return s[0] = o * m + i * v + a * N, s[3] = o * g + i * y + a * w, s[6] = o * b + i * x + a * T, s[1] = l * m + u * v + h * N, s[4] = l * g + u * y + h * w, s[7] = l * b + u * x + h * T, s[2] = d * m + f * v + p * N, s[5] = d * g + f * y + p * w, s[8] = d * b + f * x + p * T, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8];
    return t * o * u - t * i * l - r * s * u + r * i * a + n * s * l - n * o * a;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], i = e[5], a = e[6], l = e[7], u = e[8], h = u * o - i * l, d = i * a - u * s, f = l * s - o * a, p = t * h + r * d + n * f;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return e[0] = h * m, e[1] = (n * l - u * r) * m, e[2] = (i * r - n * o) * m, e[3] = d * m, e[4] = (u * t - n * a) * m, e[5] = (n * s - i * t) * m, e[6] = f * m, e[7] = (r * a - l * t) * m, e[8] = (o * t - r * s) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, n, s, o, i) {
    const a = Math.cos(s), l = Math.sin(s);
    return this.set(
      r * a,
      r * l,
      -r * (a * o + l * i) + o + e,
      -n * l,
      n * a,
      -n * (-l * o + a * i) + i + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(_l.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(_l.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(_l.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== r[n])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _l = /* @__PURE__ */ new Ei();
let SC = 0;
const rm = /* @__PURE__ */ new j(), jr = /* @__PURE__ */ new Ai(), ys = /* @__PURE__ */ new Kn(), ca = /* @__PURE__ */ new j(), Go = /* @__PURE__ */ new j(), _C = /* @__PURE__ */ new j(), MC = /* @__PURE__ */ new Ai(), om = /* @__PURE__ */ new j(1, 0, 0), im = /* @__PURE__ */ new j(0, 1, 0), am = /* @__PURE__ */ new j(0, 0, 1), AC = { type: "added" }, CC = { type: "removed" };
class Xs extends Fx {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: SC++ }), this.uuid = tf(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Xs.DEFAULT_UP.clone();
    const e = new j(), t = new Mc(), r = new Ai(), n = new j(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Kn()
      },
      normalMatrix: {
        value: new Ei()
      }
    }), this.matrix = new Kn(), this.matrixWorld = new Kn(), this.matrixAutoUpdate = Xs.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Xs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new TC(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return jr.setFromAxisAngle(e, t), this.quaternion.multiply(jr), this;
  }
  rotateOnWorldAxis(e, t) {
    return jr.setFromAxisAngle(e, t), this.quaternion.premultiply(jr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(om, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(im, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(am, e);
  }
  translateOnAxis(e, t) {
    return rm.copy(e).applyQuaternion(this.quaternion), this.position.add(rm.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(om, e);
  }
  translateY(e) {
    return this.translateOnAxis(im, e);
  }
  translateZ(e) {
    return this.translateOnAxis(am, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ys.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? ca.copy(e) : ca.set(e, t, r);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), Go.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ys.lookAt(Go, ca, this.up) : ys.lookAt(ca, Go, this.up), this.quaternion.setFromRotationMatrix(ys), n && (ys.extractRotation(n.matrixWorld), jr.setFromRotationMatrix(ys), this.quaternion.premultiply(jr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(AC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(CC)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ys.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ys.multiply(e.parent.matrixWorld)), e.applyMatrix4(ys), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, n = this.children.length; r < n; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const o = this.children[n].getObjectsByProperty(e, t);
      o.length > 0 && (r = r.concat(o));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Go, e, _C), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Go, MC, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let s = 0, o = n.length; s < o; s++) {
        const i = n[s];
        i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function s(i, a) {
      return i[a.uuid] === void 0 && (i[a.uuid] = a.toJSON(e)), a.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const i = this.geometry.parameters;
      if (i !== void 0 && i.shapes !== void 0) {
        const a = i.shapes;
        if (Array.isArray(a))
          for (let l = 0, u = a.length; l < u; l++) {
            const h = a[l];
            s(e.shapes, h);
          }
        else
          s(e.shapes, a);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const i = [];
        for (let a = 0, l = this.material.length; a < l; a++)
          i.push(s(e.materials, this.material[a]));
        n.material = i;
      } else
        n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let i = 0; i < this.children.length; i++)
        n.children.push(this.children[i].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const a = this.animations[i];
        n.animations.push(s(e.animations, a));
      }
    }
    if (t) {
      const i = o(e.geometries), a = o(e.materials), l = o(e.textures), u = o(e.images), h = o(e.shapes), d = o(e.skeletons), f = o(e.animations), p = o(e.nodes);
      i.length > 0 && (r.geometries = i), a.length > 0 && (r.materials = a), l.length > 0 && (r.textures = l), u.length > 0 && (r.images = u), h.length > 0 && (r.shapes = h), d.length > 0 && (r.skeletons = d), f.length > 0 && (r.animations = f), p.length > 0 && (r.nodes = p);
    }
    return r.object = n, r;
    function o(i) {
      const a = [];
      for (const l in i) {
        const u = i[l];
        delete u.metadata, a.push(u);
      }
      return a;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
}
Xs.DEFAULT_UP = /* @__PURE__ */ new j(0, 1, 0);
Xs.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Xs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
function EC(c) {
  if (c.length === 0)
    return 1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] < e && (e = c[t]);
  return e;
}
function RC(c) {
  if (c.length === 0)
    return -1 / 0;
  let e = c[0];
  for (let t = 1, r = c.length; t < r; ++t)
    c[t] > e && (e = c[t]);
  return e;
}
function Ox(c) {
  for (let e = c.length - 1; e >= 0; --e)
    if (c[e] >= 65535)
      return !0;
  return !1;
}
const LC = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function FC(c, e) {
  return new LC[c](e);
}
function Ix(c) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", c);
}
function OC() {
  const c = Ix("canvas");
  return c.style.display = "block", c;
}
const cm = {};
function IC(c) {
  c in cm || (cm[c] = !0, console.warn(c));
}
const PC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayMax: RC,
  arrayMin: EC,
  arrayNeedsUint32: Ox,
  createCanvasElement: OC,
  createElementNS: Ix,
  getTypedArray: FC,
  warnOnce: IC
}, Symbol.toStringTag, { value: "Module" }));
let DC = 0;
const In = /* @__PURE__ */ new Kn(), Ml = /* @__PURE__ */ new Xs(), Wr = /* @__PURE__ */ new j(), Sn = /* @__PURE__ */ new Ci(), Vo = /* @__PURE__ */ new Ci(), kt = /* @__PURE__ */ new j();
class Yt extends Fx {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: DC++ }), this.uuid = tf(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Ox(e) ? vC : yC)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Ei().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return In.makeRotationFromQuaternion(e), this.applyMatrix4(In), this;
  }
  rotateX(e) {
    return In.makeRotationX(e), this.applyMatrix4(In), this;
  }
  rotateY(e) {
    return In.makeRotationY(e), this.applyMatrix4(In), this;
  }
  rotateZ(e) {
    return In.makeRotationZ(e), this.applyMatrix4(In), this;
  }
  translate(e, t, r) {
    return In.makeTranslation(e, t, r), this.applyMatrix4(In), this;
  }
  scale(e, t, r) {
    return In.makeScale(e, t, r), this.applyMatrix4(In), this;
  }
  lookAt(e) {
    return Ml.lookAt(e), Ml.updateMatrix(), this.applyMatrix4(Ml.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Wr).negate(), this.translate(Wr.x, Wr.y, Wr.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, n = e.length; r < n; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Xe(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ci());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new j(-1 / 0, -1 / 0, -1 / 0),
        new j(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, n = t.length; r < n; r++) {
          const s = t[r];
          Sn.setFromBufferAttribute(s), this.morphTargetsRelative ? (kt.addVectors(this.boundingBox.min, Sn.min), this.boundingBox.expandByPoint(kt), kt.addVectors(this.boundingBox.max, Sn.max), this.boundingBox.expandByPoint(kt)) : (this.boundingBox.expandByPoint(Sn.min), this.boundingBox.expandByPoint(Sn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new bC());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new j(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (Sn.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s];
          Vo.setFromBufferAttribute(i), this.morphTargetsRelative ? (kt.addVectors(Sn.min, Vo.min), Sn.expandByPoint(kt), kt.addVectors(Sn.max, Vo.max), Sn.expandByPoint(kt)) : (Sn.expandByPoint(Vo.min), Sn.expandByPoint(Vo.max));
        }
      Sn.getCenter(r);
      let n = 0;
      for (let s = 0, o = e.count; s < o; s++)
        kt.fromBufferAttribute(e, s), n = Math.max(n, r.distanceToSquared(kt));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const i = t[s], a = this.morphTargetsRelative;
          for (let l = 0, u = i.count; l < u; l++)
            kt.fromBufferAttribute(i, l), a && (Wr.fromBufferAttribute(e, l), kt.add(Wr)), n = Math.max(n, r.distanceToSquared(kt));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, n = t.position.array, s = t.normal.array, o = t.uv.array, i = n.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new lo(new Float32Array(4 * i), 4));
    const a = this.getAttribute("tangent").array, l = [], u = [];
    for (let A = 0; A < i; A++)
      l[A] = new j(), u[A] = new j();
    const h = new j(), d = new j(), f = new j(), p = new Re(), m = new Re(), g = new Re(), b = new j(), v = new j();
    function y(A, U, S) {
      h.fromArray(n, A * 3), d.fromArray(n, U * 3), f.fromArray(n, S * 3), p.fromArray(o, A * 2), m.fromArray(o, U * 2), g.fromArray(o, S * 2), d.sub(h), f.sub(h), m.sub(p), g.sub(p);
      const R = 1 / (m.x * g.y - g.x * m.y);
      isFinite(R) && (b.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(R), v.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(R), l[A].add(b), l[U].add(b), l[S].add(b), u[A].add(v), u[U].add(v), u[S].add(v));
    }
    let x = this.groups;
    x.length === 0 && (x = [{
      start: 0,
      count: r.length
    }]);
    for (let A = 0, U = x.length; A < U; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let D = R, P = R + E; D < P; D += 3)
        y(
          r[D + 0],
          r[D + 1],
          r[D + 2]
        );
    }
    const N = new j(), w = new j(), T = new j(), _ = new j();
    function L(A) {
      T.fromArray(s, A * 3), _.copy(T);
      const U = l[A];
      N.copy(U), N.sub(T.multiplyScalar(T.dot(U))).normalize(), w.crossVectors(_, U);
      const R = w.dot(u[A]) < 0 ? -1 : 1;
      a[A * 4] = N.x, a[A * 4 + 1] = N.y, a[A * 4 + 2] = N.z, a[A * 4 + 3] = R;
    }
    for (let A = 0, U = x.length; A < U; ++A) {
      const S = x[A], R = S.start, E = S.count;
      for (let D = R, P = R + E; D < P; D += 3)
        L(r[D + 0]), L(r[D + 1]), L(r[D + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new lo(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let d = 0, f = r.count; d < f; d++)
          r.setXYZ(d, 0, 0, 0);
      const n = new j(), s = new j(), o = new j(), i = new j(), a = new j(), l = new j(), u = new j(), h = new j();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0), m = e.getX(d + 1), g = e.getX(d + 2);
          n.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), i.fromBufferAttribute(r, p), a.fromBufferAttribute(r, m), l.fromBufferAttribute(r, g), i.add(u), a.add(u), l.add(u), r.setXYZ(p, i.x, i.y, i.z), r.setXYZ(m, a.x, a.y, a.z), r.setXYZ(g, l.x, l.y, l.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), h.subVectors(n, s), u.cross(h), r.setXYZ(d + 0, u.x, u.y, u.z), r.setXYZ(d + 1, u.x, u.y, u.z), r.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      kt.fromBufferAttribute(e, t), kt.normalize(), e.setXYZ(t, kt.x, kt.y, kt.z);
  }
  toNonIndexed() {
    function e(i, a) {
      const l = i.array, u = i.itemSize, h = i.normalized, d = new l.constructor(a.length * u);
      let f = 0, p = 0;
      for (let m = 0, g = a.length; m < g; m++) {
        i.isInterleavedBufferAttribute ? f = a[m] * i.data.stride + i.offset : f = a[m] * u;
        for (let b = 0; b < u; b++)
          d[p++] = l[f++];
      }
      return new lo(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Yt(), r = this.index.array, n = this.attributes;
    for (const i in n) {
      const a = n[i], l = e(a, r);
      t.setAttribute(i, l);
    }
    const s = this.morphAttributes;
    for (const i in s) {
      const a = [], l = s[i];
      for (let u = 0, h = l.length; u < h; u++) {
        const d = l[u], f = e(d, r);
        a.push(f);
      }
      t.morphAttributes[i] = a;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let i = 0, a = o.length; i < a; i++) {
      const l = o[i];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const a = this.parameters;
      for (const l in a)
        a[l] !== void 0 && (e[l] = a[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const a in r) {
      const l = r[a];
      e.data.attributes[a] = l.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const a in this.morphAttributes) {
      const l = this.morphAttributes[a], u = [];
      for (let h = 0, d = l.length; h < d; h++) {
        const f = l[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[a] = u, s = !0);
    }
    s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const i = this.boundingSphere;
    return i !== null && (e.data.boundingSphere = {
      center: i.center.toArray(),
      radius: i.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const n = e.attributes;
    for (const l in n) {
      const u = n[l];
      this.setAttribute(l, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const u = [], h = s[l];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const i = e.boundingBox;
    i !== null && (this.boundingBox = i.clone());
    const a = e.boundingSphere;
    return a !== null && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class nf extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: n,
      heightSegments: s,
      depthSegments: o
    };
    const i = this;
    n = Math.floor(n), s = Math.floor(s), o = Math.floor(o);
    const a = [], l = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, r, t, e, o, s, 0), p("z", "y", "x", 1, -1, r, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, r, t, n, o, 2), p("x", "z", "y", 1, -1, e, r, -t, n, o, 3), p("x", "y", "z", 1, -1, e, t, r, n, s, 4), p("x", "y", "z", -1, -1, e, t, -r, n, s, 5), this.setIndex(a), this.setAttribute("position", new Xe(l, 3)), this.setAttribute("normal", new Xe(u, 3)), this.setAttribute("uv", new Xe(h, 2));
    function p(m, g, b, v, y, x, N, w, T, _, L) {
      const A = x / T, U = N / _, S = x / 2, R = N / 2, E = w / 2, D = T + 1, P = _ + 1;
      let se = 0, oe = 0;
      const H = new j();
      for (let X = 0; X < P; X++) {
        const C = X * U - R;
        for (let O = 0; O < D; O++) {
          const I = O * A - S;
          H[m] = I * v, H[g] = C * y, H[b] = E, l.push(H.x, H.y, H.z), H[m] = 0, H[g] = 0, H[b] = w > 0 ? 1 : -1, u.push(H.x, H.y, H.z), h.push(O / T), h.push(1 - X / _), se += 1;
        }
      }
      for (let X = 0; X < _; X++)
        for (let C = 0; C < T; C++) {
          const O = d + C + D * X, I = d + C + D * (X + 1), k = d + (C + 1) + D * (X + 1), z = d + (C + 1) + D * X;
          a.push(O, I, z), a.push(I, k, z), oe += 6;
        }
      i.addGroup(f, oe, L), f += oe, d += se;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nf(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
class ps {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, n = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      r = this.getPoint(o / e), s += r.distanceTo(n), t.push(s), n = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let n = 0;
    const s = r.length;
    let o;
    t ? o = t : o = e * r[s - 1];
    let i = 0, a = s - 1, l;
    for (; i <= a; )
      if (n = Math.floor(i + (a - i) / 2), l = r[n] - o, l < 0)
        i = n + 1;
      else if (l > 0)
        a = n - 1;
      else {
        a = n;
        break;
      }
    if (n = a, r[n] === o)
      return n / (s - 1);
    const u = r[n], d = r[n + 1] - u, f = (o - u) / d;
    return (n + f) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const o = this.getPoint(n), i = this.getPoint(s), a = t || (o.isVector2 ? new Re() : new j());
    return a.copy(i).sub(o).normalize(), a;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new j(), n = [], s = [], o = [], i = new j(), a = new Kn();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      n[f] = this.getTangentAt(p, new j());
    }
    s[0] = new j(), o[0] = new j();
    let l = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= l && (l = u, r.set(1, 0, 0)), h <= l && (l = h, r.set(0, 1, 0)), d <= l && r.set(0, 0, 1), i.crossVectors(n[0], r).normalize(), s[0].crossVectors(n[0], i), o[0].crossVectors(n[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), i.crossVectors(n[f - 1], n[f]), i.length() > Number.EPSILON) {
        i.normalize();
        const p = Math.acos(Dn(n[f - 1].dot(n[f]), -1, 1));
        s[f].applyMatrix4(a.makeRotationAxis(i, p));
      }
      o[f].crossVectors(n[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(Dn(s[0].dot(s[e]), -1, 1));
      f /= e, n[0].dot(i.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        s[p].applyMatrix4(a.makeRotationAxis(n[p], f * p)), o[p].crossVectors(n[p], s[p]);
    }
    return {
      tangents: n,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class sf extends ps {
  constructor(e = 0, t = 0, r = 1, n = 1, s = 0, o = Math.PI * 2, i = !1, a = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = i, this.aRotation = a;
  }
  getPoint(e, t) {
    const r = t || new Re(), n = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += n;
    for (; s > n; )
      s -= n;
    s < Number.EPSILON && (o ? s = 0 : s = n), this.aClockwise === !0 && !o && (s === n ? s = -n : s = s - n);
    const i = this.aStartAngle + e * s;
    let a = this.aX + this.xRadius * Math.cos(i), l = this.aY + this.yRadius * Math.sin(i);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = a - this.aX, f = l - this.aY;
      a = d * u - f * h + this.aX, l = d * h + f * u + this.aY;
    }
    return r.set(a, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class UC extends sf {
  constructor(e, t, r, n, s, o) {
    super(e, t, r, r, n, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function rf() {
  let c = 0, e = 0, t = 0, r = 0;
  function n(s, o, i, a) {
    c = s, e = i, t = -3 * s + 3 * o - 2 * i - a, r = 2 * s - 2 * o + i + a;
  }
  return {
    initCatmullRom: function(s, o, i, a, l) {
      n(o, i, l * (i - s), l * (a - o));
    },
    initNonuniformCatmullRom: function(s, o, i, a, l, u, h) {
      let d = (o - s) / l - (i - s) / (l + u) + (i - o) / u, f = (i - o) / u - (a - o) / (u + h) + (a - i) / h;
      d *= u, f *= u, n(o, i, d, f);
    },
    calc: function(s) {
      const o = s * s, i = o * s;
      return c + e * s + t * o + r * i;
    }
  };
}
const la = /* @__PURE__ */ new j(), Al = /* @__PURE__ */ new rf(), Cl = /* @__PURE__ */ new rf(), El = /* @__PURE__ */ new rf();
class zC extends ps {
  constructor(e = [], t = !1, r = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.points, s = n.length, o = (s - (this.closed ? 0 : 1)) * e;
    let i = Math.floor(o), a = o - i;
    this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / s) + 1) * s : a === 0 && i === s - 1 && (i = s - 2, a = 1);
    let l, u;
    this.closed || i > 0 ? l = n[(i - 1) % s] : (la.subVectors(n[0], n[1]).add(n[0]), l = la);
    const h = n[i % s], d = n[(i + 1) % s];
    if (this.closed || i + 2 < s ? u = n[(i + 2) % s] : (la.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), u = la), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(l.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), g = Math.pow(d.distanceToSquared(u), f);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Al.initNonuniformCatmullRom(l.x, h.x, d.x, u.x, p, m, g), Cl.initNonuniformCatmullRom(l.y, h.y, d.y, u.y, p, m, g), El.initNonuniformCatmullRom(l.z, h.z, d.z, u.z, p, m, g);
    } else
      this.curveType === "catmullrom" && (Al.initCatmullRom(l.x, h.x, d.x, u.x, this.tension), Cl.initCatmullRom(l.y, h.y, d.y, u.y, this.tension), El.initCatmullRom(l.z, h.z, d.z, u.z, this.tension));
    return r.set(
      Al.calc(a),
      Cl.calc(a),
      El.calc(a)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new j().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function lm(c, e, t, r, n) {
  const s = (r - e) * 0.5, o = (n - t) * 0.5, i = c * c, a = c * i;
  return (2 * t - 2 * r + s + o) * a + (-3 * t + 3 * r - 2 * s - o) * i + s * c + t;
}
function BC(c, e) {
  const t = 1 - c;
  return t * t * e;
}
function kC(c, e) {
  return 2 * (1 - c) * c * e;
}
function GC(c, e) {
  return c * c * e;
}
function Yo(c, e, t, r) {
  return BC(c, e) + kC(c, t) + GC(c, r);
}
function VC(c, e) {
  const t = 1 - c;
  return t * t * t * e;
}
function jC(c, e) {
  const t = 1 - c;
  return 3 * t * t * c * e;
}
function WC(c, e) {
  return 3 * (1 - c) * c * c * e;
}
function HC(c, e) {
  return c * c * c * e;
}
function Ko(c, e, t, r, n) {
  return VC(c, e) + jC(c, t) + WC(c, r) + HC(c, n);
}
class Px extends ps {
  constructor(e = new Re(), t = new Re(), r = new Re(), n = new Re()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class XC extends ps {
  constructor(e = new j(), t = new j(), r = new j(), n = new j()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2, i = this.v3;
    return r.set(
      Ko(e, n.x, s.x, o.x, i.x),
      Ko(e, n.y, s.y, o.y, i.y),
      Ko(e, n.z, s.z, o.z, i.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Dx extends ps {
  constructor(e = new Re(), t = new Re()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Re()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Re()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class $C extends ps {
  constructor(e = new j(), t = new j()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new j()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new j()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ux extends ps {
  constructor(e = new Re(), t = new Re(), r = new Re()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class zx extends ps {
  constructor(e = new j(), t = new j(), r = new j()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new j()) {
    const r = t, n = this.v0, s = this.v1, o = this.v2;
    return r.set(
      Yo(e, n.x, s.x, o.x),
      Yo(e, n.y, s.y, o.y),
      Yo(e, n.z, s.z, o.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Bx extends ps {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Re()) {
    const r = t, n = this.points, s = (n.length - 1) * e, o = Math.floor(s), i = s - o, a = n[o === 0 ? o : o - 1], l = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return r.set(
      lm(i, a.x, l.x, u.x, h.x),
      lm(i, a.y, l.y, u.y, h.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const n = e.points[t];
      this.points.push(new Re().fromArray(n));
    }
    return this;
  }
}
const ja = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve: UC,
  CatmullRomCurve3: zC,
  CubicBezierCurve: Px,
  CubicBezierCurve3: XC,
  EllipseCurve: sf,
  LineCurve: Dx,
  LineCurve3: $C,
  QuadraticBezierCurve: Ux,
  QuadraticBezierCurve3: zx,
  SplineCurve: Bx
}, Symbol.toStringTag, { value: "Module" }));
class qC extends ps {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new ja[r](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), n = this.getCurveLengths();
    let s = 0;
    for (; s < n.length; ) {
      if (n[s] >= r) {
        const o = n[s] - r, i = this.curves[s], a = i.getLength(), l = a === 0 ? 0 : 1 - o / a;
        return i.getPointAt(l, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let n = 0, s = this.curves; n < s.length; n++) {
      const o = s[n], i = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, a = o.getPoints(i);
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        r && r.equals(u) || (t.push(u), r = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const n = e.curves[t];
      this.curves.push(new ja[n.type]().fromJSON(n));
    }
    return this;
  }
}
class fu extends qC {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Re(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new Dx(this.currentPoint.clone(), new Re(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, n) {
    const s = new Ux(
      this.currentPoint.clone(),
      new Re(e, t),
      new Re(r, n)
    );
    return this.curves.push(s), this.currentPoint.set(r, n), this;
  }
  bezierCurveTo(e, t, r, n, s, o) {
    const i = new Px(
      this.currentPoint.clone(),
      new Re(e, t),
      new Re(r, n),
      new Re(s, o)
    );
    return this.curves.push(i), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new Bx(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, n, s, o) {
    const i = this.currentPoint.x, a = this.currentPoint.y;
    return this.absarc(
      e + i,
      t + a,
      r,
      n,
      s,
      o
    ), this;
  }
  absarc(e, t, r, n, s, o) {
    return this.absellipse(e, t, r, r, n, s, o), this;
  }
  ellipse(e, t, r, n, s, o, i, a) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, t + u, r, n, s, o, i, a), this;
  }
  absellipse(e, t, r, n, s, o, i, a) {
    const l = new sf(e, t, r, n, s, o, i, a);
    if (this.curves.length > 0) {
      const h = l.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ac extends Yt {
  constructor(e = [new Re(0, -0.5), new Re(0.5, 0), new Re(0, 0.5)], t = 12, r = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: n
    }, t = Math.floor(t), n = Dn(n, 0, Math.PI * 2);
    const s = [], o = [], i = [], a = [], l = [], u = 1 / t, h = new j(), d = new Re(), f = new j(), p = new j(), m = new j();
    let g = 0, b = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, m.copy(f), f.normalize(), a.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          a.push(m.x, m.y, m.z);
          break;
        default:
          g = e[v + 1].x - e[v].x, b = e[v + 1].y - e[v].y, f.x = b * 1, f.y = -g, f.z = b * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), a.push(f.x, f.y, f.z), m.copy(p);
      }
    for (let v = 0; v <= t; v++) {
      const y = r + v * u * n, x = Math.sin(y), N = Math.cos(y);
      for (let w = 0; w <= e.length - 1; w++) {
        h.x = e[w].x * x, h.y = e[w].y, h.z = e[w].x * N, o.push(h.x, h.y, h.z), d.x = v / t, d.y = w / (e.length - 1), i.push(d.x, d.y);
        const T = a[3 * w + 0] * x, _ = a[3 * w + 1], L = a[3 * w + 0] * N;
        l.push(T, _, L);
      }
    }
    for (let v = 0; v < t; v++)
      for (let y = 0; y < e.length - 1; y++) {
        const x = y + v * e.length, N = x, w = x + e.length, T = x + e.length + 1, _ = x + 1;
        s.push(N, w, _), s.push(T, _, w);
      }
    this.setIndex(s), this.setAttribute("position", new Xe(o, 3)), this.setAttribute("uv", new Xe(i, 2)), this.setAttribute("normal", new Xe(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ac(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class of extends Ac {
  constructor(e = 1, t = 1, r = 4, n = 8) {
    const s = new fu();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), n), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: n
    };
  }
  static fromJSON(e) {
    return new of(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class af extends Yt {
  constructor(e = 1, t = 32, r = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: n
    }, t = Math.max(3, t);
    const s = [], o = [], i = [], a = [], l = new j(), u = new Re();
    o.push(0, 0, 0), i.push(0, 0, 1), a.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = r + h / t * n;
      l.x = e * Math.cos(f), l.y = e * Math.sin(f), o.push(l.x, l.y, l.z), i.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, a.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      s.push(h, h + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Xe(o, 3)), this.setAttribute("normal", new Xe(i, 3)), this.setAttribute("uv", new Xe(a, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new af(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Cc extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 32, s = 1, o = !1, i = 0, a = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: n,
      heightSegments: s,
      openEnded: o,
      thetaStart: i,
      thetaLength: a
    };
    const l = this;
    n = Math.floor(n), s = Math.floor(s);
    const u = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], g = r / 2;
    let b = 0;
    v(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new Xe(h, 3)), this.setAttribute("normal", new Xe(d, 3)), this.setAttribute("uv", new Xe(f, 2));
    function v() {
      const x = new j(), N = new j();
      let w = 0;
      const T = (t - e) / r;
      for (let _ = 0; _ <= s; _++) {
        const L = [], A = _ / s, U = A * (t - e) + e;
        for (let S = 0; S <= n; S++) {
          const R = S / n, E = R * a + i, D = Math.sin(E), P = Math.cos(E);
          N.x = U * D, N.y = -A * r + g, N.z = U * P, h.push(N.x, N.y, N.z), x.set(D, T, P).normalize(), d.push(x.x, x.y, x.z), f.push(R, 1 - A), L.push(p++);
        }
        m.push(L);
      }
      for (let _ = 0; _ < n; _++)
        for (let L = 0; L < s; L++) {
          const A = m[L][_], U = m[L + 1][_], S = m[L + 1][_ + 1], R = m[L][_ + 1];
          u.push(A, U, R), u.push(U, S, R), w += 6;
        }
      l.addGroup(b, w, 0), b += w;
    }
    function y(x) {
      const N = p, w = new Re(), T = new j();
      let _ = 0;
      const L = x === !0 ? e : t, A = x === !0 ? 1 : -1;
      for (let S = 1; S <= n; S++)
        h.push(0, g * A, 0), d.push(0, A, 0), f.push(0.5, 0.5), p++;
      const U = p;
      for (let S = 0; S <= n; S++) {
        const E = S / n * a + i, D = Math.cos(E), P = Math.sin(E);
        T.x = L * P, T.y = g * A, T.z = L * D, h.push(T.x, T.y, T.z), d.push(0, A, 0), w.x = D * 0.5 + 0.5, w.y = P * 0.5 * A + 0.5, f.push(w.x, w.y), p++;
      }
      for (let S = 0; S < n; S++) {
        const R = N + S, E = U + S;
        x === !0 ? u.push(E, E + 1, R) : u.push(E + 1, E, R), _ += 3;
      }
      l.addGroup(b, _, x === !0 ? 1 : 2), b += _;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class cf extends Cc {
  constructor(e = 1, t = 1, r = 32, n = 1, s = !1, o = 0, i = Math.PI * 2) {
    super(0, e, t, r, n, s, o, i), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: n,
      openEnded: s,
      thetaStart: o,
      thetaLength: i
    };
  }
  static fromJSON(e) {
    return new cf(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Lr extends Yt {
  constructor(e = [], t = [], r = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: n
    };
    const s = [], o = [];
    i(n), l(r), u(), this.setAttribute("position", new Xe(s, 3)), this.setAttribute("normal", new Xe(s.slice(), 3)), this.setAttribute("uv", new Xe(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function i(v) {
      const y = new j(), x = new j(), N = new j();
      for (let w = 0; w < t.length; w += 3)
        f(t[w + 0], y), f(t[w + 1], x), f(t[w + 2], N), a(y, x, N, v);
    }
    function a(v, y, x, N) {
      const w = N + 1, T = [];
      for (let _ = 0; _ <= w; _++) {
        T[_] = [];
        const L = v.clone().lerp(x, _ / w), A = y.clone().lerp(x, _ / w), U = w - _;
        for (let S = 0; S <= U; S++)
          S === 0 && _ === w ? T[_][S] = L : T[_][S] = L.clone().lerp(A, S / U);
      }
      for (let _ = 0; _ < w; _++)
        for (let L = 0; L < 2 * (w - _) - 1; L++) {
          const A = Math.floor(L / 2);
          L % 2 === 0 ? (d(T[_][A + 1]), d(T[_ + 1][A]), d(T[_][A])) : (d(T[_][A + 1]), d(T[_ + 1][A + 1]), d(T[_ + 1][A]));
        }
    }
    function l(v) {
      const y = new j();
      for (let x = 0; x < s.length; x += 3)
        y.x = s[x + 0], y.y = s[x + 1], y.z = s[x + 2], y.normalize().multiplyScalar(v), s[x + 0] = y.x, s[x + 1] = y.y, s[x + 2] = y.z;
    }
    function u() {
      const v = new j();
      for (let y = 0; y < s.length; y += 3) {
        v.x = s[y + 0], v.y = s[y + 1], v.z = s[y + 2];
        const x = g(v) / 2 / Math.PI + 0.5, N = b(v) / Math.PI + 0.5;
        o.push(x, 1 - N);
      }
      p(), h();
    }
    function h() {
      for (let v = 0; v < o.length; v += 6) {
        const y = o[v + 0], x = o[v + 2], N = o[v + 4], w = Math.max(y, x, N), T = Math.min(y, x, N);
        w > 0.9 && T < 0.1 && (y < 0.2 && (o[v + 0] += 1), x < 0.2 && (o[v + 2] += 1), N < 0.2 && (o[v + 4] += 1));
      }
    }
    function d(v) {
      s.push(v.x, v.y, v.z);
    }
    function f(v, y) {
      const x = v * 3;
      y.x = e[x + 0], y.y = e[x + 1], y.z = e[x + 2];
    }
    function p() {
      const v = new j(), y = new j(), x = new j(), N = new j(), w = new Re(), T = new Re(), _ = new Re();
      for (let L = 0, A = 0; L < s.length; L += 9, A += 6) {
        v.set(s[L + 0], s[L + 1], s[L + 2]), y.set(s[L + 3], s[L + 4], s[L + 5]), x.set(s[L + 6], s[L + 7], s[L + 8]), w.set(o[A + 0], o[A + 1]), T.set(o[A + 2], o[A + 3]), _.set(o[A + 4], o[A + 5]), N.copy(v).add(y).add(x).divideScalar(3);
        const U = g(N);
        m(w, A + 0, v, U), m(T, A + 2, y, U), m(_, A + 4, x, U);
      }
    }
    function m(v, y, x, N) {
      N < 0 && v.x === 1 && (o[y] = v.x - 1), x.x === 0 && x.z === 0 && (o[y] = N / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function b(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Lr(e.vertices, e.indices, e.radius, e.details);
  }
}
class lf extends Lr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = 1 / r, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      // (1/, , 0)
      -n,
      -r,
      0,
      -n,
      r,
      0,
      n,
      -r,
      0,
      n,
      r,
      0,
      // (, 0, 1/)
      -r,
      0,
      -n,
      r,
      0,
      -n,
      -r,
      0,
      n,
      r,
      0,
      n
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new lf(e.radius, e.detail);
  }
}
const qn = /* @__PURE__ */ new j(), vs = /* @__PURE__ */ new j(), Rl = /* @__PURE__ */ new j(), xs = /* @__PURE__ */ new j(), Hr = /* @__PURE__ */ new j(), Xr = /* @__PURE__ */ new j(), um = /* @__PURE__ */ new j(), Ll = /* @__PURE__ */ new j(), Fl = /* @__PURE__ */ new j(), Ol = /* @__PURE__ */ new j();
let ua = !1;
class ks {
  constructor(e = new j(), t = new j(), r = new j()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, n) {
    n.subVectors(r, t), qn.subVectors(e, t), n.cross(qn);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, n, s) {
    qn.subVectors(n, t), vs.subVectors(r, t), Rl.subVectors(e, t);
    const o = qn.dot(qn), i = qn.dot(vs), a = qn.dot(Rl), l = vs.dot(vs), u = vs.dot(Rl), h = o * l - i * i;
    if (h === 0)
      return s.set(-2, -1, -1);
    const d = 1 / h, f = (l * a - i * u) * d, p = (o * u - i * a) * d;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, r, n) {
    return this.getBarycoord(e, t, r, n, xs), xs.x >= 0 && xs.y >= 0 && xs.x + xs.y <= 1;
  }
  static getUV(e, t, r, n, s, o, i, a) {
    return ua === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ua = !0), this.getInterpolation(e, t, r, n, s, o, i, a);
  }
  static getInterpolation(e, t, r, n, s, o, i, a) {
    return this.getBarycoord(e, t, r, n, xs), a.setScalar(0), a.addScaledVector(s, xs.x), a.addScaledVector(o, xs.y), a.addScaledVector(i, xs.z), a;
  }
  static isFrontFacing(e, t, r, n) {
    return qn.subVectors(r, t), vs.subVectors(e, t), qn.cross(vs).dot(n) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, r, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return qn.subVectors(this.c, this.b), vs.subVectors(this.a, this.b), qn.cross(vs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ks.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ks.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, n, s) {
    return ua === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ua = !0), ks.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  getInterpolation(e, t, r, n, s) {
    return ks.getInterpolation(e, this.a, this.b, this.c, t, r, n, s);
  }
  containsPoint(e) {
    return ks.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ks.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, n = this.b, s = this.c;
    let o, i;
    Hr.subVectors(n, r), Xr.subVectors(s, r), Ll.subVectors(e, r);
    const a = Hr.dot(Ll), l = Xr.dot(Ll);
    if (a <= 0 && l <= 0)
      return t.copy(r);
    Fl.subVectors(e, n);
    const u = Hr.dot(Fl), h = Xr.dot(Fl);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = a * h - u * l;
    if (d <= 0 && a >= 0 && u <= 0)
      return o = a / (a - u), t.copy(r).addScaledVector(Hr, o);
    Ol.subVectors(e, s);
    const f = Hr.dot(Ol), p = Xr.dot(Ol);
    if (p >= 0 && f <= p)
      return t.copy(s);
    const m = f * l - a * p;
    if (m <= 0 && l >= 0 && p <= 0)
      return i = l / (l - p), t.copy(r).addScaledVector(Xr, i);
    const g = u * p - f * h;
    if (g <= 0 && h - u >= 0 && f - p >= 0)
      return um.subVectors(s, n), i = (h - u) / (h - u + (f - p)), t.copy(n).addScaledVector(um, i);
    const b = 1 / (g + m + d);
    return o = m * b, i = d * b, t.copy(r).addScaledVector(Hr, o).addScaledVector(Xr, i);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ha = /* @__PURE__ */ new j(), da = /* @__PURE__ */ new j(), Il = /* @__PURE__ */ new j(), fa = /* @__PURE__ */ new ks();
class JC extends Yt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const n = Math.pow(10, 4), s = Math.cos(mC * t), o = e.getIndex(), i = e.getAttribute("position"), a = o ? o.count : i.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
      for (let p = 0; p < a; p += 3) {
        o ? (l[0] = o.getX(p), l[1] = o.getX(p + 1), l[2] = o.getX(p + 2)) : (l[0] = p, l[1] = p + 1, l[2] = p + 2);
        const { a: m, b: g, c: b } = fa;
        if (m.fromBufferAttribute(i, l[0]), g.fromBufferAttribute(i, l[1]), b.fromBufferAttribute(i, l[2]), fa.getNormal(Il), h[0] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, h[1] = `${Math.round(g.x * n)},${Math.round(g.y * n)},${Math.round(g.z * n)}`, h[2] = `${Math.round(b.x * n)},${Math.round(b.y * n)},${Math.round(b.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let v = 0; v < 3; v++) {
            const y = (v + 1) % 3, x = h[v], N = h[y], w = fa[u[v]], T = fa[u[y]], _ = `${x}_${N}`, L = `${N}_${x}`;
            L in d && d[L] ? (Il.dot(d[L].normal) <= s && (f.push(w.x, w.y, w.z), f.push(T.x, T.y, T.z)), d[L] = null) : _ in d || (d[_] = {
              index0: l[v],
              index1: l[y],
              normal: Il.clone()
            });
          }
      }
      for (const p in d)
        if (d[p]) {
          const { index0: m, index1: g } = d[p];
          ha.fromBufferAttribute(i, m), da.fromBufferAttribute(i, g), f.push(ha.x, ha.y, ha.z), f.push(da.x, da.y, da.z);
        }
      this.setAttribute("position", new Xe(f, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class kx extends fu {
  constructor(e) {
    super(e), this.uuid = tf(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const n = e.holes[t];
      this.holes.push(new fu().fromJSON(n));
    }
    return this;
  }
}
const YC = {
  triangulate: function(c, e, t = 2) {
    const r = e && e.length, n = r ? e[0] * t : c.length;
    let s = Gx(c, 0, n, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let i, a, l, u, h, d, f;
    if (r && (s = tE(c, e, s, t)), c.length > 80 * t) {
      i = l = c[0], a = u = c[1];
      for (let p = t; p < n; p += t)
        h = c[p], d = c[p + 1], h < i && (i = h), d < a && (a = d), h > l && (l = h), d > u && (u = d);
      f = Math.max(l - i, u - a), f = f !== 0 ? 32767 / f : 0;
    }
    return fi(s, o, t, i, a, f, 0), o;
  }
};
function Gx(c, e, t, r, n) {
  let s, o;
  if (n === dE(c, e, t, r) > 0)
    for (s = e; s < t; s += r)
      o = hm(s, c[s], c[s + 1], o);
  else
    for (s = t - r; s >= e; s -= r)
      o = hm(s, c[s], c[s + 1], o);
  return o && Ec(o, o.next) && (mi(o), o = o.next), o;
}
function Mr(c, e) {
  if (!c)
    return c;
  e || (e = c);
  let t = c, r;
  do
    if (r = !1, !t.steiner && (Ec(t, t.next) || xt(t.prev, t, t.next) === 0)) {
      if (mi(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function fi(c, e, t, r, n, s, o) {
  if (!c)
    return;
  !o && s && iE(c, r, n, s);
  let i = c, a, l;
  for (; c.prev !== c.next; ) {
    if (a = c.prev, l = c.next, s ? ZC(c, r, n, s) : KC(c)) {
      e.push(a.i / t | 0), e.push(c.i / t | 0), e.push(l.i / t | 0), mi(c), c = l.next, i = l.next;
      continue;
    }
    if (c = l, c === i) {
      o ? o === 1 ? (c = QC(Mr(c), e, t), fi(c, e, t, r, n, s, 2)) : o === 2 && eE(c, e, t, r, n, s) : fi(Mr(c), e, t, r, n, s, 1);
      break;
    }
  }
}
function KC(c) {
  const e = c.prev, t = c, r = c.next;
  if (xt(e, t, r) >= 0)
    return !1;
  const n = e.x, s = t.x, o = r.x, i = e.y, a = t.y, l = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, h = i < a ? i < l ? i : l : a < l ? a : l, d = n > s ? n > o ? n : o : s > o ? s : o, f = i > a ? i > l ? i : l : a > l ? a : l;
  let p = r.next;
  for (; p !== e; ) {
    if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && no(n, i, s, a, o, l, p.x, p.y) && xt(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function ZC(c, e, t, r) {
  const n = c.prev, s = c, o = c.next;
  if (xt(n, s, o) >= 0)
    return !1;
  const i = n.x, a = s.x, l = o.x, u = n.y, h = s.y, d = o.y, f = i < a ? i < l ? i : l : a < l ? a : l, p = u < h ? u < d ? u : d : h < d ? h : d, m = i > a ? i > l ? i : l : a > l ? a : l, g = u > h ? u > d ? u : d : h > d ? h : d, b = pu(f, p, e, t, r), v = pu(m, g, e, t, r);
  let y = c.prevZ, x = c.nextZ;
  for (; y && y.z >= b && x && x.z <= v; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && no(i, u, a, h, l, d, y.x, y.y) && xt(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && no(i, u, a, h, l, d, x.x, x.y) && xt(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= b; ) {
    if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && no(i, u, a, h, l, d, y.x, y.y) && xt(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= v; ) {
    if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && no(i, u, a, h, l, d, x.x, x.y) && xt(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function QC(c, e, t) {
  let r = c;
  do {
    const n = r.prev, s = r.next.next;
    !Ec(n, s) && Vx(n, r, r.next, s) && pi(n, s) && pi(s, n) && (e.push(n.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), mi(r), mi(r.next), r = c = s), r = r.next;
  } while (r !== c);
  return Mr(r);
}
function eE(c, e, t, r, n, s) {
  let o = c;
  do {
    let i = o.next.next;
    for (; i !== o.prev; ) {
      if (o.i !== i.i && lE(o, i)) {
        let a = jx(o, i);
        o = Mr(o, o.next), a = Mr(a, a.next), fi(o, e, t, r, n, s, 0), fi(a, e, t, r, n, s, 0);
        return;
      }
      i = i.next;
    }
    o = o.next;
  } while (o !== c);
}
function tE(c, e, t, r) {
  const n = [];
  let s, o, i, a, l;
  for (s = 0, o = e.length; s < o; s++)
    i = e[s] * r, a = s < o - 1 ? e[s + 1] * r : c.length, l = Gx(c, i, a, r, !1), l === l.next && (l.steiner = !0), n.push(cE(l));
  for (n.sort(nE), s = 0; s < n.length; s++)
    t = sE(n[s], t);
  return t;
}
function nE(c, e) {
  return c.x - e.x;
}
function sE(c, e) {
  const t = rE(c, e);
  if (!t)
    return e;
  const r = jx(t, c);
  return Mr(r, r.next), Mr(t, t.next);
}
function rE(c, e) {
  let t = e, r = -1 / 0, n;
  const s = c.x, o = c.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= s && d > r && (r = d, n = t.x < t.next.x ? t : t.next, d === s))
        return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n)
    return null;
  const i = n, a = n.x, l = n.y;
  let u = 1 / 0, h;
  t = n;
  do
    s >= t.x && t.x >= a && s !== t.x && no(o < l ? s : r, o, a, l, o < l ? r : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), pi(t, c) && (h < u || h === u && (t.x > n.x || t.x === n.x && oE(n, t))) && (n = t, u = h)), t = t.next;
  while (t !== i);
  return n;
}
function oE(c, e) {
  return xt(c.prev, c, e.prev) < 0 && xt(e.next, c, c.next) < 0;
}
function iE(c, e, t, r) {
  let n = c;
  do
    n.z === 0 && (n.z = pu(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== c);
  n.prevZ.nextZ = null, n.prevZ = null, aE(n);
}
function aE(c) {
  let e, t, r, n, s, o, i, a, l = 1;
  do {
    for (t = c, c = null, s = null, o = 0; t; ) {
      for (o++, r = t, i = 0, e = 0; e < l && (i++, r = r.nextZ, !!r); e++)
        ;
      for (a = l; i > 0 || a > 0 && r; )
        i !== 0 && (a === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, i--) : (n = r, r = r.nextZ, a--), s ? s.nextZ = n : c = n, n.prevZ = s, s = n;
      t = r;
    }
    s.nextZ = null, l *= 2;
  } while (o > 1);
  return c;
}
function pu(c, e, t, r, n) {
  return c = (c - t) * n | 0, e = (e - r) * n | 0, c = (c | c << 8) & 16711935, c = (c | c << 4) & 252645135, c = (c | c << 2) & 858993459, c = (c | c << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, c | e << 1;
}
function cE(c) {
  let e = c, t = c;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== c);
  return t;
}
function no(c, e, t, r, n, s, o, i) {
  return (n - o) * (e - i) >= (c - o) * (s - i) && (c - o) * (r - i) >= (t - o) * (e - i) && (t - o) * (s - i) >= (n - o) * (r - i);
}
function lE(c, e) {
  return c.next.i !== e.i && c.prev.i !== e.i && !uE(c, e) && // dones't intersect other edges
  (pi(c, e) && pi(e, c) && hE(c, e) && // locally visible
  (xt(c.prev, c, e.prev) || xt(c, e.prev, e)) || // does not create opposite-facing sectors
  Ec(c, e) && xt(c.prev, c, c.next) > 0 && xt(e.prev, e, e.next) > 0);
}
function xt(c, e, t) {
  return (e.y - c.y) * (t.x - e.x) - (e.x - c.x) * (t.y - e.y);
}
function Ec(c, e) {
  return c.x === e.x && c.y === e.y;
}
function Vx(c, e, t, r) {
  const n = ma(xt(c, e, t)), s = ma(xt(c, e, r)), o = ma(xt(t, r, c)), i = ma(xt(t, r, e));
  return !!(n !== s && o !== i || n === 0 && pa(c, t, e) || s === 0 && pa(c, r, e) || o === 0 && pa(t, c, r) || i === 0 && pa(t, e, r));
}
function pa(c, e, t) {
  return e.x <= Math.max(c.x, t.x) && e.x >= Math.min(c.x, t.x) && e.y <= Math.max(c.y, t.y) && e.y >= Math.min(c.y, t.y);
}
function ma(c) {
  return c > 0 ? 1 : c < 0 ? -1 : 0;
}
function uE(c, e) {
  let t = c;
  do {
    if (t.i !== c.i && t.next.i !== c.i && t.i !== e.i && t.next.i !== e.i && Vx(t, t.next, c, e))
      return !0;
    t = t.next;
  } while (t !== c);
  return !1;
}
function pi(c, e) {
  return xt(c.prev, c, c.next) < 0 ? xt(c, e, c.next) >= 0 && xt(c, c.prev, e) >= 0 : xt(c, e, c.prev) < 0 || xt(c, c.next, e) < 0;
}
function hE(c, e) {
  let t = c, r = !1;
  const n = (c.x + e.x) / 2, s = (c.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== c);
  return r;
}
function jx(c, e) {
  const t = new mu(c.i, c.x, c.y), r = new mu(e.i, e.x, e.y), n = c.next, s = e.prev;
  return c.next = e, e.prev = c, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function hm(c, e, t, r) {
  const n = new mu(c, e, t);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function mi(c) {
  c.next.prev = c.prev, c.prev.next = c.next, c.prevZ && (c.prevZ.nextZ = c.nextZ), c.nextZ && (c.nextZ.prevZ = c.prevZ);
}
function mu(c, e, t) {
  this.i = c, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function dE(c, e, t, r) {
  let n = 0;
  for (let s = e, o = t - r; s < t; s += r)
    n += (c[o] - c[s]) * (c[s + 1] + c[o + 1]), o = s;
  return n;
}
class $s {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let n = t - 1, s = 0; s < t; n = s++)
      r += e[n].x * e[s].y - e[s].x * e[n].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return $s.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], n = [], s = [];
    dm(e), fm(r, e);
    let o = e.length;
    t.forEach(dm);
    for (let a = 0; a < t.length; a++)
      n.push(o), o += t[a].length, fm(r, t[a]);
    const i = YC.triangulate(r, n);
    for (let a = 0; a < i.length; a += 3)
      s.push(i.slice(a, a + 3));
    return s;
  }
}
function dm(c) {
  const e = c.length;
  e > 2 && c[e - 1].equals(c[0]) && c.pop();
}
function fm(c, e) {
  for (let t = 0; t < e.length; t++)
    c.push(e[t].x), c.push(e[t].y);
}
class uf extends Yt {
  constructor(e = new kx([new Re(0.5, 0.5), new Re(-0.5, 0.5), new Re(-0.5, -0.5), new Re(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, n = [], s = [];
    for (let i = 0, a = e.length; i < a; i++) {
      const l = e[i];
      o(l);
    }
    this.setAttribute("position", new Xe(n, 3)), this.setAttribute("uv", new Xe(s, 2)), this.computeVertexNormals();
    function o(i) {
      const a = [], l = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, p = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const b = t.extrudePath, v = t.UVGenerator !== void 0 ? t.UVGenerator : fE;
      let y, x = !1, N, w, T, _;
      b && (y = b.getSpacedPoints(u), x = !0, d = !1, N = b.computeFrenetFrames(u, !1), w = new j(), T = new j(), _ = new j()), d || (g = 0, f = 0, p = 0, m = 0);
      const L = i.extractPoints(l);
      let A = L.shape;
      const U = L.holes;
      if (!$s.isClockWise(A)) {
        A = A.reverse();
        for (let F = 0, te = U.length; F < te; F++) {
          const Z = U[F];
          $s.isClockWise(Z) && (U[F] = Z.reverse());
        }
      }
      const R = $s.triangulateShape(A, U), E = A;
      for (let F = 0, te = U.length; F < te; F++) {
        const Z = U[F];
        A = A.concat(Z);
      }
      function D(F, te, Z) {
        return te || console.error("THREE.ExtrudeGeometry: vec does not exist"), F.clone().addScaledVector(te, Z);
      }
      const P = A.length, se = R.length;
      function oe(F, te, Z) {
        let Y, ee, pe;
        const ne = F.x - te.x, he = F.y - te.y, fe = Z.x - F.x, K = Z.y - F.y, Ae = ne * ne + he * he, me = ne * K - he * fe;
        if (Math.abs(me) > Number.EPSILON) {
          const be = Math.sqrt(Ae), de = Math.sqrt(fe * fe + K * K), qe = te.x - he / be, le = te.y + ne / be, Ne = Z.x - K / de, ye = Z.y + fe / de, Te = ((Ne - qe) * K - (ye - le) * fe) / (ne * K - he * fe);
          Y = qe + ne * Te - F.x, ee = le + he * Te - F.y;
          const Pe = Y * Y + ee * ee;
          if (Pe <= 2)
            return new Re(Y, ee);
          pe = Math.sqrt(Pe / 2);
        } else {
          let be = !1;
          ne > Number.EPSILON ? fe > Number.EPSILON && (be = !0) : ne < -Number.EPSILON ? fe < -Number.EPSILON && (be = !0) : Math.sign(he) === Math.sign(K) && (be = !0), be ? (Y = -he, ee = ne, pe = Math.sqrt(Ae)) : (Y = ne, ee = he, pe = Math.sqrt(Ae / 2));
        }
        return new Re(Y / pe, ee / pe);
      }
      const H = [];
      for (let F = 0, te = E.length, Z = te - 1, Y = F + 1; F < te; F++, Z++, Y++)
        Z === te && (Z = 0), Y === te && (Y = 0), H[F] = oe(E[F], E[Z], E[Y]);
      const X = [];
      let C, O = H.concat();
      for (let F = 0, te = U.length; F < te; F++) {
        const Z = U[F];
        C = [];
        for (let Y = 0, ee = Z.length, pe = ee - 1, ne = Y + 1; Y < ee; Y++, pe++, ne++)
          pe === ee && (pe = 0), ne === ee && (ne = 0), C[Y] = oe(Z[Y], Z[pe], Z[ne]);
        X.push(C), O = O.concat(C);
      }
      for (let F = 0; F < g; F++) {
        const te = F / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, pe = E.length; ee < pe; ee++) {
          const ne = D(E[ee], H[ee], Y);
          W(ne.x, ne.y, -Z);
        }
        for (let ee = 0, pe = U.length; ee < pe; ee++) {
          const ne = U[ee];
          C = X[ee];
          for (let he = 0, fe = ne.length; he < fe; he++) {
            const K = D(ne[he], C[he], Y);
            W(K.x, K.y, -Z);
          }
        }
      }
      const I = p + m;
      for (let F = 0; F < P; F++) {
        const te = d ? D(A[F], O[F], I) : A[F];
        x ? (T.copy(N.normals[0]).multiplyScalar(te.x), w.copy(N.binormals[0]).multiplyScalar(te.y), _.copy(y[0]).add(T).add(w), W(_.x, _.y, _.z)) : W(te.x, te.y, 0);
      }
      for (let F = 1; F <= u; F++)
        for (let te = 0; te < P; te++) {
          const Z = d ? D(A[te], O[te], I) : A[te];
          x ? (T.copy(N.normals[F]).multiplyScalar(Z.x), w.copy(N.binormals[F]).multiplyScalar(Z.y), _.copy(y[F]).add(T).add(w), W(_.x, _.y, _.z)) : W(Z.x, Z.y, h / u * F);
        }
      for (let F = g - 1; F >= 0; F--) {
        const te = F / g, Z = f * Math.cos(te * Math.PI / 2), Y = p * Math.sin(te * Math.PI / 2) + m;
        for (let ee = 0, pe = E.length; ee < pe; ee++) {
          const ne = D(E[ee], H[ee], Y);
          W(ne.x, ne.y, h + Z);
        }
        for (let ee = 0, pe = U.length; ee < pe; ee++) {
          const ne = U[ee];
          C = X[ee];
          for (let he = 0, fe = ne.length; he < fe; he++) {
            const K = D(ne[he], C[he], Y);
            x ? W(K.x, K.y + y[u - 1].y, y[u - 1].x + Z) : W(K.x, K.y, h + Z);
          }
        }
      }
      k(), z();
      function k() {
        const F = n.length / 3;
        if (d) {
          let te = 0, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[2] + Z, ee[1] + Z, ee[0] + Z);
          }
          te = u + g * 2, Z = P * te;
          for (let Y = 0; Y < se; Y++) {
            const ee = R[Y];
            q(ee[0] + Z, ee[1] + Z, ee[2] + Z);
          }
        } else {
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[2], Z[1], Z[0]);
          }
          for (let te = 0; te < se; te++) {
            const Z = R[te];
            q(Z[0] + P * u, Z[1] + P * u, Z[2] + P * u);
          }
        }
        r.addGroup(F, n.length / 3 - F, 0);
      }
      function z() {
        const F = n.length / 3;
        let te = 0;
        Q(E, te), te += E.length;
        for (let Z = 0, Y = U.length; Z < Y; Z++) {
          const ee = U[Z];
          Q(ee, te), te += ee.length;
        }
        r.addGroup(F, n.length / 3 - F, 1);
      }
      function Q(F, te) {
        let Z = F.length;
        for (; --Z >= 0; ) {
          const Y = Z;
          let ee = Z - 1;
          ee < 0 && (ee = F.length - 1);
          for (let pe = 0, ne = u + g * 2; pe < ne; pe++) {
            const he = P * pe, fe = P * (pe + 1), K = te + Y + he, Ae = te + ee + he, me = te + ee + fe, be = te + Y + fe;
            ie(K, Ae, me, be);
          }
        }
      }
      function W(F, te, Z) {
        a.push(F), a.push(te), a.push(Z);
      }
      function q(F, te, Z) {
        ae(F), ae(te), ae(Z);
        const Y = n.length / 3, ee = v.generateTopUV(r, n, Y - 3, Y - 2, Y - 1);
        $(ee[0]), $(ee[1]), $(ee[2]);
      }
      function ie(F, te, Z, Y) {
        ae(F), ae(te), ae(Y), ae(te), ae(Z), ae(Y);
        const ee = n.length / 3, pe = v.generateSideWallUV(r, n, ee - 6, ee - 3, ee - 2, ee - 1);
        $(pe[0]), $(pe[1]), $(pe[3]), $(pe[1]), $(pe[2]), $(pe[3]);
      }
      function ae(F) {
        n.push(a[F * 3 + 0]), n.push(a[F * 3 + 1]), n.push(a[F * 3 + 2]);
      }
      function $(F) {
        s.push(F.x), s.push(F.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return pE(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const i = t[e.shapes[s]];
      r.push(i);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new ja[n.type]().fromJSON(n)), new uf(r, e.options);
  }
}
const fE = {
  generateTopUV: function(c, e, t, r, n) {
    const s = e[t * 3], o = e[t * 3 + 1], i = e[r * 3], a = e[r * 3 + 1], l = e[n * 3], u = e[n * 3 + 1];
    return [
      new Re(s, o),
      new Re(i, a),
      new Re(l, u)
    ];
  },
  generateSideWallUV: function(c, e, t, r, n, s) {
    const o = e[t * 3], i = e[t * 3 + 1], a = e[t * 3 + 2], l = e[r * 3], u = e[r * 3 + 1], h = e[r * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], p = e[n * 3 + 2], m = e[s * 3], g = e[s * 3 + 1], b = e[s * 3 + 2];
    return Math.abs(i - u) < Math.abs(o - l) ? [
      new Re(o, 1 - a),
      new Re(l, 1 - h),
      new Re(d, 1 - p),
      new Re(m, 1 - b)
    ] : [
      new Re(i, 1 - a),
      new Re(u, 1 - h),
      new Re(f, 1 - p),
      new Re(g, 1 - b)
    ];
  }
};
function pE(c, e, t) {
  if (t.shapes = [], Array.isArray(c))
    for (let r = 0, n = c.length; r < n; r++) {
      const s = c[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(c.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class hf extends Lr {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new hf(e.radius, e.detail);
  }
}
class df extends Lr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new df(e.radius, e.detail);
  }
}
class ff extends Yt {
  constructor(e = 1, t = 1, r = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: n
    };
    const s = e / 2, o = t / 2, i = Math.floor(r), a = Math.floor(n), l = i + 1, u = a + 1, h = e / i, d = t / a, f = [], p = [], m = [], g = [];
    for (let b = 0; b < u; b++) {
      const v = b * d - o;
      for (let y = 0; y < l; y++) {
        const x = y * h - s;
        p.push(x, -v, 0), m.push(0, 0, 1), g.push(y / i), g.push(1 - b / a);
      }
    }
    for (let b = 0; b < a; b++)
      for (let v = 0; v < i; v++) {
        const y = v + l * b, x = v + l * (b + 1), N = v + 1 + l * (b + 1), w = v + 1 + l * b;
        f.push(y, x, w), f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new Xe(p, 3)), this.setAttribute("normal", new Xe(m, 3)), this.setAttribute("uv", new Xe(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ff(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class pf extends Yt {
  constructor(e = 0.5, t = 1, r = 32, n = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: n,
      thetaStart: s,
      thetaLength: o
    }, r = Math.max(3, r), n = Math.max(1, n);
    const i = [], a = [], l = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new j(), p = new Re();
    for (let m = 0; m <= n; m++) {
      for (let g = 0; g <= r; g++) {
        const b = s + g / r * o;
        f.x = h * Math.cos(b), f.y = h * Math.sin(b), a.push(f.x, f.y, f.z), l.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, u.push(p.x, p.y);
      }
      h += d;
    }
    for (let m = 0; m < n; m++) {
      const g = m * (r + 1);
      for (let b = 0; b < r; b++) {
        const v = b + g, y = v, x = v + r + 1, N = v + r + 2, w = v + 1;
        i.push(y, x, w), i.push(x, N, w);
      }
    }
    this.setIndex(i), this.setAttribute("position", new Xe(a, 3)), this.setAttribute("normal", new Xe(l, 3)), this.setAttribute("uv", new Xe(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pf(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class mf extends Yt {
  constructor(e = new kx([new Re(0, 0.5), new Re(-0.5, -0.5), new Re(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], n = [], s = [], o = [];
    let i = 0, a = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(i, a, u), i += a, a = 0;
    this.setIndex(r), this.setAttribute("position", new Xe(n, 3)), this.setAttribute("normal", new Xe(s, 3)), this.setAttribute("uv", new Xe(o, 2));
    function l(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      $s.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        $s.isClockWise(v) === !0 && (p[g] = v.reverse());
      }
      const m = $s.triangulateShape(f, p);
      for (let g = 0, b = p.length; g < b; g++) {
        const v = p[g];
        f = f.concat(v);
      }
      for (let g = 0, b = f.length; g < b; g++) {
        const v = f[g];
        n.push(v.x, v.y, 0), s.push(0, 0, 1), o.push(v.x, v.y);
      }
      for (let g = 0, b = m.length; g < b; g++) {
        const v = m[g], y = v[0] + h, x = v[1] + h, N = v[2] + h;
        r.push(y, x, N), a += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return mE(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let n = 0, s = e.shapes.length; n < s; n++) {
      const o = t[e.shapes[n]];
      r.push(o);
    }
    return new mf(r, e.curveSegments);
  }
}
function mE(c, e) {
  if (e.shapes = [], Array.isArray(c))
    for (let t = 0, r = c.length; t < r; t++) {
      const n = c[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(c.uuid);
  return e;
}
class gf extends Yt {
  constructor(e = 1, t = 32, r = 16, n = 0, s = Math.PI * 2, o = 0, i = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: n,
      phiLength: s,
      thetaStart: o,
      thetaLength: i
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const a = Math.min(o + i, Math.PI);
    let l = 0;
    const u = [], h = new j(), d = new j(), f = [], p = [], m = [], g = [];
    for (let b = 0; b <= r; b++) {
      const v = [], y = b / r;
      let x = 0;
      b === 0 && o === 0 ? x = 0.5 / t : b === r && a === Math.PI && (x = -0.5 / t);
      for (let N = 0; N <= t; N++) {
        const w = N / t;
        h.x = -e * Math.cos(n + w * s) * Math.sin(o + y * i), h.y = e * Math.cos(o + y * i), h.z = e * Math.sin(n + w * s) * Math.sin(o + y * i), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), g.push(w + x, 1 - y), v.push(l++);
      }
      u.push(v);
    }
    for (let b = 0; b < r; b++)
      for (let v = 0; v < t; v++) {
        const y = u[b][v + 1], x = u[b][v], N = u[b + 1][v], w = u[b + 1][v + 1];
        (b !== 0 || o > 0) && f.push(y, x, w), (b !== r - 1 || a < Math.PI) && f.push(x, N, w);
      }
    this.setIndex(f), this.setAttribute("position", new Xe(p, 3)), this.setAttribute("normal", new Xe(m, 3)), this.setAttribute("uv", new Xe(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new gf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class yf extends Lr {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new yf(e.radius, e.detail);
  }
}
class vf extends Yt {
  constructor(e = 1, t = 0.4, r = 12, n = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: n,
      arc: s
    }, r = Math.floor(r), n = Math.floor(n);
    const o = [], i = [], a = [], l = [], u = new j(), h = new j(), d = new j();
    for (let f = 0; f <= r; f++)
      for (let p = 0; p <= n; p++) {
        const m = p / n * s, g = f / r * Math.PI * 2;
        h.x = (e + t * Math.cos(g)) * Math.cos(m), h.y = (e + t * Math.cos(g)) * Math.sin(m), h.z = t * Math.sin(g), i.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), d.subVectors(h, u).normalize(), a.push(d.x, d.y, d.z), l.push(p / n), l.push(f / r);
      }
    for (let f = 1; f <= r; f++)
      for (let p = 1; p <= n; p++) {
        const m = (n + 1) * f + p - 1, g = (n + 1) * (f - 1) + p - 1, b = (n + 1) * (f - 1) + p, v = (n + 1) * f + p;
        o.push(m, g, v), o.push(g, b, v);
      }
    this.setIndex(o), this.setAttribute("position", new Xe(i, 3)), this.setAttribute("normal", new Xe(a, 3)), this.setAttribute("uv", new Xe(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new vf(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class xf extends Yt {
  constructor(e = 1, t = 0.4, r = 64, n = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: n,
      p: s,
      q: o
    }, r = Math.floor(r), n = Math.floor(n);
    const i = [], a = [], l = [], u = [], h = new j(), d = new j(), f = new j(), p = new j(), m = new j(), g = new j(), b = new j();
    for (let y = 0; y <= r; ++y) {
      const x = y / r * s * Math.PI * 2;
      v(x, s, o, e, f), v(x + 0.01, s, o, e, p), g.subVectors(p, f), b.addVectors(p, f), m.crossVectors(g, b), b.crossVectors(m, g), m.normalize(), b.normalize();
      for (let N = 0; N <= n; ++N) {
        const w = N / n * Math.PI * 2, T = -t * Math.cos(w), _ = t * Math.sin(w);
        h.x = f.x + (T * b.x + _ * m.x), h.y = f.y + (T * b.y + _ * m.y), h.z = f.z + (T * b.z + _ * m.z), a.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), l.push(d.x, d.y, d.z), u.push(y / r), u.push(N / n);
      }
    }
    for (let y = 1; y <= r; y++)
      for (let x = 1; x <= n; x++) {
        const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
        i.push(N, w, _), i.push(w, T, _);
      }
    this.setIndex(i), this.setAttribute("position", new Xe(a, 3)), this.setAttribute("normal", new Xe(l, 3)), this.setAttribute("uv", new Xe(u, 2));
    function v(y, x, N, w, T) {
      const _ = Math.cos(y), L = Math.sin(y), A = N / x * y, U = Math.cos(A);
      T.x = w * (2 + U) * 0.5 * _, T.y = w * (2 + U) * L * 0.5, T.z = w * Math.sin(A) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new xf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class bf extends Yt {
  constructor(e = new zx(new j(-1, -1, 0), new j(-1, 1, 0), new j(1, 1, 0)), t = 64, r = 1, n = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: n,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const i = new j(), a = new j(), l = new Re();
    let u = new j();
    const h = [], d = [], f = [], p = [];
    m(), this.setIndex(p), this.setAttribute("position", new Xe(h, 3)), this.setAttribute("normal", new Xe(d, 3)), this.setAttribute("uv", new Xe(f, 2));
    function m() {
      for (let y = 0; y < t; y++)
        g(y);
      g(s === !1 ? t : 0), v(), b();
    }
    function g(y) {
      u = e.getPointAt(y / t, u);
      const x = o.normals[y], N = o.binormals[y];
      for (let w = 0; w <= n; w++) {
        const T = w / n * Math.PI * 2, _ = Math.sin(T), L = -Math.cos(T);
        a.x = L * x.x + _ * N.x, a.y = L * x.y + _ * N.y, a.z = L * x.z + _ * N.z, a.normalize(), d.push(a.x, a.y, a.z), i.x = u.x + r * a.x, i.y = u.y + r * a.y, i.z = u.z + r * a.z, h.push(i.x, i.y, i.z);
      }
    }
    function b() {
      for (let y = 1; y <= t; y++)
        for (let x = 1; x <= n; x++) {
          const N = (n + 1) * (y - 1) + (x - 1), w = (n + 1) * y + (x - 1), T = (n + 1) * y + x, _ = (n + 1) * (y - 1) + x;
          p.push(N, w, _), p.push(w, T, _);
        }
    }
    function v() {
      for (let y = 0; y <= t; y++)
        for (let x = 0; x <= n; x++)
          l.x = y / t, l.y = x / n, f.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new bf(
      new ja[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class gE extends Yt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), n = new j(), s = new j();
      if (e.index !== null) {
        const o = e.attributes.position, i = e.index;
        let a = e.groups;
        a.length === 0 && (a = [{ start: 0, count: i.count, materialIndex: 0 }]);
        for (let l = 0, u = a.length; l < u; ++l) {
          const h = a[l], d = h.start, f = h.count;
          for (let p = d, m = d + f; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const b = i.getX(p + g), v = i.getX(p + (g + 1) % 3);
              n.fromBufferAttribute(o, b), s.fromBufferAttribute(o, v), pm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let i = 0, a = o.count / 3; i < a; i++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * i + l, h = 3 * i + (l + 1) % 3;
            n.fromBufferAttribute(o, u), s.fromBufferAttribute(o, h), pm(n, s, r) === !0 && (t.push(n.x, n.y, n.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Xe(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function pm(c, e, t) {
  const r = `${c.x},${c.y},${c.z}-${e.x},${e.y},${e.z}`, n = `${e.x},${e.y},${e.z}-${c.x},${c.y},${c.z}`;
  return t.has(r) === !0 || t.has(n) === !0 ? !1 : (t.add(r), t.add(n), !0);
}
const mm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BoxGeometry: nf,
  CapsuleGeometry: of,
  CircleGeometry: af,
  ConeGeometry: cf,
  CylinderGeometry: Cc,
  DodecahedronGeometry: lf,
  EdgesGeometry: JC,
  ExtrudeGeometry: uf,
  IcosahedronGeometry: hf,
  LatheGeometry: Ac,
  OctahedronGeometry: df,
  PlaneGeometry: ff,
  PolyhedronGeometry: Lr,
  RingGeometry: pf,
  ShapeGeometry: mf,
  SphereGeometry: gf,
  TetrahedronGeometry: yf,
  TorusGeometry: vf,
  TorusKnotGeometry: xf,
  TubeGeometry: bf,
  WireframeGeometry: gE
}, Symbol.toStringTag, { value: "Module" }));
class Wa extends Ha {
  constructor(t) {
    super();
    G(this, "nodes", []);
    G(this, "isLocked", !1);
    this.object = t, t.graph || (t.graph = this), this.addEventListener("nodeEventOutputChanged", ({ node: r, fields: n }) => {
      for (const s of n)
        this.applyNodePins(r._parentGraphNode, s, "out");
    });
  }
  newGraphNode(t, r) {
    const n = new Proxy({ x: 0, y: 0 }, {
      set: (o, i, a, l) => {
        if (a === Reflect.get(o, i))
          return !0;
        const u = Reflect.set(o, i, a, l);
        return u && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s] }), u;
      }
    }), s = {
      name: r,
      scoped: Sa(t, this),
      anchor: n,
      bounds: {},
      outs: {}
    };
    return t._parentGraphNode = s, s;
  }
  add(t) {
    if (this.nodes.indexOf(t) !== -1)
      throw ze.panic(`Graph Node[${t.scoped.uuid}] aready exists`);
    t.scoped instanceof tn && (t.scoped.eventDispatcher = this), this.nodes.push(t), this.dispatchEvent({ type: "graphAdded", soure: this, nodes: [t] });
  }
  remove(t) {
    const r = this.nodes.indexOf(t);
    if (r === -1)
      return !1;
    this.nodes.splice(r, 1), t.scoped instanceof tn && (t.scoped.eventDispatcher = null);
    for (const n of Object.keys(t.bounds))
      this.disconnect({ node: t, field: n }, !0);
    for (const n of Object.values(t.outs))
      for (const s of [...n])
        this.disconnect({ node: s.node, field: s.field }, !0);
    t.scoped.dispose && t.scoped.dispose(), this.dispatchEvent({ type: "graphRemoved", soure: this, nodes: [t] });
  }
  get(t) {
    return this.nodes.find((r) => r.scoped.uuid === t);
  }
  update(t, r, n, s) {
    for (const o of this.nodes)
      o.scoped.onUpdate && o.scoped.onUpdate(t, r, n, s);
  }
  connect(t, r, n) {
    if (!t.field && t.node.scoped instanceof _n || !t.field && r.node.scoped instanceof _n) {
      if (t.node.scoped instanceof _n != r.node.scoped instanceof _n) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      if (!(t.node.scoped instanceof _n) || !(r.node.scoped instanceof _n)) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      if (t.node.scoped.next === r.node.scoped) {
        if (n)
          return 3;
      } else if (t.node.scoped.next || r.node.scoped.prev) {
        if (n)
          return 0;
        throw ze.panic("not supported");
      }
      return n || (t.node.scoped.next = r.node.scoped, r.node.scoped.prev = t.node.scoped, this.dispatchEvent({ type: "graphModified", soure: this, nodes: [t.node, r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node })), 3;
    }
    if (!r.field) {
      if (n)
        return 0;
      throw ze.panic("not supported");
    }
    const s = r.node.bounds[r.field];
    if (s) {
      if (s.node === t.node && s.field === t.field)
        return s.type;
      if (n)
        return 0;
      throw ze.panic(`field[${r.field}] has been bound`);
    }
    const o = t.node.scoped instanceof tn ? t.node.scoped.objectType : fp(t.node.name), i = fp(r.node.name), { out: a } = t.node.scoped.typesExtended || ka(o), { in: l } = r.node.scoped.typesExtended || ka(i), u = t.field ? a[t.field] : { types: [o] }, h = r.field ? l[r.field] : { types: [i] };
    if (t.field) {
      if (!qS(u.types, h.types)) {
        if (n)
          return 0;
        throw ze.panic("type mismatched");
      }
    } else if (!YS(o, h.types)) {
      if (n)
        return 0;
      throw ze.panic("type mismatched");
    }
    const f = u.types.findIndex((g) => bc(g)) !== -1 ? 1 : 2;
    if (n)
      return f;
    r.node.bounds[r.field] = { node: t.node, type: f, field: t.field };
    const p = t.field || "$";
    return (t.node.outs[p] || (t.node.outs[p] = [])).push({ node: r.node, type: f, field: r.field }), this.applyNodeBounds(r.node), this.dispatchEvent({ type: "graphModified", soure: this, nodes: [r.node] }), this.dispatchEvent({ type: "graphConnected", soure: this, from: t.node, to: r.node }), f;
  }
  disconnect(t, r) {
    if (!t.field && t.node.scoped instanceof _n) {
      if (!t.node.scoped.prev)
        throw ze.panic("state error");
      t.node.scoped.prev.next = void 0, t.node.scoped.prev = void 0;
      return;
    }
    if (!t.field)
      throw ze.panic("not allowed");
    const n = t.node.bounds[t.field];
    if (n === void 0)
      return;
    const s = n.node, o = n.field || "$", i = s.outs[o];
    if (!i)
      throw ze.panic(`bound list not found for node[field=${t.field}]`);
    const a = t.node.scoped, l = i.findIndex((f) => f.node === t.node && f.field === t.field);
    if (l === -1)
      return;
    delete t.node.bounds[t.field], i.splice(l, 1);
    const u = a instanceof tn ? a.getObjectsExtended().in : a, h = u[t.field];
    if (h instanceof zn)
      u[t.field] = new An();
    else {
      const f = `${t.field}Node`;
      Object.hasOwn(u, f) ? u[f] = null : h && (h.isNode || h.isMaterial) && (u[t.field] = null), u instanceof zn && (u.needsUpdate = !0, u instanceof hs && (u.uniformsNeedUpdate = !0));
    }
    r || (this.dispatchEvent({ type: "graphModified", soure: this, nodes: [s, t.node] }), this.dispatchEvent({ type: "graphDisconnected", soure: this, from: s, to: t.node }));
  }
  clear() {
    for (const t of this.nodes)
      t.scoped.dispose && t.scoped.dispose();
    this.nodes.length = 0;
  }
  clone(t, r) {
    const n = r.get(this.object);
    if (!n)
      throw ze.panic(`object[${this.object.uuid}] is not found in list being transfered`);
    const s = {};
    for (const i of this.nodes) {
      const a = i.scoped;
      let l;
      const u = {};
      if (a instanceof tn) {
        l = tu(i.name), a.serialize(u), l.deserialize(u), a.object instanceof kn && (s[a.object.uuid] = a.object);
        const h = a.object[Gt], d = r.get(h);
        d && (s[h.uuid] = d);
      } else
        a.clone ? l = a.clone(!0) : l = tu(i.name, a);
      s[l.uuid] = l, s[a.uuid] = l;
    }
    const o = new Wa(n);
    for (const i of Object.values(this.nodes)) {
      let a = s[i.scoped.uuid];
      a instanceof tn ? (a.fill(t, s), a.eventDispatcher = o) : a[Gt] || (a = Sa(Me(a), o));
      const l = new Proxy({ ...i.anchor }, {
        set: (h, d, f, p) => {
          if (f === Reflect.get(h, d))
            return !0;
          const m = Reflect.set(h, d, f, p);
          return m && o.dispatchEvent({ type: "graphModified", soure: o, nodes: [u] }), m;
        }
      }), u = {
        name: i.name,
        scoped: a,
        anchor: l,
        bounds: {},
        outs: {}
      };
      a._parentGraphNode = u;
      for (const [h, d] of Object.entries(i.bounds)) {
        const { node: f, type: p, field: m } = d, g = s[f.scoped.uuid];
        if (!g)
          throw ze.panic(`node[${f.scoped.uuid}] not found`);
        u.bounds[h] = { type: p, node: g, field: m };
      }
      for (const [h, d] of Object.entries(i.outs || {})) {
        const f = u.outs[h] || (u.outs[h] = []);
        for (const p of d) {
          const { node: m, type: g, field: b } = p, v = s[m.scoped.uuid];
          if (!v)
            throw ze.panic(`node[${m.scoped.uuid}] not found`);
          f.push({ node: v, type: g, field: b });
        }
      }
      o.nodes.push(u);
    }
    for (const i of o.nodes) {
      for (const a of Object.values(i.bounds)) {
        const l = o.nodes.find((u) => u.scoped.uuid === a.node.uuid);
        l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
      }
      for (const a of Object.values(i.outs))
        for (const l of a) {
          const u = o.nodes.find((h) => h.scoped.uuid === l.node.uuid);
          u || console.error(`node[${l.node.uuid}] not found!`), l.node = u;
        }
    }
    for (const i of o.nodes)
      o.applyNodeBounds(i);
    return o;
  }
  serialize(t) {
    const r = {
      isGraph: !0,
      nodes: []
    };
    for (const n of this.nodes) {
      t.nodes[n.scoped.uuid] || (t.nodes[n.scoped.uuid] = n.scoped.toJSON(t));
      const s = {};
      Object.entries(n.outs).forEach(([i, a]) => {
        s[i] = a.map((l) => ({ n: l.node.scoped.uuid, f: l.field, t: l.type }));
      });
      const o = {
        name: n.name,
        node: n.scoped.uuid,
        anchor: { ...n.anchor },
        bounds: Object.fromEntries(Object.entries(n.bounds).map((i) => [i[0], { t: i[1].type, n: i[1].node.scoped.uuid, f: i[1].field }])),
        outs: s
      };
      r.nodes.push(o);
    }
    return r;
  }
  deserialize(t, r, n) {
    if (!t || !t.isGraph)
      return;
    if (!Array.isArray(t.nodes))
      throw ze.panic("not node info found");
    this.clear();
    const s = { ...r, ...n };
    for (const o of t.nodes) {
      let i = r[o.node];
      if (!i)
        throw ze.panic(`node[${o.node}] not found`);
      i instanceof tn ? (i.fill(this.object, s), i.eventDispatcher = this) : i = Sa(Me(i), this);
      const a = new Proxy(o.anchor, {
        set: (u, h, d, f) => {
          if (d === Reflect.get(u, h))
            return !0;
          const p = Reflect.set(u, h, d, f);
          return p && this.dispatchEvent({ type: "graphModified", soure: this, nodes: [l] }), p;
        }
      }), l = {
        name: o.name,
        scoped: i,
        anchor: a,
        bounds: {},
        outs: {}
      };
      i._parentGraphNode = l;
      for (const [u, h] of Object.entries(o.bounds)) {
        const { n: d, t: f, f: p } = h, m = r[d];
        if (!m)
          throw ze.panic(`node[${d}] not found`);
        l.bounds[u] = { type: f, node: m, field: p };
      }
      for (const [u, h] of Object.entries(o.outs || {})) {
        const d = l.outs[u] || (l.outs[u] = []);
        for (const f of h) {
          const { n: p, t: m, f: g } = f, b = r[p];
          if (!b)
            throw ze.panic(`node[${p}] not found`);
          d.push({ node: b, type: m, field: g });
        }
      }
      this.nodes.push(l);
    }
    for (const o of this.nodes) {
      for (const i of Object.values(o.bounds)) {
        const a = this.nodes.find((l) => l.scoped.uuid === i.node.uuid);
        a || console.error(`node[${i.node.uuid}] not found!`), i.node = a;
      }
      for (const i of Object.values(o.outs))
        for (const a of i) {
          const l = this.nodes.find((u) => u.scoped.uuid === a.node.uuid);
          l || console.error(`node[${a.node.uuid}] not found!`), a.node = l;
        }
    }
    for (const o of this.nodes)
      this.applyNodeBounds(o);
  }
  applyNodeBounds(t, r) {
    for (const [n, s] of Object.entries(t.bounds)) {
      if (r && !r.includes(n))
        continue;
      const { node: o, type: i, field: a } = s, l = o.outs[a || "$"];
      if (!l)
        throw ze.panic(`bound list not found for node[field=${n}]`);
      if (!l.find((m) => m.node === t && m.field === n))
        throw ze.panic(`bound slot not found for node[field=${n}]`);
      const h = o.scoped instanceof tn ? o.scoped.getObjectsExtended().out : o.scoped;
      let d = a ? h[a] : h;
      const f = t.scoped instanceof tn ? t.scoped.getObjectsExtended().in : t.scoped, p = f[n];
      if (typeof d == "object" && (d = d[Gt] || d), d !== p) {
        if (i === 1) {
          typeof p == "object" && p.dispose && p.dispose(), f[n] = d;
          continue;
        }
        typeof d == "object" ? !p || p === null ? f[n] = d : typeof p.copy == "function" ? p.copy(d) : typeof d.clone == "function" ? f[n] = d.clone() : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d) : (typeof p == "object" && p.dispose && p.dispose(), f[n] = d);
      }
    }
    t.scoped instanceof zn && (t.scoped.needsUpdate = !0, t.scoped instanceof hs && (t.scoped.uniformsNeedUpdate = !0));
  }
  applyNodePins(t, r, n) {
    if (n === "in")
      t.scoped instanceof zn ? (t.scoped.needsUpdate = !0, t.scoped instanceof hs && (t.scoped.uniformsNeedUpdate = !0)) : t.scoped instanceof tn && t.scoped.object instanceof kn && (t.scoped.object.needsUpdate = !0);
    else {
      const s = t.outs[r];
      if (!s)
        return;
      for (const o of s)
        o.type === 1 ? this.applyNodePins(o.node, o.field, "in") : this.applyNodeBounds(o.node, [o.field]);
    }
  }
  addType(t, r, n, s) {
    return r ? /^[a-z][a-z0-9_]*$/i.test(r) ? t.scoped instanceof xo ? (s === "in" ? t.scoped.addInput : t.scoped.addOutput).call(t.scoped, r, n) ? !0 : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: `Failed to create field[${r}] as type[${n}]!` }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "It is not a ScriptNode!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Illegal name!" }), !1) : (this.dispatchEvent({ type: "userEventNotice", source: this, level: "error", message: "Empty name!" }), !1);
  }
  removeType(t, r, n) {
    if (!(t.scoped instanceof xo) || !(n === "in" ? t.scoped.removeInput : t.scoped.removeOutput).call(t.scoped, r))
      return !1;
    if (n === "in")
      this.disconnect({ node: t, field: r, io: n });
    else {
      const o = t.outs[r];
      if (o)
        for (const i of [...o])
          this.disconnect({ node: i.node, field: i.field });
    }
    return !0;
  }
}
const { getTypedArray: gm } = PC, { createNodeFromType: yE } = S1;
class vE extends wr {
  constructor(t) {
    super(t);
    G(this, "_textures");
    G(this, "_listeners", {});
    G(this, "_nodes");
    G(this, "_nodesJSON");
  }
  load(t, r, n, s) {
    const o = this, i = this.path === "" ? ho.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new qs(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(l) {
      let u = null;
      try {
        u = JSON.parse(l);
      } catch (d) {
        s !== void 0 && s(d), console.error("THREE:ObjectLoader: Can't parse " + t + ".", d.message);
        return;
      }
      const h = u.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + t)), console.error("THREE.ObjectLoader: Can't load " + t);
        return;
      }
      o.parse(u, r);
    }, n, s);
  }
  async loadAsync(t, r) {
    const n = this, s = this.path === "" ? ho.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || s;
    const o = new qs(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const i = await o.loadAsync(t, r), a = JSON.parse(i), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + t);
    return await n.parseAsync(a);
  }
  parse(t, r) {
    this._nodesJSON = t.nodes;
    const n = this.parseAnimations(t.animations), s = this.parseShapes(t.shapes), o = this.parseGeometries(t.geometries, s), i = this.parseImages(t.images, function() {
      r !== void 0 && r(u);
    }), a = this.parseTextures(t.textures, i), l = this.parseMaterials(t.materials, a);
    if (t.listeners)
      for (const d of t.listeners) {
        const f = this.parseObject(d, o, l, a, n);
        this._listeners[f.uuid] = f;
      }
    const u = this.parseObject(t.object, o, l, a, n), h = this.parseSkeletons(t.skeletons, u);
    if (this.bindSkeletons(u, h), r !== void 0) {
      let d = !1;
      for (const f in i)
        if (i[f].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && r(u);
    }
    this._nodesJSON = null, u.traverse((d) => {
      d.userData.graph && new Wa(d).deserialize(d.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const d of Object.values(this._nodes || {}))
      d.fill && d.fill(u, this._nodes || {}, this._textures || {});
    return u;
  }
  async parseAsync(t) {
    this._nodesJSON = t.nodes;
    const r = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes), s = this.parseGeometries(t.geometries, n), o = await this.parseImagesAsync(t.images), i = this.parseTextures(t.textures, o), a = this.parseMaterials(t.materials, i);
    if (t.listeners)
      for (const h of t.listeners) {
        const d = this.parseObject(h, s, a, i, r);
        this._listeners[d.uuid] = d;
      }
    const l = this.parseObject(t.object, s, a, i, r), u = this.parseSkeletons(t.skeletons, l);
    this.bindSkeletons(l, u), this._nodesJSON = null, l.traverse((h) => {
      h.userData.graph && new Wa(h).deserialize(h.userData.graph, this._nodes || {}, this._textures || {});
    });
    for (const h of Object.values(this._nodes || {}))
      h.fill && h.fill(l, this._nodes || {}, this._textures || {});
    return l;
  }
  parseShapes(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0, s = t.length; n < s; n++) {
        const o = new No().fromJSON(t[n]);
        r[o.uuid] = o;
      }
    return r;
  }
  parseSkeletons(t, r) {
    const n = {}, s = {};
    if (r.traverse(function(o) {
      o.isBone && (s[o.uuid] = o);
    }), t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = new Su();
        a.fromJSON(t[o], s), n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(t, r) {
    const n = {};
    if (t !== void 0) {
      const s = new $b();
      for (let o = 0, i = t.length; o < i; o++) {
        let a;
        const l = t[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = s.parse(l);
            break;
          default:
            l.type in mm ? a = mm[l.type].fromJSON(l, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(t, r) {
    const n = {};
    if (this._textures = r, t !== void 0) {
      const s = this.parseNodes(this._nodesJSON, r);
      this._nodes = s;
      const o = new Ua();
      o.setTextures(r), o.setNodes(s);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = s[l.uuid];
        u ? n[l.uuid] = u : n[l.uuid] = o.parse(l);
      }
    } else
      this._nodesJSON && (this._nodes = this.parseNodes(this._nodesJSON, r));
    return n;
  }
  parseAnimations(t) {
    const r = {};
    if (t !== void 0)
      for (let n = 0; n < t.length; n++) {
        const s = t[n], o = _u.parse(s);
        r[o.uuid] = o;
      }
    return r;
  }
  parseImages(t, r) {
    const n = this, s = {};
    let o;
    function i(l) {
      return n.manager.itemStart(l), o.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
        return i(h);
      } else
        return l.data ? {
          data: gm(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      const l = new qb(r);
      o = new qf(l), o.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = t.length; u < h; u++) {
        const d = t[u], f = d.url;
        if (Array.isArray(f)) {
          const p = [];
          for (let m = 0, g = f.length; m < g; m++) {
            const b = f[m], v = a(b);
            v !== null && (v instanceof HTMLImageElement ? p.push(v) : p.push(new ya(v.data, v.width, v.height)));
          }
          s[d.uuid] = new ji(p);
        } else {
          const p = a(d.url);
          s[d.uuid] = new ji(p);
        }
      }
    }
    return s;
  }
  async parseImagesAsync(t) {
    const r = this, n = {};
    let s;
    async function o(i) {
      if (typeof i == "string" && i) {
        const a = i, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : r.resourcePath + a;
        return await s.loadAsync(l);
      } else
        return i.data ? {
          data: gm(i.type, i.data),
          width: i.width,
          height: i.height
        } : null;
    }
    if (t !== void 0 && t.length > 0) {
      s = new qf(this.manager), s.setCrossOrigin(this.crossOrigin);
      for (let i = 0, a = t.length; i < a; i++) {
        const l = t[i], u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, f = u.length; d < f; d++) {
            const p = u[d], m = await o(p);
            m !== null && (m instanceof HTMLImageElement ? h.push(m) : h.push(new ya(m.data, m.width, m.height)));
          }
          n[l.uuid] = new ji(h);
        } else {
          const h = await o(l.url);
          n[l.uuid] = new ji(h);
        }
      }
    }
    return n;
  }
  parseTextures(t, r) {
    function n(o, i) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), i[o]);
    }
    const s = {};
    if (t !== void 0)
      for (let o = 0, i = t.length; o < i; o++) {
        const a = t[o];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), r[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = r[a.image], u = l.data;
        let h;
        Array.isArray(u) ? (h = new Jb(), u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new ya() : h = new kn(), u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = n(a.mapping, xE)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = n(a.wrap[0], ym), h.wrapT = n(a.wrap[1], ym)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, vm)), a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, vm)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), s[a.uuid] = h;
      }
    return s;
  }
  parseObject(t, r, n, s, o) {
    var m;
    function i(g) {
      return r[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", g), r[g];
    }
    function a(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const b = [];
          for (let v = 0, y = g.length; v < y; v++) {
            const x = g[v];
            n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), b.push(n[x]);
          }
          return b;
        }
        return n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), n[g];
      }
    }
    function l(g) {
      return s[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", g), s[g];
    }
    if (this._listeners[t.uuid]) {
      const g = this._listeners[t.uuid];
      if (t.children !== void 0) {
        const b = t.children;
        for (let v = 0; v < b.length; v++)
          g.add(this.parseObject(b[v], r, n, s, o));
      }
      return g;
    }
    const u = t.geometry ? i(t.geometry) : void 0, h = t.material ? a(t.material) : void 0;
    (u || h) && (t = { ...t, geometry: u, material: h });
    const d = ((m = t.userData) == null ? void 0 : m.extend) || t.type;
    if (d === "PositionalAudio2" && t.listener) {
      const g = this._listeners[t.listener];
      t = { ...t, listener: g };
    }
    if (!c_(d) && /^\[.*\]$/.test(t.name)) {
      const g = new vn();
      return g.uuid = t.uuid, t.name !== void 0 && (g.name = t.name), g;
    }
    const f = a_(d, t);
    switch (E1(d)) {
      case "Scene":
        t.background !== void 0 && (Number.isInteger(t.background) ? f.background = new je(t.background) : f.background = l(t.background)), t.environment !== void 0 && (f.environment = l(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? f.fog = new Yb(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (f.fog = new Kb(t.fog.color, t.fog.density)), t.fog.name !== "" && (f.fog.name = t.fog.name)), t.backgroundBlurriness !== void 0 && (f.backgroundBlurriness = t.backgroundBlurriness), t.backgroundIntensity !== void 0 && (f.backgroundIntensity = t.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        t.focus !== void 0 && (f.focus = t.focus), t.zoom !== void 0 && (f.zoom = t.zoom), t.filmGauge !== void 0 && (f.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (f.filmOffset = t.filmOffset), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        t.zoom !== void 0 && (f.zoom = t.zoom), t.view !== void 0 && (f.view = Object.assign({}, t.view));
        break;
      case "SkinnedMesh":
        t.bindMode !== void 0 && (f.bindMode = t.bindMode), t.bindMatrix !== void 0 && f.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (f.skeleton = t.skeleton);
        break;
    }
    if (f.uuid = t.uuid, t.name !== void 0 && (f.name = t.name), t.matrix !== void 0 ? (f.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (f.matrixAutoUpdate = t.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (t.position !== void 0 && f.position.fromArray(t.position), t.rotation !== void 0 && f.rotation.fromArray(t.rotation), t.quaternion !== void 0 && f.quaternion.fromArray(t.quaternion), t.scale !== void 0 && f.scale.fromArray(t.scale)), t.up !== void 0 && f.up.fromArray(t.up), t.castShadow !== void 0 && (f.castShadow = t.castShadow), t.receiveShadow !== void 0 && (f.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (f.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (f.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (f.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && f.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (f.shadow.camera = this.parseObject(t.shadow.camera, r, n, s, o))), t.visible !== void 0 && (f.visible = t.visible), t.frustumCulled !== void 0 && (f.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (f.renderOrder = t.renderOrder), t.userData !== void 0 && (f.userData = t.userData), t.layers !== void 0 && (f.layers.mask = t.layers), t.children !== void 0) {
      const g = t.children;
      for (let b = 0; b < g.length; b++)
        f.add(this.parseObject(g[b], r, n, s, o));
    }
    if (t.animations !== void 0) {
      const g = t.animations;
      for (let b = 0; b < g.length; b++) {
        const v = g[b];
        f.animations.push(o[v]);
      }
    }
    if (t.type === "LOD") {
      t.autoUpdate !== void 0 && (f.autoUpdate = t.autoUpdate);
      const g = t.levels;
      for (let b = 0; b < g.length; b++) {
        const v = g[b], y = f.getObjectByProperty("uuid", v.object);
        y !== void 0 && f.addLevel(y, v.distance, v.hysteresis);
      }
    }
    return f.deserialize && f.deserialize(t), f;
  }
  bindSkeletons(t, r) {
    Object.keys(r).length !== 0 && t.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const s = r[n.skeleton];
        s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(s, n.bindMatrix);
      }
    });
  }
  parseNodes(t, r) {
    if (t !== void 0) {
      const n = {}, s = new Ua();
      for (const i of t) {
        const { uuid: a, type: l, _inst: u } = i;
        if (/Material$/.test(l)) {
          const f = s.parse(i);
          f.uuid = a, n[a] = f;
          continue;
        }
        const d = u ? tu(u) : yE(l);
        n[a] = d, n[a].uuid = a;
      }
      const o = { nodes: n, textures: r };
      for (const i of t) {
        i.meta = o;
        const a = n[i.uuid];
        a.isMaterial || (a.deserialize(i), delete i.meta);
      }
      return n;
    }
    return {};
  }
}
const xE = {
  UVMapping: Zb,
  CubeReflectionMapping: Qb,
  CubeRefractionMapping: eN,
  EquirectangularReflectionMapping: jm,
  EquirectangularRefractionMapping: tN,
  CubeUVReflectionMapping: nN
}, ym = {
  RepeatWrapping: Js,
  ClampToEdgeWrapping: fo,
  MirroredRepeatWrapping: Vm
}, vm = {
  NearestFilter: Vs,
  NearestMipmapNearestFilter: Bm,
  NearestMipmapLinearFilter: Gm,
  LinearFilter: uo,
  LinearMipmapNearestFilter: km,
  LinearMipmapLinearFilter: bo
};
async function bE(c) {
  window.import || (window.import = new Function("path", "return import(path)"));
  try {
    return await window.import(c);
  } catch (e) {
    console.error(e);
  }
}
const xm = {
  resolution: "auto",
  toneMapping: Tm,
  toneMappingExposure: 1,
  shadowMap: {
    enabled: !0,
    type: sN
  },
  vrEnable: !1
};
class NE extends M.EventDispatcher {
  constructor(t) {
    super();
    G(this, "renderer");
    G(this, "clock");
    G(this, "size", { width: 2048, height: 2048 });
    G(this, "uuid", M.MathUtils.generateUUID());
    G(this, "defaultScene", new pC());
    G(this, "currentScene");
    G(this, "currentCamera");
    G(this, "defaultCamera");
    // vr
    G(this, "vrSession");
    /** left, right */
    G(this, "hands", []);
    G(this, "handsConllisionMap", /* @__PURE__ */ new Set());
    G(this, "working", !1);
    // for app
    G(this, "settings", { ...xm });
    G(this, "scenes", []);
    G(this, "spawns");
    this.context = t, Object.assign(nn, {
      navigateTo: this.navigateTo.bind(this),
      setCamera: this.setCamera.bind(this),
      spawn: this.createObjectFromSpawn.bind(this)
    }), this.renderer = new M.WebGLRenderer({
      canvas: this.context,
      antialias: !0
    }), this.renderer.outputColorSpace = M.SRGBColorSpace, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.autoUpdate = !0, this.renderer.shadowMap.type = M.PCFSoftShadowMap, this.renderer.autoClear = !1, this.renderer.toneMapping = M.ACESFilmicToneMapping, this.renderer.setClearColor(16777215), nn.gpuComputeRender = new KA(d_, f_, this.renderer), this.clock = new M.Clock(), this.currentScene = this.defaultScene, this.defaultCamera = new M.PerspectiveCamera(50, 1, 1e-3, 1e3), this.defaultCamera.name = "Perspective", this.defaultCamera.position.set(4, 3, 8), this.defaultCamera.lookAt(0, 0, 0);
    const r = this.currentScene.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.currentCamera = r, this.resize(this.size.width, this.size.height, 1);
  }
  resize(t, r, n) {
    if (!this.context)
      return;
    const s = Math.max(n, 1), o = t / r;
    this.size.width = t * s, this.size.height = r * s, this.renderer.setSize(this.size.width, this.size.height, !1), this.currentCamera && (this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = o, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / o, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix()));
  }
  navigateTo(t) {
    const r = this.scenes.find((s) => s.uuid === t || s.name === t);
    if (!r) {
      console.error(`Scene[${t}] not found`);
      return;
    }
    if (this.currentScene === r)
      return;
    this.currentScene && this.currentScene.deactive(), this.currentScene = r, this.currentScene.active();
    const n = r.getObjectByProperty("isCamera", !0) || this.defaultCamera;
    this.setCamera(n), this.settings.vrEnable && (this.currentScene.getObjectByName("vr-controller0") || this.setupVr(r), this.vrSession || this.startVR());
  }
  createObjectFromSpawn(t) {
    if (!this.spawns)
      return;
    const r = this.spawns.children.find((n) => n.name === t);
    if (r)
      return A1(r, !0, this.spawns);
  }
  setCamera(t) {
    if (this.currentCamera !== t && (this.currentCamera = t, this.currentCamera)) {
      const r = this.size.width / this.size.height;
      this.currentCamera instanceof M.PerspectiveCamera ? (this.currentCamera.aspect = r, this.currentCamera.updateProjectionMatrix()) : this.currentCamera instanceof M.OrthographicCamera && (this.currentCamera.top = this.currentCamera.right / r, this.currentCamera.bottom = -this.currentCamera.top, this.currentCamera.updateProjectionMatrix());
    }
  }
  async load(t) {
    const r = new vE(), s = await (await fetch(t)).json();
    if (s.project.plugins)
      try {
        const l = await Promise.all(s.project.plugins.map((u) => bE(u)));
        for (const u in l) {
          l[u].pluginInstall(
            Ye,
            Rx,
            Es,
            Nc
          );
          const d = s.project.plugins[u].split("/").pop();
          ze.notice(`Plugin ${d} has been installed successfully!`);
        }
      } catch (l) {
        console.error(l);
      }
    const o = await r.parseAsync(s), { project: i } = s;
    i.world && (Ts(this.settings), Object.assign(this.settings, { ...xm, ...i.world })), this.settings.resolution || (this.settings.resolution = "auto"), this.settings.vrEnable && (this.renderer.xr.enabled = !0), this.scenes.length = 0;
    for (const l of o.children)
      l.name === "[Spawns]" ? this.spawns = l : this.scenes.push(l);
    const a = this.scenes.find((l) => l.name === "index") || this.scenes[0] || this.defaultScene;
    this.navigateTo(a.uuid);
  }
  setupVr(t) {
    const r = this.renderer.xr.getController(0);
    r.name = "vr-controller0", t.add(r);
    const n = this.renderer.xr.getController(1);
    t.add(n);
    const s = new lC(), o = this.renderer.xr.getControllerGrip(0);
    o.add(s.createControllerModel(o)), t.add(o);
    const i = this.renderer.xr.getHand(0);
    this.hands[0] || (this.hands[0] = new Zp(i), this.hands[0].name = "left"), i.add(this.hands[0]), t.add(i);
    const a = this.renderer.xr.getControllerGrip(1);
    a.add(s.createControllerModel(a)), t.add(a);
    const l = this.renderer.xr.getHand(1);
    this.hands[1] || (this.hands[1] = new Zp(l), this.hands[1].name = "right"), l.add(this.hands[1]), t.add(l);
  }
  async startVR() {
    if (!navigator.xr || !await navigator.xr.isSessionSupported("immersive-vr"))
      return ze.error("Your browser is not currently supported VR!"), !1;
    if (this.vrSession)
      return ze.warn("VR has already been started!"), !1;
    let r;
    const n = new Promise((i) => r = i), s = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
    this.vrSession = await navigator.xr.requestSession("immersive-vr", s), await this.renderer.xr.setSession(this.vrSession);
    const o = () => {
      this.vrSession && (this.vrSession.removeEventListener("end", o), this.vrSession = null, this.currentCamera = this.defaultCamera, ze.debug("VR has been exited successfully!")), r(!0);
    };
    return this.vrSession.addEventListener("end", o), this.currentCamera = this.defaultCamera, n;
  }
  stopVR() {
    this.vrSession && this.vrSession.end();
  }
  updateVR() {
    this.renderer.xr.updateCamera(this.currentCamera);
    for (const t of this.hands)
      if (t)
        for (const r of this.currentScene.children) {
          if (r.bodyType === wc.Ghost)
            continue;
          const n = `${t.name}:${r.uuid}`;
          t.intersectBoxObject(r) ? this.handsConllisionMap.has(n) || (this.handsConllisionMap.add(n), r.dispatchEvent({ type: "onCollisionEnter", target: t })) : this.handsConllisionMap.has(n) && (this.handsConllisionMap.delete(n), r.dispatchEvent({ type: "onCollisionLeave", target: t }));
        }
  }
  render(t, r) {
    nn.delta = t, nn.now = r, this.currentScene.update(this.renderer, this.currentCamera, t, r), Jr.update(), this.renderer.xr.enabled && this.updateVR(), this.renderer.render(this.currentScene, this.currentCamera);
  }
  async run() {
    if (this.working)
      throw ze.panic("already working");
    this.working = !0, this.clock.start();
    const t = (r, n) => {
      if (!this.working) {
        this.renderer.setAnimationLoop(null);
        return;
      }
      const s = this.clock.getDelta(), o = this.clock.oldTime;
      this.render(s, o);
    };
    this.renderer.setAnimationLoop(t);
  }
  dispose() {
    this.clock.stop(), this.renderer.dispose();
  }
}
const wE = "[Spawns]", TE = "__isHidden", SE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AsyncFunction: Cx,
  AudioListener2: ax,
  BezierLine: O1,
  BezierLineMaterial: hi,
  Box: I1,
  BuiltinObjectKeyHidden: TE,
  BuiltinSceneSpawns: wE,
  Capsule: P1,
  Character: Sx,
  Cone: D1,
  Cylinder: U1,
  EffectNode: Qd,
  EventDispatcher: Ha,
  EventListenerNode: hr,
  Model3D: Sc,
  Particles: _x,
  PhysicalScene: $d,
  Plane: G1,
  PositionalAudio2: cx,
  Reflector: Zd,
  ScriptBlockNode: _n,
  ScriptNode: xo,
  ShapeArc: X1,
  ShapeCircle: H1,
  ShapeRounded: W1,
  ShapeSquare: j1,
  ShapeTriangle: V1,
  SkyBox: Mx,
  Sphere: z1,
  StaticMesh: Tx,
  Text3D: ix,
  TextMesh: Yd,
  Torus: B1,
  TorusKnot: k1,
  U3JsRuntime: NE,
  WaterPlane: uu,
  addEffectNode: ef,
  clone: A1,
  cloneTracingBegin: _1,
  cloneTracingEnd: M1,
  logger: ze,
  nodeProxy: Sa,
  objectsTransferred: _r,
  textMembers: di
}, Symbol.toStringTag, { value: "Module" }));
window.U3JS || (window.U3JS = SE);
export {
  Cx as AsyncFunction,
  ax as AudioListener2,
  O1 as BezierLine,
  hi as BezierLineMaterial,
  I1 as Box,
  TE as BuiltinObjectKeyHidden,
  wE as BuiltinSceneSpawns,
  P1 as Capsule,
  Sx as Character,
  D1 as Cone,
  U1 as Cylinder,
  Qd as EffectNode,
  OE as EventDispatcher,
  hr as EventListenerNode,
  Sc as Model3D,
  _x as Particles,
  $d as PhysicalScene,
  G1 as Plane,
  cx as PositionalAudio2,
  Zd as Reflector,
  _n as ScriptBlockNode,
  xo as ScriptNode,
  X1 as ShapeArc,
  H1 as ShapeCircle,
  W1 as ShapeRounded,
  j1 as ShapeSquare,
  V1 as ShapeTriangle,
  Mx as SkyBox,
  z1 as Sphere,
  Tx as StaticMesh,
  ix as Text3D,
  Yd as TextMesh,
  B1 as Torus,
  k1 as TorusKnot,
  NE as U3JsRuntime,
  uu as WaterPlane,
  ef as addEffectNode,
  A1 as clone,
  _1 as cloneTracingBegin,
  M1 as cloneTracingEnd,
  ze as logger,
  Sa as nodeProxy,
  _r as objectsTransferred,
  di as textMembers
};
